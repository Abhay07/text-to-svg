!function(g,n){"object"==typeof exports&&"object"==typeof module?module.exports=n():"function"==typeof define&&define.amd?define([],n):"object"==typeof exports?exports.WritingAnimation=n():g.WritingAnimation=n()}(window,function(){return function(g){var n={};function I(t){if(n[t])return n[t].exports;var C=n[t]={i:t,l:!1,exports:{}};return g[t].call(C.exports,C,C.exports,I),C.l=!0,C.exports}return I.m=g,I.c=n,I.d=function(g,n,t){I.o(g,n)||Object.defineProperty(g,n,{enumerable:!0,get:t})},I.r=function(g){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(g,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(g,"__esModule",{value:!0})},I.t=function(g,n){if(1&n&&(g=I(g)),8&n)return g;if(4&n&&"object"==typeof g&&g&&g.__esModule)return g;var t=Object.create(null);if(I.r(t),Object.defineProperty(t,"default",{enumerable:!0,value:g}),2&n&&"string"!=typeof g)for(var C in g)I.d(t,C,function(n){return g[n]}.bind(null,C));return t},I.n=function(g){var n=g&&g.__esModule?function(){return g.default}:function(){return g};return I.d(n,"a",n),n},I.o=function(g,n){return Object.prototype.hasOwnProperty.call(g,n)},I.p="",I(I.s=4)}([function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* WEBPACK VAR INJECTION */(function(Buffer) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return isBrowser; });\n/* unused harmony export isNode */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return nodeBufferToArrayBuffer; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return arrayBufferToNodeBuffer; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return checkArgument; });\nfunction isBrowser() {\n    return typeof window !== \'undefined\';\n}\n\nfunction isNode() {\n    return typeof window === \'undefined\';\n}\n\nfunction nodeBufferToArrayBuffer(buffer) {\n    const ab = new ArrayBuffer(buffer.length);\n    const view = new Uint8Array(ab);\n    for (let i = 0; i < buffer.length; ++i) {\n        view[i] = buffer[i];\n    }\n\n    return ab;\n}\n\nfunction arrayBufferToNodeBuffer(ab) {\n    const buffer = new Buffer(ab.byteLength);\n    const view = new Uint8Array(ab);\n    for (let i = 0; i < buffer.length; ++i) {\n        buffer[i] = view[i];\n    }\n\n    return buffer;\n}\n\nfunction checkArgument(expression, message) {\n    if (!expression) {\n        throw message;\n    }\n}\n\n\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(6).Buffer))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Xcml0aW5nQW5pbWF0aW9uLy4vbm9kZV9tb2R1bGVzL29wZW50eXBlLmpzL3NyYy91dGlsLmpzPzFiMTAiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLG1CQUFtQjtBQUN0QztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLG1CQUFtQjtBQUN0QztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFOEYiLCJmaWxlIjoiMC5qcyIsInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIGlzQnJvd3NlcigpIHtcbiAgICByZXR1cm4gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCc7XG59XG5cbmZ1bmN0aW9uIGlzTm9kZSgpIHtcbiAgICByZXR1cm4gdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCc7XG59XG5cbmZ1bmN0aW9uIG5vZGVCdWZmZXJUb0FycmF5QnVmZmVyKGJ1ZmZlcikge1xuICAgIGNvbnN0IGFiID0gbmV3IEFycmF5QnVmZmVyKGJ1ZmZlci5sZW5ndGgpO1xuICAgIGNvbnN0IHZpZXcgPSBuZXcgVWludDhBcnJheShhYik7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBidWZmZXIubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmlld1tpXSA9IGJ1ZmZlcltpXTtcbiAgICB9XG5cbiAgICByZXR1cm4gYWI7XG59XG5cbmZ1bmN0aW9uIGFycmF5QnVmZmVyVG9Ob2RlQnVmZmVyKGFiKSB7XG4gICAgY29uc3QgYnVmZmVyID0gbmV3IEJ1ZmZlcihhYi5ieXRlTGVuZ3RoKTtcbiAgICBjb25zdCB2aWV3ID0gbmV3IFVpbnQ4QXJyYXkoYWIpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnVmZmVyLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGJ1ZmZlcltpXSA9IHZpZXdbaV07XG4gICAgfVxuXG4gICAgcmV0dXJuIGJ1ZmZlcjtcbn1cblxuZnVuY3Rpb24gY2hlY2tBcmd1bWVudChleHByZXNzaW9uLCBtZXNzYWdlKSB7XG4gICAgaWYgKCFleHByZXNzaW9uKSB7XG4gICAgICAgIHRocm93IG1lc3NhZ2U7XG4gICAgfVxufVxuXG5leHBvcnQgeyBpc0Jyb3dzZXIsIGlzTm9kZSwgbm9kZUJ1ZmZlclRvQXJyYXlCdWZmZXIsIGFycmF5QnVmZmVyVG9Ob2RlQnVmZmVyLCBjaGVja0FyZ3VtZW50IH07XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///0\n')},function(module,exports){eval("/* (ignored) *///# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Xcml0aW5nQW5pbWF0aW9uL2ZzIChpZ25vcmVkKT84NjA1Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBIiwiZmlsZSI6IjEuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiAoaWdub3JlZCkgKi8iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///1\n")},function(module,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n\n// EXTERNAL MODULE: ./node_modules/tiny-inflate/index.js\nvar tiny_inflate = __webpack_require__(3);\nvar tiny_inflate_default = /*#__PURE__*/__webpack_require__.n(tiny_inflate);\n\n// CONCATENATED MODULE: ./node_modules/opentype.js/src/bbox.js\n// The Bounding Box object\n\nfunction derive(v0, v1, v2, v3, t) {\n    return Math.pow(1 - t, 3) * v0 +\n        3 * Math.pow(1 - t, 2) * t * v1 +\n        3 * (1 - t) * Math.pow(t, 2) * v2 +\n        Math.pow(t, 3) * v3;\n}\n/**\n * A bounding box is an enclosing box that describes the smallest measure within which all the points lie.\n * It is used to calculate the bounding box of a glyph or text path.\n *\n * On initialization, x1/y1/x2/y2 will be NaN. Check if the bounding box is empty using `isEmpty()`.\n *\n * @exports opentype.BoundingBox\n * @class\n * @constructor\n */\nfunction BoundingBox() {\n    this.x1 = Number.NaN;\n    this.y1 = Number.NaN;\n    this.x2 = Number.NaN;\n    this.y2 = Number.NaN;\n}\n\n/**\n * Returns true if the bounding box is empty, that is, no points have been added to the box yet.\n */\nBoundingBox.prototype.isEmpty = function() {\n    return isNaN(this.x1) || isNaN(this.y1) || isNaN(this.x2) || isNaN(this.y2);\n};\n\n/**\n * Add the point to the bounding box.\n * The x1/y1/x2/y2 coordinates of the bounding box will now encompass the given point.\n * @param {number} x - The X coordinate of the point.\n * @param {number} y - The Y coordinate of the point.\n */\nBoundingBox.prototype.addPoint = function(x, y) {\n    if (typeof x === 'number') {\n        if (isNaN(this.x1) || isNaN(this.x2)) {\n            this.x1 = x;\n            this.x2 = x;\n        }\n        if (x < this.x1) {\n            this.x1 = x;\n        }\n        if (x > this.x2) {\n            this.x2 = x;\n        }\n    }\n    if (typeof y === 'number') {\n        if (isNaN(this.y1) || isNaN(this.y2)) {\n            this.y1 = y;\n            this.y2 = y;\n        }\n        if (y < this.y1) {\n            this.y1 = y;\n        }\n        if (y > this.y2) {\n            this.y2 = y;\n        }\n    }\n};\n\n/**\n * Add a X coordinate to the bounding box.\n * This extends the bounding box to include the X coordinate.\n * This function is used internally inside of addBezier.\n * @param {number} x - The X coordinate of the point.\n */\nBoundingBox.prototype.addX = function(x) {\n    this.addPoint(x, null);\n};\n\n/**\n * Add a Y coordinate to the bounding box.\n * This extends the bounding box to include the Y coordinate.\n * This function is used internally inside of addBezier.\n * @param {number} y - The Y coordinate of the point.\n */\nBoundingBox.prototype.addY = function(y) {\n    this.addPoint(null, y);\n};\n\n/**\n * Add a Bézier curve to the bounding box.\n * This extends the bounding box to include the entire Bézier.\n * @param {number} x0 - The starting X coordinate.\n * @param {number} y0 - The starting Y coordinate.\n * @param {number} x1 - The X coordinate of the first control point.\n * @param {number} y1 - The Y coordinate of the first control point.\n * @param {number} x2 - The X coordinate of the second control point.\n * @param {number} y2 - The Y coordinate of the second control point.\n * @param {number} x - The ending X coordinate.\n * @param {number} y - The ending Y coordinate.\n */\nBoundingBox.prototype.addBezier = function(x0, y0, x1, y1, x2, y2, x, y) {\n    // This code is based on http://nishiohirokazu.blogspot.com/2009/06/how-to-calculate-bezier-curves-bounding.html\n    // and https://github.com/icons8/svg-path-bounding-box\n\n    const p0 = [x0, y0];\n    const p1 = [x1, y1];\n    const p2 = [x2, y2];\n    const p3 = [x, y];\n\n    this.addPoint(x0, y0);\n    this.addPoint(x, y);\n\n    for (let i = 0; i <= 1; i++) {\n        const b = 6 * p0[i] - 12 * p1[i] + 6 * p2[i];\n        const a = -3 * p0[i] + 9 * p1[i] - 9 * p2[i] + 3 * p3[i];\n        const c = 3 * p1[i] - 3 * p0[i];\n\n        if (a === 0) {\n            if (b === 0) continue;\n            const t = -c / b;\n            if (0 < t && t < 1) {\n                if (i === 0) this.addX(derive(p0[i], p1[i], p2[i], p3[i], t));\n                if (i === 1) this.addY(derive(p0[i], p1[i], p2[i], p3[i], t));\n            }\n            continue;\n        }\n\n        const b2ac = Math.pow(b, 2) - 4 * c * a;\n        if (b2ac < 0) continue;\n        const t1 = (-b + Math.sqrt(b2ac)) / (2 * a);\n        if (0 < t1 && t1 < 1) {\n            if (i === 0) this.addX(derive(p0[i], p1[i], p2[i], p3[i], t1));\n            if (i === 1) this.addY(derive(p0[i], p1[i], p2[i], p3[i], t1));\n        }\n        const t2 = (-b - Math.sqrt(b2ac)) / (2 * a);\n        if (0 < t2 && t2 < 1) {\n            if (i === 0) this.addX(derive(p0[i], p1[i], p2[i], p3[i], t2));\n            if (i === 1) this.addY(derive(p0[i], p1[i], p2[i], p3[i], t2));\n        }\n    }\n};\n\n/**\n * Add a quadratic curve to the bounding box.\n * This extends the bounding box to include the entire quadratic curve.\n * @param {number} x0 - The starting X coordinate.\n * @param {number} y0 - The starting Y coordinate.\n * @param {number} x1 - The X coordinate of the control point.\n * @param {number} y1 - The Y coordinate of the control point.\n * @param {number} x - The ending X coordinate.\n * @param {number} y - The ending Y coordinate.\n */\nBoundingBox.prototype.addQuad = function(x0, y0, x1, y1, x, y) {\n    const cp1x = x0 + 2 / 3 * (x1 - x0);\n    const cp1y = y0 + 2 / 3 * (y1 - y0);\n    const cp2x = cp1x + 1 / 3 * (x - x0);\n    const cp2y = cp1y + 1 / 3 * (y - y0);\n    this.addBezier(x0, y0, cp1x, cp1y, cp2x, cp2y, x, y);\n};\n\n/* harmony default export */ var bbox = (BoundingBox);\n\n// CONCATENATED MODULE: ./node_modules/opentype.js/src/path.js\n// Geometric objects\n\n\n\n/**\n * A bézier path containing a set of path commands similar to a SVG path.\n * Paths can be drawn on a context using `draw`.\n * @exports opentype.Path\n * @class\n * @constructor\n */\nfunction Path() {\n    this.commands = [];\n    this.fill = 'black';\n    this.stroke = null;\n    this.strokeWidth = 1;\n}\n\n/**\n * @param  {number} x\n * @param  {number} y\n */\nPath.prototype.moveTo = function(x, y) {\n    this.commands.push({\n        type: 'M',\n        x: x,\n        y: y\n    });\n};\n\n/**\n * @param  {number} x\n * @param  {number} y\n */\nPath.prototype.lineTo = function(x, y) {\n    this.commands.push({\n        type: 'L',\n        x: x,\n        y: y\n    });\n};\n\n/**\n * Draws cubic curve\n * @function\n * curveTo\n * @memberof opentype.Path.prototype\n * @param  {number} x1 - x of control 1\n * @param  {number} y1 - y of control 1\n * @param  {number} x2 - x of control 2\n * @param  {number} y2 - y of control 2\n * @param  {number} x - x of path point\n * @param  {number} y - y of path point\n */\n\n/**\n * Draws cubic curve\n * @function\n * bezierCurveTo\n * @memberof opentype.Path.prototype\n * @param  {number} x1 - x of control 1\n * @param  {number} y1 - y of control 1\n * @param  {number} x2 - x of control 2\n * @param  {number} y2 - y of control 2\n * @param  {number} x - x of path point\n * @param  {number} y - y of path point\n * @see curveTo\n */\nPath.prototype.curveTo = Path.prototype.bezierCurveTo = function(x1, y1, x2, y2, x, y) {\n    this.commands.push({\n        type: 'C',\n        x1: x1,\n        y1: y1,\n        x2: x2,\n        y2: y2,\n        x: x,\n        y: y\n    });\n};\n\n/**\n * Draws quadratic curve\n * @function\n * quadraticCurveTo\n * @memberof opentype.Path.prototype\n * @param  {number} x1 - x of control\n * @param  {number} y1 - y of control\n * @param  {number} x - x of path point\n * @param  {number} y - y of path point\n */\n\n/**\n * Draws quadratic curve\n * @function\n * quadTo\n * @memberof opentype.Path.prototype\n * @param  {number} x1 - x of control\n * @param  {number} y1 - y of control\n * @param  {number} x - x of path point\n * @param  {number} y - y of path point\n */\nPath.prototype.quadTo = Path.prototype.quadraticCurveTo = function(x1, y1, x, y) {\n    this.commands.push({\n        type: 'Q',\n        x1: x1,\n        y1: y1,\n        x: x,\n        y: y\n    });\n};\n\n/**\n * Closes the path\n * @function closePath\n * @memberof opentype.Path.prototype\n */\n\n/**\n * Close the path\n * @function close\n * @memberof opentype.Path.prototype\n */\nPath.prototype.close = Path.prototype.closePath = function() {\n    this.commands.push({\n        type: 'Z'\n    });\n};\n\n/**\n * Add the given path or list of commands to the commands of this path.\n * @param  {Array} pathOrCommands - another opentype.Path, an opentype.BoundingBox, or an array of commands.\n */\nPath.prototype.extend = function(pathOrCommands) {\n    if (pathOrCommands.commands) {\n        pathOrCommands = pathOrCommands.commands;\n    } else if (pathOrCommands instanceof bbox) {\n        const box = pathOrCommands;\n        this.moveTo(box.x1, box.y1);\n        this.lineTo(box.x2, box.y1);\n        this.lineTo(box.x2, box.y2);\n        this.lineTo(box.x1, box.y2);\n        this.close();\n        return;\n    }\n\n    Array.prototype.push.apply(this.commands, pathOrCommands);\n};\n\n/**\n * Calculate the bounding box of the path.\n * @returns {opentype.BoundingBox}\n */\nPath.prototype.getBoundingBox = function() {\n    const box = new bbox();\n\n    let startX = 0;\n    let startY = 0;\n    let prevX = 0;\n    let prevY = 0;\n    for (let i = 0; i < this.commands.length; i++) {\n        const cmd = this.commands[i];\n        switch (cmd.type) {\n            case 'M':\n                box.addPoint(cmd.x, cmd.y);\n                startX = prevX = cmd.x;\n                startY = prevY = cmd.y;\n                break;\n            case 'L':\n                box.addPoint(cmd.x, cmd.y);\n                prevX = cmd.x;\n                prevY = cmd.y;\n                break;\n            case 'Q':\n                box.addQuad(prevX, prevY, cmd.x1, cmd.y1, cmd.x, cmd.y);\n                prevX = cmd.x;\n                prevY = cmd.y;\n                break;\n            case 'C':\n                box.addBezier(prevX, prevY, cmd.x1, cmd.y1, cmd.x2, cmd.y2, cmd.x, cmd.y);\n                prevX = cmd.x;\n                prevY = cmd.y;\n                break;\n            case 'Z':\n                prevX = startX;\n                prevY = startY;\n                break;\n            default:\n                throw new Error('Unexpected path command ' + cmd.type);\n        }\n    }\n    if (box.isEmpty()) {\n        box.addPoint(0, 0);\n    }\n    return box;\n};\n\n/**\n * Draw the path to a 2D context.\n * @param {CanvasRenderingContext2D} ctx - A 2D drawing context.\n */\nPath.prototype.draw = function(ctx) {\n    ctx.beginPath();\n    for (let i = 0; i < this.commands.length; i += 1) {\n        const cmd = this.commands[i];\n        if (cmd.type === 'M') {\n            ctx.moveTo(cmd.x, cmd.y);\n        } else if (cmd.type === 'L') {\n            ctx.lineTo(cmd.x, cmd.y);\n        } else if (cmd.type === 'C') {\n            ctx.bezierCurveTo(cmd.x1, cmd.y1, cmd.x2, cmd.y2, cmd.x, cmd.y);\n        } else if (cmd.type === 'Q') {\n            ctx.quadraticCurveTo(cmd.x1, cmd.y1, cmd.x, cmd.y);\n        } else if (cmd.type === 'Z') {\n            ctx.closePath();\n        }\n    }\n\n    if (this.fill) {\n        ctx.fillStyle = this.fill;\n        ctx.fill();\n    }\n\n    if (this.stroke) {\n        ctx.strokeStyle = this.stroke;\n        ctx.lineWidth = this.strokeWidth;\n        ctx.stroke();\n    }\n};\n\n/**\n * Convert the Path to a string of path data instructions\n * See http://www.w3.org/TR/SVG/paths.html#PathData\n * @param  {number} [decimalPlaces=2] - The amount of decimal places for floating-point values\n * @return {string}\n */\nPath.prototype.toPathData = function(decimalPlaces) {\n    decimalPlaces = decimalPlaces !== undefined ? decimalPlaces : 2;\n\n    function floatToString(v) {\n        if (Math.round(v) === v) {\n            return '' + Math.round(v);\n        } else {\n            return v.toFixed(decimalPlaces);\n        }\n    }\n\n    function packValues() {\n        let s = '';\n        for (let i = 0; i < arguments.length; i += 1) {\n            const v = arguments[i];\n            if (v >= 0 && i > 0) {\n                s += ' ';\n            }\n\n            s += floatToString(v);\n        }\n\n        return s;\n    }\n\n    let d = '';\n    for (let i = 0; i < this.commands.length; i += 1) {\n        const cmd = this.commands[i];\n        if (cmd.type === 'M') {\n            d += 'M' + packValues(cmd.x, cmd.y);\n        } else if (cmd.type === 'L') {\n            d += 'L' + packValues(cmd.x, cmd.y);\n        } else if (cmd.type === 'C') {\n            d += 'C' + packValues(cmd.x1, cmd.y1, cmd.x2, cmd.y2, cmd.x, cmd.y);\n        } else if (cmd.type === 'Q') {\n            d += 'Q' + packValues(cmd.x1, cmd.y1, cmd.x, cmd.y);\n        } else if (cmd.type === 'Z') {\n            d += 'Z';\n        }\n    }\n\n    return d;\n};\n\n/**\n * Convert the path to an SVG <path> element, as a string.\n * @param  {number} [decimalPlaces=2] - The amount of decimal places for floating-point values\n * @return {string}\n */\nPath.prototype.toSVG = function(decimalPlaces) {\n    let svg = '<path d=\"';\n    svg += this.toPathData(decimalPlaces);\n    svg += '\"';\n    if (this.fill && this.fill !== 'black') {\n        if (this.fill === null) {\n            svg += ' fill=\"none\"';\n        } else {\n            svg += ' fill=\"' + this.fill + '\"';\n        }\n    }\n\n    if (this.stroke) {\n        svg += ' stroke=\"' + this.stroke + '\" stroke-width=\"' + this.strokeWidth + '\"';\n    }\n\n    svg += '/>';\n    return svg;\n};\n\n/**\n * Convert the path to a DOM element.\n * @param  {number} [decimalPlaces=2] - The amount of decimal places for floating-point values\n * @return {SVGPathElement}\n */\nPath.prototype.toDOMElement = function(decimalPlaces) {\n    const temporaryPath = this.toPathData(decimalPlaces);\n    const newPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');\n\n    newPath.setAttribute('d', temporaryPath);\n\n    return newPath;\n};\n\n/* harmony default export */ var src_path = (Path);\n\n// CONCATENATED MODULE: ./node_modules/opentype.js/src/check.js\n// Run-time checking of preconditions.\n\nfunction fail(message) {\n    throw new Error(message);\n}\n\n// Precondition function that checks if the given predicate is true.\n// If not, it will throw an error.\nfunction argument(predicate, message) {\n    if (!predicate) {\n        fail(message);\n    }\n}\n\n\n/* harmony default export */ var check = ({ fail, argument, assert: argument });\n\n// CONCATENATED MODULE: ./node_modules/opentype.js/src/types.js\n// Data types used in the OpenType font file.\n// All OpenType fonts use Motorola-style byte ordering (Big Endian)\n\n\n\nconst LIMIT16 = 32768; // The limit at which a 16-bit number switches signs == 2^15\nconst LIMIT32 = 2147483648; // The limit at which a 32-bit number switches signs == 2 ^ 31\n\n/**\n * @exports opentype.decode\n * @class\n */\nconst decode = {};\n/**\n * @exports opentype.encode\n * @class\n */\nconst encode = {};\n/**\n * @exports opentype.sizeOf\n * @class\n */\nconst sizeOf = {};\n\n// Return a function that always returns the same value.\nfunction constant(v) {\n    return function() {\n        return v;\n    };\n}\n\n// OpenType data types //////////////////////////////////////////////////////\n\n/**\n * Convert an 8-bit unsigned integer to a list of 1 byte.\n * @param {number}\n * @returns {Array}\n */\nencode.BYTE = function(v) {\n    check.argument(v >= 0 && v <= 255, 'Byte value should be between 0 and 255.');\n    return [v];\n};\n/**\n * @constant\n * @type {number}\n */\nsizeOf.BYTE = constant(1);\n\n/**\n * Convert a 8-bit signed integer to a list of 1 byte.\n * @param {string}\n * @returns {Array}\n */\nencode.CHAR = function(v) {\n    return [v.charCodeAt(0)];\n};\n\n/**\n * @constant\n * @type {number}\n */\nsizeOf.CHAR = constant(1);\n\n/**\n * Convert an ASCII string to a list of bytes.\n * @param {string}\n * @returns {Array}\n */\nencode.CHARARRAY = function(v) {\n    const b = [];\n    for (let i = 0; i < v.length; i += 1) {\n        b[i] = v.charCodeAt(i);\n    }\n\n    return b;\n};\n\n/**\n * @param {Array}\n * @returns {number}\n */\nsizeOf.CHARARRAY = function(v) {\n    return v.length;\n};\n\n/**\n * Convert a 16-bit unsigned integer to a list of 2 bytes.\n * @param {number}\n * @returns {Array}\n */\nencode.USHORT = function(v) {\n    return [(v >> 8) & 0xFF, v & 0xFF];\n};\n\n/**\n * @constant\n * @type {number}\n */\nsizeOf.USHORT = constant(2);\n\n/**\n * Convert a 16-bit signed integer to a list of 2 bytes.\n * @param {number}\n * @returns {Array}\n */\nencode.SHORT = function(v) {\n    // Two's complement\n    if (v >= LIMIT16) {\n        v = -(2 * LIMIT16 - v);\n    }\n\n    return [(v >> 8) & 0xFF, v & 0xFF];\n};\n\n/**\n * @constant\n * @type {number}\n */\nsizeOf.SHORT = constant(2);\n\n/**\n * Convert a 24-bit unsigned integer to a list of 3 bytes.\n * @param {number}\n * @returns {Array}\n */\nencode.UINT24 = function(v) {\n    return [(v >> 16) & 0xFF, (v >> 8) & 0xFF, v & 0xFF];\n};\n\n/**\n * @constant\n * @type {number}\n */\nsizeOf.UINT24 = constant(3);\n\n/**\n * Convert a 32-bit unsigned integer to a list of 4 bytes.\n * @param {number}\n * @returns {Array}\n */\nencode.ULONG = function(v) {\n    return [(v >> 24) & 0xFF, (v >> 16) & 0xFF, (v >> 8) & 0xFF, v & 0xFF];\n};\n\n/**\n * @constant\n * @type {number}\n */\nsizeOf.ULONG = constant(4);\n\n/**\n * Convert a 32-bit unsigned integer to a list of 4 bytes.\n * @param {number}\n * @returns {Array}\n */\nencode.LONG = function(v) {\n    // Two's complement\n    if (v >= LIMIT32) {\n        v = -(2 * LIMIT32 - v);\n    }\n\n    return [(v >> 24) & 0xFF, (v >> 16) & 0xFF, (v >> 8) & 0xFF, v & 0xFF];\n};\n\n/**\n * @constant\n * @type {number}\n */\nsizeOf.LONG = constant(4);\n\nencode.FIXED = encode.ULONG;\nsizeOf.FIXED = sizeOf.ULONG;\n\nencode.FWORD = encode.SHORT;\nsizeOf.FWORD = sizeOf.SHORT;\n\nencode.UFWORD = encode.USHORT;\nsizeOf.UFWORD = sizeOf.USHORT;\n\n/**\n * Convert a 32-bit Apple Mac timestamp integer to a list of 8 bytes, 64-bit timestamp.\n * @param {number}\n * @returns {Array}\n */\nencode.LONGDATETIME = function(v) {\n    return [0, 0, 0, 0, (v >> 24) & 0xFF, (v >> 16) & 0xFF, (v >> 8) & 0xFF, v & 0xFF];\n};\n\n/**\n * @constant\n * @type {number}\n */\nsizeOf.LONGDATETIME = constant(8);\n\n/**\n * Convert a 4-char tag to a list of 4 bytes.\n * @param {string}\n * @returns {Array}\n */\nencode.TAG = function(v) {\n    check.argument(v.length === 4, 'Tag should be exactly 4 ASCII characters.');\n    return [v.charCodeAt(0),\n            v.charCodeAt(1),\n            v.charCodeAt(2),\n            v.charCodeAt(3)];\n};\n\n/**\n * @constant\n * @type {number}\n */\nsizeOf.TAG = constant(4);\n\n// CFF data types ///////////////////////////////////////////////////////////\n\nencode.Card8 = encode.BYTE;\nsizeOf.Card8 = sizeOf.BYTE;\n\nencode.Card16 = encode.USHORT;\nsizeOf.Card16 = sizeOf.USHORT;\n\nencode.OffSize = encode.BYTE;\nsizeOf.OffSize = sizeOf.BYTE;\n\nencode.SID = encode.USHORT;\nsizeOf.SID = sizeOf.USHORT;\n\n// Convert a numeric operand or charstring number to a variable-size list of bytes.\n/**\n * Convert a numeric operand or charstring number to a variable-size list of bytes.\n * @param {number}\n * @returns {Array}\n */\nencode.NUMBER = function(v) {\n    if (v >= -107 && v <= 107) {\n        return [v + 139];\n    } else if (v >= 108 && v <= 1131) {\n        v = v - 108;\n        return [(v >> 8) + 247, v & 0xFF];\n    } else if (v >= -1131 && v <= -108) {\n        v = -v - 108;\n        return [(v >> 8) + 251, v & 0xFF];\n    } else if (v >= -32768 && v <= 32767) {\n        return encode.NUMBER16(v);\n    } else {\n        return encode.NUMBER32(v);\n    }\n};\n\n/**\n * @param {number}\n * @returns {number}\n */\nsizeOf.NUMBER = function(v) {\n    return encode.NUMBER(v).length;\n};\n\n/**\n * Convert a signed number between -32768 and +32767 to a three-byte value.\n * This ensures we always use three bytes, but is not the most compact format.\n * @param {number}\n * @returns {Array}\n */\nencode.NUMBER16 = function(v) {\n    return [28, (v >> 8) & 0xFF, v & 0xFF];\n};\n\n/**\n * @constant\n * @type {number}\n */\nsizeOf.NUMBER16 = constant(3);\n\n/**\n * Convert a signed number between -(2^31) and +(2^31-1) to a five-byte value.\n * This is useful if you want to be sure you always use four bytes,\n * at the expense of wasting a few bytes for smaller numbers.\n * @param {number}\n * @returns {Array}\n */\nencode.NUMBER32 = function(v) {\n    return [29, (v >> 24) & 0xFF, (v >> 16) & 0xFF, (v >> 8) & 0xFF, v & 0xFF];\n};\n\n/**\n * @constant\n * @type {number}\n */\nsizeOf.NUMBER32 = constant(5);\n\n/**\n * @param {number}\n * @returns {Array}\n */\nencode.REAL = function(v) {\n    let value = v.toString();\n\n    // Some numbers use an epsilon to encode the value. (e.g. JavaScript will store 0.0000001 as 1e-7)\n    // This code converts it back to a number without the epsilon.\n    const m = /\\.(\\d*?)(?:9{5,20}|0{5,20})\\d{0,2}(?:e(.+)|$)/.exec(value);\n    if (m) {\n        const epsilon = parseFloat('1e' + ((m[2] ? +m[2] : 0) + m[1].length));\n        value = (Math.round(v * epsilon) / epsilon).toString();\n    }\n\n    let nibbles = '';\n    for (let i = 0, ii = value.length; i < ii; i += 1) {\n        const c = value[i];\n        if (c === 'e') {\n            nibbles += value[++i] === '-' ? 'c' : 'b';\n        } else if (c === '.') {\n            nibbles += 'a';\n        } else if (c === '-') {\n            nibbles += 'e';\n        } else {\n            nibbles += c;\n        }\n    }\n\n    nibbles += (nibbles.length & 1) ? 'f' : 'ff';\n    const out = [30];\n    for (let i = 0, ii = nibbles.length; i < ii; i += 2) {\n        out.push(parseInt(nibbles.substr(i, 2), 16));\n    }\n\n    return out;\n};\n\n/**\n * @param {number}\n * @returns {number}\n */\nsizeOf.REAL = function(v) {\n    return encode.REAL(v).length;\n};\n\nencode.NAME = encode.CHARARRAY;\nsizeOf.NAME = sizeOf.CHARARRAY;\n\nencode.STRING = encode.CHARARRAY;\nsizeOf.STRING = sizeOf.CHARARRAY;\n\n/**\n * @param {DataView} data\n * @param {number} offset\n * @param {number} numBytes\n * @returns {string}\n */\ndecode.UTF8 = function(data, offset, numBytes) {\n    const codePoints = [];\n    const numChars = numBytes;\n    for (let j = 0; j < numChars; j++, offset += 1) {\n        codePoints[j] = data.getUint8(offset);\n    }\n\n    return String.fromCharCode.apply(null, codePoints);\n};\n\n/**\n * @param {DataView} data\n * @param {number} offset\n * @param {number} numBytes\n * @returns {string}\n */\ndecode.UTF16 = function(data, offset, numBytes) {\n    const codePoints = [];\n    const numChars = numBytes / 2;\n    for (let j = 0; j < numChars; j++, offset += 2) {\n        codePoints[j] = data.getUint16(offset);\n    }\n\n    return String.fromCharCode.apply(null, codePoints);\n};\n\n/**\n * Convert a JavaScript string to UTF16-BE.\n * @param {string}\n * @returns {Array}\n */\nencode.UTF16 = function(v) {\n    const b = [];\n    for (let i = 0; i < v.length; i += 1) {\n        const codepoint = v.charCodeAt(i);\n        b[b.length] = (codepoint >> 8) & 0xFF;\n        b[b.length] = codepoint & 0xFF;\n    }\n\n    return b;\n};\n\n/**\n * @param {string}\n * @returns {number}\n */\nsizeOf.UTF16 = function(v) {\n    return v.length * 2;\n};\n\n// Data for converting old eight-bit Macintosh encodings to Unicode.\n// This representation is optimized for decoding; encoding is slower\n// and needs more memory. The assumption is that all opentype.js users\n// want to open fonts, but saving a font will be comparatively rare\n// so it can be more expensive. Keyed by IANA character set name.\n//\n// Python script for generating these strings:\n//\n//     s = u''.join([chr(c).decode('mac_greek') for c in range(128, 256)])\n//     print(s.encode('utf-8'))\n/**\n * @private\n */\nconst eightBitMacEncodings = {\n    'x-mac-croatian':  // Python: 'mac_croatian'\n    'ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®Š™´¨≠ŽØ∞±≤≥∆µ∂∑∏š∫ªºΩžø' +\n    '¿¡¬√ƒ≈Ć«Č… ÀÃÕŒœĐ—“”‘’÷◊©⁄€‹›Æ»–·‚„‰ÂćÁčÈÍÎÏÌÓÔđÒÚÛÙıˆ˜¯πË˚¸Êæˇ',\n    'x-mac-cyrillic':  // Python: 'mac_cyrillic'\n    'АБВГДЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯ†°Ґ£§•¶І®©™Ђђ≠Ѓѓ∞±≤≥іµґЈЄєЇїЉљЊњ' +\n    'јЅ¬√ƒ≈∆«»… ЋћЌќѕ–—“”‘’÷„ЎўЏџ№Ёёяабвгдежзийклмнопрстуфхцчшщъыьэю',\n    'x-mac-gaelic': // http://unicode.org/Public/MAPPINGS/VENDORS/APPLE/GAELIC.TXT\n    'ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®©™´¨≠ÆØḂ±≤≥ḃĊċḊḋḞḟĠġṀæø' +\n    'ṁṖṗɼƒſṠ«»… ÀÃÕŒœ–—“”‘’ṡẛÿŸṪ€‹›Ŷŷṫ·Ỳỳ⁊ÂÊÁËÈÍÎÏÌÓÔ♣ÒÚÛÙıÝýŴŵẄẅẀẁẂẃ',\n    'x-mac-greek':  // Python: 'mac_greek'\n    'Ä¹²É³ÖÜ΅àâä΄¨çéèêë£™îï•½‰ôö¦€ùûü†ΓΔΘΛΞΠß®©ΣΪ§≠°·Α±≤≥¥ΒΕΖΗΙΚΜΦΫΨΩ' +\n    'άΝ¬ΟΡ≈Τ«»… ΥΧΆΈœ–―“”‘’÷ΉΊΌΎέήίόΏύαβψδεφγηιξκλμνοπώρστθωςχυζϊϋΐΰ\\u00AD',\n    'x-mac-icelandic':  // Python: 'mac_iceland'\n    'ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûüÝ°¢£§•¶ß®©™´¨≠ÆØ∞±≤≥¥µ∂∑∏π∫ªºΩæø' +\n    '¿¡¬√ƒ≈∆«»… ÀÃÕŒœ–—“”‘’÷◊ÿŸ⁄€ÐðÞþý·‚„‰ÂÊÁËÈÍÎÏÌÓÔÒÚÛÙıˆ˜¯˘˙˚¸˝˛ˇ',\n    'x-mac-inuit': // http://unicode.org/Public/MAPPINGS/VENDORS/APPLE/INUIT.TXT\n    'ᐃᐄᐅᐆᐊᐋᐱᐲᐳᐴᐸᐹᑉᑎᑏᑐᑑᑕᑖᑦᑭᑮᑯᑰᑲᑳᒃᒋᒌᒍᒎᒐᒑ°ᒡᒥᒦ•¶ᒧ®©™ᒨᒪᒫᒻᓂᓃᓄᓅᓇᓈᓐᓯᓰᓱᓲᓴᓵᔅᓕᓖᓗ' +\n    'ᓘᓚᓛᓪᔨᔩᔪᔫᔭ… ᔮᔾᕕᕖᕗ–—“”‘’ᕘᕙᕚᕝᕆᕇᕈᕉᕋᕌᕐᕿᖀᖁᖂᖃᖄᖅᖏᖐᖑᖒᖓᖔᖕᙱᙲᙳᙴᙵᙶᖖᖠᖡᖢᖣᖤᖥᖦᕼŁł',\n    'x-mac-ce':  // Python: 'mac_latin2'\n    'ÄĀāÉĄÖÜáąČäčĆćéŹźĎíďĒēĖóėôöõúĚěü†°Ę£§•¶ß®©™ę¨≠ģĮįĪ≤≥īĶ∂∑łĻļĽľĹĺŅ' +\n    'ņŃ¬√ńŇ∆«»… ňŐÕőŌ–—“”‘’÷◊ōŔŕŘ‹›řŖŗŠ‚„šŚśÁŤťÍŽžŪÓÔūŮÚůŰűŲųÝýķŻŁżĢˇ',\n    macintosh:  // Python: 'mac_roman'\n    'ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®©™´¨≠ÆØ∞±≤≥¥µ∂∑∏π∫ªºΩæø' +\n    '¿¡¬√ƒ≈∆«»… ÀÃÕŒœ–—“”‘’÷◊ÿŸ⁄€‹›ﬁﬂ‡·‚„‰ÂÊÁËÈÍÎÏÌÓÔÒÚÛÙıˆ˜¯˘˙˚¸˝˛ˇ',\n    'x-mac-romanian':  // Python: 'mac_romanian'\n    'ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®©™´¨≠ĂȘ∞±≤≥¥µ∂∑∏π∫ªºΩăș' +\n    '¿¡¬√ƒ≈∆«»… ÀÃÕŒœ–—“”‘’÷◊ÿŸ⁄€‹›Țț‡·‚„‰ÂÊÁËÈÍÎÏÌÓÔÒÚÛÙıˆ˜¯˘˙˚¸˝˛ˇ',\n    'x-mac-turkish':  // Python: 'mac_turkish'\n    'ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®©™´¨≠ÆØ∞±≤≥¥µ∂∑∏π∫ªºΩæø' +\n    '¿¡¬√ƒ≈∆«»… ÀÃÕŒœ–—“”‘’÷◊ÿŸĞğİıŞş‡·‚„‰ÂÊÁËÈÍÎÏÌÓÔÒÚÛÙˆ˜¯˘˙˚¸˝˛ˇ'\n};\n\n/**\n * Decodes an old-style Macintosh string. Returns either a Unicode JavaScript\n * string, or 'undefined' if the encoding is unsupported. For example, we do\n * not support Chinese, Japanese or Korean because these would need large\n * mapping tables.\n * @param {DataView} dataView\n * @param {number} offset\n * @param {number} dataLength\n * @param {string} encoding\n * @returns {string}\n */\ndecode.MACSTRING = function(dataView, offset, dataLength, encoding) {\n    const table = eightBitMacEncodings[encoding];\n    if (table === undefined) {\n        return undefined;\n    }\n\n    let result = '';\n    for (let i = 0; i < dataLength; i++) {\n        const c = dataView.getUint8(offset + i);\n        // In all eight-bit Mac encodings, the characters 0x00..0x7F are\n        // mapped to U+0000..U+007F; we only need to look up the others.\n        if (c <= 0x7F) {\n            result += String.fromCharCode(c);\n        } else {\n            result += table[c & 0x7F];\n        }\n    }\n\n    return result;\n};\n\n// Helper function for encode.MACSTRING. Returns a dictionary for mapping\n// Unicode character codes to their 8-bit MacOS equivalent. This table\n// is not exactly a super cheap data structure, but we do not care because\n// encoding Macintosh strings is only rarely needed in typical applications.\nconst macEncodingTableCache = typeof WeakMap === 'function' && new WeakMap();\nlet macEncodingCacheKeys;\nconst getMacEncodingTable = function (encoding) {\n    // Since we use encoding as a cache key for WeakMap, it has to be\n    // a String object and not a literal. And at least on NodeJS 2.10.1,\n    // WeakMap requires that the same String instance is passed for cache hits.\n    if (!macEncodingCacheKeys) {\n        macEncodingCacheKeys = {};\n        for (let e in eightBitMacEncodings) {\n            /*jshint -W053 */  // Suppress \"Do not use String as a constructor.\"\n            macEncodingCacheKeys[e] = new String(e);\n        }\n    }\n\n    const cacheKey = macEncodingCacheKeys[encoding];\n    if (cacheKey === undefined) {\n        return undefined;\n    }\n\n    // We can't do \"if (cache.has(key)) {return cache.get(key)}\" here:\n    // since garbage collection may run at any time, it could also kick in\n    // between the calls to cache.has() and cache.get(). In that case,\n    // we would return 'undefined' even though we do support the encoding.\n    if (macEncodingTableCache) {\n        const cachedTable = macEncodingTableCache.get(cacheKey);\n        if (cachedTable !== undefined) {\n            return cachedTable;\n        }\n    }\n\n    const decodingTable = eightBitMacEncodings[encoding];\n    if (decodingTable === undefined) {\n        return undefined;\n    }\n\n    const encodingTable = {};\n    for (let i = 0; i < decodingTable.length; i++) {\n        encodingTable[decodingTable.charCodeAt(i)] = i + 0x80;\n    }\n\n    if (macEncodingTableCache) {\n        macEncodingTableCache.set(cacheKey, encodingTable);\n    }\n\n    return encodingTable;\n};\n\n/**\n * Encodes an old-style Macintosh string. Returns a byte array upon success.\n * If the requested encoding is unsupported, or if the input string contains\n * a character that cannot be expressed in the encoding, the function returns\n * 'undefined'.\n * @param {string} str\n * @param {string} encoding\n * @returns {Array}\n */\nencode.MACSTRING = function(str, encoding) {\n    const table = getMacEncodingTable(encoding);\n    if (table === undefined) {\n        return undefined;\n    }\n\n    const result = [];\n    for (let i = 0; i < str.length; i++) {\n        let c = str.charCodeAt(i);\n\n        // In all eight-bit Mac encodings, the characters 0x00..0x7F are\n        // mapped to U+0000..U+007F; we only need to look up the others.\n        if (c >= 0x80) {\n            c = table[c];\n            if (c === undefined) {\n                // str contains a Unicode character that cannot be encoded\n                // in the requested encoding.\n                return undefined;\n            }\n        }\n        result[i] = c;\n        // result.push(c);\n    }\n\n    return result;\n};\n\n/**\n * @param {string} str\n * @param {string} encoding\n * @returns {number}\n */\nsizeOf.MACSTRING = function(str, encoding) {\n    const b = encode.MACSTRING(str, encoding);\n    if (b !== undefined) {\n        return b.length;\n    } else {\n        return 0;\n    }\n};\n\n// Helper for encode.VARDELTAS\nfunction isByteEncodable(value) {\n    return value >= -128 && value <= 127;\n}\n\n// Helper for encode.VARDELTAS\nfunction encodeVarDeltaRunAsZeroes(deltas, pos, result) {\n    let runLength = 0;\n    const numDeltas = deltas.length;\n    while (pos < numDeltas && runLength < 64 && deltas[pos] === 0) {\n        ++pos;\n        ++runLength;\n    }\n    result.push(0x80 | (runLength - 1));\n    return pos;\n}\n\n// Helper for encode.VARDELTAS\nfunction encodeVarDeltaRunAsBytes(deltas, offset, result) {\n    let runLength = 0;\n    const numDeltas = deltas.length;\n    let pos = offset;\n    while (pos < numDeltas && runLength < 64) {\n        const value = deltas[pos];\n        if (!isByteEncodable(value)) {\n            break;\n        }\n\n        // Within a byte-encoded run of deltas, a single zero is best\n        // stored literally as 0x00 value. However, if we have two or\n        // more zeroes in a sequence, it is better to start a new run.\n        // Fore example, the sequence of deltas [15, 15, 0, 15, 15]\n        // becomes 6 bytes (04 0F 0F 00 0F 0F) when storing the zero\n        // within the current run, but 7 bytes (01 0F 0F 80 01 0F 0F)\n        // when starting a new run.\n        if (value === 0 && pos + 1 < numDeltas && deltas[pos + 1] === 0) {\n            break;\n        }\n\n        ++pos;\n        ++runLength;\n    }\n    result.push(runLength - 1);\n    for (let i = offset; i < pos; ++i) {\n        result.push((deltas[i] + 256) & 0xff);\n    }\n    return pos;\n}\n\n// Helper for encode.VARDELTAS\nfunction encodeVarDeltaRunAsWords(deltas, offset, result) {\n    let runLength = 0;\n    const numDeltas = deltas.length;\n    let pos = offset;\n    while (pos < numDeltas && runLength < 64) {\n        const value = deltas[pos];\n\n        // Within a word-encoded run of deltas, it is easiest to start\n        // a new run (with a different encoding) whenever we encounter\n        // a zero value. For example, the sequence [0x6666, 0, 0x7777]\n        // needs 7 bytes when storing the zero inside the current run\n        // (42 66 66 00 00 77 77), and equally 7 bytes when starting a\n        // new run (40 66 66 80 40 77 77).\n        if (value === 0) {\n            break;\n        }\n\n        // Within a word-encoded run of deltas, a single value in the\n        // range (-128..127) should be encoded within the current run\n        // because it is more compact. For example, the sequence\n        // [0x6666, 2, 0x7777] becomes 7 bytes when storing the value\n        // literally (42 66 66 00 02 77 77), but 8 bytes when starting\n        // a new run (40 66 66 00 02 40 77 77).\n        if (isByteEncodable(value) && pos + 1 < numDeltas && isByteEncodable(deltas[pos + 1])) {\n            break;\n        }\n\n        ++pos;\n        ++runLength;\n    }\n    result.push(0x40 | (runLength - 1));\n    for (let i = offset; i < pos; ++i) {\n        const val = deltas[i];\n        result.push(((val + 0x10000) >> 8) & 0xff, (val + 0x100) & 0xff);\n    }\n    return pos;\n}\n\n/**\n * Encode a list of variation adjustment deltas.\n *\n * Variation adjustment deltas are used in ‘gvar’ and ‘cvar’ tables.\n * They indicate how points (in ‘gvar’) or values (in ‘cvar’) get adjusted\n * when generating instances of variation fonts.\n *\n * @see https://www.microsoft.com/typography/otspec/gvar.htm\n * @see https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6gvar.html\n * @param {Array}\n * @return {Array}\n */\nencode.VARDELTAS = function(deltas) {\n    let pos = 0;\n    const result = [];\n    while (pos < deltas.length) {\n        const value = deltas[pos];\n        if (value === 0) {\n            pos = encodeVarDeltaRunAsZeroes(deltas, pos, result);\n        } else if (value >= -128 && value <= 127) {\n            pos = encodeVarDeltaRunAsBytes(deltas, pos, result);\n        } else {\n            pos = encodeVarDeltaRunAsWords(deltas, pos, result);\n        }\n    }\n    return result;\n};\n\n// Convert a list of values to a CFF INDEX structure.\n// The values should be objects containing name / type / value.\n/**\n * @param {Array} l\n * @returns {Array}\n */\nencode.INDEX = function(l) {\n    //var offset, offsets, offsetEncoder, encodedOffsets, encodedOffset, data,\n    //    i, v;\n    // Because we have to know which data type to use to encode the offsets,\n    // we have to go through the values twice: once to encode the data and\n    // calculate the offsets, then again to encode the offsets using the fitting data type.\n    let offset = 1; // First offset is always 1.\n    const offsets = [offset];\n    const data = [];\n    for (let i = 0; i < l.length; i += 1) {\n        const v = encode.OBJECT(l[i]);\n        Array.prototype.push.apply(data, v);\n        offset += v.length;\n        offsets.push(offset);\n    }\n\n    if (data.length === 0) {\n        return [0, 0];\n    }\n\n    const encodedOffsets = [];\n    const offSize = (1 + Math.floor(Math.log(offset) / Math.log(2)) / 8) | 0;\n    const offsetEncoder = [undefined, encode.BYTE, encode.USHORT, encode.UINT24, encode.ULONG][offSize];\n    for (let i = 0; i < offsets.length; i += 1) {\n        const encodedOffset = offsetEncoder(offsets[i]);\n        Array.prototype.push.apply(encodedOffsets, encodedOffset);\n    }\n\n    return Array.prototype.concat(encode.Card16(l.length),\n                           encode.OffSize(offSize),\n                           encodedOffsets,\n                           data);\n};\n\n/**\n * @param {Array}\n * @returns {number}\n */\nsizeOf.INDEX = function(v) {\n    return encode.INDEX(v).length;\n};\n\n/**\n * Convert an object to a CFF DICT structure.\n * The keys should be numeric.\n * The values should be objects containing name / type / value.\n * @param {Object} m\n * @returns {Array}\n */\nencode.DICT = function(m) {\n    let d = [];\n    const keys = Object.keys(m);\n    const length = keys.length;\n\n    for (let i = 0; i < length; i += 1) {\n        // Object.keys() return string keys, but our keys are always numeric.\n        const k = parseInt(keys[i], 0);\n        const v = m[k];\n        // Value comes before the key.\n        d = d.concat(encode.OPERAND(v.value, v.type));\n        d = d.concat(encode.OPERATOR(k));\n    }\n\n    return d;\n};\n\n/**\n * @param {Object}\n * @returns {number}\n */\nsizeOf.DICT = function(m) {\n    return encode.DICT(m).length;\n};\n\n/**\n * @param {number}\n * @returns {Array}\n */\nencode.OPERATOR = function(v) {\n    if (v < 1200) {\n        return [v];\n    } else {\n        return [12, v - 1200];\n    }\n};\n\n/**\n * @param {Array} v\n * @param {string}\n * @returns {Array}\n */\nencode.OPERAND = function(v, type) {\n    let d = [];\n    if (Array.isArray(type)) {\n        for (let i = 0; i < type.length; i += 1) {\n            check.argument(v.length === type.length, 'Not enough arguments given for type' + type);\n            d = d.concat(encode.OPERAND(v[i], type[i]));\n        }\n    } else {\n        if (type === 'SID') {\n            d = d.concat(encode.NUMBER(v));\n        } else if (type === 'offset') {\n            // We make it easy for ourselves and always encode offsets as\n            // 4 bytes. This makes offset calculation for the top dict easier.\n            d = d.concat(encode.NUMBER32(v));\n        } else if (type === 'number') {\n            d = d.concat(encode.NUMBER(v));\n        } else if (type === 'real') {\n            d = d.concat(encode.REAL(v));\n        } else {\n            throw new Error('Unknown operand type ' + type);\n            // FIXME Add support for booleans\n        }\n    }\n\n    return d;\n};\n\nencode.OP = encode.BYTE;\nsizeOf.OP = sizeOf.BYTE;\n\n// memoize charstring encoding using WeakMap if available\nconst wmm = typeof WeakMap === 'function' && new WeakMap();\n\n/**\n * Convert a list of CharString operations to bytes.\n * @param {Array}\n * @returns {Array}\n */\nencode.CHARSTRING = function(ops) {\n    // See encode.MACSTRING for why we don't do \"if (wmm && wmm.has(ops))\".\n    if (wmm) {\n        const cachedValue = wmm.get(ops);\n        if (cachedValue !== undefined) {\n            return cachedValue;\n        }\n    }\n\n    let d = [];\n    const length = ops.length;\n\n    for (let i = 0; i < length; i += 1) {\n        const op = ops[i];\n        d = d.concat(encode[op.type](op.value));\n    }\n\n    if (wmm) {\n        wmm.set(ops, d);\n    }\n\n    return d;\n};\n\n/**\n * @param {Array}\n * @returns {number}\n */\nsizeOf.CHARSTRING = function(ops) {\n    return encode.CHARSTRING(ops).length;\n};\n\n// Utility functions ////////////////////////////////////////////////////////\n\n/**\n * Convert an object containing name / type / value to bytes.\n * @param {Object}\n * @returns {Array}\n */\nencode.OBJECT = function(v) {\n    const encodingFunction = encode[v.type];\n    check.argument(encodingFunction !== undefined, 'No encoding function for type ' + v.type);\n    return encodingFunction(v.value);\n};\n\n/**\n * @param {Object}\n * @returns {number}\n */\nsizeOf.OBJECT = function(v) {\n    const sizeOfFunction = sizeOf[v.type];\n    check.argument(sizeOfFunction !== undefined, 'No sizeOf function for type ' + v.type);\n    return sizeOfFunction(v.value);\n};\n\n/**\n * Convert a table object to bytes.\n * A table contains a list of fields containing the metadata (name, type and default value).\n * The table itself has the field values set as attributes.\n * @param {opentype.Table}\n * @returns {Array}\n */\nencode.TABLE = function(table) {\n    let d = [];\n    const length = table.fields.length;\n    const subtables = [];\n    const subtableOffsets = [];\n\n    for (let i = 0; i < length; i += 1) {\n        const field = table.fields[i];\n        const encodingFunction = encode[field.type];\n        check.argument(encodingFunction !== undefined, 'No encoding function for field type ' + field.type + ' (' + field.name + ')');\n        let value = table[field.name];\n        if (value === undefined) {\n            value = field.value;\n        }\n\n        const bytes = encodingFunction(value);\n\n        if (field.type === 'TABLE') {\n            subtableOffsets.push(d.length);\n            d = d.concat([0, 0]);\n            subtables.push(bytes);\n        } else {\n            d = d.concat(bytes);\n        }\n    }\n\n    for (let i = 0; i < subtables.length; i += 1) {\n        const o = subtableOffsets[i];\n        const offset = d.length;\n        check.argument(offset < 65536, 'Table ' + table.tableName + ' too big.');\n        d[o] = offset >> 8;\n        d[o + 1] = offset & 0xff;\n        d = d.concat(subtables[i]);\n    }\n\n    return d;\n};\n\n/**\n * @param {opentype.Table}\n * @returns {number}\n */\nsizeOf.TABLE = function(table) {\n    let numBytes = 0;\n    const length = table.fields.length;\n\n    for (let i = 0; i < length; i += 1) {\n        const field = table.fields[i];\n        const sizeOfFunction = sizeOf[field.type];\n        check.argument(sizeOfFunction !== undefined, 'No sizeOf function for field type ' + field.type + ' (' + field.name + ')');\n        let value = table[field.name];\n        if (value === undefined) {\n            value = field.value;\n        }\n\n        numBytes += sizeOfFunction(value);\n\n        // Subtables take 2 more bytes for offsets.\n        if (field.type === 'TABLE') {\n            numBytes += 2;\n        }\n    }\n\n    return numBytes;\n};\n\nencode.RECORD = encode.TABLE;\nsizeOf.RECORD = sizeOf.TABLE;\n\n// Merge in a list of bytes.\nencode.LITERAL = function(v) {\n    return v;\n};\n\nsizeOf.LITERAL = function(v) {\n    return v.length;\n};\n\n\n\n// CONCATENATED MODULE: ./node_modules/opentype.js/src/table.js\n// Table metadata\n\n\n\n\n/**\n * @exports opentype.Table\n * @class\n * @param {string} tableName\n * @param {Array} fields\n * @param {Object} options\n * @constructor\n */\nfunction Table(tableName, fields, options) {\n    for (let i = 0; i < fields.length; i += 1) {\n        const field = fields[i];\n        this[field.name] = field.value;\n    }\n\n    this.tableName = tableName;\n    this.fields = fields;\n    if (options) {\n        const optionKeys = Object.keys(options);\n        for (let i = 0; i < optionKeys.length; i += 1) {\n            const k = optionKeys[i];\n            const v = options[k];\n            if (this[k] !== undefined) {\n                this[k] = v;\n            }\n        }\n    }\n}\n\n/**\n * Encodes the table and returns an array of bytes\n * @return {Array}\n */\nTable.prototype.encode = function() {\n    return encode.TABLE(this);\n};\n\n/**\n * Get the size of the table.\n * @return {number}\n */\nTable.prototype.sizeOf = function() {\n    return sizeOf.TABLE(this);\n};\n\n/**\n * @private\n */\nfunction ushortList(itemName, list, count) {\n    if (count === undefined) {\n        count = list.length;\n    }\n    const fields = new Array(list.length + 1);\n    fields[0] = {name: itemName + 'Count', type: 'USHORT', value: count};\n    for (let i = 0; i < list.length; i++) {\n        fields[i + 1] = {name: itemName + i, type: 'USHORT', value: list[i]};\n    }\n    return fields;\n}\n\n/**\n * @private\n */\nfunction tableList(itemName, records, itemCallback) {\n    const count = records.length;\n    const fields = new Array(count + 1);\n    fields[0] = {name: itemName + 'Count', type: 'USHORT', value: count};\n    for (let i = 0; i < count; i++) {\n        fields[i + 1] = {name: itemName + i, type: 'TABLE', value: itemCallback(records[i], i)};\n    }\n    return fields;\n}\n\n/**\n * @private\n */\nfunction recordList(itemName, records, itemCallback) {\n    const count = records.length;\n    let fields = [];\n    fields[0] = {name: itemName + 'Count', type: 'USHORT', value: count};\n    for (let i = 0; i < count; i++) {\n        fields = fields.concat(itemCallback(records[i], i));\n    }\n    return fields;\n}\n\n// Common Layout Tables\n\n/**\n * @exports opentype.Coverage\n * @class\n * @param {opentype.Table}\n * @constructor\n * @extends opentype.Table\n */\nfunction Coverage(coverageTable) {\n    if (coverageTable.format === 1) {\n        Table.call(this, 'coverageTable',\n            [{name: 'coverageFormat', type: 'USHORT', value: 1}]\n            .concat(ushortList('glyph', coverageTable.glyphs))\n        );\n    } else {\n        check.assert(false, 'Can\\'t create coverage table format 2 yet.');\n    }\n}\nCoverage.prototype = Object.create(Table.prototype);\nCoverage.prototype.constructor = Coverage;\n\nfunction ScriptList(scriptListTable) {\n    Table.call(this, 'scriptListTable',\n        recordList('scriptRecord', scriptListTable, function(scriptRecord, i) {\n            const script = scriptRecord.script;\n            let defaultLangSys = script.defaultLangSys;\n            check.assert(!!defaultLangSys, 'Unable to write GSUB: script ' + scriptRecord.tag + ' has no default language system.');\n            return [\n                {name: 'scriptTag' + i, type: 'TAG', value: scriptRecord.tag},\n                {name: 'script' + i, type: 'TABLE', value: new Table('scriptTable', [\n                    {name: 'defaultLangSys', type: 'TABLE', value: new Table('defaultLangSys', [\n                        {name: 'lookupOrder', type: 'USHORT', value: 0},\n                        {name: 'reqFeatureIndex', type: 'USHORT', value: defaultLangSys.reqFeatureIndex}]\n                        .concat(ushortList('featureIndex', defaultLangSys.featureIndexes)))}\n                    ].concat(recordList('langSys', script.langSysRecords, function(langSysRecord, i) {\n                        const langSys = langSysRecord.langSys;\n                        return [\n                            {name: 'langSysTag' + i, type: 'TAG', value: langSysRecord.tag},\n                            {name: 'langSys' + i, type: 'TABLE', value: new Table('langSys', [\n                                {name: 'lookupOrder', type: 'USHORT', value: 0},\n                                {name: 'reqFeatureIndex', type: 'USHORT', value: langSys.reqFeatureIndex}\n                                ].concat(ushortList('featureIndex', langSys.featureIndexes)))}\n                        ];\n                    })))}\n            ];\n        })\n    );\n}\nScriptList.prototype = Object.create(Table.prototype);\nScriptList.prototype.constructor = ScriptList;\n\n/**\n * @exports opentype.FeatureList\n * @class\n * @param {opentype.Table}\n * @constructor\n * @extends opentype.Table\n */\nfunction FeatureList(featureListTable) {\n    Table.call(this, 'featureListTable',\n        recordList('featureRecord', featureListTable, function(featureRecord, i) {\n            const feature = featureRecord.feature;\n            return [\n                {name: 'featureTag' + i, type: 'TAG', value: featureRecord.tag},\n                {name: 'feature' + i, type: 'TABLE', value: new Table('featureTable', [\n                    {name: 'featureParams', type: 'USHORT', value: feature.featureParams},\n                    ].concat(ushortList('lookupListIndex', feature.lookupListIndexes)))}\n            ];\n        })\n    );\n}\nFeatureList.prototype = Object.create(Table.prototype);\nFeatureList.prototype.constructor = FeatureList;\n\n/**\n * @exports opentype.LookupList\n * @class\n * @param {opentype.Table}\n * @param {Object}\n * @constructor\n * @extends opentype.Table\n */\nfunction LookupList(lookupListTable, subtableMakers) {\n    Table.call(this, 'lookupListTable', tableList('lookup', lookupListTable, function(lookupTable) {\n        let subtableCallback = subtableMakers[lookupTable.lookupType];\n        check.assert(!!subtableCallback, 'Unable to write GSUB lookup type ' + lookupTable.lookupType + ' tables.');\n        return new Table('lookupTable', [\n            {name: 'lookupType', type: 'USHORT', value: lookupTable.lookupType},\n            {name: 'lookupFlag', type: 'USHORT', value: lookupTable.lookupFlag}\n        ].concat(tableList('subtable', lookupTable.subtables, subtableCallback)));\n    }));\n}\nLookupList.prototype = Object.create(Table.prototype);\nLookupList.prototype.constructor = LookupList;\n\n// Record = same as Table, but inlined (a Table has an offset and its data is further in the stream)\n// Don't use offsets inside Records (probable bug), only in Tables.\n/* harmony default export */ var src_table = ({\n    Table,\n    Record: Table,\n    Coverage,\n    ScriptList,\n    FeatureList,\n    LookupList,\n    ushortList,\n    tableList,\n    recordList,\n});\n\n// CONCATENATED MODULE: ./node_modules/opentype.js/src/parse.js\n// Parsing utility functions\n\n\n\n// Retrieve an unsigned byte from the DataView.\nfunction getByte(dataView, offset) {\n    return dataView.getUint8(offset);\n}\n\n// Retrieve an unsigned 16-bit short from the DataView.\n// The value is stored in big endian.\nfunction getUShort(dataView, offset) {\n    return dataView.getUint16(offset, false);\n}\n\n// Retrieve a signed 16-bit short from the DataView.\n// The value is stored in big endian.\nfunction getShort(dataView, offset) {\n    return dataView.getInt16(offset, false);\n}\n\n// Retrieve an unsigned 32-bit long from the DataView.\n// The value is stored in big endian.\nfunction getULong(dataView, offset) {\n    return dataView.getUint32(offset, false);\n}\n\n// Retrieve a 32-bit signed fixed-point number (16.16) from the DataView.\n// The value is stored in big endian.\nfunction getFixed(dataView, offset) {\n    const decimal = dataView.getInt16(offset, false);\n    const fraction = dataView.getUint16(offset + 2, false);\n    return decimal + fraction / 65535;\n}\n\n// Retrieve a 4-character tag from the DataView.\n// Tags are used to identify tables.\nfunction getTag(dataView, offset) {\n    let tag = '';\n    for (let i = offset; i < offset + 4; i += 1) {\n        tag += String.fromCharCode(dataView.getInt8(i));\n    }\n\n    return tag;\n}\n\n// Retrieve an offset from the DataView.\n// Offsets are 1 to 4 bytes in length, depending on the offSize argument.\nfunction getOffset(dataView, offset, offSize) {\n    let v = 0;\n    for (let i = 0; i < offSize; i += 1) {\n        v <<= 8;\n        v += dataView.getUint8(offset + i);\n    }\n\n    return v;\n}\n\n// Retrieve a number of bytes from start offset to the end offset from the DataView.\nfunction getBytes(dataView, startOffset, endOffset) {\n    const bytes = [];\n    for (let i = startOffset; i < endOffset; i += 1) {\n        bytes.push(dataView.getUint8(i));\n    }\n\n    return bytes;\n}\n\n// Convert the list of bytes to a string.\nfunction bytesToString(bytes) {\n    let s = '';\n    for (let i = 0; i < bytes.length; i += 1) {\n        s += String.fromCharCode(bytes[i]);\n    }\n\n    return s;\n}\n\nconst typeOffsets = {\n    byte: 1,\n    uShort: 2,\n    short: 2,\n    uLong: 4,\n    fixed: 4,\n    longDateTime: 8,\n    tag: 4\n};\n\n// A stateful parser that changes the offset whenever a value is retrieved.\n// The data is a DataView.\nfunction Parser(data, offset) {\n    this.data = data;\n    this.offset = offset;\n    this.relativeOffset = 0;\n}\n\nParser.prototype.parseByte = function() {\n    const v = this.data.getUint8(this.offset + this.relativeOffset);\n    this.relativeOffset += 1;\n    return v;\n};\n\nParser.prototype.parseChar = function() {\n    const v = this.data.getInt8(this.offset + this.relativeOffset);\n    this.relativeOffset += 1;\n    return v;\n};\n\nParser.prototype.parseCard8 = Parser.prototype.parseByte;\n\nParser.prototype.parseUShort = function() {\n    const v = this.data.getUint16(this.offset + this.relativeOffset);\n    this.relativeOffset += 2;\n    return v;\n};\n\nParser.prototype.parseCard16 = Parser.prototype.parseUShort;\nParser.prototype.parseSID = Parser.prototype.parseUShort;\nParser.prototype.parseOffset16 = Parser.prototype.parseUShort;\n\nParser.prototype.parseShort = function() {\n    const v = this.data.getInt16(this.offset + this.relativeOffset);\n    this.relativeOffset += 2;\n    return v;\n};\n\nParser.prototype.parseF2Dot14 = function() {\n    const v = this.data.getInt16(this.offset + this.relativeOffset) / 16384;\n    this.relativeOffset += 2;\n    return v;\n};\n\nParser.prototype.parseULong = function() {\n    const v = getULong(this.data, this.offset + this.relativeOffset);\n    this.relativeOffset += 4;\n    return v;\n};\n\nParser.prototype.parseFixed = function() {\n    const v = getFixed(this.data, this.offset + this.relativeOffset);\n    this.relativeOffset += 4;\n    return v;\n};\n\nParser.prototype.parseString = function(length) {\n    const dataView = this.data;\n    const offset = this.offset + this.relativeOffset;\n    let string = '';\n    this.relativeOffset += length;\n    for (let i = 0; i < length; i++) {\n        string += String.fromCharCode(dataView.getUint8(offset + i));\n    }\n\n    return string;\n};\n\nParser.prototype.parseTag = function() {\n    return this.parseString(4);\n};\n\n// LONGDATETIME is a 64-bit integer.\n// JavaScript and unix timestamps traditionally use 32 bits, so we\n// only take the last 32 bits.\n// + Since until 2038 those bits will be filled by zeros we can ignore them.\nParser.prototype.parseLongDateTime = function() {\n    let v = getULong(this.data, this.offset + this.relativeOffset + 4);\n    // Subtract seconds between 01/01/1904 and 01/01/1970\n    // to convert Apple Mac timestamp to Standard Unix timestamp\n    v -= 2082844800;\n    this.relativeOffset += 8;\n    return v;\n};\n\nParser.prototype.parseVersion = function() {\n    const major = getUShort(this.data, this.offset + this.relativeOffset);\n\n    // How to interpret the minor version is very vague in the spec. 0x5000 is 5, 0x1000 is 1\n    // This returns the correct number if minor = 0xN000 where N is 0-9\n    const minor = getUShort(this.data, this.offset + this.relativeOffset + 2);\n    this.relativeOffset += 4;\n    return major + minor / 0x1000 / 10;\n};\n\nParser.prototype.skip = function(type, amount) {\n    if (amount === undefined) {\n        amount = 1;\n    }\n\n    this.relativeOffset += typeOffsets[type] * amount;\n};\n\n///// Parsing lists and records ///////////////////////////////\n\n// Parse a list of 16 bit unsigned integers. The length of the list can be read on the stream\n// or provided as an argument.\nParser.prototype.parseOffset16List =\nParser.prototype.parseUShortList = function(count) {\n    if (count === undefined) { count = this.parseUShort(); }\n    const offsets = new Array(count);\n    const dataView = this.data;\n    let offset = this.offset + this.relativeOffset;\n    for (let i = 0; i < count; i++) {\n        offsets[i] = dataView.getUint16(offset);\n        offset += 2;\n    }\n\n    this.relativeOffset += count * 2;\n    return offsets;\n};\n\n// Parses a list of 16 bit signed integers.\nParser.prototype.parseShortList = function(count) {\n    const list = new Array(count);\n    const dataView = this.data;\n    let offset = this.offset + this.relativeOffset;\n    for (let i = 0; i < count; i++) {\n        list[i] = dataView.getInt16(offset);\n        offset += 2;\n    }\n\n    this.relativeOffset += count * 2;\n    return list;\n};\n\n// Parses a list of bytes.\nParser.prototype.parseByteList = function(count) {\n    const list = new Array(count);\n    const dataView = this.data;\n    let offset = this.offset + this.relativeOffset;\n    for (let i = 0; i < count; i++) {\n        list[i] = dataView.getUint8(offset++);\n    }\n\n    this.relativeOffset += count;\n    return list;\n};\n\n/**\n * Parse a list of items.\n * Record count is optional, if omitted it is read from the stream.\n * itemCallback is one of the Parser methods.\n */\nParser.prototype.parseList = function(count, itemCallback) {\n    if (!itemCallback) {\n        itemCallback = count;\n        count = this.parseUShort();\n    }\n    const list = new Array(count);\n    for (let i = 0; i < count; i++) {\n        list[i] = itemCallback.call(this);\n    }\n    return list;\n};\n\n/**\n * Parse a list of records.\n * Record count is optional, if omitted it is read from the stream.\n * Example of recordDescription: { sequenceIndex: Parser.uShort, lookupListIndex: Parser.uShort }\n */\nParser.prototype.parseRecordList = function(count, recordDescription) {\n    // If the count argument is absent, read it in the stream.\n    if (!recordDescription) {\n        recordDescription = count;\n        count = this.parseUShort();\n    }\n    const records = new Array(count);\n    const fields = Object.keys(recordDescription);\n    for (let i = 0; i < count; i++) {\n        const rec = {};\n        for (let j = 0; j < fields.length; j++) {\n            const fieldName = fields[j];\n            const fieldType = recordDescription[fieldName];\n            rec[fieldName] = fieldType.call(this);\n        }\n        records[i] = rec;\n    }\n    return records;\n};\n\n// Parse a data structure into an object\n// Example of description: { sequenceIndex: Parser.uShort, lookupListIndex: Parser.uShort }\nParser.prototype.parseStruct = function(description) {\n    if (typeof description === 'function') {\n        return description.call(this);\n    } else {\n        const fields = Object.keys(description);\n        const struct = {};\n        for (let j = 0; j < fields.length; j++) {\n            const fieldName = fields[j];\n            const fieldType = description[fieldName];\n            struct[fieldName] = fieldType.call(this);\n        }\n        return struct;\n    }\n};\n\nParser.prototype.parsePointer = function(description) {\n    const structOffset = this.parseOffset16();\n    if (structOffset > 0) {                         // NULL offset => return undefined\n        return new Parser(this.data, this.offset + structOffset).parseStruct(description);\n    }\n    return undefined;\n};\n\n/**\n * Parse a list of offsets to lists of 16-bit integers,\n * or a list of offsets to lists of offsets to any kind of items.\n * If itemCallback is not provided, a list of list of UShort is assumed.\n * If provided, itemCallback is called on each item and must parse the item.\n * See examples in tables/gsub.js\n */\nParser.prototype.parseListOfLists = function(itemCallback) {\n    const offsets = this.parseOffset16List();\n    const count = offsets.length;\n    const relativeOffset = this.relativeOffset;\n    const list = new Array(count);\n    for (let i = 0; i < count; i++) {\n        const start = offsets[i];\n        if (start === 0) {                  // NULL offset\n            list[i] = undefined;            // Add i as owned property to list. Convenient with assert.\n            continue;\n        }\n        this.relativeOffset = start;\n        if (itemCallback) {\n            const subOffsets = this.parseOffset16List();\n            const subList = new Array(subOffsets.length);\n            for (let j = 0; j < subOffsets.length; j++) {\n                this.relativeOffset = start + subOffsets[j];\n                subList[j] = itemCallback.call(this);\n            }\n            list[i] = subList;\n        } else {\n            list[i] = this.parseUShortList();\n        }\n    }\n    this.relativeOffset = relativeOffset;\n    return list;\n};\n\n///// Complex tables parsing //////////////////////////////////\n\n// Parse a coverage table in a GSUB, GPOS or GDEF table.\n// https://www.microsoft.com/typography/OTSPEC/chapter2.htm\n// parser.offset must point to the start of the table containing the coverage.\nParser.prototype.parseCoverage = function() {\n    const startOffset = this.offset + this.relativeOffset;\n    const format = this.parseUShort();\n    const count = this.parseUShort();\n    if (format === 1) {\n        return {\n            format: 1,\n            glyphs: this.parseUShortList(count)\n        };\n    } else if (format === 2) {\n        const ranges = new Array(count);\n        for (let i = 0; i < count; i++) {\n            ranges[i] = {\n                start: this.parseUShort(),\n                end: this.parseUShort(),\n                index: this.parseUShort()\n            };\n        }\n        return {\n            format: 2,\n            ranges: ranges\n        };\n    }\n    throw new Error('0x' + startOffset.toString(16) + ': Coverage format must be 1 or 2.');\n};\n\n// Parse a Class Definition Table in a GSUB, GPOS or GDEF table.\n// https://www.microsoft.com/typography/OTSPEC/chapter2.htm\nParser.prototype.parseClassDef = function() {\n    const startOffset = this.offset + this.relativeOffset;\n    const format = this.parseUShort();\n    if (format === 1) {\n        return {\n            format: 1,\n            startGlyph: this.parseUShort(),\n            classes: this.parseUShortList()\n        };\n    } else if (format === 2) {\n        return {\n            format: 2,\n            ranges: this.parseRecordList({\n                start: Parser.uShort,\n                end: Parser.uShort,\n                classId: Parser.uShort\n            })\n        };\n    }\n    throw new Error('0x' + startOffset.toString(16) + ': ClassDef format must be 1 or 2.');\n};\n\n///// Static methods ///////////////////////////////////\n// These convenience methods can be used as callbacks and should be called with \"this\" context set to a Parser instance.\n\nParser.list = function(count, itemCallback) {\n    return function() {\n        return this.parseList(count, itemCallback);\n    };\n};\n\nParser.recordList = function(count, recordDescription) {\n    return function() {\n        return this.parseRecordList(count, recordDescription);\n    };\n};\n\nParser.pointer = function(description) {\n    return function() {\n        return this.parsePointer(description);\n    };\n};\n\nParser.tag = Parser.prototype.parseTag;\nParser.byte = Parser.prototype.parseByte;\nParser.uShort = Parser.offset16 = Parser.prototype.parseUShort;\nParser.uShortList = Parser.prototype.parseUShortList;\nParser.struct = Parser.prototype.parseStruct;\nParser.coverage = Parser.prototype.parseCoverage;\nParser.classDef = Parser.prototype.parseClassDef;\n\n///// Script, Feature, Lookup lists ///////////////////////////////////////////////\n// https://www.microsoft.com/typography/OTSPEC/chapter2.htm\n\nconst parse_langSysTable = {\n    reserved: Parser.uShort,\n    reqFeatureIndex: Parser.uShort,\n    featureIndexes: Parser.uShortList\n};\n\nParser.prototype.parseScriptList = function() {\n    return this.parsePointer(Parser.recordList({\n        tag: Parser.tag,\n        script: Parser.pointer({\n            defaultLangSys: Parser.pointer(parse_langSysTable),\n            langSysRecords: Parser.recordList({\n                tag: Parser.tag,\n                langSys: Parser.pointer(parse_langSysTable)\n            })\n        })\n    }));\n};\n\nParser.prototype.parseFeatureList = function() {\n    return this.parsePointer(Parser.recordList({\n        tag: Parser.tag,\n        feature: Parser.pointer({\n            featureParams: Parser.offset16,\n            lookupListIndexes: Parser.uShortList\n        })\n    }));\n};\n\nParser.prototype.parseLookupList = function(lookupTableParsers) {\n    return this.parsePointer(Parser.list(Parser.pointer(function() {\n        const lookupType = this.parseUShort();\n        check.argument(1 <= lookupType && lookupType <= 8, 'GSUB lookup type ' + lookupType + ' unknown.');\n        const lookupFlag = this.parseUShort();\n        const useMarkFilteringSet = lookupFlag & 0x10;\n        return {\n            lookupType: lookupType,\n            lookupFlag: lookupFlag,\n            subtables: this.parseList(Parser.pointer(lookupTableParsers[lookupType])),\n            markFilteringSet: useMarkFilteringSet ? this.parseUShort() : undefined\n        };\n    })));\n};\n\n/* harmony default export */ var src_parse = ({\n    getByte,\n    getCard8: getByte,\n    getUShort,\n    getCard16: getUShort,\n    getShort,\n    getULong,\n    getFixed,\n    getTag,\n    getOffset,\n    getBytes,\n    bytesToString,\n    Parser,\n});\n\n\n\n// CONCATENATED MODULE: ./node_modules/opentype.js/src/tables/cmap.js\n// The `cmap` table stores the mappings from characters to glyphs.\n// https://www.microsoft.com/typography/OTSPEC/cmap.htm\n\n\n\n\n\nfunction parseCmapTableFormat12(cmap, p) {\n    //Skip reserved.\n    p.parseUShort();\n\n    // Length in bytes of the sub-tables.\n    cmap.length = p.parseULong();\n    cmap.language = p.parseULong();\n\n    let groupCount;\n    cmap.groupCount = groupCount = p.parseULong();\n    cmap.glyphIndexMap = {};\n\n    for (let i = 0; i < groupCount; i += 1) {\n        const startCharCode = p.parseULong();\n        const endCharCode = p.parseULong();\n        let startGlyphId = p.parseULong();\n\n        for (let c = startCharCode; c <= endCharCode; c += 1) {\n            cmap.glyphIndexMap[c] = startGlyphId;\n            startGlyphId++;\n        }\n    }\n}\n\nfunction parseCmapTableFormat4(cmap, p, data, start, offset) {\n    // Length in bytes of the sub-tables.\n    cmap.length = p.parseUShort();\n    cmap.language = p.parseUShort();\n\n    // segCount is stored x 2.\n    let segCount;\n    cmap.segCount = segCount = p.parseUShort() >> 1;\n\n    // Skip searchRange, entrySelector, rangeShift.\n    p.skip('uShort', 3);\n\n    // The \"unrolled\" mapping from character codes to glyph indices.\n    cmap.glyphIndexMap = {};\n    const endCountParser = new src_parse.Parser(data, start + offset + 14);\n    const startCountParser = new src_parse.Parser(data, start + offset + 16 + segCount * 2);\n    const idDeltaParser = new src_parse.Parser(data, start + offset + 16 + segCount * 4);\n    const idRangeOffsetParser = new src_parse.Parser(data, start + offset + 16 + segCount * 6);\n    let glyphIndexOffset = start + offset + 16 + segCount * 8;\n    for (let i = 0; i < segCount - 1; i += 1) {\n        let glyphIndex;\n        const endCount = endCountParser.parseUShort();\n        const startCount = startCountParser.parseUShort();\n        const idDelta = idDeltaParser.parseShort();\n        const idRangeOffset = idRangeOffsetParser.parseUShort();\n        for (let c = startCount; c <= endCount; c += 1) {\n            if (idRangeOffset !== 0) {\n                // The idRangeOffset is relative to the current position in the idRangeOffset array.\n                // Take the current offset in the idRangeOffset array.\n                glyphIndexOffset = (idRangeOffsetParser.offset + idRangeOffsetParser.relativeOffset - 2);\n\n                // Add the value of the idRangeOffset, which will move us into the glyphIndex array.\n                glyphIndexOffset += idRangeOffset;\n\n                // Then add the character index of the current segment, multiplied by 2 for USHORTs.\n                glyphIndexOffset += (c - startCount) * 2;\n                glyphIndex = src_parse.getUShort(data, glyphIndexOffset);\n                if (glyphIndex !== 0) {\n                    glyphIndex = (glyphIndex + idDelta) & 0xFFFF;\n                }\n            } else {\n                glyphIndex = (c + idDelta) & 0xFFFF;\n            }\n\n            cmap.glyphIndexMap[c] = glyphIndex;\n        }\n    }\n}\n\n// Parse the `cmap` table. This table stores the mappings from characters to glyphs.\n// There are many available formats, but we only support the Windows format 4 and 12.\n// This function returns a `CmapEncoding` object or null if no supported format could be found.\nfunction parseCmapTable(data, start) {\n    const cmap = {};\n    cmap.version = src_parse.getUShort(data, start);\n    check.argument(cmap.version === 0, 'cmap table version should be 0.');\n\n    // The cmap table can contain many sub-tables, each with their own format.\n    // We're only interested in a \"platform 3\" table. This is a Windows format.\n    cmap.numTables = src_parse.getUShort(data, start + 2);\n    let offset = -1;\n    for (let i = cmap.numTables - 1; i >= 0; i -= 1) {\n        const platformId = src_parse.getUShort(data, start + 4 + (i * 8));\n        const encodingId = src_parse.getUShort(data, start + 4 + (i * 8) + 2);\n        if (platformId === 3 && (encodingId === 0 || encodingId === 1 || encodingId === 10)) {\n            offset = src_parse.getULong(data, start + 4 + (i * 8) + 4);\n            break;\n        }\n    }\n\n    if (offset === -1) {\n        // There is no cmap table in the font that we support.\n        throw new Error('No valid cmap sub-tables found.');\n    }\n\n    const p = new src_parse.Parser(data, start + offset);\n    cmap.format = p.parseUShort();\n\n    if (cmap.format === 12) {\n        parseCmapTableFormat12(cmap, p);\n    } else if (cmap.format === 4) {\n        parseCmapTableFormat4(cmap, p, data, start, offset);\n    } else {\n        throw new Error('Only format 4 and 12 cmap tables are supported (found format ' + cmap.format + ').');\n    }\n\n    return cmap;\n}\n\nfunction addSegment(t, code, glyphIndex) {\n    t.segments.push({\n        end: code,\n        start: code,\n        delta: -(code - glyphIndex),\n        offset: 0\n    });\n}\n\nfunction addTerminatorSegment(t) {\n    t.segments.push({\n        end: 0xFFFF,\n        start: 0xFFFF,\n        delta: 1,\n        offset: 0\n    });\n}\n\nfunction makeCmapTable(glyphs) {\n    const t = new src_table.Table('cmap', [\n        {name: 'version', type: 'USHORT', value: 0},\n        {name: 'numTables', type: 'USHORT', value: 1},\n        {name: 'platformID', type: 'USHORT', value: 3},\n        {name: 'encodingID', type: 'USHORT', value: 1},\n        {name: 'offset', type: 'ULONG', value: 12},\n        {name: 'format', type: 'USHORT', value: 4},\n        {name: 'length', type: 'USHORT', value: 0},\n        {name: 'language', type: 'USHORT', value: 0},\n        {name: 'segCountX2', type: 'USHORT', value: 0},\n        {name: 'searchRange', type: 'USHORT', value: 0},\n        {name: 'entrySelector', type: 'USHORT', value: 0},\n        {name: 'rangeShift', type: 'USHORT', value: 0}\n    ]);\n\n    t.segments = [];\n    for (let i = 0; i < glyphs.length; i += 1) {\n        const glyph = glyphs.get(i);\n        for (let j = 0; j < glyph.unicodes.length; j += 1) {\n            addSegment(t, glyph.unicodes[j], i);\n        }\n\n        t.segments = t.segments.sort(function(a, b) {\n            return a.start - b.start;\n        });\n    }\n\n    addTerminatorSegment(t);\n\n    let segCount;\n    segCount = t.segments.length;\n    t.segCountX2 = segCount * 2;\n    t.searchRange = Math.pow(2, Math.floor(Math.log(segCount) / Math.log(2))) * 2;\n    t.entrySelector = Math.log(t.searchRange / 2) / Math.log(2);\n    t.rangeShift = t.segCountX2 - t.searchRange;\n\n    // Set up parallel segment arrays.\n    let endCounts = [];\n    let startCounts = [];\n    let idDeltas = [];\n    let idRangeOffsets = [];\n    let glyphIds = [];\n\n    for (let i = 0; i < segCount; i += 1) {\n        const segment = t.segments[i];\n        endCounts = endCounts.concat({name: 'end_' + i, type: 'USHORT', value: segment.end});\n        startCounts = startCounts.concat({name: 'start_' + i, type: 'USHORT', value: segment.start});\n        idDeltas = idDeltas.concat({name: 'idDelta_' + i, type: 'SHORT', value: segment.delta});\n        idRangeOffsets = idRangeOffsets.concat({name: 'idRangeOffset_' + i, type: 'USHORT', value: segment.offset});\n        if (segment.glyphId !== undefined) {\n            glyphIds = glyphIds.concat({name: 'glyph_' + i, type: 'USHORT', value: segment.glyphId});\n        }\n    }\n\n    t.fields = t.fields.concat(endCounts);\n    t.fields.push({name: 'reservedPad', type: 'USHORT', value: 0});\n    t.fields = t.fields.concat(startCounts);\n    t.fields = t.fields.concat(idDeltas);\n    t.fields = t.fields.concat(idRangeOffsets);\n    t.fields = t.fields.concat(glyphIds);\n\n    t.length = 14 + // Subtable header\n        endCounts.length * 2 +\n        2 + // reservedPad\n        startCounts.length * 2 +\n        idDeltas.length * 2 +\n        idRangeOffsets.length * 2 +\n        glyphIds.length * 2;\n\n    return t;\n}\n\n/* harmony default export */ var tables_cmap = ({ parse: parseCmapTable, make: makeCmapTable });\n\n// CONCATENATED MODULE: ./node_modules/opentype.js/src/encoding.js\n// Glyph encoding\n\nconst cffStandardStrings = [\n    '.notdef', 'space', 'exclam', 'quotedbl', 'numbersign', 'dollar', 'percent', 'ampersand', 'quoteright',\n    'parenleft', 'parenright', 'asterisk', 'plus', 'comma', 'hyphen', 'period', 'slash', 'zero', 'one', 'two',\n    'three', 'four', 'five', 'six', 'seven', 'eight', 'nine', 'colon', 'semicolon', 'less', 'equal', 'greater',\n    'question', 'at', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S',\n    'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'bracketleft', 'backslash', 'bracketright', 'asciicircum', 'underscore',\n    'quoteleft', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't',\n    'u', 'v', 'w', 'x', 'y', 'z', 'braceleft', 'bar', 'braceright', 'asciitilde', 'exclamdown', 'cent', 'sterling',\n    'fraction', 'yen', 'florin', 'section', 'currency', 'quotesingle', 'quotedblleft', 'guillemotleft',\n    'guilsinglleft', 'guilsinglright', 'fi', 'fl', 'endash', 'dagger', 'daggerdbl', 'periodcentered', 'paragraph',\n    'bullet', 'quotesinglbase', 'quotedblbase', 'quotedblright', 'guillemotright', 'ellipsis', 'perthousand',\n    'questiondown', 'grave', 'acute', 'circumflex', 'tilde', 'macron', 'breve', 'dotaccent', 'dieresis', 'ring',\n    'cedilla', 'hungarumlaut', 'ogonek', 'caron', 'emdash', 'AE', 'ordfeminine', 'Lslash', 'Oslash', 'OE',\n    'ordmasculine', 'ae', 'dotlessi', 'lslash', 'oslash', 'oe', 'germandbls', 'onesuperior', 'logicalnot', 'mu',\n    'trademark', 'Eth', 'onehalf', 'plusminus', 'Thorn', 'onequarter', 'divide', 'brokenbar', 'degree', 'thorn',\n    'threequarters', 'twosuperior', 'registered', 'minus', 'eth', 'multiply', 'threesuperior', 'copyright',\n    'Aacute', 'Acircumflex', 'Adieresis', 'Agrave', 'Aring', 'Atilde', 'Ccedilla', 'Eacute', 'Ecircumflex',\n    'Edieresis', 'Egrave', 'Iacute', 'Icircumflex', 'Idieresis', 'Igrave', 'Ntilde', 'Oacute', 'Ocircumflex',\n    'Odieresis', 'Ograve', 'Otilde', 'Scaron', 'Uacute', 'Ucircumflex', 'Udieresis', 'Ugrave', 'Yacute',\n    'Ydieresis', 'Zcaron', 'aacute', 'acircumflex', 'adieresis', 'agrave', 'aring', 'atilde', 'ccedilla', 'eacute',\n    'ecircumflex', 'edieresis', 'egrave', 'iacute', 'icircumflex', 'idieresis', 'igrave', 'ntilde', 'oacute',\n    'ocircumflex', 'odieresis', 'ograve', 'otilde', 'scaron', 'uacute', 'ucircumflex', 'udieresis', 'ugrave',\n    'yacute', 'ydieresis', 'zcaron', 'exclamsmall', 'Hungarumlautsmall', 'dollaroldstyle', 'dollarsuperior',\n    'ampersandsmall', 'Acutesmall', 'parenleftsuperior', 'parenrightsuperior', '266 ff', 'onedotenleader',\n    'zerooldstyle', 'oneoldstyle', 'twooldstyle', 'threeoldstyle', 'fouroldstyle', 'fiveoldstyle', 'sixoldstyle',\n    'sevenoldstyle', 'eightoldstyle', 'nineoldstyle', 'commasuperior', 'threequartersemdash', 'periodsuperior',\n    'questionsmall', 'asuperior', 'bsuperior', 'centsuperior', 'dsuperior', 'esuperior', 'isuperior', 'lsuperior',\n    'msuperior', 'nsuperior', 'osuperior', 'rsuperior', 'ssuperior', 'tsuperior', 'ff', 'ffi', 'ffl',\n    'parenleftinferior', 'parenrightinferior', 'Circumflexsmall', 'hyphensuperior', 'Gravesmall', 'Asmall',\n    'Bsmall', 'Csmall', 'Dsmall', 'Esmall', 'Fsmall', 'Gsmall', 'Hsmall', 'Ismall', 'Jsmall', 'Ksmall', 'Lsmall',\n    'Msmall', 'Nsmall', 'Osmall', 'Psmall', 'Qsmall', 'Rsmall', 'Ssmall', 'Tsmall', 'Usmall', 'Vsmall', 'Wsmall',\n    'Xsmall', 'Ysmall', 'Zsmall', 'colonmonetary', 'onefitted', 'rupiah', 'Tildesmall', 'exclamdownsmall',\n    'centoldstyle', 'Lslashsmall', 'Scaronsmall', 'Zcaronsmall', 'Dieresissmall', 'Brevesmall', 'Caronsmall',\n    'Dotaccentsmall', 'Macronsmall', 'figuredash', 'hypheninferior', 'Ogoneksmall', 'Ringsmall', 'Cedillasmall',\n    'questiondownsmall', 'oneeighth', 'threeeighths', 'fiveeighths', 'seveneighths', 'onethird', 'twothirds',\n    'zerosuperior', 'foursuperior', 'fivesuperior', 'sixsuperior', 'sevensuperior', 'eightsuperior', 'ninesuperior',\n    'zeroinferior', 'oneinferior', 'twoinferior', 'threeinferior', 'fourinferior', 'fiveinferior', 'sixinferior',\n    'seveninferior', 'eightinferior', 'nineinferior', 'centinferior', 'dollarinferior', 'periodinferior',\n    'commainferior', 'Agravesmall', 'Aacutesmall', 'Acircumflexsmall', 'Atildesmall', 'Adieresissmall',\n    'Aringsmall', 'AEsmall', 'Ccedillasmall', 'Egravesmall', 'Eacutesmall', 'Ecircumflexsmall', 'Edieresissmall',\n    'Igravesmall', 'Iacutesmall', 'Icircumflexsmall', 'Idieresissmall', 'Ethsmall', 'Ntildesmall', 'Ogravesmall',\n    'Oacutesmall', 'Ocircumflexsmall', 'Otildesmall', 'Odieresissmall', 'OEsmall', 'Oslashsmall', 'Ugravesmall',\n    'Uacutesmall', 'Ucircumflexsmall', 'Udieresissmall', 'Yacutesmall', 'Thornsmall', 'Ydieresissmall', '001.000',\n    '001.001', '001.002', '001.003', 'Black', 'Bold', 'Book', 'Light', 'Medium', 'Regular', 'Roman', 'Semibold'];\n\nconst cffStandardEncoding = [\n    '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '',\n    '', '', '', '', 'space', 'exclam', 'quotedbl', 'numbersign', 'dollar', 'percent', 'ampersand', 'quoteright',\n    'parenleft', 'parenright', 'asterisk', 'plus', 'comma', 'hyphen', 'period', 'slash', 'zero', 'one', 'two',\n    'three', 'four', 'five', 'six', 'seven', 'eight', 'nine', 'colon', 'semicolon', 'less', 'equal', 'greater',\n    'question', 'at', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S',\n    'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'bracketleft', 'backslash', 'bracketright', 'asciicircum', 'underscore',\n    'quoteleft', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't',\n    'u', 'v', 'w', 'x', 'y', 'z', 'braceleft', 'bar', 'braceright', 'asciitilde', '', '', '', '', '', '', '', '',\n    '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '',\n    'exclamdown', 'cent', 'sterling', 'fraction', 'yen', 'florin', 'section', 'currency', 'quotesingle',\n    'quotedblleft', 'guillemotleft', 'guilsinglleft', 'guilsinglright', 'fi', 'fl', '', 'endash', 'dagger',\n    'daggerdbl', 'periodcentered', '', 'paragraph', 'bullet', 'quotesinglbase', 'quotedblbase', 'quotedblright',\n    'guillemotright', 'ellipsis', 'perthousand', '', 'questiondown', '', 'grave', 'acute', 'circumflex', 'tilde',\n    'macron', 'breve', 'dotaccent', 'dieresis', '', 'ring', 'cedilla', '', 'hungarumlaut', 'ogonek', 'caron',\n    'emdash', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', 'AE', '', 'ordfeminine', '', '', '',\n    '', 'Lslash', 'Oslash', 'OE', 'ordmasculine', '', '', '', '', '', 'ae', '', '', '', 'dotlessi', '', '',\n    'lslash', 'oslash', 'oe', 'germandbls'];\n\nconst cffExpertEncoding = [\n    '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '',\n    '', '', '', '', 'space', 'exclamsmall', 'Hungarumlautsmall', '', 'dollaroldstyle', 'dollarsuperior',\n    'ampersandsmall', 'Acutesmall', 'parenleftsuperior', 'parenrightsuperior', 'twodotenleader', 'onedotenleader',\n    'comma', 'hyphen', 'period', 'fraction', 'zerooldstyle', 'oneoldstyle', 'twooldstyle', 'threeoldstyle',\n    'fouroldstyle', 'fiveoldstyle', 'sixoldstyle', 'sevenoldstyle', 'eightoldstyle', 'nineoldstyle', 'colon',\n    'semicolon', 'commasuperior', 'threequartersemdash', 'periodsuperior', 'questionsmall', '', 'asuperior',\n    'bsuperior', 'centsuperior', 'dsuperior', 'esuperior', '', '', 'isuperior', '', '', 'lsuperior', 'msuperior',\n    'nsuperior', 'osuperior', '', '', 'rsuperior', 'ssuperior', 'tsuperior', '', 'ff', 'fi', 'fl', 'ffi', 'ffl',\n    'parenleftinferior', '', 'parenrightinferior', 'Circumflexsmall', 'hyphensuperior', 'Gravesmall', 'Asmall',\n    'Bsmall', 'Csmall', 'Dsmall', 'Esmall', 'Fsmall', 'Gsmall', 'Hsmall', 'Ismall', 'Jsmall', 'Ksmall', 'Lsmall',\n    'Msmall', 'Nsmall', 'Osmall', 'Psmall', 'Qsmall', 'Rsmall', 'Ssmall', 'Tsmall', 'Usmall', 'Vsmall', 'Wsmall',\n    'Xsmall', 'Ysmall', 'Zsmall', 'colonmonetary', 'onefitted', 'rupiah', 'Tildesmall', '', '', '', '', '', '', '',\n    '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '',\n    'exclamdownsmall', 'centoldstyle', 'Lslashsmall', '', '', 'Scaronsmall', 'Zcaronsmall', 'Dieresissmall',\n    'Brevesmall', 'Caronsmall', '', 'Dotaccentsmall', '', '', 'Macronsmall', '', '', 'figuredash', 'hypheninferior',\n    '', '', 'Ogoneksmall', 'Ringsmall', 'Cedillasmall', '', '', '', 'onequarter', 'onehalf', 'threequarters',\n    'questiondownsmall', 'oneeighth', 'threeeighths', 'fiveeighths', 'seveneighths', 'onethird', 'twothirds', '',\n    '', 'zerosuperior', 'onesuperior', 'twosuperior', 'threesuperior', 'foursuperior', 'fivesuperior',\n    'sixsuperior', 'sevensuperior', 'eightsuperior', 'ninesuperior', 'zeroinferior', 'oneinferior', 'twoinferior',\n    'threeinferior', 'fourinferior', 'fiveinferior', 'sixinferior', 'seveninferior', 'eightinferior',\n    'nineinferior', 'centinferior', 'dollarinferior', 'periodinferior', 'commainferior', 'Agravesmall',\n    'Aacutesmall', 'Acircumflexsmall', 'Atildesmall', 'Adieresissmall', 'Aringsmall', 'AEsmall', 'Ccedillasmall',\n    'Egravesmall', 'Eacutesmall', 'Ecircumflexsmall', 'Edieresissmall', 'Igravesmall', 'Iacutesmall',\n    'Icircumflexsmall', 'Idieresissmall', 'Ethsmall', 'Ntildesmall', 'Ogravesmall', 'Oacutesmall',\n    'Ocircumflexsmall', 'Otildesmall', 'Odieresissmall', 'OEsmall', 'Oslashsmall', 'Ugravesmall', 'Uacutesmall',\n    'Ucircumflexsmall', 'Udieresissmall', 'Yacutesmall', 'Thornsmall', 'Ydieresissmall'];\n\nconst standardNames = [\n    '.notdef', '.null', 'nonmarkingreturn', 'space', 'exclam', 'quotedbl', 'numbersign', 'dollar', 'percent',\n    'ampersand', 'quotesingle', 'parenleft', 'parenright', 'asterisk', 'plus', 'comma', 'hyphen', 'period', 'slash',\n    'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine', 'colon', 'semicolon', 'less',\n    'equal', 'greater', 'question', 'at', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O',\n    'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'bracketleft', 'backslash', 'bracketright',\n    'asciicircum', 'underscore', 'grave', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o',\n    'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', 'braceleft', 'bar', 'braceright', 'asciitilde',\n    'Adieresis', 'Aring', 'Ccedilla', 'Eacute', 'Ntilde', 'Odieresis', 'Udieresis', 'aacute', 'agrave',\n    'acircumflex', 'adieresis', 'atilde', 'aring', 'ccedilla', 'eacute', 'egrave', 'ecircumflex', 'edieresis',\n    'iacute', 'igrave', 'icircumflex', 'idieresis', 'ntilde', 'oacute', 'ograve', 'ocircumflex', 'odieresis',\n    'otilde', 'uacute', 'ugrave', 'ucircumflex', 'udieresis', 'dagger', 'degree', 'cent', 'sterling', 'section',\n    'bullet', 'paragraph', 'germandbls', 'registered', 'copyright', 'trademark', 'acute', 'dieresis', 'notequal',\n    'AE', 'Oslash', 'infinity', 'plusminus', 'lessequal', 'greaterequal', 'yen', 'mu', 'partialdiff', 'summation',\n    'product', 'pi', 'integral', 'ordfeminine', 'ordmasculine', 'Omega', 'ae', 'oslash', 'questiondown',\n    'exclamdown', 'logicalnot', 'radical', 'florin', 'approxequal', 'Delta', 'guillemotleft', 'guillemotright',\n    'ellipsis', 'nonbreakingspace', 'Agrave', 'Atilde', 'Otilde', 'OE', 'oe', 'endash', 'emdash', 'quotedblleft',\n    'quotedblright', 'quoteleft', 'quoteright', 'divide', 'lozenge', 'ydieresis', 'Ydieresis', 'fraction',\n    'currency', 'guilsinglleft', 'guilsinglright', 'fi', 'fl', 'daggerdbl', 'periodcentered', 'quotesinglbase',\n    'quotedblbase', 'perthousand', 'Acircumflex', 'Ecircumflex', 'Aacute', 'Edieresis', 'Egrave', 'Iacute',\n    'Icircumflex', 'Idieresis', 'Igrave', 'Oacute', 'Ocircumflex', 'apple', 'Ograve', 'Uacute', 'Ucircumflex',\n    'Ugrave', 'dotlessi', 'circumflex', 'tilde', 'macron', 'breve', 'dotaccent', 'ring', 'cedilla', 'hungarumlaut',\n    'ogonek', 'caron', 'Lslash', 'lslash', 'Scaron', 'scaron', 'Zcaron', 'zcaron', 'brokenbar', 'Eth', 'eth',\n    'Yacute', 'yacute', 'Thorn', 'thorn', 'minus', 'multiply', 'onesuperior', 'twosuperior', 'threesuperior',\n    'onehalf', 'onequarter', 'threequarters', 'franc', 'Gbreve', 'gbreve', 'Idotaccent', 'Scedilla', 'scedilla',\n    'Cacute', 'cacute', 'Ccaron', 'ccaron', 'dcroat'];\n\n/**\n * This is the encoding used for fonts created from scratch.\n * It loops through all glyphs and finds the appropriate unicode value.\n * Since it's linear time, other encodings will be faster.\n * @exports opentype.DefaultEncoding\n * @class\n * @constructor\n * @param {opentype.Font}\n */\nfunction DefaultEncoding(font) {\n    this.font = font;\n}\n\nDefaultEncoding.prototype.charToGlyphIndex = function(c) {\n    const code = c.charCodeAt(0);\n    const glyphs = this.font.glyphs;\n    if (glyphs) {\n        for (let i = 0; i < glyphs.length; i += 1) {\n            const glyph = glyphs.get(i);\n            for (let j = 0; j < glyph.unicodes.length; j += 1) {\n                if (glyph.unicodes[j] === code) {\n                    return i;\n                }\n            }\n        }\n    }\n    return null;\n};\n\n/**\n * @exports opentype.CmapEncoding\n * @class\n * @constructor\n * @param {Object} cmap - a object with the cmap encoded data\n */\nfunction CmapEncoding(cmap) {\n    this.cmap = cmap;\n}\n\n/**\n * @param  {string} c - the character\n * @return {number} The glyph index.\n */\nCmapEncoding.prototype.charToGlyphIndex = function(c) {\n    return this.cmap.glyphIndexMap[c.charCodeAt(0)] || 0;\n};\n\n/**\n * @exports opentype.CffEncoding\n * @class\n * @constructor\n * @param {string} encoding - The encoding\n * @param {Array} charset - The character set.\n */\nfunction CffEncoding(encoding, charset) {\n    this.encoding = encoding;\n    this.charset = charset;\n}\n\n/**\n * @param  {string} s - The character\n * @return {number} The index.\n */\nCffEncoding.prototype.charToGlyphIndex = function(s) {\n    const code = s.charCodeAt(0);\n    const charName = this.encoding[code];\n    return this.charset.indexOf(charName);\n};\n\n/**\n * @exports opentype.GlyphNames\n * @class\n * @constructor\n * @param {Object} post\n */\nfunction GlyphNames(post) {\n    switch (post.version) {\n        case 1:\n            this.names = standardNames.slice();\n            break;\n        case 2:\n            this.names = new Array(post.numberOfGlyphs);\n            for (let i = 0; i < post.numberOfGlyphs; i++) {\n                if (post.glyphNameIndex[i] < standardNames.length) {\n                    this.names[i] = standardNames[post.glyphNameIndex[i]];\n                } else {\n                    this.names[i] = post.names[post.glyphNameIndex[i] - standardNames.length];\n                }\n            }\n\n            break;\n        case 2.5:\n            this.names = new Array(post.numberOfGlyphs);\n            for (let i = 0; i < post.numberOfGlyphs; i++) {\n                this.names[i] = standardNames[i + post.glyphNameIndex[i]];\n            }\n\n            break;\n        case 3:\n            this.names = [];\n            break;\n        default:\n            this.names = [];\n            break;\n    }\n}\n\n/**\n * Gets the index of a glyph by name.\n * @param  {string} name - The glyph name\n * @return {number} The index\n */\nGlyphNames.prototype.nameToGlyphIndex = function(name) {\n    return this.names.indexOf(name);\n};\n\n/**\n * @param  {number} gid\n * @return {string}\n */\nGlyphNames.prototype.glyphIndexToName = function(gid) {\n    return this.names[gid];\n};\n\n/**\n * @alias opentype.addGlyphNames\n * @param {opentype.Font}\n */\nfunction addGlyphNames(font) {\n    let glyph;\n    const glyphIndexMap = font.tables.cmap.glyphIndexMap;\n    const charCodes = Object.keys(glyphIndexMap);\n\n    for (let i = 0; i < charCodes.length; i += 1) {\n        const c = charCodes[i];\n        const glyphIndex = glyphIndexMap[c];\n        glyph = font.glyphs.get(glyphIndex);\n        glyph.addUnicode(parseInt(c));\n    }\n\n    for (let i = 0; i < font.glyphs.length; i += 1) {\n        glyph = font.glyphs.get(i);\n        if (font.cffEncoding) {\n            if (font.isCIDFont) {\n                glyph.name = 'gid' + i;\n            } else {\n                glyph.name = font.cffEncoding.charset[i];\n            }\n        } else if (font.glyphNames.names) {\n            glyph.name = font.glyphNames.glyphIndexToName(i);\n        }\n    }\n}\n\n\n\n// CONCATENATED MODULE: ./node_modules/opentype.js/src/draw.js\n// Drawing utility functions.\n\n// Draw a line on the given context from point `x1,y1` to point `x2,y2`.\nfunction line(ctx, x1, y1, x2, y2) {\n    ctx.beginPath();\n    ctx.moveTo(x1, y1);\n    ctx.lineTo(x2, y2);\n    ctx.stroke();\n}\n\n/* harmony default export */ var draw = ({ line });\n\n// CONCATENATED MODULE: ./node_modules/opentype.js/src/tables/glyf.js\n// The `glyf` table describes the glyphs in TrueType outline format.\n// http://www.microsoft.com/typography/otspec/glyf.htm\n\n\n\n\n\n\n// Parse the coordinate data for a glyph.\nfunction parseGlyphCoordinate(p, flag, previousValue, shortVectorBitMask, sameBitMask) {\n    let v;\n    if ((flag & shortVectorBitMask) > 0) {\n        // The coordinate is 1 byte long.\n        v = p.parseByte();\n        // The `same` bit is re-used for short values to signify the sign of the value.\n        if ((flag & sameBitMask) === 0) {\n            v = -v;\n        }\n\n        v = previousValue + v;\n    } else {\n        //  The coordinate is 2 bytes long.\n        // If the `same` bit is set, the coordinate is the same as the previous coordinate.\n        if ((flag & sameBitMask) > 0) {\n            v = previousValue;\n        } else {\n            // Parse the coordinate as a signed 16-bit delta value.\n            v = previousValue + p.parseShort();\n        }\n    }\n\n    return v;\n}\n\n// Parse a TrueType glyph.\nfunction glyf_parseGlyph(glyph, data, start) {\n    const p = new src_parse.Parser(data, start);\n    glyph.numberOfContours = p.parseShort();\n    glyph._xMin = p.parseShort();\n    glyph._yMin = p.parseShort();\n    glyph._xMax = p.parseShort();\n    glyph._yMax = p.parseShort();\n    let flags;\n    let flag;\n\n    if (glyph.numberOfContours > 0) {\n        // This glyph is not a composite.\n        const endPointIndices = glyph.endPointIndices = [];\n        for (let i = 0; i < glyph.numberOfContours; i += 1) {\n            endPointIndices.push(p.parseUShort());\n        }\n\n        glyph.instructionLength = p.parseUShort();\n        glyph.instructions = [];\n        for (let i = 0; i < glyph.instructionLength; i += 1) {\n            glyph.instructions.push(p.parseByte());\n        }\n\n        const numberOfCoordinates = endPointIndices[endPointIndices.length - 1] + 1;\n        flags = [];\n        for (let i = 0; i < numberOfCoordinates; i += 1) {\n            flag = p.parseByte();\n            flags.push(flag);\n            // If bit 3 is set, we repeat this flag n times, where n is the next byte.\n            if ((flag & 8) > 0) {\n                const repeatCount = p.parseByte();\n                for (let j = 0; j < repeatCount; j += 1) {\n                    flags.push(flag);\n                    i += 1;\n                }\n            }\n        }\n\n        check.argument(flags.length === numberOfCoordinates, 'Bad flags.');\n\n        if (endPointIndices.length > 0) {\n            const points = [];\n            let point;\n            // X/Y coordinates are relative to the previous point, except for the first point which is relative to 0,0.\n            if (numberOfCoordinates > 0) {\n                for (let i = 0; i < numberOfCoordinates; i += 1) {\n                    flag = flags[i];\n                    point = {};\n                    point.onCurve = !!(flag & 1);\n                    point.lastPointOfContour = endPointIndices.indexOf(i) >= 0;\n                    points.push(point);\n                }\n\n                let px = 0;\n                for (let i = 0; i < numberOfCoordinates; i += 1) {\n                    flag = flags[i];\n                    point = points[i];\n                    point.x = parseGlyphCoordinate(p, flag, px, 2, 16);\n                    px = point.x;\n                }\n\n                let py = 0;\n                for (let i = 0; i < numberOfCoordinates; i += 1) {\n                    flag = flags[i];\n                    point = points[i];\n                    point.y = parseGlyphCoordinate(p, flag, py, 4, 32);\n                    py = point.y;\n                }\n            }\n\n            glyph.points = points;\n        } else {\n            glyph.points = [];\n        }\n    } else if (glyph.numberOfContours === 0) {\n        glyph.points = [];\n    } else {\n        glyph.isComposite = true;\n        glyph.points = [];\n        glyph.components = [];\n        let moreComponents = true;\n        while (moreComponents) {\n            flags = p.parseUShort();\n            const component = {\n                glyphIndex: p.parseUShort(),\n                xScale: 1,\n                scale01: 0,\n                scale10: 0,\n                yScale: 1,\n                dx: 0,\n                dy: 0\n            };\n            if ((flags & 1) > 0) {\n                // The arguments are words\n                if ((flags & 2) > 0) {\n                    // values are offset\n                    component.dx = p.parseShort();\n                    component.dy = p.parseShort();\n                } else {\n                    // values are matched points\n                    component.matchedPoints = [p.parseUShort(), p.parseUShort()];\n                }\n\n            } else {\n                // The arguments are bytes\n                if ((flags & 2) > 0) {\n                    // values are offset\n                    component.dx = p.parseChar();\n                    component.dy = p.parseChar();\n                } else {\n                    // values are matched points\n                    component.matchedPoints = [p.parseByte(), p.parseByte()];\n                }\n            }\n\n            if ((flags & 8) > 0) {\n                // We have a scale\n                component.xScale = component.yScale = p.parseF2Dot14();\n            } else if ((flags & 64) > 0) {\n                // We have an X / Y scale\n                component.xScale = p.parseF2Dot14();\n                component.yScale = p.parseF2Dot14();\n            } else if ((flags & 128) > 0) {\n                // We have a 2x2 transformation\n                component.xScale = p.parseF2Dot14();\n                component.scale01 = p.parseF2Dot14();\n                component.scale10 = p.parseF2Dot14();\n                component.yScale = p.parseF2Dot14();\n            }\n\n            glyph.components.push(component);\n            moreComponents = !!(flags & 32);\n        }\n        if (flags & 0x100) {\n            // We have instructions\n            glyph.instructionLength = p.parseUShort();\n            glyph.instructions = [];\n            for (let i = 0; i < glyph.instructionLength; i += 1) {\n                glyph.instructions.push(p.parseByte());\n            }\n        }\n    }\n}\n\n// Transform an array of points and return a new array.\nfunction transformPoints(points, transform) {\n    const newPoints = [];\n    for (let i = 0; i < points.length; i += 1) {\n        const pt = points[i];\n        const newPt = {\n            x: transform.xScale * pt.x + transform.scale01 * pt.y + transform.dx,\n            y: transform.scale10 * pt.x + transform.yScale * pt.y + transform.dy,\n            onCurve: pt.onCurve,\n            lastPointOfContour: pt.lastPointOfContour\n        };\n        newPoints.push(newPt);\n    }\n\n    return newPoints;\n}\n\nfunction getContours(points) {\n    const contours = [];\n    let currentContour = [];\n    for (let i = 0; i < points.length; i += 1) {\n        const pt = points[i];\n        currentContour.push(pt);\n        if (pt.lastPointOfContour) {\n            contours.push(currentContour);\n            currentContour = [];\n        }\n    }\n\n    check.argument(currentContour.length === 0, 'There are still points left in the current contour.');\n    return contours;\n}\n\n// Convert the TrueType glyph outline to a Path.\nfunction getPath(points) {\n    const p = new src_path();\n    if (!points) {\n        return p;\n    }\n\n    const contours = getContours(points);\n\n    for (let contourIndex = 0; contourIndex < contours.length; ++contourIndex) {\n        const contour = contours[contourIndex];\n\n        let prev = null;\n        let curr = contour[contour.length - 1];\n        let next = contour[0];\n\n        if (curr.onCurve) {\n            p.moveTo(curr.x, curr.y);\n        } else {\n            if (next.onCurve) {\n                p.moveTo(next.x, next.y);\n            } else {\n                // If both first and last points are off-curve, start at their middle.\n                const start = {x: (curr.x + next.x) * 0.5, y: (curr.y + next.y) * 0.5};\n                p.moveTo(start.x, start.y);\n            }\n        }\n\n        for (let i = 0; i < contour.length; ++i) {\n            prev = curr;\n            curr = next;\n            next = contour[(i + 1) % contour.length];\n\n            if (curr.onCurve) {\n                // This is a straight line.\n                p.lineTo(curr.x, curr.y);\n            } else {\n                let prev2 = prev;\n                let next2 = next;\n\n                if (!prev.onCurve) {\n                    prev2 = { x: (curr.x + prev.x) * 0.5, y: (curr.y + prev.y) * 0.5 };\n                    p.lineTo(prev2.x, prev2.y);\n                }\n\n                if (!next.onCurve) {\n                    next2 = { x: (curr.x + next.x) * 0.5, y: (curr.y + next.y) * 0.5 };\n                }\n\n                p.lineTo(prev2.x, prev2.y);\n                p.quadraticCurveTo(curr.x, curr.y, next2.x, next2.y);\n            }\n        }\n\n        p.closePath();\n    }\n    return p;\n}\n\nfunction glyf_buildPath(glyphs, glyph) {\n    if (glyph.isComposite) {\n        for (let j = 0; j < glyph.components.length; j += 1) {\n            const component = glyph.components[j];\n            const componentGlyph = glyphs.get(component.glyphIndex);\n            // Force the ttfGlyphLoader to parse the glyph.\n            componentGlyph.getPath();\n            if (componentGlyph.points) {\n                let transformedPoints;\n                if (component.matchedPoints === undefined) {\n                    // component positioned by offset\n                    transformedPoints = transformPoints(componentGlyph.points, component);\n                } else {\n                    // component positioned by matched points\n                    if ((component.matchedPoints[0] > glyph.points.length - 1) ||\n                        (component.matchedPoints[1] > componentGlyph.points.length - 1)) {\n                        throw Error('Matched points out of range in ' + glyph.name);\n                    }\n                    const firstPt = glyph.points[component.matchedPoints[0]];\n                    let secondPt = componentGlyph.points[component.matchedPoints[1]];\n                    const transform = {\n                        xScale: component.xScale, scale01: component.scale01,\n                        scale10: component.scale10, yScale: component.yScale,\n                        dx: 0, dy: 0\n                    };\n                    secondPt = transformPoints([secondPt], transform)[0];\n                    transform.dx = firstPt.x - secondPt.x;\n                    transform.dy = firstPt.y - secondPt.y;\n                    transformedPoints = transformPoints(componentGlyph.points, transform);\n                }\n                glyph.points = glyph.points.concat(transformedPoints);\n            }\n        }\n    }\n\n    return getPath(glyph.points);\n}\n\n// Parse all the glyphs according to the offsets from the `loca` table.\nfunction parseGlyfTable(data, start, loca, font) {\n    const glyphs = new glyphset.GlyphSet(font);\n\n    // The last element of the loca table is invalid.\n    for (let i = 0; i < loca.length - 1; i += 1) {\n        const offset = loca[i];\n        const nextOffset = loca[i + 1];\n        if (offset !== nextOffset) {\n            glyphs.push(i, glyphset.ttfGlyphLoader(font, i, glyf_parseGlyph, data, start + offset, glyf_buildPath));\n        } else {\n            glyphs.push(i, glyphset.glyphLoader(font, i));\n        }\n    }\n\n    return glyphs;\n}\n\n/* harmony default export */ var glyf = ({ getPath, parse: parseGlyfTable });\n\n// CONCATENATED MODULE: ./node_modules/opentype.js/src/glyph.js\n// The Glyph object\n\n\n\n\n\n\nfunction getPathDefinition(glyph, path) {\n    let _path = path || {commands: []};\n    return {\n        configurable: true,\n\n        get: function() {\n            if (typeof _path === 'function') {\n                _path = _path();\n            }\n\n            return _path;\n        },\n\n        set: function(p) {\n            _path = p;\n        }\n    };\n}\n/**\n * @typedef GlyphOptions\n * @type Object\n * @property {string} [name] - The glyph name\n * @property {number} [unicode]\n * @property {Array} [unicodes]\n * @property {number} [xMin]\n * @property {number} [yMin]\n * @property {number} [xMax]\n * @property {number} [yMax]\n * @property {number} [advanceWidth]\n */\n\n// A Glyph is an individual mark that often corresponds to a character.\n// Some glyphs, such as ligatures, are a combination of many characters.\n// Glyphs are the basic building blocks of a font.\n//\n// The `Glyph` class contains utility methods for drawing the path and its points.\n/**\n * @exports opentype.Glyph\n * @class\n * @param {GlyphOptions}\n * @constructor\n */\nfunction Glyph(options) {\n    // By putting all the code on a prototype function (which is only declared once)\n    // we reduce the memory requirements for larger fonts by some 2%\n    this.bindConstructorValues(options);\n}\n\n/**\n * @param  {GlyphOptions}\n */\nGlyph.prototype.bindConstructorValues = function(options) {\n    this.index = options.index || 0;\n\n    // These three values cannot be deferred for memory optimization:\n    this.name = options.name || null;\n    this.unicode = options.unicode || undefined;\n    this.unicodes = options.unicodes || options.unicode !== undefined ? [options.unicode] : [];\n\n    // But by binding these values only when necessary, we reduce can\n    // the memory requirements by almost 3% for larger fonts.\n    if (options.xMin) {\n        this.xMin = options.xMin;\n    }\n\n    if (options.yMin) {\n        this.yMin = options.yMin;\n    }\n\n    if (options.xMax) {\n        this.xMax = options.xMax;\n    }\n\n    if (options.yMax) {\n        this.yMax = options.yMax;\n    }\n\n    if (options.advanceWidth) {\n        this.advanceWidth = options.advanceWidth;\n    }\n\n    // The path for a glyph is the most memory intensive, and is bound as a value\n    // with a getter/setter to ensure we actually do path parsing only once the\n    // path is actually needed by anything.\n    Object.defineProperty(this, 'path', getPathDefinition(this, options.path));\n};\n\n/**\n * @param {number}\n */\nGlyph.prototype.addUnicode = function(unicode) {\n    if (this.unicodes.length === 0) {\n        this.unicode = unicode;\n    }\n\n    this.unicodes.push(unicode);\n};\n\n/**\n * Calculate the minimum bounding box for this glyph.\n * @return {opentype.BoundingBox}\n */\nGlyph.prototype.getBoundingBox = function() {\n    return this.path.getBoundingBox();\n};\n\n/**\n * Convert the glyph to a Path we can draw on a drawing context.\n * @param  {number} [x=0] - Horizontal position of the beginning of the text.\n * @param  {number} [y=0] - Vertical position of the *baseline* of the text.\n * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.\n * @param  {Object=} options - xScale, yScale to stretch the glyph.\n * @param  {opentype.Font} if hinting is to be used, the font\n * @return {opentype.Path}\n */\nGlyph.prototype.getPath = function(x, y, fontSize, options, font) {\n    x = x !== undefined ? x : 0;\n    y = y !== undefined ? y : 0;\n    fontSize = fontSize !== undefined ? fontSize : 72;\n    let commands;\n    let hPoints;\n    if (!options) options = { };\n    let xScale = options.xScale;\n    let yScale = options.yScale;\n\n    if (options.hinting && font && font.hinting) {\n        // in case of hinting, the hinting engine takes care\n        // of scaling the points (not the path) before hinting.\n        hPoints = this.path && font.hinting.exec(this, fontSize);\n        // in case the hinting engine failed hPoints is undefined\n        // and thus reverts to plain rending\n    }\n\n    if (hPoints) {\n        commands = glyf.getPath(hPoints).commands;\n        x = Math.round(x);\n        y = Math.round(y);\n        // TODO in case of hinting xyScaling is not yet supported\n        xScale = yScale = 1;\n    } else {\n        commands = this.path.commands;\n        const scale = 1 / this.path.unitsPerEm * fontSize;\n        if (xScale === undefined) xScale = scale;\n        if (yScale === undefined) yScale = scale;\n    }\n\n    const p = new src_path();\n    for (let i = 0; i < commands.length; i += 1) {\n        const cmd = commands[i];\n        if (cmd.type === 'M') {\n            p.moveTo(x + (cmd.x * xScale), y + (-cmd.y * yScale));\n        } else if (cmd.type === 'L') {\n            p.lineTo(x + (cmd.x * xScale), y + (-cmd.y * yScale));\n        } else if (cmd.type === 'Q') {\n            p.quadraticCurveTo(x + (cmd.x1 * xScale), y + (-cmd.y1 * yScale),\n                               x + (cmd.x * xScale), y + (-cmd.y * yScale));\n        } else if (cmd.type === 'C') {\n            p.curveTo(x + (cmd.x1 * xScale), y + (-cmd.y1 * yScale),\n                      x + (cmd.x2 * xScale), y + (-cmd.y2 * yScale),\n                      x + (cmd.x * xScale), y + (-cmd.y * yScale));\n        } else if (cmd.type === 'Z') {\n            p.closePath();\n        }\n    }\n\n    return p;\n};\n\n/**\n * Split the glyph into contours.\n * This function is here for backwards compatibility, and to\n * provide raw access to the TrueType glyph outlines.\n * @return {Array}\n */\nGlyph.prototype.getContours = function() {\n    if (this.points === undefined) {\n        return [];\n    }\n\n    const contours = [];\n    let currentContour = [];\n    for (let i = 0; i < this.points.length; i += 1) {\n        const pt = this.points[i];\n        currentContour.push(pt);\n        if (pt.lastPointOfContour) {\n            contours.push(currentContour);\n            currentContour = [];\n        }\n    }\n\n    check.argument(currentContour.length === 0, 'There are still points left in the current contour.');\n    return contours;\n};\n\n/**\n * Calculate the xMin/yMin/xMax/yMax/lsb/rsb for a Glyph.\n * @return {Object}\n */\nGlyph.prototype.getMetrics = function() {\n    const commands = this.path.commands;\n    const xCoords = [];\n    const yCoords = [];\n    for (let i = 0; i < commands.length; i += 1) {\n        const cmd = commands[i];\n        if (cmd.type !== 'Z') {\n            xCoords.push(cmd.x);\n            yCoords.push(cmd.y);\n        }\n\n        if (cmd.type === 'Q' || cmd.type === 'C') {\n            xCoords.push(cmd.x1);\n            yCoords.push(cmd.y1);\n        }\n\n        if (cmd.type === 'C') {\n            xCoords.push(cmd.x2);\n            yCoords.push(cmd.y2);\n        }\n    }\n\n    const metrics = {\n        xMin: Math.min.apply(null, xCoords),\n        yMin: Math.min.apply(null, yCoords),\n        xMax: Math.max.apply(null, xCoords),\n        yMax: Math.max.apply(null, yCoords),\n        leftSideBearing: this.leftSideBearing\n    };\n\n    if (!isFinite(metrics.xMin)) {\n        metrics.xMin = 0;\n    }\n\n    if (!isFinite(metrics.xMax)) {\n        metrics.xMax = this.advanceWidth;\n    }\n\n    if (!isFinite(metrics.yMin)) {\n        metrics.yMin = 0;\n    }\n\n    if (!isFinite(metrics.yMax)) {\n        metrics.yMax = 0;\n    }\n\n    metrics.rightSideBearing = this.advanceWidth - metrics.leftSideBearing - (metrics.xMax - metrics.xMin);\n    return metrics;\n};\n\n/**\n * Draw the glyph on the given context.\n * @param  {CanvasRenderingContext2D} ctx - A 2D drawing context, like Canvas.\n * @param  {number} [x=0] - Horizontal position of the beginning of the text.\n * @param  {number} [y=0] - Vertical position of the *baseline* of the text.\n * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.\n * @param  {Object=} options - xScale, yScale to stretch the glyph.\n */\nGlyph.prototype.draw = function(ctx, x, y, fontSize, options) {\n    this.getPath(x, y, fontSize, options).draw(ctx);\n};\n\n/**\n * Draw the points of the glyph.\n * On-curve points will be drawn in blue, off-curve points will be drawn in red.\n * @param  {CanvasRenderingContext2D} ctx - A 2D drawing context, like Canvas.\n * @param  {number} [x=0] - Horizontal position of the beginning of the text.\n * @param  {number} [y=0] - Vertical position of the *baseline* of the text.\n * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.\n */\nGlyph.prototype.drawPoints = function(ctx, x, y, fontSize) {\n    function drawCircles(l, x, y, scale) {\n        const PI_SQ = Math.PI * 2;\n        ctx.beginPath();\n        for (let j = 0; j < l.length; j += 1) {\n            ctx.moveTo(x + (l[j].x * scale), y + (l[j].y * scale));\n            ctx.arc(x + (l[j].x * scale), y + (l[j].y * scale), 2, 0, PI_SQ, false);\n        }\n\n        ctx.closePath();\n        ctx.fill();\n    }\n\n    x = x !== undefined ? x : 0;\n    y = y !== undefined ? y : 0;\n    fontSize = fontSize !== undefined ? fontSize : 24;\n    const scale = 1 / this.path.unitsPerEm * fontSize;\n\n    const blueCircles = [];\n    const redCircles = [];\n    const path = this.path;\n    for (let i = 0; i < path.commands.length; i += 1) {\n        const cmd = path.commands[i];\n        if (cmd.x !== undefined) {\n            blueCircles.push({x: cmd.x, y: -cmd.y});\n        }\n\n        if (cmd.x1 !== undefined) {\n            redCircles.push({x: cmd.x1, y: -cmd.y1});\n        }\n\n        if (cmd.x2 !== undefined) {\n            redCircles.push({x: cmd.x2, y: -cmd.y2});\n        }\n    }\n\n    ctx.fillStyle = 'blue';\n    drawCircles(blueCircles, x, y, scale);\n    ctx.fillStyle = 'red';\n    drawCircles(redCircles, x, y, scale);\n};\n\n/**\n * Draw lines indicating important font measurements.\n * Black lines indicate the origin of the coordinate system (point 0,0).\n * Blue lines indicate the glyph bounding box.\n * Green line indicates the advance width of the glyph.\n * @param  {CanvasRenderingContext2D} ctx - A 2D drawing context, like Canvas.\n * @param  {number} [x=0] - Horizontal position of the beginning of the text.\n * @param  {number} [y=0] - Vertical position of the *baseline* of the text.\n * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.\n */\nGlyph.prototype.drawMetrics = function(ctx, x, y, fontSize) {\n    let scale;\n    x = x !== undefined ? x : 0;\n    y = y !== undefined ? y : 0;\n    fontSize = fontSize !== undefined ? fontSize : 24;\n    scale = 1 / this.path.unitsPerEm * fontSize;\n    ctx.lineWidth = 1;\n\n    // Draw the origin\n    ctx.strokeStyle = 'black';\n    draw.line(ctx, x, -10000, x, 10000);\n    draw.line(ctx, -10000, y, 10000, y);\n\n    // This code is here due to memory optimization: by not using\n    // defaults in the constructor, we save a notable amount of memory.\n    const xMin = this.xMin || 0;\n    let yMin = this.yMin || 0;\n    const xMax = this.xMax || 0;\n    let yMax = this.yMax || 0;\n    const advanceWidth = this.advanceWidth || 0;\n\n    // Draw the glyph box\n    ctx.strokeStyle = 'blue';\n    draw.line(ctx, x + (xMin * scale), -10000, x + (xMin * scale), 10000);\n    draw.line(ctx, x + (xMax * scale), -10000, x + (xMax * scale), 10000);\n    draw.line(ctx, -10000, y + (-yMin * scale), 10000, y + (-yMin * scale));\n    draw.line(ctx, -10000, y + (-yMax * scale), 10000, y + (-yMax * scale));\n\n    // Draw the advance width\n    ctx.strokeStyle = 'green';\n    draw.line(ctx, x + (advanceWidth * scale), -10000, x + (advanceWidth * scale), 10000);\n};\n\n/* harmony default export */ var src_glyph = (Glyph);\n\n// CONCATENATED MODULE: ./node_modules/opentype.js/src/glyphset.js\n// The GlyphSet object\n\n\n\n// Define a property on the glyph that depends on the path being loaded.\nfunction defineDependentProperty(glyph, externalName, internalName) {\n    Object.defineProperty(glyph, externalName, {\n        get: function() {\n            // Request the path property to make sure the path is loaded.\n            glyph.path; // jshint ignore:line\n            return glyph[internalName];\n        },\n        set: function(newValue) {\n            glyph[internalName] = newValue;\n        },\n        enumerable: true,\n        configurable: true\n    });\n}\n\n/**\n * A GlyphSet represents all glyphs available in the font, but modelled using\n * a deferred glyph loader, for retrieving glyphs only once they are absolutely\n * necessary, to keep the memory footprint down.\n * @exports opentype.GlyphSet\n * @class\n * @param {opentype.Font}\n * @param {Array}\n */\nfunction GlyphSet(font, glyphs) {\n    this.font = font;\n    this.glyphs = {};\n    if (Array.isArray(glyphs)) {\n        for (let i = 0; i < glyphs.length; i++) {\n            this.glyphs[i] = glyphs[i];\n        }\n    }\n\n    this.length = (glyphs && glyphs.length) || 0;\n}\n\n/**\n * @param  {number} index\n * @return {opentype.Glyph}\n */\nGlyphSet.prototype.get = function(index) {\n    if (typeof this.glyphs[index] === 'function') {\n        this.glyphs[index] = this.glyphs[index]();\n    }\n\n    return this.glyphs[index];\n};\n\n/**\n * @param  {number} index\n * @param  {Object}\n */\nGlyphSet.prototype.push = function(index, loader) {\n    this.glyphs[index] = loader;\n    this.length++;\n};\n\n/**\n * @alias opentype.glyphLoader\n * @param  {opentype.Font} font\n * @param  {number} index\n * @return {opentype.Glyph}\n */\nfunction glyphLoader(font, index) {\n    return new src_glyph({index: index, font: font});\n}\n\n/**\n * Generate a stub glyph that can be filled with all metadata *except*\n * the \"points\" and \"path\" properties, which must be loaded only once\n * the glyph's path is actually requested for text shaping.\n * @alias opentype.ttfGlyphLoader\n * @param  {opentype.Font} font\n * @param  {number} index\n * @param  {Function} parseGlyph\n * @param  {Object} data\n * @param  {number} position\n * @param  {Function} buildPath\n * @return {opentype.Glyph}\n */\nfunction ttfGlyphLoader(font, index, parseGlyph, data, position, buildPath) {\n    return function() {\n        const glyph = new src_glyph({index: index, font: font});\n\n        glyph.path = function() {\n            parseGlyph(glyph, data, position);\n            const path = buildPath(font.glyphs, glyph);\n            path.unitsPerEm = font.unitsPerEm;\n            return path;\n        };\n\n        defineDependentProperty(glyph, 'xMin', '_xMin');\n        defineDependentProperty(glyph, 'xMax', '_xMax');\n        defineDependentProperty(glyph, 'yMin', '_yMin');\n        defineDependentProperty(glyph, 'yMax', '_yMax');\n\n        return glyph;\n    };\n}\n/**\n * @alias opentype.cffGlyphLoader\n * @param  {opentype.Font} font\n * @param  {number} index\n * @param  {Function} parseCFFCharstring\n * @param  {string} charstring\n * @return {opentype.Glyph}\n */\nfunction cffGlyphLoader(font, index, parseCFFCharstring, charstring) {\n    return function() {\n        const glyph = new src_glyph({index: index, font: font});\n\n        glyph.path = function() {\n            const path = parseCFFCharstring(font, glyph, charstring);\n            path.unitsPerEm = font.unitsPerEm;\n            return path;\n        };\n\n        return glyph;\n    };\n}\n\n/* harmony default export */ var glyphset = ({ GlyphSet, glyphLoader, ttfGlyphLoader, cffGlyphLoader });\n\n// CONCATENATED MODULE: ./node_modules/opentype.js/src/tables/cff.js\n// The `CFF` table contains the glyph outlines in PostScript format.\n// https://www.microsoft.com/typography/OTSPEC/cff.htm\n// http://download.microsoft.com/download/8/0/1/801a191c-029d-4af3-9642-555f6fe514ee/cff.pdf\n// http://download.microsoft.com/download/8/0/1/801a191c-029d-4af3-9642-555f6fe514ee/type2.pdf\n\n\n\n\n\n\n\n// Custom equals function that can also check lists.\nfunction equals(a, b) {\n    if (a === b) {\n        return true;\n    } else if (Array.isArray(a) && Array.isArray(b)) {\n        if (a.length !== b.length) {\n            return false;\n        }\n\n        for (let i = 0; i < a.length; i += 1) {\n            if (!equals(a[i], b[i])) {\n                return false;\n            }\n        }\n\n        return true;\n    } else {\n        return false;\n    }\n}\n\n// Subroutines are encoded using the negative half of the number space.\n// See type 2 chapter 4.7 \"Subroutine operators\".\nfunction calcCFFSubroutineBias(subrs) {\n    let bias;\n    if (subrs.length < 1240) {\n        bias = 107;\n    } else if (subrs.length < 33900) {\n        bias = 1131;\n    } else {\n        bias = 32768;\n    }\n\n    return bias;\n}\n\n// Parse a `CFF` INDEX array.\n// An index array consists of a list of offsets, then a list of objects at those offsets.\nfunction parseCFFIndex(data, start, conversionFn) {\n    const offsets = [];\n    const objects = [];\n    const count = src_parse.getCard16(data, start);\n    let objectOffset;\n    let endOffset;\n    if (count !== 0) {\n        const offsetSize = src_parse.getByte(data, start + 2);\n        objectOffset = start + ((count + 1) * offsetSize) + 2;\n        let pos = start + 3;\n        for (let i = 0; i < count + 1; i += 1) {\n            offsets.push(src_parse.getOffset(data, pos, offsetSize));\n            pos += offsetSize;\n        }\n\n        // The total size of the index array is 4 header bytes + the value of the last offset.\n        endOffset = objectOffset + offsets[count];\n    } else {\n        endOffset = start + 2;\n    }\n\n    for (let i = 0; i < offsets.length - 1; i += 1) {\n        let value = src_parse.getBytes(data, objectOffset + offsets[i], objectOffset + offsets[i + 1]);\n        if (conversionFn) {\n            value = conversionFn(value);\n        }\n\n        objects.push(value);\n    }\n\n    return {objects: objects, startOffset: start, endOffset: endOffset};\n}\n\n// Parse a `CFF` DICT real value.\nfunction parseFloatOperand(parser) {\n    let s = '';\n    const eof = 15;\n    const lookup = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '.', 'E', 'E-', null, '-'];\n    while (true) {\n        const b = parser.parseByte();\n        const n1 = b >> 4;\n        const n2 = b & 15;\n\n        if (n1 === eof) {\n            break;\n        }\n\n        s += lookup[n1];\n\n        if (n2 === eof) {\n            break;\n        }\n\n        s += lookup[n2];\n    }\n\n    return parseFloat(s);\n}\n\n// Parse a `CFF` DICT operand.\nfunction parseOperand(parser, b0) {\n    let b1;\n    let b2;\n    let b3;\n    let b4;\n    if (b0 === 28) {\n        b1 = parser.parseByte();\n        b2 = parser.parseByte();\n        return b1 << 8 | b2;\n    }\n\n    if (b0 === 29) {\n        b1 = parser.parseByte();\n        b2 = parser.parseByte();\n        b3 = parser.parseByte();\n        b4 = parser.parseByte();\n        return b1 << 24 | b2 << 16 | b3 << 8 | b4;\n    }\n\n    if (b0 === 30) {\n        return parseFloatOperand(parser);\n    }\n\n    if (b0 >= 32 && b0 <= 246) {\n        return b0 - 139;\n    }\n\n    if (b0 >= 247 && b0 <= 250) {\n        b1 = parser.parseByte();\n        return (b0 - 247) * 256 + b1 + 108;\n    }\n\n    if (b0 >= 251 && b0 <= 254) {\n        b1 = parser.parseByte();\n        return -(b0 - 251) * 256 - b1 - 108;\n    }\n\n    throw new Error('Invalid b0 ' + b0);\n}\n\n// Convert the entries returned by `parseDict` to a proper dictionary.\n// If a value is a list of one, it is unpacked.\nfunction entriesToObject(entries) {\n    const o = {};\n    for (let i = 0; i < entries.length; i += 1) {\n        const key = entries[i][0];\n        const values = entries[i][1];\n        let value;\n        if (values.length === 1) {\n            value = values[0];\n        } else {\n            value = values;\n        }\n\n        if (o.hasOwnProperty(key) && !isNaN(o[key])) {\n            throw new Error('Object ' + o + ' already has key ' + key);\n        }\n\n        o[key] = value;\n    }\n\n    return o;\n}\n\n// Parse a `CFF` DICT object.\n// A dictionary contains key-value pairs in a compact tokenized format.\nfunction parseCFFDict(data, start, size) {\n    start = start !== undefined ? start : 0;\n    const parser = new src_parse.Parser(data, start);\n    const entries = [];\n    let operands = [];\n    size = size !== undefined ? size : data.length;\n\n    while (parser.relativeOffset < size) {\n        let op = parser.parseByte();\n\n        // The first byte for each dict item distinguishes between operator (key) and operand (value).\n        // Values <= 21 are operators.\n        if (op <= 21) {\n            // Two-byte operators have an initial escape byte of 12.\n            if (op === 12) {\n                op = 1200 + parser.parseByte();\n            }\n\n            entries.push([op, operands]);\n            operands = [];\n        } else {\n            // Since the operands (values) come before the operators (keys), we store all operands in a list\n            // until we encounter an operator.\n            operands.push(parseOperand(parser, op));\n        }\n    }\n\n    return entriesToObject(entries);\n}\n\n// Given a String Index (SID), return the value of the string.\n// Strings below index 392 are standard CFF strings and are not encoded in the font.\nfunction getCFFString(strings, index) {\n    if (index <= 390) {\n        index = cffStandardStrings[index];\n    } else {\n        index = strings[index - 391];\n    }\n\n    return index;\n}\n\n// Interpret a dictionary and return a new dictionary with readable keys and values for missing entries.\n// This function takes `meta` which is a list of objects containing `operand`, `name` and `default`.\nfunction interpretDict(dict, meta, strings) {\n    const newDict = {};\n    let value;\n\n    // Because we also want to include missing values, we start out from the meta list\n    // and lookup values in the dict.\n    for (let i = 0; i < meta.length; i += 1) {\n        const m = meta[i];\n\n        if (Array.isArray(m.type)) {\n            const values = [];\n            values.length = m.type.length;\n            for (let j = 0; j < m.type.length; j++) {\n                value = dict[m.op] !== undefined ? dict[m.op][j] : undefined;\n                if (value === undefined) {\n                    value = m.value !== undefined && m.value[j] !== undefined ? m.value[j] : null;\n                }\n                if (m.type[j] === 'SID') {\n                    value = getCFFString(strings, value);\n                }\n                values[j] = value;\n            }\n            newDict[m.name] = values;\n        } else {\n            value = dict[m.op];\n            if (value === undefined) {\n                value = m.value !== undefined ? m.value : null;\n            }\n\n            if (m.type === 'SID') {\n                value = getCFFString(strings, value);\n            }\n            newDict[m.name] = value;\n        }\n    }\n\n    return newDict;\n}\n\n// Parse the CFF header.\nfunction parseCFFHeader(data, start) {\n    const header = {};\n    header.formatMajor = src_parse.getCard8(data, start);\n    header.formatMinor = src_parse.getCard8(data, start + 1);\n    header.size = src_parse.getCard8(data, start + 2);\n    header.offsetSize = src_parse.getCard8(data, start + 3);\n    header.startOffset = start;\n    header.endOffset = start + 4;\n    return header;\n}\n\nconst TOP_DICT_META = [\n    {name: 'version', op: 0, type: 'SID'},\n    {name: 'notice', op: 1, type: 'SID'},\n    {name: 'copyright', op: 1200, type: 'SID'},\n    {name: 'fullName', op: 2, type: 'SID'},\n    {name: 'familyName', op: 3, type: 'SID'},\n    {name: 'weight', op: 4, type: 'SID'},\n    {name: 'isFixedPitch', op: 1201, type: 'number', value: 0},\n    {name: 'italicAngle', op: 1202, type: 'number', value: 0},\n    {name: 'underlinePosition', op: 1203, type: 'number', value: -100},\n    {name: 'underlineThickness', op: 1204, type: 'number', value: 50},\n    {name: 'paintType', op: 1205, type: 'number', value: 0},\n    {name: 'charstringType', op: 1206, type: 'number', value: 2},\n    {\n        name: 'fontMatrix',\n        op: 1207,\n        type: ['real', 'real', 'real', 'real', 'real', 'real'],\n        value: [0.001, 0, 0, 0.001, 0, 0]\n    },\n    {name: 'uniqueId', op: 13, type: 'number'},\n    {name: 'fontBBox', op: 5, type: ['number', 'number', 'number', 'number'], value: [0, 0, 0, 0]},\n    {name: 'strokeWidth', op: 1208, type: 'number', value: 0},\n    {name: 'xuid', op: 14, type: [], value: null},\n    {name: 'charset', op: 15, type: 'offset', value: 0},\n    {name: 'encoding', op: 16, type: 'offset', value: 0},\n    {name: 'charStrings', op: 17, type: 'offset', value: 0},\n    {name: 'private', op: 18, type: ['number', 'offset'], value: [0, 0]},\n    {name: 'ros', op: 1230, type: ['SID', 'SID', 'number']},\n    {name: 'cidFontVersion', op: 1231, type: 'number', value: 0},\n    {name: 'cidFontRevision', op: 1232, type: 'number', value: 0},\n    {name: 'cidFontType', op: 1233, type: 'number', value: 0},\n    {name: 'cidCount', op: 1234, type: 'number', value: 8720},\n    {name: 'uidBase', op: 1235, type: 'number'},\n    {name: 'fdArray', op: 1236, type: 'offset'},\n    {name: 'fdSelect', op: 1237, type: 'offset'},\n    {name: 'fontName', op: 1238, type: 'SID'}\n];\n\nconst PRIVATE_DICT_META = [\n    {name: 'subrs', op: 19, type: 'offset', value: 0},\n    {name: 'defaultWidthX', op: 20, type: 'number', value: 0},\n    {name: 'nominalWidthX', op: 21, type: 'number', value: 0}\n];\n\n// Parse the CFF top dictionary. A CFF table can contain multiple fonts, each with their own top dictionary.\n// The top dictionary contains the essential metadata for the font, together with the private dictionary.\nfunction parseCFFTopDict(data, strings) {\n    const dict = parseCFFDict(data, 0, data.byteLength);\n    return interpretDict(dict, TOP_DICT_META, strings);\n}\n\n// Parse the CFF private dictionary. We don't fully parse out all the values, only the ones we need.\nfunction parseCFFPrivateDict(data, start, size, strings) {\n    const dict = parseCFFDict(data, start, size);\n    return interpretDict(dict, PRIVATE_DICT_META, strings);\n}\n\n// Returns a list of \"Top DICT\"s found using an INDEX list.\n// Used to read both the usual high-level Top DICTs and also the FDArray\n// discovered inside CID-keyed fonts.  When a Top DICT has a reference to\n// a Private DICT that is read and saved into the Top DICT.\n//\n// In addition to the expected/optional values as outlined in TOP_DICT_META\n// the following values might be saved into the Top DICT.\n//\n//    _subrs []        array of local CFF subroutines from Private DICT\n//    _subrsBias       bias value computed from number of subroutines\n//                      (see calcCFFSubroutineBias() and parseCFFCharstring())\n//    _defaultWidthX   default widths for CFF characters\n//    _nominalWidthX   bias added to width embedded within glyph description\n//\n//    _privateDict     saved copy of parsed Private DICT from Top DICT\nfunction gatherCFFTopDicts(data, start, cffIndex, strings) {\n    const topDictArray = [];\n    for (let iTopDict = 0; iTopDict < cffIndex.length; iTopDict += 1) {\n        const topDictData = new DataView(new Uint8Array(cffIndex[iTopDict]).buffer);\n        const topDict = parseCFFTopDict(topDictData, strings);\n        topDict._subrs = [];\n        topDict._subrsBias = 0;\n        const privateSize = topDict.private[0];\n        const privateOffset = topDict.private[1];\n        if (privateSize !== 0 && privateOffset !== 0) {\n            const privateDict = parseCFFPrivateDict(data, privateOffset + start, privateSize, strings);\n            topDict._defaultWidthX = privateDict.defaultWidthX;\n            topDict._nominalWidthX = privateDict.nominalWidthX;\n            if (privateDict.subrs !== 0) {\n                const subrOffset = privateOffset + privateDict.subrs;\n                const subrIndex = parseCFFIndex(data, subrOffset + start);\n                topDict._subrs = subrIndex.objects;\n                topDict._subrsBias = calcCFFSubroutineBias(topDict._subrs);\n            }\n            topDict._privateDict = privateDict;\n        }\n        topDictArray.push(topDict);\n    }\n    return topDictArray;\n}\n\n// Parse the CFF charset table, which contains internal names for all the glyphs.\n// This function will return a list of glyph names.\n// See Adobe TN #5176 chapter 13, \"Charsets\".\nfunction parseCFFCharset(data, start, nGlyphs, strings) {\n    let sid;\n    let count;\n    const parser = new src_parse.Parser(data, start);\n\n    // The .notdef glyph is not included, so subtract 1.\n    nGlyphs -= 1;\n    const charset = ['.notdef'];\n\n    const format = parser.parseCard8();\n    if (format === 0) {\n        for (let i = 0; i < nGlyphs; i += 1) {\n            sid = parser.parseSID();\n            charset.push(getCFFString(strings, sid));\n        }\n    } else if (format === 1) {\n        while (charset.length <= nGlyphs) {\n            sid = parser.parseSID();\n            count = parser.parseCard8();\n            for (let i = 0; i <= count; i += 1) {\n                charset.push(getCFFString(strings, sid));\n                sid += 1;\n            }\n        }\n    } else if (format === 2) {\n        while (charset.length <= nGlyphs) {\n            sid = parser.parseSID();\n            count = parser.parseCard16();\n            for (let i = 0; i <= count; i += 1) {\n                charset.push(getCFFString(strings, sid));\n                sid += 1;\n            }\n        }\n    } else {\n        throw new Error('Unknown charset format ' + format);\n    }\n\n    return charset;\n}\n\n// Parse the CFF encoding data. Only one encoding can be specified per font.\n// See Adobe TN #5176 chapter 12, \"Encodings\".\nfunction parseCFFEncoding(data, start, charset) {\n    let code;\n    const enc = {};\n    const parser = new src_parse.Parser(data, start);\n    const format = parser.parseCard8();\n    if (format === 0) {\n        const nCodes = parser.parseCard8();\n        for (let i = 0; i < nCodes; i += 1) {\n            code = parser.parseCard8();\n            enc[code] = i;\n        }\n    } else if (format === 1) {\n        const nRanges = parser.parseCard8();\n        code = 1;\n        for (let i = 0; i < nRanges; i += 1) {\n            const first = parser.parseCard8();\n            const nLeft = parser.parseCard8();\n            for (let j = first; j <= first + nLeft; j += 1) {\n                enc[j] = code;\n                code += 1;\n            }\n        }\n    } else {\n        throw new Error('Unknown encoding format ' + format);\n    }\n\n    return new CffEncoding(enc, charset);\n}\n\n// Take in charstring code and return a Glyph object.\n// The encoding is described in the Type 2 Charstring Format\n// https://www.microsoft.com/typography/OTSPEC/charstr2.htm\nfunction cff_parseCFFCharstring(font, glyph, code) {\n    let c1x;\n    let c1y;\n    let c2x;\n    let c2y;\n    const p = new src_path();\n    const stack = [];\n    let nStems = 0;\n    let haveWidth = false;\n    let open = false;\n    let x = 0;\n    let y = 0;\n    let subrs;\n    let subrsBias;\n    let defaultWidthX;\n    let nominalWidthX;\n    if (font.isCIDFont) {\n        const fdIndex = font.tables.cff.topDict._fdSelect[glyph.index];\n        const fdDict = font.tables.cff.topDict._fdArray[fdIndex];\n        subrs = fdDict._subrs;\n        subrsBias = fdDict._subrsBias;\n        defaultWidthX = fdDict._defaultWidthX;\n        nominalWidthX = fdDict._nominalWidthX;\n    } else {\n        subrs = font.tables.cff.topDict._subrs;\n        subrsBias = font.tables.cff.topDict._subrsBias;\n        defaultWidthX = font.tables.cff.topDict._defaultWidthX;\n        nominalWidthX = font.tables.cff.topDict._nominalWidthX;\n    }\n    let width = defaultWidthX;\n\n    function newContour(x, y) {\n        if (open) {\n            p.closePath();\n        }\n\n        p.moveTo(x, y);\n        open = true;\n    }\n\n    function parseStems() {\n        let hasWidthArg;\n\n        // The number of stem operators on the stack is always even.\n        // If the value is uneven, that means a width is specified.\n        hasWidthArg = stack.length % 2 !== 0;\n        if (hasWidthArg && !haveWidth) {\n            width = stack.shift() + nominalWidthX;\n        }\n\n        nStems += stack.length >> 1;\n        stack.length = 0;\n        haveWidth = true;\n    }\n\n    function parse(code) {\n        let b1;\n        let b2;\n        let b3;\n        let b4;\n        let codeIndex;\n        let subrCode;\n        let jpx;\n        let jpy;\n        let c3x;\n        let c3y;\n        let c4x;\n        let c4y;\n\n        let i = 0;\n        while (i < code.length) {\n            let v = code[i];\n            i += 1;\n            switch (v) {\n                case 1: // hstem\n                    parseStems();\n                    break;\n                case 3: // vstem\n                    parseStems();\n                    break;\n                case 4: // vmoveto\n                    if (stack.length > 1 && !haveWidth) {\n                        width = stack.shift() + nominalWidthX;\n                        haveWidth = true;\n                    }\n\n                    y += stack.pop();\n                    newContour(x, y);\n                    break;\n                case 5: // rlineto\n                    while (stack.length > 0) {\n                        x += stack.shift();\n                        y += stack.shift();\n                        p.lineTo(x, y);\n                    }\n\n                    break;\n                case 6: // hlineto\n                    while (stack.length > 0) {\n                        x += stack.shift();\n                        p.lineTo(x, y);\n                        if (stack.length === 0) {\n                            break;\n                        }\n\n                        y += stack.shift();\n                        p.lineTo(x, y);\n                    }\n\n                    break;\n                case 7: // vlineto\n                    while (stack.length > 0) {\n                        y += stack.shift();\n                        p.lineTo(x, y);\n                        if (stack.length === 0) {\n                            break;\n                        }\n\n                        x += stack.shift();\n                        p.lineTo(x, y);\n                    }\n\n                    break;\n                case 8: // rrcurveto\n                    while (stack.length > 0) {\n                        c1x = x + stack.shift();\n                        c1y = y + stack.shift();\n                        c2x = c1x + stack.shift();\n                        c2y = c1y + stack.shift();\n                        x = c2x + stack.shift();\n                        y = c2y + stack.shift();\n                        p.curveTo(c1x, c1y, c2x, c2y, x, y);\n                    }\n\n                    break;\n                case 10: // callsubr\n                    codeIndex = stack.pop() + subrsBias;\n                    subrCode = subrs[codeIndex];\n                    if (subrCode) {\n                        parse(subrCode);\n                    }\n\n                    break;\n                case 11: // return\n                    return;\n                case 12: // flex operators\n                    v = code[i];\n                    i += 1;\n                    switch (v) {\n                        case 35: // flex\n                            // |- dx1 dy1 dx2 dy2 dx3 dy3 dx4 dy4 dx5 dy5 dx6 dy6 fd flex (12 35) |-\n                            c1x = x   + stack.shift();    // dx1\n                            c1y = y   + stack.shift();    // dy1\n                            c2x = c1x + stack.shift();    // dx2\n                            c2y = c1y + stack.shift();    // dy2\n                            jpx = c2x + stack.shift();    // dx3\n                            jpy = c2y + stack.shift();    // dy3\n                            c3x = jpx + stack.shift();    // dx4\n                            c3y = jpy + stack.shift();    // dy4\n                            c4x = c3x + stack.shift();    // dx5\n                            c4y = c3y + stack.shift();    // dy5\n                            x = c4x   + stack.shift();    // dx6\n                            y = c4y   + stack.shift();    // dy6\n                            stack.shift();                // flex depth\n                            p.curveTo(c1x, c1y, c2x, c2y, jpx, jpy);\n                            p.curveTo(c3x, c3y, c4x, c4y, x, y);\n                            break;\n                        case 34: // hflex\n                            // |- dx1 dx2 dy2 dx3 dx4 dx5 dx6 hflex (12 34) |-\n                            c1x = x   + stack.shift();    // dx1\n                            c1y = y;                      // dy1\n                            c2x = c1x + stack.shift();    // dx2\n                            c2y = c1y + stack.shift();    // dy2\n                            jpx = c2x + stack.shift();    // dx3\n                            jpy = c2y;                    // dy3\n                            c3x = jpx + stack.shift();    // dx4\n                            c3y = c2y;                    // dy4\n                            c4x = c3x + stack.shift();    // dx5\n                            c4y = y;                      // dy5\n                            x = c4x + stack.shift();      // dx6\n                            p.curveTo(c1x, c1y, c2x, c2y, jpx, jpy);\n                            p.curveTo(c3x, c3y, c4x, c4y, x, y);\n                            break;\n                        case 36: // hflex1\n                            // |- dx1 dy1 dx2 dy2 dx3 dx4 dx5 dy5 dx6 hflex1 (12 36) |-\n                            c1x = x   + stack.shift();    // dx1\n                            c1y = y   + stack.shift();    // dy1\n                            c2x = c1x + stack.shift();    // dx2\n                            c2y = c1y + stack.shift();    // dy2\n                            jpx = c2x + stack.shift();    // dx3\n                            jpy = c2y;                    // dy3\n                            c3x = jpx + stack.shift();    // dx4\n                            c3y = c2y;                    // dy4\n                            c4x = c3x + stack.shift();    // dx5\n                            c4y = c3y + stack.shift();    // dy5\n                            x = c4x + stack.shift();      // dx6\n                            p.curveTo(c1x, c1y, c2x, c2y, jpx, jpy);\n                            p.curveTo(c3x, c3y, c4x, c4y, x, y);\n                            break;\n                        case 37: // flex1\n                            // |- dx1 dy1 dx2 dy2 dx3 dy3 dx4 dy4 dx5 dy5 d6 flex1 (12 37) |-\n                            c1x = x   + stack.shift();    // dx1\n                            c1y = y   + stack.shift();    // dy1\n                            c2x = c1x + stack.shift();    // dx2\n                            c2y = c1y + stack.shift();    // dy2\n                            jpx = c2x + stack.shift();    // dx3\n                            jpy = c2y + stack.shift();    // dy3\n                            c3x = jpx + stack.shift();    // dx4\n                            c3y = jpy + stack.shift();    // dy4\n                            c4x = c3x + stack.shift();    // dx5\n                            c4y = c3y + stack.shift();    // dy5\n                            if (Math.abs(c4x - x) > Math.abs(c4y - y)) {\n                                x = c4x + stack.shift();\n                            } else {\n                                y = c4y + stack.shift();\n                            }\n\n                            p.curveTo(c1x, c1y, c2x, c2y, jpx, jpy);\n                            p.curveTo(c3x, c3y, c4x, c4y, x, y);\n                            break;\n                        default:\n                            console.log('Glyph ' + glyph.index + ': unknown operator ' + 1200 + v);\n                            stack.length = 0;\n                    }\n                    break;\n                case 14: // endchar\n                    if (stack.length > 0 && !haveWidth) {\n                        width = stack.shift() + nominalWidthX;\n                        haveWidth = true;\n                    }\n\n                    if (open) {\n                        p.closePath();\n                        open = false;\n                    }\n\n                    break;\n                case 18: // hstemhm\n                    parseStems();\n                    break;\n                case 19: // hintmask\n                case 20: // cntrmask\n                    parseStems();\n                    i += (nStems + 7) >> 3;\n                    break;\n                case 21: // rmoveto\n                    if (stack.length > 2 && !haveWidth) {\n                        width = stack.shift() + nominalWidthX;\n                        haveWidth = true;\n                    }\n\n                    y += stack.pop();\n                    x += stack.pop();\n                    newContour(x, y);\n                    break;\n                case 22: // hmoveto\n                    if (stack.length > 1 && !haveWidth) {\n                        width = stack.shift() + nominalWidthX;\n                        haveWidth = true;\n                    }\n\n                    x += stack.pop();\n                    newContour(x, y);\n                    break;\n                case 23: // vstemhm\n                    parseStems();\n                    break;\n                case 24: // rcurveline\n                    while (stack.length > 2) {\n                        c1x = x + stack.shift();\n                        c1y = y + stack.shift();\n                        c2x = c1x + stack.shift();\n                        c2y = c1y + stack.shift();\n                        x = c2x + stack.shift();\n                        y = c2y + stack.shift();\n                        p.curveTo(c1x, c1y, c2x, c2y, x, y);\n                    }\n\n                    x += stack.shift();\n                    y += stack.shift();\n                    p.lineTo(x, y);\n                    break;\n                case 25: // rlinecurve\n                    while (stack.length > 6) {\n                        x += stack.shift();\n                        y += stack.shift();\n                        p.lineTo(x, y);\n                    }\n\n                    c1x = x + stack.shift();\n                    c1y = y + stack.shift();\n                    c2x = c1x + stack.shift();\n                    c2y = c1y + stack.shift();\n                    x = c2x + stack.shift();\n                    y = c2y + stack.shift();\n                    p.curveTo(c1x, c1y, c2x, c2y, x, y);\n                    break;\n                case 26: // vvcurveto\n                    if (stack.length % 2) {\n                        x += stack.shift();\n                    }\n\n                    while (stack.length > 0) {\n                        c1x = x;\n                        c1y = y + stack.shift();\n                        c2x = c1x + stack.shift();\n                        c2y = c1y + stack.shift();\n                        x = c2x;\n                        y = c2y + stack.shift();\n                        p.curveTo(c1x, c1y, c2x, c2y, x, y);\n                    }\n\n                    break;\n                case 27: // hhcurveto\n                    if (stack.length % 2) {\n                        y += stack.shift();\n                    }\n\n                    while (stack.length > 0) {\n                        c1x = x + stack.shift();\n                        c1y = y;\n                        c2x = c1x + stack.shift();\n                        c2y = c1y + stack.shift();\n                        x = c2x + stack.shift();\n                        y = c2y;\n                        p.curveTo(c1x, c1y, c2x, c2y, x, y);\n                    }\n\n                    break;\n                case 28: // shortint\n                    b1 = code[i];\n                    b2 = code[i + 1];\n                    stack.push(((b1 << 24) | (b2 << 16)) >> 16);\n                    i += 2;\n                    break;\n                case 29: // callgsubr\n                    codeIndex = stack.pop() + font.gsubrsBias;\n                    subrCode = font.gsubrs[codeIndex];\n                    if (subrCode) {\n                        parse(subrCode);\n                    }\n\n                    break;\n                case 30: // vhcurveto\n                    while (stack.length > 0) {\n                        c1x = x;\n                        c1y = y + stack.shift();\n                        c2x = c1x + stack.shift();\n                        c2y = c1y + stack.shift();\n                        x = c2x + stack.shift();\n                        y = c2y + (stack.length === 1 ? stack.shift() : 0);\n                        p.curveTo(c1x, c1y, c2x, c2y, x, y);\n                        if (stack.length === 0) {\n                            break;\n                        }\n\n                        c1x = x + stack.shift();\n                        c1y = y;\n                        c2x = c1x + stack.shift();\n                        c2y = c1y + stack.shift();\n                        y = c2y + stack.shift();\n                        x = c2x + (stack.length === 1 ? stack.shift() : 0);\n                        p.curveTo(c1x, c1y, c2x, c2y, x, y);\n                    }\n\n                    break;\n                case 31: // hvcurveto\n                    while (stack.length > 0) {\n                        c1x = x + stack.shift();\n                        c1y = y;\n                        c2x = c1x + stack.shift();\n                        c2y = c1y + stack.shift();\n                        y = c2y + stack.shift();\n                        x = c2x + (stack.length === 1 ? stack.shift() : 0);\n                        p.curveTo(c1x, c1y, c2x, c2y, x, y);\n                        if (stack.length === 0) {\n                            break;\n                        }\n\n                        c1x = x;\n                        c1y = y + stack.shift();\n                        c2x = c1x + stack.shift();\n                        c2y = c1y + stack.shift();\n                        x = c2x + stack.shift();\n                        y = c2y + (stack.length === 1 ? stack.shift() : 0);\n                        p.curveTo(c1x, c1y, c2x, c2y, x, y);\n                    }\n\n                    break;\n                default:\n                    if (v < 32) {\n                        console.log('Glyph ' + glyph.index + ': unknown operator ' + v);\n                    } else if (v < 247) {\n                        stack.push(v - 139);\n                    } else if (v < 251) {\n                        b1 = code[i];\n                        i += 1;\n                        stack.push((v - 247) * 256 + b1 + 108);\n                    } else if (v < 255) {\n                        b1 = code[i];\n                        i += 1;\n                        stack.push(-(v - 251) * 256 - b1 - 108);\n                    } else {\n                        b1 = code[i];\n                        b2 = code[i + 1];\n                        b3 = code[i + 2];\n                        b4 = code[i + 3];\n                        i += 4;\n                        stack.push(((b1 << 24) | (b2 << 16) | (b3 << 8) | b4) / 65536);\n                    }\n            }\n        }\n    }\n\n    parse(code);\n\n    glyph.advanceWidth = width;\n    return p;\n}\n\nfunction parseCFFFDSelect(data, start, nGlyphs, fdArrayCount) {\n    const fdSelect = [];\n    let fdIndex;\n    const parser = new src_parse.Parser(data, start);\n    const format = parser.parseCard8();\n    if (format === 0) {\n        // Simple list of nGlyphs elements\n        for (let iGid = 0; iGid < nGlyphs; iGid++) {\n            fdIndex = parser.parseCard8();\n            if (fdIndex >= fdArrayCount) {\n                throw new Error('CFF table CID Font FDSelect has bad FD index value ' + fdIndex + ' (FD count ' + fdArrayCount + ')');\n            }\n            fdSelect.push(fdIndex);\n        }\n    } else if (format === 3) {\n        // Ranges\n        const nRanges = parser.parseCard16();\n        let first = parser.parseCard16();\n        if (first !== 0) {\n            throw new Error('CFF Table CID Font FDSelect format 3 range has bad initial GID ' + first);\n        }\n        let next;\n        for (let iRange = 0; iRange < nRanges; iRange++) {\n            fdIndex = parser.parseCard8();\n            next = parser.parseCard16();\n            if (fdIndex >= fdArrayCount) {\n                throw new Error('CFF table CID Font FDSelect has bad FD index value ' + fdIndex + ' (FD count ' + fdArrayCount + ')');\n            }\n            if (next > nGlyphs) {\n                throw new Error('CFF Table CID Font FDSelect format 3 range has bad GID ' + next);\n            }\n            for (; first < next; first++) {\n                fdSelect.push(fdIndex);\n            }\n            first = next;\n        }\n        if (next !== nGlyphs) {\n            throw new Error('CFF Table CID Font FDSelect format 3 range has bad final GID ' + next);\n        }\n    } else {\n        throw new Error('CFF Table CID Font FDSelect table has unsupported format ' + format);\n    }\n    return fdSelect;\n}\n\n// Parse the `CFF` table, which contains the glyph outlines in PostScript format.\nfunction parseCFFTable(data, start, font) {\n    font.tables.cff = {};\n    const header = parseCFFHeader(data, start);\n    const nameIndex = parseCFFIndex(data, header.endOffset, src_parse.bytesToString);\n    const topDictIndex = parseCFFIndex(data, nameIndex.endOffset);\n    const stringIndex = parseCFFIndex(data, topDictIndex.endOffset, src_parse.bytesToString);\n    const globalSubrIndex = parseCFFIndex(data, stringIndex.endOffset);\n    font.gsubrs = globalSubrIndex.objects;\n    font.gsubrsBias = calcCFFSubroutineBias(font.gsubrs);\n\n    const topDictArray = gatherCFFTopDicts(data, start, topDictIndex.objects, stringIndex.objects);\n    if (topDictArray.length !== 1) {\n        throw new Error('CFF table has too many fonts in \\'FontSet\\' - count of fonts NameIndex.length = ' + topDictArray.length);\n    }\n\n    const topDict = topDictArray[0];\n    font.tables.cff.topDict = topDict;\n\n    if (topDict._privateDict) {\n        font.defaultWidthX = topDict._privateDict.defaultWidthX;\n        font.nominalWidthX = topDict._privateDict.nominalWidthX;\n    }\n\n    if (topDict.ros[0] !== undefined && topDict.ros[1] !== undefined) {\n        font.isCIDFont = true;\n    }\n\n    if (font.isCIDFont) {\n        let fdArrayOffset = topDict.fdArray;\n        let fdSelectOffset = topDict.fdSelect;\n        if (fdArrayOffset === 0 || fdSelectOffset === 0) {\n            throw new Error('Font is marked as a CID font, but FDArray and/or FDSelect information is missing');\n        }\n        fdArrayOffset += start;\n        const fdArrayIndex = parseCFFIndex(data, fdArrayOffset);\n        const fdArray = gatherCFFTopDicts(data, start, fdArrayIndex.objects, stringIndex.objects);\n        topDict._fdArray = fdArray;\n        fdSelectOffset += start;\n        topDict._fdSelect = parseCFFFDSelect(data, fdSelectOffset, font.numGlyphs, fdArray.length);\n    }\n\n    const privateDictOffset = start + topDict.private[1];\n    const privateDict = parseCFFPrivateDict(data, privateDictOffset, topDict.private[0], stringIndex.objects);\n    font.defaultWidthX = privateDict.defaultWidthX;\n    font.nominalWidthX = privateDict.nominalWidthX;\n\n    if (privateDict.subrs !== 0) {\n        const subrOffset = privateDictOffset + privateDict.subrs;\n        const subrIndex = parseCFFIndex(data, subrOffset);\n        font.subrs = subrIndex.objects;\n        font.subrsBias = calcCFFSubroutineBias(font.subrs);\n    } else {\n        font.subrs = [];\n        font.subrsBias = 0;\n    }\n\n    // Offsets in the top dict are relative to the beginning of the CFF data, so add the CFF start offset.\n    const charStringsIndex = parseCFFIndex(data, start + topDict.charStrings);\n    font.nGlyphs = charStringsIndex.objects.length;\n\n    const charset = parseCFFCharset(data, start + topDict.charset, font.nGlyphs, stringIndex.objects);\n    if (topDict.encoding === 0) { // Standard encoding\n        font.cffEncoding = new CffEncoding(cffStandardEncoding, charset);\n    } else if (topDict.encoding === 1) { // Expert encoding\n        font.cffEncoding = new CffEncoding(cffExpertEncoding, charset);\n    } else {\n        font.cffEncoding = parseCFFEncoding(data, start + topDict.encoding, charset);\n    }\n\n    // Prefer the CMAP encoding to the CFF encoding.\n    font.encoding = font.encoding || font.cffEncoding;\n\n    font.glyphs = new glyphset.GlyphSet(font);\n    for (let i = 0; i < font.nGlyphs; i += 1) {\n        const charString = charStringsIndex.objects[i];\n        font.glyphs.push(i, glyphset.cffGlyphLoader(font, i, cff_parseCFFCharstring, charString));\n    }\n}\n\n// Convert a string to a String ID (SID).\n// The list of strings is modified in place.\nfunction encodeString(s, strings) {\n    let sid;\n\n    // Is the string in the CFF standard strings?\n    let i = cffStandardStrings.indexOf(s);\n    if (i >= 0) {\n        sid = i;\n    }\n\n    // Is the string already in the string index?\n    i = strings.indexOf(s);\n    if (i >= 0) {\n        sid = i + cffStandardStrings.length;\n    } else {\n        sid = cffStandardStrings.length + strings.length;\n        strings.push(s);\n    }\n\n    return sid;\n}\n\nfunction makeHeader() {\n    return new src_table.Record('Header', [\n        {name: 'major', type: 'Card8', value: 1},\n        {name: 'minor', type: 'Card8', value: 0},\n        {name: 'hdrSize', type: 'Card8', value: 4},\n        {name: 'major', type: 'Card8', value: 1}\n    ]);\n}\n\nfunction makeNameIndex(fontNames) {\n    const t = new src_table.Record('Name INDEX', [\n        {name: 'names', type: 'INDEX', value: []}\n    ]);\n    t.names = [];\n    for (let i = 0; i < fontNames.length; i += 1) {\n        t.names.push({name: 'name_' + i, type: 'NAME', value: fontNames[i]});\n    }\n\n    return t;\n}\n\n// Given a dictionary's metadata, create a DICT structure.\nfunction makeDict(meta, attrs, strings) {\n    const m = {};\n    for (let i = 0; i < meta.length; i += 1) {\n        const entry = meta[i];\n        let value = attrs[entry.name];\n        if (value !== undefined && !equals(value, entry.value)) {\n            if (entry.type === 'SID') {\n                value = encodeString(value, strings);\n            }\n\n            m[entry.op] = {name: entry.name, type: entry.type, value: value};\n        }\n    }\n\n    return m;\n}\n\n// The Top DICT houses the global font attributes.\nfunction makeTopDict(attrs, strings) {\n    const t = new src_table.Record('Top DICT', [\n        {name: 'dict', type: 'DICT', value: {}}\n    ]);\n    t.dict = makeDict(TOP_DICT_META, attrs, strings);\n    return t;\n}\n\nfunction makeTopDictIndex(topDict) {\n    const t = new src_table.Record('Top DICT INDEX', [\n        {name: 'topDicts', type: 'INDEX', value: []}\n    ]);\n    t.topDicts = [{name: 'topDict_0', type: 'TABLE', value: topDict}];\n    return t;\n}\n\nfunction makeStringIndex(strings) {\n    const t = new src_table.Record('String INDEX', [\n        {name: 'strings', type: 'INDEX', value: []}\n    ]);\n    t.strings = [];\n    for (let i = 0; i < strings.length; i += 1) {\n        t.strings.push({name: 'string_' + i, type: 'STRING', value: strings[i]});\n    }\n\n    return t;\n}\n\nfunction makeGlobalSubrIndex() {\n    // Currently we don't use subroutines.\n    return new src_table.Record('Global Subr INDEX', [\n        {name: 'subrs', type: 'INDEX', value: []}\n    ]);\n}\n\nfunction makeCharsets(glyphNames, strings) {\n    const t = new src_table.Record('Charsets', [\n        {name: 'format', type: 'Card8', value: 0}\n    ]);\n    for (let i = 0; i < glyphNames.length; i += 1) {\n        const glyphName = glyphNames[i];\n        const glyphSID = encodeString(glyphName, strings);\n        t.fields.push({name: 'glyph_' + i, type: 'SID', value: glyphSID});\n    }\n\n    return t;\n}\n\nfunction glyphToOps(glyph) {\n    const ops = [];\n    const path = glyph.path;\n    ops.push({name: 'width', type: 'NUMBER', value: glyph.advanceWidth});\n    let x = 0;\n    let y = 0;\n    for (let i = 0; i < path.commands.length; i += 1) {\n        let dx;\n        let dy;\n        let cmd = path.commands[i];\n        if (cmd.type === 'Q') {\n            // CFF only supports bézier curves, so convert the quad to a bézier.\n            const _13 = 1 / 3;\n            const _23 = 2 / 3;\n\n            // We're going to create a new command so we don't change the original path.\n            cmd = {\n                type: 'C',\n                x: cmd.x,\n                y: cmd.y,\n                x1: _13 * x + _23 * cmd.x1,\n                y1: _13 * y + _23 * cmd.y1,\n                x2: _13 * cmd.x + _23 * cmd.x1,\n                y2: _13 * cmd.y + _23 * cmd.y1\n            };\n        }\n\n        if (cmd.type === 'M') {\n            dx = Math.round(cmd.x - x);\n            dy = Math.round(cmd.y - y);\n            ops.push({name: 'dx', type: 'NUMBER', value: dx});\n            ops.push({name: 'dy', type: 'NUMBER', value: dy});\n            ops.push({name: 'rmoveto', type: 'OP', value: 21});\n            x = Math.round(cmd.x);\n            y = Math.round(cmd.y);\n        } else if (cmd.type === 'L') {\n            dx = Math.round(cmd.x - x);\n            dy = Math.round(cmd.y - y);\n            ops.push({name: 'dx', type: 'NUMBER', value: dx});\n            ops.push({name: 'dy', type: 'NUMBER', value: dy});\n            ops.push({name: 'rlineto', type: 'OP', value: 5});\n            x = Math.round(cmd.x);\n            y = Math.round(cmd.y);\n        } else if (cmd.type === 'C') {\n            const dx1 = Math.round(cmd.x1 - x);\n            const dy1 = Math.round(cmd.y1 - y);\n            const dx2 = Math.round(cmd.x2 - cmd.x1);\n            const dy2 = Math.round(cmd.y2 - cmd.y1);\n            dx = Math.round(cmd.x - cmd.x2);\n            dy = Math.round(cmd.y - cmd.y2);\n            ops.push({name: 'dx1', type: 'NUMBER', value: dx1});\n            ops.push({name: 'dy1', type: 'NUMBER', value: dy1});\n            ops.push({name: 'dx2', type: 'NUMBER', value: dx2});\n            ops.push({name: 'dy2', type: 'NUMBER', value: dy2});\n            ops.push({name: 'dx', type: 'NUMBER', value: dx});\n            ops.push({name: 'dy', type: 'NUMBER', value: dy});\n            ops.push({name: 'rrcurveto', type: 'OP', value: 8});\n            x = Math.round(cmd.x);\n            y = Math.round(cmd.y);\n        }\n\n        // Contours are closed automatically.\n    }\n\n    ops.push({name: 'endchar', type: 'OP', value: 14});\n    return ops;\n}\n\nfunction makeCharStringsIndex(glyphs) {\n    const t = new src_table.Record('CharStrings INDEX', [\n        {name: 'charStrings', type: 'INDEX', value: []}\n    ]);\n\n    for (let i = 0; i < glyphs.length; i += 1) {\n        const glyph = glyphs.get(i);\n        const ops = glyphToOps(glyph);\n        t.charStrings.push({name: glyph.name, type: 'CHARSTRING', value: ops});\n    }\n\n    return t;\n}\n\nfunction makePrivateDict(attrs, strings) {\n    const t = new src_table.Record('Private DICT', [\n        {name: 'dict', type: 'DICT', value: {}}\n    ]);\n    t.dict = makeDict(PRIVATE_DICT_META, attrs, strings);\n    return t;\n}\n\nfunction makeCFFTable(glyphs, options) {\n    const t = new src_table.Table('CFF ', [\n        {name: 'header', type: 'RECORD'},\n        {name: 'nameIndex', type: 'RECORD'},\n        {name: 'topDictIndex', type: 'RECORD'},\n        {name: 'stringIndex', type: 'RECORD'},\n        {name: 'globalSubrIndex', type: 'RECORD'},\n        {name: 'charsets', type: 'RECORD'},\n        {name: 'charStringsIndex', type: 'RECORD'},\n        {name: 'privateDict', type: 'RECORD'}\n    ]);\n\n    const fontScale = 1 / options.unitsPerEm;\n    // We use non-zero values for the offsets so that the DICT encodes them.\n    // This is important because the size of the Top DICT plays a role in offset calculation,\n    // and the size shouldn't change after we've written correct offsets.\n    const attrs = {\n        version: options.version,\n        fullName: options.fullName,\n        familyName: options.familyName,\n        weight: options.weightName,\n        fontBBox: options.fontBBox || [0, 0, 0, 0],\n        fontMatrix: [fontScale, 0, 0, fontScale, 0, 0],\n        charset: 999,\n        encoding: 0,\n        charStrings: 999,\n        private: [0, 999]\n    };\n\n    const privateAttrs = {};\n\n    const glyphNames = [];\n    let glyph;\n\n    // Skip first glyph (.notdef)\n    for (let i = 1; i < glyphs.length; i += 1) {\n        glyph = glyphs.get(i);\n        glyphNames.push(glyph.name);\n    }\n\n    const strings = [];\n\n    t.header = makeHeader();\n    t.nameIndex = makeNameIndex([options.postScriptName]);\n    let topDict = makeTopDict(attrs, strings);\n    t.topDictIndex = makeTopDictIndex(topDict);\n    t.globalSubrIndex = makeGlobalSubrIndex();\n    t.charsets = makeCharsets(glyphNames, strings);\n    t.charStringsIndex = makeCharStringsIndex(glyphs);\n    t.privateDict = makePrivateDict(privateAttrs, strings);\n\n    // Needs to come at the end, to encode all custom strings used in the font.\n    t.stringIndex = makeStringIndex(strings);\n\n    const startOffset = t.header.sizeOf() +\n        t.nameIndex.sizeOf() +\n        t.topDictIndex.sizeOf() +\n        t.stringIndex.sizeOf() +\n        t.globalSubrIndex.sizeOf();\n    attrs.charset = startOffset;\n\n    // We use the CFF standard encoding; proper encoding will be handled in cmap.\n    attrs.encoding = 0;\n    attrs.charStrings = attrs.charset + t.charsets.sizeOf();\n    attrs.private[1] = attrs.charStrings + t.charStringsIndex.sizeOf();\n\n    // Recreate the Top DICT INDEX with the correct offsets.\n    topDict = makeTopDict(attrs, strings);\n    t.topDictIndex = makeTopDictIndex(topDict);\n\n    return t;\n}\n\n/* harmony default export */ var cff = ({ parse: parseCFFTable, make: makeCFFTable });\n\n// CONCATENATED MODULE: ./node_modules/opentype.js/src/tables/head.js\n// The `head` table contains global information about the font.\n// https://www.microsoft.com/typography/OTSPEC/head.htm\n\n\n\n\n\n// Parse the header `head` table\nfunction parseHeadTable(data, start) {\n    const head = {};\n    const p = new src_parse.Parser(data, start);\n    head.version = p.parseVersion();\n    head.fontRevision = Math.round(p.parseFixed() * 1000) / 1000;\n    head.checkSumAdjustment = p.parseULong();\n    head.magicNumber = p.parseULong();\n    check.argument(head.magicNumber === 0x5F0F3CF5, 'Font header has wrong magic number.');\n    head.flags = p.parseUShort();\n    head.unitsPerEm = p.parseUShort();\n    head.created = p.parseLongDateTime();\n    head.modified = p.parseLongDateTime();\n    head.xMin = p.parseShort();\n    head.yMin = p.parseShort();\n    head.xMax = p.parseShort();\n    head.yMax = p.parseShort();\n    head.macStyle = p.parseUShort();\n    head.lowestRecPPEM = p.parseUShort();\n    head.fontDirectionHint = p.parseShort();\n    head.indexToLocFormat = p.parseShort();\n    head.glyphDataFormat = p.parseShort();\n    return head;\n}\n\nfunction makeHeadTable(options) {\n    // Apple Mac timestamp epoch is 01/01/1904 not 01/01/1970\n    const timestamp = Math.round(new Date().getTime() / 1000) + 2082844800;\n    let createdTimestamp = timestamp;\n\n    if (options.createdTimestamp) {\n        createdTimestamp = options.createdTimestamp + 2082844800;\n    }\n\n    return new src_table.Table('head', [\n        {name: 'version', type: 'FIXED', value: 0x00010000},\n        {name: 'fontRevision', type: 'FIXED', value: 0x00010000},\n        {name: 'checkSumAdjustment', type: 'ULONG', value: 0},\n        {name: 'magicNumber', type: 'ULONG', value: 0x5F0F3CF5},\n        {name: 'flags', type: 'USHORT', value: 0},\n        {name: 'unitsPerEm', type: 'USHORT', value: 1000},\n        {name: 'created', type: 'LONGDATETIME', value: createdTimestamp},\n        {name: 'modified', type: 'LONGDATETIME', value: timestamp},\n        {name: 'xMin', type: 'SHORT', value: 0},\n        {name: 'yMin', type: 'SHORT', value: 0},\n        {name: 'xMax', type: 'SHORT', value: 0},\n        {name: 'yMax', type: 'SHORT', value: 0},\n        {name: 'macStyle', type: 'USHORT', value: 0},\n        {name: 'lowestRecPPEM', type: 'USHORT', value: 0},\n        {name: 'fontDirectionHint', type: 'SHORT', value: 2},\n        {name: 'indexToLocFormat', type: 'SHORT', value: 0},\n        {name: 'glyphDataFormat', type: 'SHORT', value: 0}\n    ], options);\n}\n\n/* harmony default export */ var tables_head = ({ parse: parseHeadTable, make: makeHeadTable });\n\n// CONCATENATED MODULE: ./node_modules/opentype.js/src/tables/hhea.js\n// The `hhea` table contains information for horizontal layout.\n// https://www.microsoft.com/typography/OTSPEC/hhea.htm\n\n\n\n\n// Parse the horizontal header `hhea` table\nfunction parseHheaTable(data, start) {\n    const hhea = {};\n    const p = new src_parse.Parser(data, start);\n    hhea.version = p.parseVersion();\n    hhea.ascender = p.parseShort();\n    hhea.descender = p.parseShort();\n    hhea.lineGap = p.parseShort();\n    hhea.advanceWidthMax = p.parseUShort();\n    hhea.minLeftSideBearing = p.parseShort();\n    hhea.minRightSideBearing = p.parseShort();\n    hhea.xMaxExtent = p.parseShort();\n    hhea.caretSlopeRise = p.parseShort();\n    hhea.caretSlopeRun = p.parseShort();\n    hhea.caretOffset = p.parseShort();\n    p.relativeOffset += 8;\n    hhea.metricDataFormat = p.parseShort();\n    hhea.numberOfHMetrics = p.parseUShort();\n    return hhea;\n}\n\nfunction makeHheaTable(options) {\n    return new src_table.Table('hhea', [\n        {name: 'version', type: 'FIXED', value: 0x00010000},\n        {name: 'ascender', type: 'FWORD', value: 0},\n        {name: 'descender', type: 'FWORD', value: 0},\n        {name: 'lineGap', type: 'FWORD', value: 0},\n        {name: 'advanceWidthMax', type: 'UFWORD', value: 0},\n        {name: 'minLeftSideBearing', type: 'FWORD', value: 0},\n        {name: 'minRightSideBearing', type: 'FWORD', value: 0},\n        {name: 'xMaxExtent', type: 'FWORD', value: 0},\n        {name: 'caretSlopeRise', type: 'SHORT', value: 1},\n        {name: 'caretSlopeRun', type: 'SHORT', value: 0},\n        {name: 'caretOffset', type: 'SHORT', value: 0},\n        {name: 'reserved1', type: 'SHORT', value: 0},\n        {name: 'reserved2', type: 'SHORT', value: 0},\n        {name: 'reserved3', type: 'SHORT', value: 0},\n        {name: 'reserved4', type: 'SHORT', value: 0},\n        {name: 'metricDataFormat', type: 'SHORT', value: 0},\n        {name: 'numberOfHMetrics', type: 'USHORT', value: 0}\n    ], options);\n}\n\n/* harmony default export */ var tables_hhea = ({ parse: parseHheaTable, make: makeHheaTable });\n\n// CONCATENATED MODULE: ./node_modules/opentype.js/src/tables/hmtx.js\n// The `hmtx` table contains the horizontal metrics for all glyphs.\n// https://www.microsoft.com/typography/OTSPEC/hmtx.htm\n\n\n\n\n// Parse the `hmtx` table, which contains the horizontal metrics for all glyphs.\n// This function augments the glyph array, adding the advanceWidth and leftSideBearing to each glyph.\nfunction parseHmtxTable(data, start, numMetrics, numGlyphs, glyphs) {\n    let advanceWidth;\n    let leftSideBearing;\n    const p = new src_parse.Parser(data, start);\n    for (let i = 0; i < numGlyphs; i += 1) {\n        // If the font is monospaced, only one entry is needed. This last entry applies to all subsequent glyphs.\n        if (i < numMetrics) {\n            advanceWidth = p.parseUShort();\n            leftSideBearing = p.parseShort();\n        }\n\n        const glyph = glyphs.get(i);\n        glyph.advanceWidth = advanceWidth;\n        glyph.leftSideBearing = leftSideBearing;\n    }\n}\n\nfunction makeHmtxTable(glyphs) {\n    const t = new src_table.Table('hmtx', []);\n    for (let i = 0; i < glyphs.length; i += 1) {\n        const glyph = glyphs.get(i);\n        const advanceWidth = glyph.advanceWidth || 0;\n        const leftSideBearing = glyph.leftSideBearing || 0;\n        t.fields.push({name: 'advanceWidth_' + i, type: 'USHORT', value: advanceWidth});\n        t.fields.push({name: 'leftSideBearing_' + i, type: 'SHORT', value: leftSideBearing});\n    }\n\n    return t;\n}\n\n/* harmony default export */ var hmtx = ({ parse: parseHmtxTable, make: makeHmtxTable });\n\n// CONCATENATED MODULE: ./node_modules/opentype.js/src/tables/ltag.js\n// The `ltag` table stores IETF BCP-47 language tags. It allows supporting\n// languages for which TrueType does not assign a numeric code.\n// https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6ltag.html\n// http://www.w3.org/International/articles/language-tags/\n// http://www.iana.org/assignments/language-subtag-registry/language-subtag-registry\n\n\n\n\n\nfunction makeLtagTable(tags) {\n    const result = new src_table.Table('ltag', [\n        {name: 'version', type: 'ULONG', value: 1},\n        {name: 'flags', type: 'ULONG', value: 0},\n        {name: 'numTags', type: 'ULONG', value: tags.length}\n    ]);\n\n    let stringPool = '';\n    const stringPoolOffset = 12 + tags.length * 4;\n    for (let i = 0; i < tags.length; ++i) {\n        let pos = stringPool.indexOf(tags[i]);\n        if (pos < 0) {\n            pos = stringPool.length;\n            stringPool += tags[i];\n        }\n\n        result.fields.push({name: 'offset ' + i, type: 'USHORT', value: stringPoolOffset + pos});\n        result.fields.push({name: 'length ' + i, type: 'USHORT', value: tags[i].length});\n    }\n\n    result.fields.push({name: 'stringPool', type: 'CHARARRAY', value: stringPool});\n    return result;\n}\n\nfunction parseLtagTable(data, start) {\n    const p = new src_parse.Parser(data, start);\n    const tableVersion = p.parseULong();\n    check.argument(tableVersion === 1, 'Unsupported ltag table version.');\n    // The 'ltag' specification does not define any flags; skip the field.\n    p.skip('uLong', 1);\n    const numTags = p.parseULong();\n\n    const tags = [];\n    for (let i = 0; i < numTags; i++) {\n        let tag = '';\n        const offset = start + p.parseUShort();\n        const length = p.parseUShort();\n        for (let j = offset; j < offset + length; ++j) {\n            tag += String.fromCharCode(data.getInt8(j));\n        }\n\n        tags.push(tag);\n    }\n\n    return tags;\n}\n\n/* harmony default export */ var tables_ltag = ({ make: makeLtagTable, parse: parseLtagTable });\n\n// CONCATENATED MODULE: ./node_modules/opentype.js/src/tables/maxp.js\n// The `maxp` table establishes the memory requirements for the font.\n// We need it just to get the number of glyphs in the font.\n// https://www.microsoft.com/typography/OTSPEC/maxp.htm\n\n\n\n\n// Parse the maximum profile `maxp` table.\nfunction parseMaxpTable(data, start) {\n    const maxp = {};\n    const p = new src_parse.Parser(data, start);\n    maxp.version = p.parseVersion();\n    maxp.numGlyphs = p.parseUShort();\n    if (maxp.version === 1.0) {\n        maxp.maxPoints = p.parseUShort();\n        maxp.maxContours = p.parseUShort();\n        maxp.maxCompositePoints = p.parseUShort();\n        maxp.maxCompositeContours = p.parseUShort();\n        maxp.maxZones = p.parseUShort();\n        maxp.maxTwilightPoints = p.parseUShort();\n        maxp.maxStorage = p.parseUShort();\n        maxp.maxFunctionDefs = p.parseUShort();\n        maxp.maxInstructionDefs = p.parseUShort();\n        maxp.maxStackElements = p.parseUShort();\n        maxp.maxSizeOfInstructions = p.parseUShort();\n        maxp.maxComponentElements = p.parseUShort();\n        maxp.maxComponentDepth = p.parseUShort();\n    }\n\n    return maxp;\n}\n\nfunction makeMaxpTable(numGlyphs) {\n    return new src_table.Table('maxp', [\n        {name: 'version', type: 'FIXED', value: 0x00005000},\n        {name: 'numGlyphs', type: 'USHORT', value: numGlyphs}\n    ]);\n}\n\n/* harmony default export */ var tables_maxp = ({ parse: parseMaxpTable, make: makeMaxpTable });\n\n// CONCATENATED MODULE: ./node_modules/opentype.js/src/tables/name.js\n// The `name` naming table.\n// https://www.microsoft.com/typography/OTSPEC/name.htm\n\n\n\n\n\n// NameIDs for the name table.\nconst nameTableNames = [\n    'copyright',              // 0\n    'fontFamily',             // 1\n    'fontSubfamily',          // 2\n    'uniqueID',               // 3\n    'fullName',               // 4\n    'version',                // 5\n    'postScriptName',         // 6\n    'trademark',              // 7\n    'manufacturer',           // 8\n    'designer',               // 9\n    'description',            // 10\n    'manufacturerURL',        // 11\n    'designerURL',            // 12\n    'license',                // 13\n    'licenseURL',             // 14\n    'reserved',               // 15\n    'preferredFamily',        // 16\n    'preferredSubfamily',     // 17\n    'compatibleFullName',     // 18\n    'sampleText',             // 19\n    'postScriptFindFontName', // 20\n    'wwsFamily',              // 21\n    'wwsSubfamily'            // 22\n];\n\nconst macLanguages = {\n    0: 'en',\n    1: 'fr',\n    2: 'de',\n    3: 'it',\n    4: 'nl',\n    5: 'sv',\n    6: 'es',\n    7: 'da',\n    8: 'pt',\n    9: 'no',\n    10: 'he',\n    11: 'ja',\n    12: 'ar',\n    13: 'fi',\n    14: 'el',\n    15: 'is',\n    16: 'mt',\n    17: 'tr',\n    18: 'hr',\n    19: 'zh-Hant',\n    20: 'ur',\n    21: 'hi',\n    22: 'th',\n    23: 'ko',\n    24: 'lt',\n    25: 'pl',\n    26: 'hu',\n    27: 'es',\n    28: 'lv',\n    29: 'se',\n    30: 'fo',\n    31: 'fa',\n    32: 'ru',\n    33: 'zh',\n    34: 'nl-BE',\n    35: 'ga',\n    36: 'sq',\n    37: 'ro',\n    38: 'cz',\n    39: 'sk',\n    40: 'si',\n    41: 'yi',\n    42: 'sr',\n    43: 'mk',\n    44: 'bg',\n    45: 'uk',\n    46: 'be',\n    47: 'uz',\n    48: 'kk',\n    49: 'az-Cyrl',\n    50: 'az-Arab',\n    51: 'hy',\n    52: 'ka',\n    53: 'mo',\n    54: 'ky',\n    55: 'tg',\n    56: 'tk',\n    57: 'mn-CN',\n    58: 'mn',\n    59: 'ps',\n    60: 'ks',\n    61: 'ku',\n    62: 'sd',\n    63: 'bo',\n    64: 'ne',\n    65: 'sa',\n    66: 'mr',\n    67: 'bn',\n    68: 'as',\n    69: 'gu',\n    70: 'pa',\n    71: 'or',\n    72: 'ml',\n    73: 'kn',\n    74: 'ta',\n    75: 'te',\n    76: 'si',\n    77: 'my',\n    78: 'km',\n    79: 'lo',\n    80: 'vi',\n    81: 'id',\n    82: 'tl',\n    83: 'ms',\n    84: 'ms-Arab',\n    85: 'am',\n    86: 'ti',\n    87: 'om',\n    88: 'so',\n    89: 'sw',\n    90: 'rw',\n    91: 'rn',\n    92: 'ny',\n    93: 'mg',\n    94: 'eo',\n    128: 'cy',\n    129: 'eu',\n    130: 'ca',\n    131: 'la',\n    132: 'qu',\n    133: 'gn',\n    134: 'ay',\n    135: 'tt',\n    136: 'ug',\n    137: 'dz',\n    138: 'jv',\n    139: 'su',\n    140: 'gl',\n    141: 'af',\n    142: 'br',\n    143: 'iu',\n    144: 'gd',\n    145: 'gv',\n    146: 'ga',\n    147: 'to',\n    148: 'el-polyton',\n    149: 'kl',\n    150: 'az',\n    151: 'nn'\n};\n\n// MacOS language ID → MacOS script ID\n//\n// Note that the script ID is not sufficient to determine what encoding\n// to use in TrueType files. For some languages, MacOS used a modification\n// of a mainstream script. For example, an Icelandic name would be stored\n// with smRoman in the TrueType naming table, but the actual encoding\n// is a special Icelandic version of the normal Macintosh Roman encoding.\n// As another example, Inuktitut uses an 8-bit encoding for Canadian Aboriginal\n// Syllables but MacOS had run out of available script codes, so this was\n// done as a (pretty radical) \"modification\" of Ethiopic.\n//\n// http://unicode.org/Public/MAPPINGS/VENDORS/APPLE/Readme.txt\nconst macLanguageToScript = {\n    0: 0,  // langEnglish → smRoman\n    1: 0,  // langFrench → smRoman\n    2: 0,  // langGerman → smRoman\n    3: 0,  // langItalian → smRoman\n    4: 0,  // langDutch → smRoman\n    5: 0,  // langSwedish → smRoman\n    6: 0,  // langSpanish → smRoman\n    7: 0,  // langDanish → smRoman\n    8: 0,  // langPortuguese → smRoman\n    9: 0,  // langNorwegian → smRoman\n    10: 5,  // langHebrew → smHebrew\n    11: 1,  // langJapanese → smJapanese\n    12: 4,  // langArabic → smArabic\n    13: 0,  // langFinnish → smRoman\n    14: 6,  // langGreek → smGreek\n    15: 0,  // langIcelandic → smRoman (modified)\n    16: 0,  // langMaltese → smRoman\n    17: 0,  // langTurkish → smRoman (modified)\n    18: 0,  // langCroatian → smRoman (modified)\n    19: 2,  // langTradChinese → smTradChinese\n    20: 4,  // langUrdu → smArabic\n    21: 9,  // langHindi → smDevanagari\n    22: 21,  // langThai → smThai\n    23: 3,  // langKorean → smKorean\n    24: 29,  // langLithuanian → smCentralEuroRoman\n    25: 29,  // langPolish → smCentralEuroRoman\n    26: 29,  // langHungarian → smCentralEuroRoman\n    27: 29,  // langEstonian → smCentralEuroRoman\n    28: 29,  // langLatvian → smCentralEuroRoman\n    29: 0,  // langSami → smRoman\n    30: 0,  // langFaroese → smRoman (modified)\n    31: 4,  // langFarsi → smArabic (modified)\n    32: 7,  // langRussian → smCyrillic\n    33: 25,  // langSimpChinese → smSimpChinese\n    34: 0,  // langFlemish → smRoman\n    35: 0,  // langIrishGaelic → smRoman (modified)\n    36: 0,  // langAlbanian → smRoman\n    37: 0,  // langRomanian → smRoman (modified)\n    38: 29,  // langCzech → smCentralEuroRoman\n    39: 29,  // langSlovak → smCentralEuroRoman\n    40: 0,  // langSlovenian → smRoman (modified)\n    41: 5,  // langYiddish → smHebrew\n    42: 7,  // langSerbian → smCyrillic\n    43: 7,  // langMacedonian → smCyrillic\n    44: 7,  // langBulgarian → smCyrillic\n    45: 7,  // langUkrainian → smCyrillic (modified)\n    46: 7,  // langByelorussian → smCyrillic\n    47: 7,  // langUzbek → smCyrillic\n    48: 7,  // langKazakh → smCyrillic\n    49: 7,  // langAzerbaijani → smCyrillic\n    50: 4,  // langAzerbaijanAr → smArabic\n    51: 24,  // langArmenian → smArmenian\n    52: 23,  // langGeorgian → smGeorgian\n    53: 7,  // langMoldavian → smCyrillic\n    54: 7,  // langKirghiz → smCyrillic\n    55: 7,  // langTajiki → smCyrillic\n    56: 7,  // langTurkmen → smCyrillic\n    57: 27,  // langMongolian → smMongolian\n    58: 7,  // langMongolianCyr → smCyrillic\n    59: 4,  // langPashto → smArabic\n    60: 4,  // langKurdish → smArabic\n    61: 4,  // langKashmiri → smArabic\n    62: 4,  // langSindhi → smArabic\n    63: 26,  // langTibetan → smTibetan\n    64: 9,  // langNepali → smDevanagari\n    65: 9,  // langSanskrit → smDevanagari\n    66: 9,  // langMarathi → smDevanagari\n    67: 13,  // langBengali → smBengali\n    68: 13,  // langAssamese → smBengali\n    69: 11,  // langGujarati → smGujarati\n    70: 10,  // langPunjabi → smGurmukhi\n    71: 12,  // langOriya → smOriya\n    72: 17,  // langMalayalam → smMalayalam\n    73: 16,  // langKannada → smKannada\n    74: 14,  // langTamil → smTamil\n    75: 15,  // langTelugu → smTelugu\n    76: 18,  // langSinhalese → smSinhalese\n    77: 19,  // langBurmese → smBurmese\n    78: 20,  // langKhmer → smKhmer\n    79: 22,  // langLao → smLao\n    80: 30,  // langVietnamese → smVietnamese\n    81: 0,  // langIndonesian → smRoman\n    82: 0,  // langTagalog → smRoman\n    83: 0,  // langMalayRoman → smRoman\n    84: 4,  // langMalayArabic → smArabic\n    85: 28,  // langAmharic → smEthiopic\n    86: 28,  // langTigrinya → smEthiopic\n    87: 28,  // langOromo → smEthiopic\n    88: 0,  // langSomali → smRoman\n    89: 0,  // langSwahili → smRoman\n    90: 0,  // langKinyarwanda → smRoman\n    91: 0,  // langRundi → smRoman\n    92: 0,  // langNyanja → smRoman\n    93: 0,  // langMalagasy → smRoman\n    94: 0,  // langEsperanto → smRoman\n    128: 0,  // langWelsh → smRoman (modified)\n    129: 0,  // langBasque → smRoman\n    130: 0,  // langCatalan → smRoman\n    131: 0,  // langLatin → smRoman\n    132: 0,  // langQuechua → smRoman\n    133: 0,  // langGuarani → smRoman\n    134: 0,  // langAymara → smRoman\n    135: 7,  // langTatar → smCyrillic\n    136: 4,  // langUighur → smArabic\n    137: 26,  // langDzongkha → smTibetan\n    138: 0,  // langJavaneseRom → smRoman\n    139: 0,  // langSundaneseRom → smRoman\n    140: 0,  // langGalician → smRoman\n    141: 0,  // langAfrikaans → smRoman\n    142: 0,  // langBreton → smRoman (modified)\n    143: 28,  // langInuktitut → smEthiopic (modified)\n    144: 0,  // langScottishGaelic → smRoman (modified)\n    145: 0,  // langManxGaelic → smRoman (modified)\n    146: 0,  // langIrishGaelicScript → smRoman (modified)\n    147: 0,  // langTongan → smRoman\n    148: 6,  // langGreekAncient → smRoman\n    149: 0,  // langGreenlandic → smRoman\n    150: 0,  // langAzerbaijanRoman → smRoman\n    151: 0   // langNynorsk → smRoman\n};\n\n// While Microsoft indicates a region/country for all its language\n// IDs, we omit the region code if it's equal to the \"most likely\n// region subtag\" according to Unicode CLDR. For scripts, we omit\n// the subtag if it is equal to the Suppress-Script entry in the\n// IANA language subtag registry for IETF BCP 47.\n//\n// For example, Microsoft states that its language code 0x041A is\n// Croatian in Croatia. We transform this to the BCP 47 language code 'hr'\n// and not 'hr-HR' because Croatia is the default country for Croatian,\n// according to Unicode CLDR. As another example, Microsoft states\n// that 0x101A is Croatian (Latin) in Bosnia-Herzegovina. We transform\n// this to 'hr-BA' and not 'hr-Latn-BA' because Latin is the default script\n// for the Croatian language, according to IANA.\n//\n// http://www.unicode.org/cldr/charts/latest/supplemental/likely_subtags.html\n// http://www.iana.org/assignments/language-subtag-registry/language-subtag-registry\nconst windowsLanguages = {\n    0x0436: 'af',\n    0x041C: 'sq',\n    0x0484: 'gsw',\n    0x045E: 'am',\n    0x1401: 'ar-DZ',\n    0x3C01: 'ar-BH',\n    0x0C01: 'ar',\n    0x0801: 'ar-IQ',\n    0x2C01: 'ar-JO',\n    0x3401: 'ar-KW',\n    0x3001: 'ar-LB',\n    0x1001: 'ar-LY',\n    0x1801: 'ary',\n    0x2001: 'ar-OM',\n    0x4001: 'ar-QA',\n    0x0401: 'ar-SA',\n    0x2801: 'ar-SY',\n    0x1C01: 'aeb',\n    0x3801: 'ar-AE',\n    0x2401: 'ar-YE',\n    0x042B: 'hy',\n    0x044D: 'as',\n    0x082C: 'az-Cyrl',\n    0x042C: 'az',\n    0x046D: 'ba',\n    0x042D: 'eu',\n    0x0423: 'be',\n    0x0845: 'bn',\n    0x0445: 'bn-IN',\n    0x201A: 'bs-Cyrl',\n    0x141A: 'bs',\n    0x047E: 'br',\n    0x0402: 'bg',\n    0x0403: 'ca',\n    0x0C04: 'zh-HK',\n    0x1404: 'zh-MO',\n    0x0804: 'zh',\n    0x1004: 'zh-SG',\n    0x0404: 'zh-TW',\n    0x0483: 'co',\n    0x041A: 'hr',\n    0x101A: 'hr-BA',\n    0x0405: 'cs',\n    0x0406: 'da',\n    0x048C: 'prs',\n    0x0465: 'dv',\n    0x0813: 'nl-BE',\n    0x0413: 'nl',\n    0x0C09: 'en-AU',\n    0x2809: 'en-BZ',\n    0x1009: 'en-CA',\n    0x2409: 'en-029',\n    0x4009: 'en-IN',\n    0x1809: 'en-IE',\n    0x2009: 'en-JM',\n    0x4409: 'en-MY',\n    0x1409: 'en-NZ',\n    0x3409: 'en-PH',\n    0x4809: 'en-SG',\n    0x1C09: 'en-ZA',\n    0x2C09: 'en-TT',\n    0x0809: 'en-GB',\n    0x0409: 'en',\n    0x3009: 'en-ZW',\n    0x0425: 'et',\n    0x0438: 'fo',\n    0x0464: 'fil',\n    0x040B: 'fi',\n    0x080C: 'fr-BE',\n    0x0C0C: 'fr-CA',\n    0x040C: 'fr',\n    0x140C: 'fr-LU',\n    0x180C: 'fr-MC',\n    0x100C: 'fr-CH',\n    0x0462: 'fy',\n    0x0456: 'gl',\n    0x0437: 'ka',\n    0x0C07: 'de-AT',\n    0x0407: 'de',\n    0x1407: 'de-LI',\n    0x1007: 'de-LU',\n    0x0807: 'de-CH',\n    0x0408: 'el',\n    0x046F: 'kl',\n    0x0447: 'gu',\n    0x0468: 'ha',\n    0x040D: 'he',\n    0x0439: 'hi',\n    0x040E: 'hu',\n    0x040F: 'is',\n    0x0470: 'ig',\n    0x0421: 'id',\n    0x045D: 'iu',\n    0x085D: 'iu-Latn',\n    0x083C: 'ga',\n    0x0434: 'xh',\n    0x0435: 'zu',\n    0x0410: 'it',\n    0x0810: 'it-CH',\n    0x0411: 'ja',\n    0x044B: 'kn',\n    0x043F: 'kk',\n    0x0453: 'km',\n    0x0486: 'quc',\n    0x0487: 'rw',\n    0x0441: 'sw',\n    0x0457: 'kok',\n    0x0412: 'ko',\n    0x0440: 'ky',\n    0x0454: 'lo',\n    0x0426: 'lv',\n    0x0427: 'lt',\n    0x082E: 'dsb',\n    0x046E: 'lb',\n    0x042F: 'mk',\n    0x083E: 'ms-BN',\n    0x043E: 'ms',\n    0x044C: 'ml',\n    0x043A: 'mt',\n    0x0481: 'mi',\n    0x047A: 'arn',\n    0x044E: 'mr',\n    0x047C: 'moh',\n    0x0450: 'mn',\n    0x0850: 'mn-CN',\n    0x0461: 'ne',\n    0x0414: 'nb',\n    0x0814: 'nn',\n    0x0482: 'oc',\n    0x0448: 'or',\n    0x0463: 'ps',\n    0x0415: 'pl',\n    0x0416: 'pt',\n    0x0816: 'pt-PT',\n    0x0446: 'pa',\n    0x046B: 'qu-BO',\n    0x086B: 'qu-EC',\n    0x0C6B: 'qu',\n    0x0418: 'ro',\n    0x0417: 'rm',\n    0x0419: 'ru',\n    0x243B: 'smn',\n    0x103B: 'smj-NO',\n    0x143B: 'smj',\n    0x0C3B: 'se-FI',\n    0x043B: 'se',\n    0x083B: 'se-SE',\n    0x203B: 'sms',\n    0x183B: 'sma-NO',\n    0x1C3B: 'sms',\n    0x044F: 'sa',\n    0x1C1A: 'sr-Cyrl-BA',\n    0x0C1A: 'sr',\n    0x181A: 'sr-Latn-BA',\n    0x081A: 'sr-Latn',\n    0x046C: 'nso',\n    0x0432: 'tn',\n    0x045B: 'si',\n    0x041B: 'sk',\n    0x0424: 'sl',\n    0x2C0A: 'es-AR',\n    0x400A: 'es-BO',\n    0x340A: 'es-CL',\n    0x240A: 'es-CO',\n    0x140A: 'es-CR',\n    0x1C0A: 'es-DO',\n    0x300A: 'es-EC',\n    0x440A: 'es-SV',\n    0x100A: 'es-GT',\n    0x480A: 'es-HN',\n    0x080A: 'es-MX',\n    0x4C0A: 'es-NI',\n    0x180A: 'es-PA',\n    0x3C0A: 'es-PY',\n    0x280A: 'es-PE',\n    0x500A: 'es-PR',\n\n    // Microsoft has defined two different language codes for\n    // “Spanish with modern sorting” and “Spanish with traditional\n    // sorting”. This makes sense for collation APIs, and it would be\n    // possible to express this in BCP 47 language tags via Unicode\n    // extensions (eg., es-u-co-trad is Spanish with traditional\n    // sorting). However, for storing names in fonts, the distinction\n    // does not make sense, so we give “es” in both cases.\n    0x0C0A: 'es',\n    0x040A: 'es',\n\n    0x540A: 'es-US',\n    0x380A: 'es-UY',\n    0x200A: 'es-VE',\n    0x081D: 'sv-FI',\n    0x041D: 'sv',\n    0x045A: 'syr',\n    0x0428: 'tg',\n    0x085F: 'tzm',\n    0x0449: 'ta',\n    0x0444: 'tt',\n    0x044A: 'te',\n    0x041E: 'th',\n    0x0451: 'bo',\n    0x041F: 'tr',\n    0x0442: 'tk',\n    0x0480: 'ug',\n    0x0422: 'uk',\n    0x042E: 'hsb',\n    0x0420: 'ur',\n    0x0843: 'uz-Cyrl',\n    0x0443: 'uz',\n    0x042A: 'vi',\n    0x0452: 'cy',\n    0x0488: 'wo',\n    0x0485: 'sah',\n    0x0478: 'ii',\n    0x046A: 'yo'\n};\n\n// Returns a IETF BCP 47 language code, for example 'zh-Hant'\n// for 'Chinese in the traditional script'.\nfunction getLanguageCode(platformID, languageID, ltag) {\n    switch (platformID) {\n        case 0:  // Unicode\n            if (languageID === 0xFFFF) {\n                return 'und';\n            } else if (ltag) {\n                return ltag[languageID];\n            }\n\n            break;\n\n        case 1:  // Macintosh\n            return macLanguages[languageID];\n\n        case 3:  // Windows\n            return windowsLanguages[languageID];\n    }\n\n    return undefined;\n}\n\nconst utf16 = 'utf-16';\n\n// MacOS script ID → encoding. This table stores the default case,\n// which can be overridden by macLanguageEncodings.\nconst macScriptEncodings = {\n    0: 'macintosh',           // smRoman\n    1: 'x-mac-japanese',      // smJapanese\n    2: 'x-mac-chinesetrad',   // smTradChinese\n    3: 'x-mac-korean',        // smKorean\n    6: 'x-mac-greek',         // smGreek\n    7: 'x-mac-cyrillic',      // smCyrillic\n    9: 'x-mac-devanagai',     // smDevanagari\n    10: 'x-mac-gurmukhi',     // smGurmukhi\n    11: 'x-mac-gujarati',     // smGujarati\n    12: 'x-mac-oriya',        // smOriya\n    13: 'x-mac-bengali',      // smBengali\n    14: 'x-mac-tamil',        // smTamil\n    15: 'x-mac-telugu',       // smTelugu\n    16: 'x-mac-kannada',      // smKannada\n    17: 'x-mac-malayalam',    // smMalayalam\n    18: 'x-mac-sinhalese',    // smSinhalese\n    19: 'x-mac-burmese',      // smBurmese\n    20: 'x-mac-khmer',        // smKhmer\n    21: 'x-mac-thai',         // smThai\n    22: 'x-mac-lao',          // smLao\n    23: 'x-mac-georgian',     // smGeorgian\n    24: 'x-mac-armenian',     // smArmenian\n    25: 'x-mac-chinesesimp',  // smSimpChinese\n    26: 'x-mac-tibetan',      // smTibetan\n    27: 'x-mac-mongolian',    // smMongolian\n    28: 'x-mac-ethiopic',     // smEthiopic\n    29: 'x-mac-ce',           // smCentralEuroRoman\n    30: 'x-mac-vietnamese',   // smVietnamese\n    31: 'x-mac-extarabic'     // smExtArabic\n};\n\n// MacOS language ID → encoding. This table stores the exceptional\n// cases, which override macScriptEncodings. For writing MacOS naming\n// tables, we need to emit a MacOS script ID. Therefore, we cannot\n// merge macScriptEncodings into macLanguageEncodings.\n//\n// http://unicode.org/Public/MAPPINGS/VENDORS/APPLE/Readme.txt\nconst macLanguageEncodings = {\n    15: 'x-mac-icelandic',    // langIcelandic\n    17: 'x-mac-turkish',      // langTurkish\n    18: 'x-mac-croatian',     // langCroatian\n    24: 'x-mac-ce',           // langLithuanian\n    25: 'x-mac-ce',           // langPolish\n    26: 'x-mac-ce',           // langHungarian\n    27: 'x-mac-ce',           // langEstonian\n    28: 'x-mac-ce',           // langLatvian\n    30: 'x-mac-icelandic',    // langFaroese\n    37: 'x-mac-romanian',     // langRomanian\n    38: 'x-mac-ce',           // langCzech\n    39: 'x-mac-ce',           // langSlovak\n    40: 'x-mac-ce',           // langSlovenian\n    143: 'x-mac-inuit',       // langInuktitut\n    146: 'x-mac-gaelic'       // langIrishGaelicScript\n};\n\nfunction getEncoding(platformID, encodingID, languageID) {\n    switch (platformID) {\n        case 0:  // Unicode\n            return utf16;\n\n        case 1:  // Apple Macintosh\n            return macLanguageEncodings[languageID] || macScriptEncodings[encodingID];\n\n        case 3:  // Microsoft Windows\n            if (encodingID === 1 || encodingID === 10) {\n                return utf16;\n            }\n\n            break;\n    }\n\n    return undefined;\n}\n\n// Parse the naming `name` table.\n// FIXME: Format 1 additional fields are not supported yet.\n// ltag is the content of the `ltag' table, such as ['en', 'zh-Hans', 'de-CH-1904'].\nfunction parseNameTable(data, start, ltag) {\n    const name = {};\n    const p = new src_parse.Parser(data, start);\n    const format = p.parseUShort();\n    const count = p.parseUShort();\n    const stringOffset = p.offset + p.parseUShort();\n    for (let i = 0; i < count; i++) {\n        const platformID = p.parseUShort();\n        const encodingID = p.parseUShort();\n        const languageID = p.parseUShort();\n        const nameID = p.parseUShort();\n        const property = nameTableNames[nameID] || nameID;\n        const byteLength = p.parseUShort();\n        const offset = p.parseUShort();\n        const language = getLanguageCode(platformID, languageID, ltag);\n        const encoding = getEncoding(platformID, encodingID, languageID);\n        if (encoding !== undefined && language !== undefined) {\n            let text;\n            if (encoding === utf16) {\n                text = decode.UTF16(data, stringOffset + offset, byteLength);\n            } else {\n                text = decode.MACSTRING(data, stringOffset + offset, byteLength, encoding);\n            }\n\n            if (text) {\n                let translations = name[property];\n                if (translations === undefined) {\n                    translations = name[property] = {};\n                }\n\n                translations[language] = text;\n            }\n        }\n    }\n\n    let langTagCount = 0;\n    if (format === 1) {\n        // FIXME: Also handle Microsoft's 'name' table 1.\n        langTagCount = p.parseUShort();\n    }\n\n    return name;\n}\n\n// {23: 'foo'} → {'foo': 23}\n// ['bar', 'baz'] → {'bar': 0, 'baz': 1}\nfunction reverseDict(dict) {\n    const result = {};\n    for (let key in dict) {\n        result[dict[key]] = parseInt(key);\n    }\n\n    return result;\n}\n\nfunction makeNameRecord(platformID, encodingID, languageID, nameID, length, offset) {\n    return new src_table.Record('NameRecord', [\n        {name: 'platformID', type: 'USHORT', value: platformID},\n        {name: 'encodingID', type: 'USHORT', value: encodingID},\n        {name: 'languageID', type: 'USHORT', value: languageID},\n        {name: 'nameID', type: 'USHORT', value: nameID},\n        {name: 'length', type: 'USHORT', value: length},\n        {name: 'offset', type: 'USHORT', value: offset}\n    ]);\n}\n\n// Finds the position of needle in haystack, or -1 if not there.\n// Like String.indexOf(), but for arrays.\nfunction findSubArray(needle, haystack) {\n    const needleLength = needle.length;\n    const limit = haystack.length - needleLength + 1;\n\n    loop:\n    for (let pos = 0; pos < limit; pos++) {\n        for (; pos < limit; pos++) {\n            for (let k = 0; k < needleLength; k++) {\n                if (haystack[pos + k] !== needle[k]) {\n                    continue loop;\n                }\n            }\n\n            return pos;\n        }\n    }\n\n    return -1;\n}\n\nfunction addStringToPool(s, pool) {\n    let offset = findSubArray(s, pool);\n    if (offset < 0) {\n        offset = pool.length;\n        let i = 0;\n        const len = s.length;\n        for (; i < len; ++i) {\n            pool.push(s[i]);\n        }\n\n    }\n\n    return offset;\n}\n\nfunction makeNameTable(names, ltag) {\n    let nameID;\n    const nameIDs = [];\n\n    const namesWithNumericKeys = {};\n    const nameTableIds = reverseDict(nameTableNames);\n    for (let key in names) {\n        let id = nameTableIds[key];\n        if (id === undefined) {\n            id = key;\n        }\n\n        nameID = parseInt(id);\n\n        if (isNaN(nameID)) {\n            throw new Error('Name table entry \"' + key + '\" does not exist, see nameTableNames for complete list.');\n        }\n\n        namesWithNumericKeys[nameID] = names[key];\n        nameIDs.push(nameID);\n    }\n\n    const macLanguageIds = reverseDict(macLanguages);\n    const windowsLanguageIds = reverseDict(windowsLanguages);\n\n    const nameRecords = [];\n    const stringPool = [];\n\n    for (let i = 0; i < nameIDs.length; i++) {\n        nameID = nameIDs[i];\n        const translations = namesWithNumericKeys[nameID];\n        for (let lang in translations) {\n            const text = translations[lang];\n\n            // For MacOS, we try to emit the name in the form that was introduced\n            // in the initial version of the TrueType spec (in the late 1980s).\n            // However, this can fail for various reasons: the requested BCP 47\n            // language code might not have an old-style Mac equivalent;\n            // we might not have a codec for the needed character encoding;\n            // or the name might contain characters that cannot be expressed\n            // in the old-style Macintosh encoding. In case of failure, we emit\n            // the name in a more modern fashion (Unicode encoding with BCP 47\n            // language tags) that is recognized by MacOS 10.5, released in 2009.\n            // If fonts were only read by operating systems, we could simply\n            // emit all names in the modern form; this would be much easier.\n            // However, there are many applications and libraries that read\n            // 'name' tables directly, and these will usually only recognize\n            // the ancient form (silently skipping the unrecognized names).\n            let macPlatform = 1;  // Macintosh\n            let macLanguage = macLanguageIds[lang];\n            let macScript = macLanguageToScript[macLanguage];\n            const macEncoding = getEncoding(macPlatform, macScript, macLanguage);\n            let macName = encode.MACSTRING(text, macEncoding);\n            if (macName === undefined) {\n                macPlatform = 0;  // Unicode\n                macLanguage = ltag.indexOf(lang);\n                if (macLanguage < 0) {\n                    macLanguage = ltag.length;\n                    ltag.push(lang);\n                }\n\n                macScript = 4;  // Unicode 2.0 and later\n                macName = encode.UTF16(text);\n            }\n\n            const macNameOffset = addStringToPool(macName, stringPool);\n            nameRecords.push(makeNameRecord(macPlatform, macScript, macLanguage,\n                                            nameID, macName.length, macNameOffset));\n\n            const winLanguage = windowsLanguageIds[lang];\n            if (winLanguage !== undefined) {\n                const winName = encode.UTF16(text);\n                const winNameOffset = addStringToPool(winName, stringPool);\n                nameRecords.push(makeNameRecord(3, 1, winLanguage,\n                                                nameID, winName.length, winNameOffset));\n            }\n        }\n    }\n\n    nameRecords.sort(function(a, b) {\n        return ((a.platformID - b.platformID) ||\n                (a.encodingID - b.encodingID) ||\n                (a.languageID - b.languageID) ||\n                (a.nameID - b.nameID));\n    });\n\n    const t = new src_table.Table('name', [\n        {name: 'format', type: 'USHORT', value: 0},\n        {name: 'count', type: 'USHORT', value: nameRecords.length},\n        {name: 'stringOffset', type: 'USHORT', value: 6 + nameRecords.length * 12}\n    ]);\n\n    for (let r = 0; r < nameRecords.length; r++) {\n        t.fields.push({name: 'record_' + r, type: 'RECORD', value: nameRecords[r]});\n    }\n\n    t.fields.push({name: 'strings', type: 'LITERAL', value: stringPool});\n    return t;\n}\n\n/* harmony default export */ var tables_name = ({ parse: parseNameTable, make: makeNameTable });\n\n// CONCATENATED MODULE: ./node_modules/opentype.js/src/tables/os2.js\n// The `OS/2` table contains metrics required in OpenType fonts.\n// https://www.microsoft.com/typography/OTSPEC/os2.htm\n\n\n\n\nconst unicodeRanges = [\n    {begin: 0x0000, end: 0x007F}, // Basic Latin\n    {begin: 0x0080, end: 0x00FF}, // Latin-1 Supplement\n    {begin: 0x0100, end: 0x017F}, // Latin Extended-A\n    {begin: 0x0180, end: 0x024F}, // Latin Extended-B\n    {begin: 0x0250, end: 0x02AF}, // IPA Extensions\n    {begin: 0x02B0, end: 0x02FF}, // Spacing Modifier Letters\n    {begin: 0x0300, end: 0x036F}, // Combining Diacritical Marks\n    {begin: 0x0370, end: 0x03FF}, // Greek and Coptic\n    {begin: 0x2C80, end: 0x2CFF}, // Coptic\n    {begin: 0x0400, end: 0x04FF}, // Cyrillic\n    {begin: 0x0530, end: 0x058F}, // Armenian\n    {begin: 0x0590, end: 0x05FF}, // Hebrew\n    {begin: 0xA500, end: 0xA63F}, // Vai\n    {begin: 0x0600, end: 0x06FF}, // Arabic\n    {begin: 0x07C0, end: 0x07FF}, // NKo\n    {begin: 0x0900, end: 0x097F}, // Devanagari\n    {begin: 0x0980, end: 0x09FF}, // Bengali\n    {begin: 0x0A00, end: 0x0A7F}, // Gurmukhi\n    {begin: 0x0A80, end: 0x0AFF}, // Gujarati\n    {begin: 0x0B00, end: 0x0B7F}, // Oriya\n    {begin: 0x0B80, end: 0x0BFF}, // Tamil\n    {begin: 0x0C00, end: 0x0C7F}, // Telugu\n    {begin: 0x0C80, end: 0x0CFF}, // Kannada\n    {begin: 0x0D00, end: 0x0D7F}, // Malayalam\n    {begin: 0x0E00, end: 0x0E7F}, // Thai\n    {begin: 0x0E80, end: 0x0EFF}, // Lao\n    {begin: 0x10A0, end: 0x10FF}, // Georgian\n    {begin: 0x1B00, end: 0x1B7F}, // Balinese\n    {begin: 0x1100, end: 0x11FF}, // Hangul Jamo\n    {begin: 0x1E00, end: 0x1EFF}, // Latin Extended Additional\n    {begin: 0x1F00, end: 0x1FFF}, // Greek Extended\n    {begin: 0x2000, end: 0x206F}, // General Punctuation\n    {begin: 0x2070, end: 0x209F}, // Superscripts And Subscripts\n    {begin: 0x20A0, end: 0x20CF}, // Currency Symbol\n    {begin: 0x20D0, end: 0x20FF}, // Combining Diacritical Marks For Symbols\n    {begin: 0x2100, end: 0x214F}, // Letterlike Symbols\n    {begin: 0x2150, end: 0x218F}, // Number Forms\n    {begin: 0x2190, end: 0x21FF}, // Arrows\n    {begin: 0x2200, end: 0x22FF}, // Mathematical Operators\n    {begin: 0x2300, end: 0x23FF}, // Miscellaneous Technical\n    {begin: 0x2400, end: 0x243F}, // Control Pictures\n    {begin: 0x2440, end: 0x245F}, // Optical Character Recognition\n    {begin: 0x2460, end: 0x24FF}, // Enclosed Alphanumerics\n    {begin: 0x2500, end: 0x257F}, // Box Drawing\n    {begin: 0x2580, end: 0x259F}, // Block Elements\n    {begin: 0x25A0, end: 0x25FF}, // Geometric Shapes\n    {begin: 0x2600, end: 0x26FF}, // Miscellaneous Symbols\n    {begin: 0x2700, end: 0x27BF}, // Dingbats\n    {begin: 0x3000, end: 0x303F}, // CJK Symbols And Punctuation\n    {begin: 0x3040, end: 0x309F}, // Hiragana\n    {begin: 0x30A0, end: 0x30FF}, // Katakana\n    {begin: 0x3100, end: 0x312F}, // Bopomofo\n    {begin: 0x3130, end: 0x318F}, // Hangul Compatibility Jamo\n    {begin: 0xA840, end: 0xA87F}, // Phags-pa\n    {begin: 0x3200, end: 0x32FF}, // Enclosed CJK Letters And Months\n    {begin: 0x3300, end: 0x33FF}, // CJK Compatibility\n    {begin: 0xAC00, end: 0xD7AF}, // Hangul Syllables\n    {begin: 0xD800, end: 0xDFFF}, // Non-Plane 0 *\n    {begin: 0x10900, end: 0x1091F}, // Phoenicia\n    {begin: 0x4E00, end: 0x9FFF}, // CJK Unified Ideographs\n    {begin: 0xE000, end: 0xF8FF}, // Private Use Area (plane 0)\n    {begin: 0x31C0, end: 0x31EF}, // CJK Strokes\n    {begin: 0xFB00, end: 0xFB4F}, // Alphabetic Presentation Forms\n    {begin: 0xFB50, end: 0xFDFF}, // Arabic Presentation Forms-A\n    {begin: 0xFE20, end: 0xFE2F}, // Combining Half Marks\n    {begin: 0xFE10, end: 0xFE1F}, // Vertical Forms\n    {begin: 0xFE50, end: 0xFE6F}, // Small Form Variants\n    {begin: 0xFE70, end: 0xFEFF}, // Arabic Presentation Forms-B\n    {begin: 0xFF00, end: 0xFFEF}, // Halfwidth And Fullwidth Forms\n    {begin: 0xFFF0, end: 0xFFFF}, // Specials\n    {begin: 0x0F00, end: 0x0FFF}, // Tibetan\n    {begin: 0x0700, end: 0x074F}, // Syriac\n    {begin: 0x0780, end: 0x07BF}, // Thaana\n    {begin: 0x0D80, end: 0x0DFF}, // Sinhala\n    {begin: 0x1000, end: 0x109F}, // Myanmar\n    {begin: 0x1200, end: 0x137F}, // Ethiopic\n    {begin: 0x13A0, end: 0x13FF}, // Cherokee\n    {begin: 0x1400, end: 0x167F}, // Unified Canadian Aboriginal Syllabics\n    {begin: 0x1680, end: 0x169F}, // Ogham\n    {begin: 0x16A0, end: 0x16FF}, // Runic\n    {begin: 0x1780, end: 0x17FF}, // Khmer\n    {begin: 0x1800, end: 0x18AF}, // Mongolian\n    {begin: 0x2800, end: 0x28FF}, // Braille Patterns\n    {begin: 0xA000, end: 0xA48F}, // Yi Syllables\n    {begin: 0x1700, end: 0x171F}, // Tagalog\n    {begin: 0x10300, end: 0x1032F}, // Old Italic\n    {begin: 0x10330, end: 0x1034F}, // Gothic\n    {begin: 0x10400, end: 0x1044F}, // Deseret\n    {begin: 0x1D000, end: 0x1D0FF}, // Byzantine Musical Symbols\n    {begin: 0x1D400, end: 0x1D7FF}, // Mathematical Alphanumeric Symbols\n    {begin: 0xFF000, end: 0xFFFFD}, // Private Use (plane 15)\n    {begin: 0xFE00, end: 0xFE0F}, // Variation Selectors\n    {begin: 0xE0000, end: 0xE007F}, // Tags\n    {begin: 0x1900, end: 0x194F}, // Limbu\n    {begin: 0x1950, end: 0x197F}, // Tai Le\n    {begin: 0x1980, end: 0x19DF}, // New Tai Lue\n    {begin: 0x1A00, end: 0x1A1F}, // Buginese\n    {begin: 0x2C00, end: 0x2C5F}, // Glagolitic\n    {begin: 0x2D30, end: 0x2D7F}, // Tifinagh\n    {begin: 0x4DC0, end: 0x4DFF}, // Yijing Hexagram Symbols\n    {begin: 0xA800, end: 0xA82F}, // Syloti Nagri\n    {begin: 0x10000, end: 0x1007F}, // Linear B Syllabary\n    {begin: 0x10140, end: 0x1018F}, // Ancient Greek Numbers\n    {begin: 0x10380, end: 0x1039F}, // Ugaritic\n    {begin: 0x103A0, end: 0x103DF}, // Old Persian\n    {begin: 0x10450, end: 0x1047F}, // Shavian\n    {begin: 0x10480, end: 0x104AF}, // Osmanya\n    {begin: 0x10800, end: 0x1083F}, // Cypriot Syllabary\n    {begin: 0x10A00, end: 0x10A5F}, // Kharoshthi\n    {begin: 0x1D300, end: 0x1D35F}, // Tai Xuan Jing Symbols\n    {begin: 0x12000, end: 0x123FF}, // Cuneiform\n    {begin: 0x1D360, end: 0x1D37F}, // Counting Rod Numerals\n    {begin: 0x1B80, end: 0x1BBF}, // Sundanese\n    {begin: 0x1C00, end: 0x1C4F}, // Lepcha\n    {begin: 0x1C50, end: 0x1C7F}, // Ol Chiki\n    {begin: 0xA880, end: 0xA8DF}, // Saurashtra\n    {begin: 0xA900, end: 0xA92F}, // Kayah Li\n    {begin: 0xA930, end: 0xA95F}, // Rejang\n    {begin: 0xAA00, end: 0xAA5F}, // Cham\n    {begin: 0x10190, end: 0x101CF}, // Ancient Symbols\n    {begin: 0x101D0, end: 0x101FF}, // Phaistos Disc\n    {begin: 0x102A0, end: 0x102DF}, // Carian\n    {begin: 0x1F030, end: 0x1F09F}  // Domino Tiles\n];\n\nfunction getUnicodeRange(unicode) {\n    for (let i = 0; i < unicodeRanges.length; i += 1) {\n        const range = unicodeRanges[i];\n        if (unicode >= range.begin && unicode < range.end) {\n            return i;\n        }\n    }\n\n    return -1;\n}\n\n// Parse the OS/2 and Windows metrics `OS/2` table\nfunction parseOS2Table(data, start) {\n    const os2 = {};\n    const p = new src_parse.Parser(data, start);\n    os2.version = p.parseUShort();\n    os2.xAvgCharWidth = p.parseShort();\n    os2.usWeightClass = p.parseUShort();\n    os2.usWidthClass = p.parseUShort();\n    os2.fsType = p.parseUShort();\n    os2.ySubscriptXSize = p.parseShort();\n    os2.ySubscriptYSize = p.parseShort();\n    os2.ySubscriptXOffset = p.parseShort();\n    os2.ySubscriptYOffset = p.parseShort();\n    os2.ySuperscriptXSize = p.parseShort();\n    os2.ySuperscriptYSize = p.parseShort();\n    os2.ySuperscriptXOffset = p.parseShort();\n    os2.ySuperscriptYOffset = p.parseShort();\n    os2.yStrikeoutSize = p.parseShort();\n    os2.yStrikeoutPosition = p.parseShort();\n    os2.sFamilyClass = p.parseShort();\n    os2.panose = [];\n    for (let i = 0; i < 10; i++) {\n        os2.panose[i] = p.parseByte();\n    }\n\n    os2.ulUnicodeRange1 = p.parseULong();\n    os2.ulUnicodeRange2 = p.parseULong();\n    os2.ulUnicodeRange3 = p.parseULong();\n    os2.ulUnicodeRange4 = p.parseULong();\n    os2.achVendID = String.fromCharCode(p.parseByte(), p.parseByte(), p.parseByte(), p.parseByte());\n    os2.fsSelection = p.parseUShort();\n    os2.usFirstCharIndex = p.parseUShort();\n    os2.usLastCharIndex = p.parseUShort();\n    os2.sTypoAscender = p.parseShort();\n    os2.sTypoDescender = p.parseShort();\n    os2.sTypoLineGap = p.parseShort();\n    os2.usWinAscent = p.parseUShort();\n    os2.usWinDescent = p.parseUShort();\n    if (os2.version >= 1) {\n        os2.ulCodePageRange1 = p.parseULong();\n        os2.ulCodePageRange2 = p.parseULong();\n    }\n\n    if (os2.version >= 2) {\n        os2.sxHeight = p.parseShort();\n        os2.sCapHeight = p.parseShort();\n        os2.usDefaultChar = p.parseUShort();\n        os2.usBreakChar = p.parseUShort();\n        os2.usMaxContent = p.parseUShort();\n    }\n\n    return os2;\n}\n\nfunction makeOS2Table(options) {\n    return new src_table.Table('OS/2', [\n        {name: 'version', type: 'USHORT', value: 0x0003},\n        {name: 'xAvgCharWidth', type: 'SHORT', value: 0},\n        {name: 'usWeightClass', type: 'USHORT', value: 0},\n        {name: 'usWidthClass', type: 'USHORT', value: 0},\n        {name: 'fsType', type: 'USHORT', value: 0},\n        {name: 'ySubscriptXSize', type: 'SHORT', value: 650},\n        {name: 'ySubscriptYSize', type: 'SHORT', value: 699},\n        {name: 'ySubscriptXOffset', type: 'SHORT', value: 0},\n        {name: 'ySubscriptYOffset', type: 'SHORT', value: 140},\n        {name: 'ySuperscriptXSize', type: 'SHORT', value: 650},\n        {name: 'ySuperscriptYSize', type: 'SHORT', value: 699},\n        {name: 'ySuperscriptXOffset', type: 'SHORT', value: 0},\n        {name: 'ySuperscriptYOffset', type: 'SHORT', value: 479},\n        {name: 'yStrikeoutSize', type: 'SHORT', value: 49},\n        {name: 'yStrikeoutPosition', type: 'SHORT', value: 258},\n        {name: 'sFamilyClass', type: 'SHORT', value: 0},\n        {name: 'bFamilyType', type: 'BYTE', value: 0},\n        {name: 'bSerifStyle', type: 'BYTE', value: 0},\n        {name: 'bWeight', type: 'BYTE', value: 0},\n        {name: 'bProportion', type: 'BYTE', value: 0},\n        {name: 'bContrast', type: 'BYTE', value: 0},\n        {name: 'bStrokeVariation', type: 'BYTE', value: 0},\n        {name: 'bArmStyle', type: 'BYTE', value: 0},\n        {name: 'bLetterform', type: 'BYTE', value: 0},\n        {name: 'bMidline', type: 'BYTE', value: 0},\n        {name: 'bXHeight', type: 'BYTE', value: 0},\n        {name: 'ulUnicodeRange1', type: 'ULONG', value: 0},\n        {name: 'ulUnicodeRange2', type: 'ULONG', value: 0},\n        {name: 'ulUnicodeRange3', type: 'ULONG', value: 0},\n        {name: 'ulUnicodeRange4', type: 'ULONG', value: 0},\n        {name: 'achVendID', type: 'CHARARRAY', value: 'XXXX'},\n        {name: 'fsSelection', type: 'USHORT', value: 0},\n        {name: 'usFirstCharIndex', type: 'USHORT', value: 0},\n        {name: 'usLastCharIndex', type: 'USHORT', value: 0},\n        {name: 'sTypoAscender', type: 'SHORT', value: 0},\n        {name: 'sTypoDescender', type: 'SHORT', value: 0},\n        {name: 'sTypoLineGap', type: 'SHORT', value: 0},\n        {name: 'usWinAscent', type: 'USHORT', value: 0},\n        {name: 'usWinDescent', type: 'USHORT', value: 0},\n        {name: 'ulCodePageRange1', type: 'ULONG', value: 0},\n        {name: 'ulCodePageRange2', type: 'ULONG', value: 0},\n        {name: 'sxHeight', type: 'SHORT', value: 0},\n        {name: 'sCapHeight', type: 'SHORT', value: 0},\n        {name: 'usDefaultChar', type: 'USHORT', value: 0},\n        {name: 'usBreakChar', type: 'USHORT', value: 0},\n        {name: 'usMaxContext', type: 'USHORT', value: 0}\n    ], options);\n}\n\n/* harmony default export */ var tables_os2 = ({ parse: parseOS2Table, make: makeOS2Table, unicodeRanges, getUnicodeRange });\n\n// CONCATENATED MODULE: ./node_modules/opentype.js/src/tables/post.js\n// The `post` table stores additional PostScript information, such as glyph names.\n// https://www.microsoft.com/typography/OTSPEC/post.htm\n\n\n\n\n\n// Parse the PostScript `post` table\nfunction parsePostTable(data, start) {\n    const post = {};\n    const p = new src_parse.Parser(data, start);\n    post.version = p.parseVersion();\n    post.italicAngle = p.parseFixed();\n    post.underlinePosition = p.parseShort();\n    post.underlineThickness = p.parseShort();\n    post.isFixedPitch = p.parseULong();\n    post.minMemType42 = p.parseULong();\n    post.maxMemType42 = p.parseULong();\n    post.minMemType1 = p.parseULong();\n    post.maxMemType1 = p.parseULong();\n    switch (post.version) {\n        case 1:\n            post.names = standardNames.slice();\n            break;\n        case 2:\n            post.numberOfGlyphs = p.parseUShort();\n            post.glyphNameIndex = new Array(post.numberOfGlyphs);\n            for (let i = 0; i < post.numberOfGlyphs; i++) {\n                post.glyphNameIndex[i] = p.parseUShort();\n            }\n\n            post.names = [];\n            for (let i = 0; i < post.numberOfGlyphs; i++) {\n                if (post.glyphNameIndex[i] >= standardNames.length) {\n                    const nameLength = p.parseChar();\n                    post.names.push(p.parseString(nameLength));\n                }\n            }\n\n            break;\n        case 2.5:\n            post.numberOfGlyphs = p.parseUShort();\n            post.offset = new Array(post.numberOfGlyphs);\n            for (let i = 0; i < post.numberOfGlyphs; i++) {\n                post.offset[i] = p.parseChar();\n            }\n\n            break;\n    }\n    return post;\n}\n\nfunction makePostTable() {\n    return new src_table.Table('post', [\n        {name: 'version', type: 'FIXED', value: 0x00030000},\n        {name: 'italicAngle', type: 'FIXED', value: 0},\n        {name: 'underlinePosition', type: 'FWORD', value: 0},\n        {name: 'underlineThickness', type: 'FWORD', value: 0},\n        {name: 'isFixedPitch', type: 'ULONG', value: 0},\n        {name: 'minMemType42', type: 'ULONG', value: 0},\n        {name: 'maxMemType42', type: 'ULONG', value: 0},\n        {name: 'minMemType1', type: 'ULONG', value: 0},\n        {name: 'maxMemType1', type: 'ULONG', value: 0}\n    ]);\n}\n\n/* harmony default export */ var tables_post = ({ parse: parsePostTable, make: makePostTable });\n\n// CONCATENATED MODULE: ./node_modules/opentype.js/src/tables/gsub.js\n// The `GSUB` table contains ligatures, among other things.\n// https://www.microsoft.com/typography/OTSPEC/gsub.htm\n\n\n\n\n\nconst subtableParsers = new Array(9);         // subtableParsers[0] is unused\n\n// https://www.microsoft.com/typography/OTSPEC/GSUB.htm#SS\nsubtableParsers[1] = function parseLookup1() {\n    const start = this.offset + this.relativeOffset;\n    const substFormat = this.parseUShort();\n    if (substFormat === 1) {\n        return {\n            substFormat: 1,\n            coverage: this.parsePointer(Parser.coverage),\n            deltaGlyphId: this.parseUShort()\n        };\n    } else if (substFormat === 2) {\n        return {\n            substFormat: 2,\n            coverage: this.parsePointer(Parser.coverage),\n            substitute: this.parseOffset16List()\n        };\n    }\n    check.assert(false, '0x' + start.toString(16) + ': lookup type 1 format must be 1 or 2.');\n};\n\n// https://www.microsoft.com/typography/OTSPEC/GSUB.htm#MS\nsubtableParsers[2] = function parseLookup2() {\n    const substFormat = this.parseUShort();\n    check.argument(substFormat === 1, 'GSUB Multiple Substitution Subtable identifier-format must be 1');\n    return {\n        substFormat: substFormat,\n        coverage: this.parsePointer(Parser.coverage),\n        sequences: this.parseListOfLists()\n    };\n};\n\n// https://www.microsoft.com/typography/OTSPEC/GSUB.htm#AS\nsubtableParsers[3] = function parseLookup3() {\n    const substFormat = this.parseUShort();\n    check.argument(substFormat === 1, 'GSUB Alternate Substitution Subtable identifier-format must be 1');\n    return {\n        substFormat: substFormat,\n        coverage: this.parsePointer(Parser.coverage),\n        alternateSets: this.parseListOfLists()\n    };\n};\n\n// https://www.microsoft.com/typography/OTSPEC/GSUB.htm#LS\nsubtableParsers[4] = function parseLookup4() {\n    const substFormat = this.parseUShort();\n    check.argument(substFormat === 1, 'GSUB ligature table identifier-format must be 1');\n    return {\n        substFormat: substFormat,\n        coverage: this.parsePointer(Parser.coverage),\n        ligatureSets: this.parseListOfLists(function() {\n            return {\n                ligGlyph: this.parseUShort(),\n                components: this.parseUShortList(this.parseUShort() - 1)\n            };\n        })\n    };\n};\n\nconst lookupRecordDesc = {\n    sequenceIndex: Parser.uShort,\n    lookupListIndex: Parser.uShort\n};\n\n// https://www.microsoft.com/typography/OTSPEC/GSUB.htm#CSF\nsubtableParsers[5] = function parseLookup5() {\n    const start = this.offset + this.relativeOffset;\n    const substFormat = this.parseUShort();\n\n    if (substFormat === 1) {\n        return {\n            substFormat: substFormat,\n            coverage: this.parsePointer(Parser.coverage),\n            ruleSets: this.parseListOfLists(function() {\n                const glyphCount = this.parseUShort();\n                const substCount = this.parseUShort();\n                return {\n                    input: this.parseUShortList(glyphCount - 1),\n                    lookupRecords: this.parseRecordList(substCount, lookupRecordDesc)\n                };\n            })\n        };\n    } else if (substFormat === 2) {\n        return {\n            substFormat: substFormat,\n            coverage: this.parsePointer(Parser.coverage),\n            classDef: this.parsePointer(Parser.classDef),\n            classSets: this.parseListOfLists(function() {\n                const glyphCount = this.parseUShort();\n                const substCount = this.parseUShort();\n                return {\n                    classes: this.parseUShortList(glyphCount - 1),\n                    lookupRecords: this.parseRecordList(substCount, lookupRecordDesc)\n                };\n            })\n        };\n    } else if (substFormat === 3) {\n        const glyphCount = this.parseUShort();\n        const substCount = this.parseUShort();\n        return {\n            substFormat: substFormat,\n            coverages: this.parseList(glyphCount, Parser.pointer(Parser.coverage)),\n            lookupRecords: this.parseRecordList(substCount, lookupRecordDesc)\n        };\n    }\n    check.assert(false, '0x' + start.toString(16) + ': lookup type 5 format must be 1, 2 or 3.');\n};\n\n// https://www.microsoft.com/typography/OTSPEC/GSUB.htm#CC\nsubtableParsers[6] = function parseLookup6() {\n    const start = this.offset + this.relativeOffset;\n    const substFormat = this.parseUShort();\n    if (substFormat === 1) {\n        return {\n            substFormat: 1,\n            coverage: this.parsePointer(Parser.coverage),\n            chainRuleSets: this.parseListOfLists(function() {\n                return {\n                    backtrack: this.parseUShortList(),\n                    input: this.parseUShortList(this.parseShort() - 1),\n                    lookahead: this.parseUShortList(),\n                    lookupRecords: this.parseRecordList(lookupRecordDesc)\n                };\n            })\n        };\n    } else if (substFormat === 2) {\n        return {\n            substFormat: 2,\n            coverage: this.parsePointer(Parser.coverage),\n            backtrackClassDef: this.parsePointer(Parser.classDef),\n            inputClassDef: this.parsePointer(Parser.classDef),\n            lookaheadClassDef: this.parsePointer(Parser.classDef),\n            chainClassSet: this.parseListOfLists(function() {\n                return {\n                    backtrack: this.parseUShortList(),\n                    input: this.parseUShortList(this.parseShort() - 1),\n                    lookahead: this.parseUShortList(),\n                    lookupRecords: this.parseRecordList(lookupRecordDesc)\n                };\n            })\n        };\n    } else if (substFormat === 3) {\n        return {\n            substFormat: 3,\n            backtrackCoverage: this.parseList(Parser.pointer(Parser.coverage)),\n            inputCoverage: this.parseList(Parser.pointer(Parser.coverage)),\n            lookaheadCoverage: this.parseList(Parser.pointer(Parser.coverage)),\n            lookupRecords: this.parseRecordList(lookupRecordDesc)\n        };\n    }\n    check.assert(false, '0x' + start.toString(16) + ': lookup type 6 format must be 1, 2 or 3.');\n};\n\n// https://www.microsoft.com/typography/OTSPEC/GSUB.htm#ES\nsubtableParsers[7] = function parseLookup7() {\n    // Extension Substitution subtable\n    const substFormat = this.parseUShort();\n    check.argument(substFormat === 1, 'GSUB Extension Substitution subtable identifier-format must be 1');\n    const extensionLookupType = this.parseUShort();\n    const extensionParser = new Parser(this.data, this.offset + this.parseULong());\n    return {\n        substFormat: 1,\n        lookupType: extensionLookupType,\n        extension: subtableParsers[extensionLookupType].call(extensionParser)\n    };\n};\n\n// https://www.microsoft.com/typography/OTSPEC/GSUB.htm#RCCS\nsubtableParsers[8] = function parseLookup8() {\n    const substFormat = this.parseUShort();\n    check.argument(substFormat === 1, 'GSUB Reverse Chaining Contextual Single Substitution Subtable identifier-format must be 1');\n    return {\n        substFormat: substFormat,\n        coverage: this.parsePointer(Parser.coverage),\n        backtrackCoverage: this.parseList(Parser.pointer(Parser.coverage)),\n        lookaheadCoverage: this.parseList(Parser.pointer(Parser.coverage)),\n        substitutes: this.parseUShortList()\n    };\n};\n\n// https://www.microsoft.com/typography/OTSPEC/gsub.htm\nfunction parseGsubTable(data, start) {\n    start = start || 0;\n    const p = new Parser(data, start);\n    const tableVersion = p.parseVersion();\n    check.argument(tableVersion === 1, 'Unsupported GSUB table version.');\n    return {\n        version: tableVersion,\n        scripts: p.parseScriptList(),\n        features: p.parseFeatureList(),\n        lookups: p.parseLookupList(subtableParsers)\n    };\n}\n\n// GSUB Writing //////////////////////////////////////////////\nconst gsub_subtableMakers = new Array(9);\n\ngsub_subtableMakers[1] = function makeLookup1(subtable) {\n    if (subtable.substFormat === 1) {\n        return new src_table.Table('substitutionTable', [\n            {name: 'substFormat', type: 'USHORT', value: 1},\n            {name: 'coverage', type: 'TABLE', value: new src_table.Coverage(subtable.coverage)},\n            {name: 'deltaGlyphID', type: 'USHORT', value: subtable.deltaGlyphId}\n        ]);\n    } else {\n        return new src_table.Table('substitutionTable', [\n            {name: 'substFormat', type: 'USHORT', value: 2},\n            {name: 'coverage', type: 'TABLE', value: new src_table.Coverage(subtable.coverage)}\n        ].concat(src_table.ushortList('substitute', subtable.substitute)));\n    }\n    check.fail('Lookup type 1 substFormat must be 1 or 2.');\n};\n\ngsub_subtableMakers[3] = function makeLookup3(subtable) {\n    check.assert(subtable.substFormat === 1, 'Lookup type 3 substFormat must be 1.');\n    return new src_table.Table('substitutionTable', [\n        {name: 'substFormat', type: 'USHORT', value: 1},\n        {name: 'coverage', type: 'TABLE', value: new src_table.Coverage(subtable.coverage)}\n    ].concat(src_table.tableList('altSet', subtable.alternateSets, function(alternateSet) {\n        return new src_table.Table('alternateSetTable', src_table.ushortList('alternate', alternateSet));\n    })));\n};\n\ngsub_subtableMakers[4] = function makeLookup4(subtable) {\n    check.assert(subtable.substFormat === 1, 'Lookup type 4 substFormat must be 1.');\n    return new src_table.Table('substitutionTable', [\n        {name: 'substFormat', type: 'USHORT', value: 1},\n        {name: 'coverage', type: 'TABLE', value: new src_table.Coverage(subtable.coverage)}\n    ].concat(src_table.tableList('ligSet', subtable.ligatureSets, function(ligatureSet) {\n        return new src_table.Table('ligatureSetTable', src_table.tableList('ligature', ligatureSet, function(ligature) {\n            return new src_table.Table('ligatureTable',\n                [{name: 'ligGlyph', type: 'USHORT', value: ligature.ligGlyph}]\n                .concat(src_table.ushortList('component', ligature.components, ligature.components.length + 1))\n            );\n        }));\n    })));\n};\n\nfunction makeGsubTable(gsub) {\n    return new src_table.Table('GSUB', [\n        {name: 'version', type: 'ULONG', value: 0x10000},\n        {name: 'scripts', type: 'TABLE', value: new src_table.ScriptList(gsub.scripts)},\n        {name: 'features', type: 'TABLE', value: new src_table.FeatureList(gsub.features)},\n        {name: 'lookups', type: 'TABLE', value: new src_table.LookupList(gsub.lookups, gsub_subtableMakers)}\n    ]);\n}\n\n/* harmony default export */ var tables_gsub = ({ parse: parseGsubTable, make: makeGsubTable });\n\n// CONCATENATED MODULE: ./node_modules/opentype.js/src/tables/meta.js\n// The `GPOS` table contains kerning pairs, among other things.\n// https://www.microsoft.com/typography/OTSPEC/gpos.htm\n\n\n\n\n\n\n// Parse the metadata `meta` table.\n// https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6meta.html\nfunction parseMetaTable(data, start) {\n    const p = new src_parse.Parser(data, start);\n    const tableVersion = p.parseULong();\n    check.argument(tableVersion === 1, 'Unsupported META table version.');\n    p.parseULong(); // flags - currently unused and set to 0\n    p.parseULong(); // tableOffset\n    const numDataMaps = p.parseULong();\n\n    const tags = {};\n    for (let i = 0; i < numDataMaps; i++) {\n        const tag = p.parseTag();\n        const dataOffset = p.parseULong();\n        const dataLength = p.parseULong();\n        const text = decode.UTF8(data, start + dataOffset, dataLength);\n\n        tags[tag] = text;\n    }\n    return tags;\n}\n\nfunction makeMetaTable(tags) {\n    const numTags = Object.keys(tags).length;\n    let stringPool = '';\n    const stringPoolOffset = 16 + numTags * 12;\n\n    const result = new src_table.Table('meta', [\n        {name: 'version', type: 'ULONG', value: 1},\n        {name: 'flags', type: 'ULONG', value: 0},\n        {name: 'offset', type: 'ULONG', value: stringPoolOffset},\n        {name: 'numTags', type: 'ULONG', value: numTags}\n    ]);\n\n    for (let tag in tags) {\n        const pos = stringPool.length;\n        stringPool += tags[tag];\n\n        result.fields.push({name: 'tag ' + tag, type: 'TAG', value: tag});\n        result.fields.push({name: 'offset ' + tag, type: 'ULONG', value: stringPoolOffset + pos});\n        result.fields.push({name: 'length ' + tag, type: 'ULONG', value: tags[tag].length});\n    }\n\n    result.fields.push({name: 'stringPool', type: 'CHARARRAY', value: stringPool});\n\n    return result;\n}\n\n/* harmony default export */ var meta = ({ parse: parseMetaTable, make: makeMetaTable });\n\n// CONCATENATED MODULE: ./node_modules/opentype.js/src/tables/sfnt.js\n// The `sfnt` wrapper provides organization for the tables in the font.\n// It is the top-level data structure in a font.\n// https://www.microsoft.com/typography/OTSPEC/otff.htm\n// Recommendations for creating OpenType Fonts:\n// http://www.microsoft.com/typography/otspec140/recom.htm\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction log2(v) {\n    return Math.log(v) / Math.log(2) | 0;\n}\n\nfunction computeCheckSum(bytes) {\n    while (bytes.length % 4 !== 0) {\n        bytes.push(0);\n    }\n\n    let sum = 0;\n    for (let i = 0; i < bytes.length; i += 4) {\n        sum += (bytes[i] << 24) +\n            (bytes[i + 1] << 16) +\n            (bytes[i + 2] << 8) +\n            (bytes[i + 3]);\n    }\n\n    sum %= Math.pow(2, 32);\n    return sum;\n}\n\nfunction makeTableRecord(tag, checkSum, offset, length) {\n    return new src_table.Record('Table Record', [\n        {name: 'tag', type: 'TAG', value: tag !== undefined ? tag : ''},\n        {name: 'checkSum', type: 'ULONG', value: checkSum !== undefined ? checkSum : 0},\n        {name: 'offset', type: 'ULONG', value: offset !== undefined ? offset : 0},\n        {name: 'length', type: 'ULONG', value: length !== undefined ? length : 0}\n    ]);\n}\n\nfunction makeSfntTable(tables) {\n    const sfnt = new src_table.Table('sfnt', [\n        {name: 'version', type: 'TAG', value: 'OTTO'},\n        {name: 'numTables', type: 'USHORT', value: 0},\n        {name: 'searchRange', type: 'USHORT', value: 0},\n        {name: 'entrySelector', type: 'USHORT', value: 0},\n        {name: 'rangeShift', type: 'USHORT', value: 0}\n    ]);\n    sfnt.tables = tables;\n    sfnt.numTables = tables.length;\n    const highestPowerOf2 = Math.pow(2, log2(sfnt.numTables));\n    sfnt.searchRange = 16 * highestPowerOf2;\n    sfnt.entrySelector = log2(highestPowerOf2);\n    sfnt.rangeShift = sfnt.numTables * 16 - sfnt.searchRange;\n\n    const recordFields = [];\n    const tableFields = [];\n\n    let offset = sfnt.sizeOf() + (makeTableRecord().sizeOf() * sfnt.numTables);\n    while (offset % 4 !== 0) {\n        offset += 1;\n        tableFields.push({name: 'padding', type: 'BYTE', value: 0});\n    }\n\n    for (let i = 0; i < tables.length; i += 1) {\n        const t = tables[i];\n        check.argument(t.tableName.length === 4, 'Table name' + t.tableName + ' is invalid.');\n        const tableLength = t.sizeOf();\n        const tableRecord = makeTableRecord(t.tableName, computeCheckSum(t.encode()), offset, tableLength);\n        recordFields.push({name: tableRecord.tag + ' Table Record', type: 'RECORD', value: tableRecord});\n        tableFields.push({name: t.tableName + ' table', type: 'RECORD', value: t});\n        offset += tableLength;\n        check.argument(!isNaN(offset), 'Something went wrong calculating the offset.');\n        while (offset % 4 !== 0) {\n            offset += 1;\n            tableFields.push({name: 'padding', type: 'BYTE', value: 0});\n        }\n    }\n\n    // Table records need to be sorted alphabetically.\n    recordFields.sort(function(r1, r2) {\n        if (r1.value.tag > r2.value.tag) {\n            return 1;\n        } else {\n            return -1;\n        }\n    });\n\n    sfnt.fields = sfnt.fields.concat(recordFields);\n    sfnt.fields = sfnt.fields.concat(tableFields);\n    return sfnt;\n}\n\n// Get the metrics for a character. If the string has more than one character\n// this function returns metrics for the first available character.\n// You can provide optional fallback metrics if no characters are available.\nfunction metricsForChar(font, chars, notFoundMetrics) {\n    for (let i = 0; i < chars.length; i += 1) {\n        const glyphIndex = font.charToGlyphIndex(chars[i]);\n        if (glyphIndex > 0) {\n            const glyph = font.glyphs.get(glyphIndex);\n            return glyph.getMetrics();\n        }\n    }\n\n    return notFoundMetrics;\n}\n\nfunction average(vs) {\n    let sum = 0;\n    for (let i = 0; i < vs.length; i += 1) {\n        sum += vs[i];\n    }\n\n    return sum / vs.length;\n}\n\n// Convert the font object to a SFNT data structure.\n// This structure contains all the necessary tables and metadata to create a binary OTF file.\nfunction fontToSfntTable(font) {\n    const xMins = [];\n    const yMins = [];\n    const xMaxs = [];\n    const yMaxs = [];\n    const advanceWidths = [];\n    const leftSideBearings = [];\n    const rightSideBearings = [];\n    let firstCharIndex;\n    let lastCharIndex = 0;\n    let ulUnicodeRange1 = 0;\n    let ulUnicodeRange2 = 0;\n    let ulUnicodeRange3 = 0;\n    let ulUnicodeRange4 = 0;\n\n    for (let i = 0; i < font.glyphs.length; i += 1) {\n        const glyph = font.glyphs.get(i);\n        const unicode = glyph.unicode | 0;\n\n        if (isNaN(glyph.advanceWidth)) {\n            throw new Error('Glyph ' + glyph.name + ' (' + i + '): advanceWidth is not a number.');\n        }\n\n        if (firstCharIndex > unicode || firstCharIndex === undefined) {\n            // ignore .notdef char\n            if (unicode > 0) {\n                firstCharIndex = unicode;\n            }\n        }\n\n        if (lastCharIndex < unicode) {\n            lastCharIndex = unicode;\n        }\n\n        const position = tables_os2.getUnicodeRange(unicode);\n        if (position < 32) {\n            ulUnicodeRange1 |= 1 << position;\n        } else if (position < 64) {\n            ulUnicodeRange2 |= 1 << position - 32;\n        } else if (position < 96) {\n            ulUnicodeRange3 |= 1 << position - 64;\n        } else if (position < 123) {\n            ulUnicodeRange4 |= 1 << position - 96;\n        } else {\n            throw new Error('Unicode ranges bits > 123 are reserved for internal usage');\n        }\n        // Skip non-important characters.\n        if (glyph.name === '.notdef') continue;\n        const metrics = glyph.getMetrics();\n        xMins.push(metrics.xMin);\n        yMins.push(metrics.yMin);\n        xMaxs.push(metrics.xMax);\n        yMaxs.push(metrics.yMax);\n        leftSideBearings.push(metrics.leftSideBearing);\n        rightSideBearings.push(metrics.rightSideBearing);\n        advanceWidths.push(glyph.advanceWidth);\n    }\n\n    const globals = {\n        xMin: Math.min.apply(null, xMins),\n        yMin: Math.min.apply(null, yMins),\n        xMax: Math.max.apply(null, xMaxs),\n        yMax: Math.max.apply(null, yMaxs),\n        advanceWidthMax: Math.max.apply(null, advanceWidths),\n        advanceWidthAvg: average(advanceWidths),\n        minLeftSideBearing: Math.min.apply(null, leftSideBearings),\n        maxLeftSideBearing: Math.max.apply(null, leftSideBearings),\n        minRightSideBearing: Math.min.apply(null, rightSideBearings)\n    };\n    globals.ascender = font.ascender;\n    globals.descender = font.descender;\n\n    const headTable = tables_head.make({\n        flags: 3, // 00000011 (baseline for font at y=0; left sidebearing point at x=0)\n        unitsPerEm: font.unitsPerEm,\n        xMin: globals.xMin,\n        yMin: globals.yMin,\n        xMax: globals.xMax,\n        yMax: globals.yMax,\n        lowestRecPPEM: 3,\n        createdTimestamp: font.createdTimestamp\n    });\n\n    const hheaTable = tables_hhea.make({\n        ascender: globals.ascender,\n        descender: globals.descender,\n        advanceWidthMax: globals.advanceWidthMax,\n        minLeftSideBearing: globals.minLeftSideBearing,\n        minRightSideBearing: globals.minRightSideBearing,\n        xMaxExtent: globals.maxLeftSideBearing + (globals.xMax - globals.xMin),\n        numberOfHMetrics: font.glyphs.length\n    });\n\n    const maxpTable = tables_maxp.make(font.glyphs.length);\n\n    const os2Table = tables_os2.make({\n        xAvgCharWidth: Math.round(globals.advanceWidthAvg),\n        usWeightClass: font.tables.os2.usWeightClass,\n        usWidthClass: font.tables.os2.usWidthClass,\n        usFirstCharIndex: firstCharIndex,\n        usLastCharIndex: lastCharIndex,\n        ulUnicodeRange1: ulUnicodeRange1,\n        ulUnicodeRange2: ulUnicodeRange2,\n        ulUnicodeRange3: ulUnicodeRange3,\n        ulUnicodeRange4: ulUnicodeRange4,\n        fsSelection: font.tables.os2.fsSelection, // REGULAR\n        // See http://typophile.com/node/13081 for more info on vertical metrics.\n        // We get metrics for typical characters (such as \"x\" for xHeight).\n        // We provide some fallback characters if characters are unavailable: their\n        // ordering was chosen experimentally.\n        sTypoAscender: globals.ascender,\n        sTypoDescender: globals.descender,\n        sTypoLineGap: 0,\n        usWinAscent: globals.yMax,\n        usWinDescent: Math.abs(globals.yMin),\n        ulCodePageRange1: 1, // FIXME: hard-code Latin 1 support for now\n        sxHeight: metricsForChar(font, 'xyvw', {yMax: Math.round(globals.ascender / 2)}).yMax,\n        sCapHeight: metricsForChar(font, 'HIKLEFJMNTZBDPRAGOQSUVWXY', globals).yMax,\n        usDefaultChar: font.hasChar(' ') ? 32 : 0, // Use space as the default character, if available.\n        usBreakChar: font.hasChar(' ') ? 32 : 0 // Use space as the break character, if available.\n    });\n\n    const hmtxTable = hmtx.make(font.glyphs);\n    const cmapTable = tables_cmap.make(font.glyphs);\n\n    const englishFamilyName = font.getEnglishName('fontFamily');\n    const englishStyleName = font.getEnglishName('fontSubfamily');\n    const englishFullName = englishFamilyName + ' ' + englishStyleName;\n    let postScriptName = font.getEnglishName('postScriptName');\n    if (!postScriptName) {\n        postScriptName = englishFamilyName.replace(/\\s/g, '') + '-' + englishStyleName;\n    }\n\n    const names = {};\n    for (let n in font.names) {\n        names[n] = font.names[n];\n    }\n\n    if (!names.uniqueID) {\n        names.uniqueID = {en: font.getEnglishName('manufacturer') + ':' + englishFullName};\n    }\n\n    if (!names.postScriptName) {\n        names.postScriptName = {en: postScriptName};\n    }\n\n    if (!names.preferredFamily) {\n        names.preferredFamily = font.names.fontFamily;\n    }\n\n    if (!names.preferredSubfamily) {\n        names.preferredSubfamily = font.names.fontSubfamily;\n    }\n\n    const languageTags = [];\n    const nameTable = tables_name.make(names, languageTags);\n    const ltagTable = (languageTags.length > 0 ? tables_ltag.make(languageTags) : undefined);\n\n    const postTable = tables_post.make();\n    const cffTable = cff.make(font.glyphs, {\n        version: font.getEnglishName('version'),\n        fullName: englishFullName,\n        familyName: englishFamilyName,\n        weightName: englishStyleName,\n        postScriptName: postScriptName,\n        unitsPerEm: font.unitsPerEm,\n        fontBBox: [0, globals.yMin, globals.ascender, globals.advanceWidthMax]\n    });\n\n    const metaTable = (font.metas && Object.keys(font.metas).length > 0) ? meta.make(font.metas) : undefined;\n\n    // The order does not matter because makeSfntTable() will sort them.\n    const tables = [headTable, hheaTable, maxpTable, os2Table, nameTable, cmapTable, postTable, cffTable, hmtxTable];\n    if (ltagTable) {\n        tables.push(ltagTable);\n    }\n    // Optional tables\n    if (font.tables.gsub) {\n        tables.push(tables_gsub.make(font.tables.gsub));\n    }\n    if (metaTable) {\n        tables.push(metaTable);\n    }\n\n    const sfntTable = makeSfntTable(tables);\n\n    // Compute the font's checkSum and store it in head.checkSumAdjustment.\n    const bytes = sfntTable.encode();\n    const checkSum = computeCheckSum(bytes);\n    const tableFields = sfntTable.fields;\n    let checkSumAdjusted = false;\n    for (let i = 0; i < tableFields.length; i += 1) {\n        if (tableFields[i].name === 'head table') {\n            tableFields[i].value.checkSumAdjustment = 0xB1B0AFBA - checkSum;\n            checkSumAdjusted = true;\n            break;\n        }\n    }\n\n    if (!checkSumAdjusted) {\n        throw new Error('Could not find head table with checkSum to adjust.');\n    }\n\n    return sfntTable;\n}\n\n/* harmony default export */ var tables_sfnt = ({ make: makeSfntTable, fontToTable: fontToSfntTable, computeCheckSum });\n\n// CONCATENATED MODULE: ./node_modules/opentype.js/src/layout.js\n// The Layout object is the prototype of Substitution objects, and provides\n// utility methods to manipulate common layout tables (GPOS, GSUB, GDEF...)\n\n\n\nfunction searchTag(arr, tag) {\n    /* jshint bitwise: false */\n    let imin = 0;\n    let imax = arr.length - 1;\n    while (imin <= imax) {\n        const imid = (imin + imax) >>> 1;\n        const val = arr[imid].tag;\n        if (val === tag) {\n            return imid;\n        } else if (val < tag) {\n            imin = imid + 1;\n        } else { imax = imid - 1; }\n    }\n    // Not found: return -1-insertion point\n    return -imin - 1;\n}\n\nfunction binSearch(arr, value) {\n    /* jshint bitwise: false */\n    let imin = 0;\n    let imax = arr.length - 1;\n    while (imin <= imax) {\n        const imid = (imin + imax) >>> 1;\n        const val = arr[imid];\n        if (val === value) {\n            return imid;\n        } else if (val < value) {\n            imin = imid + 1;\n        } else { imax = imid - 1; }\n    }\n    // Not found: return -1-insertion point\n    return -imin - 1;\n}\n\n/**\n * @exports opentype.Layout\n * @class\n */\nfunction Layout(font, tableName) {\n    this.font = font;\n    this.tableName = tableName;\n}\n\nLayout.prototype = {\n\n    /**\n     * Binary search an object by \"tag\" property\n     * @instance\n     * @function searchTag\n     * @memberof opentype.Layout\n     * @param  {Array} arr\n     * @param  {string} tag\n     * @return {number}\n     */\n    searchTag: searchTag,\n\n    /**\n     * Binary search in a list of numbers\n     * @instance\n     * @function binSearch\n     * @memberof opentype.Layout\n     * @param  {Array} arr\n     * @param  {number} value\n     * @return {number}\n     */\n    binSearch: binSearch,\n\n    /**\n     * Get or create the Layout table (GSUB, GPOS etc).\n     * @param  {boolean} create - Whether to create a new one.\n     * @return {Object} The GSUB or GPOS table.\n     */\n    getTable: function(create) {\n        let layout = this.font.tables[this.tableName];\n        if (!layout && create) {\n            layout = this.font.tables[this.tableName] = this.createDefaultTable();\n        }\n        return layout;\n    },\n\n    /**\n     * Returns all scripts in the substitution table.\n     * @instance\n     * @return {Array}\n     */\n    getScriptNames: function() {\n        let layout = this.getTable();\n        if (!layout) { return []; }\n        return layout.scripts.map(function(script) {\n            return script.tag;\n        });\n    },\n\n    /**\n     * Returns the best bet for a script name.\n     * Returns 'DFLT' if it exists.\n     * If not, returns 'latn' if it exists.\n     * If neither exist, returns undefined.\n     */\n    getDefaultScriptName: function() {\n        let layout = this.getTable();\n        if (!layout) { return; }\n        let hasLatn = false;\n        for (let i = 0; i < layout.scripts.length; i++) {\n            const name = layout.scripts[i].tag;\n            if (name === 'DFLT') return name;\n            if (name === 'latn') hasLatn = true;\n        }\n        if (hasLatn) return 'latn';\n    },\n\n    /**\n     * Returns all LangSysRecords in the given script.\n     * @instance\n     * @param {string} [script='DFLT']\n     * @param {boolean} create - forces the creation of this script table if it doesn't exist.\n     * @return {Object} An object with tag and script properties.\n     */\n    getScriptTable: function(script, create) {\n        const layout = this.getTable(create);\n        if (layout) {\n            script = script || 'DFLT';\n            const scripts = layout.scripts;\n            const pos = searchTag(layout.scripts, script);\n            if (pos >= 0) {\n                return scripts[pos].script;\n            } else if (create) {\n                const scr = {\n                    tag: script,\n                    script: {\n                        defaultLangSys: {reserved: 0, reqFeatureIndex: 0xffff, featureIndexes: []},\n                        langSysRecords: []\n                    }\n                };\n                scripts.splice(-1 - pos, 0, scr);\n                return scr.script;\n            }\n        }\n    },\n\n    /**\n     * Returns a language system table\n     * @instance\n     * @param {string} [script='DFLT']\n     * @param {string} [language='dlft']\n     * @param {boolean} create - forces the creation of this langSysTable if it doesn't exist.\n     * @return {Object}\n     */\n    getLangSysTable: function(script, language, create) {\n        const scriptTable = this.getScriptTable(script, create);\n        if (scriptTable) {\n            if (!language || language === 'dflt' || language === 'DFLT') {\n                return scriptTable.defaultLangSys;\n            }\n            const pos = searchTag(scriptTable.langSysRecords, language);\n            if (pos >= 0) {\n                return scriptTable.langSysRecords[pos].langSys;\n            } else if (create) {\n                const langSysRecord = {\n                    tag: language,\n                    langSys: {reserved: 0, reqFeatureIndex: 0xffff, featureIndexes: []}\n                };\n                scriptTable.langSysRecords.splice(-1 - pos, 0, langSysRecord);\n                return langSysRecord.langSys;\n            }\n        }\n    },\n\n    /**\n     * Get a specific feature table.\n     * @instance\n     * @param {string} [script='DFLT']\n     * @param {string} [language='dlft']\n     * @param {string} feature - One of the codes listed at https://www.microsoft.com/typography/OTSPEC/featurelist.htm\n     * @param {boolean} create - forces the creation of the feature table if it doesn't exist.\n     * @return {Object}\n     */\n    getFeatureTable: function(script, language, feature, create) {\n        const langSysTable = this.getLangSysTable(script, language, create);\n        if (langSysTable) {\n            let featureRecord;\n            const featIndexes = langSysTable.featureIndexes;\n            const allFeatures = this.font.tables[this.tableName].features;\n            // The FeatureIndex array of indices is in arbitrary order,\n            // even if allFeatures is sorted alphabetically by feature tag.\n            for (let i = 0; i < featIndexes.length; i++) {\n                featureRecord = allFeatures[featIndexes[i]];\n                if (featureRecord.tag === feature) {\n                    return featureRecord.feature;\n                }\n            }\n            if (create) {\n                const index = allFeatures.length;\n                // Automatic ordering of features would require to shift feature indexes in the script list.\n                check.assert(index === 0 || feature >= allFeatures[index - 1].tag, 'Features must be added in alphabetical order.');\n                featureRecord = {\n                    tag: feature,\n                    feature: { params: 0, lookupListIndexes: [] }\n                };\n                allFeatures.push(featureRecord);\n                featIndexes.push(index);\n                return featureRecord.feature;\n            }\n        }\n    },\n\n    /**\n     * Get the lookup tables of a given type for a script/language/feature.\n     * @instance\n     * @param {string} [script='DFLT']\n     * @param {string} [language='dlft']\n     * @param {string} feature - 4-letter feature code\n     * @param {number} lookupType - 1 to 8\n     * @param {boolean} create - forces the creation of the lookup table if it doesn't exist, with no subtables.\n     * @return {Object[]}\n     */\n    getLookupTables: function(script, language, feature, lookupType, create) {\n        const featureTable = this.getFeatureTable(script, language, feature, create);\n        const tables = [];\n        if (featureTable) {\n            let lookupTable;\n            const lookupListIndexes = featureTable.lookupListIndexes;\n            const allLookups = this.font.tables[this.tableName].lookups;\n            // lookupListIndexes are in no particular order, so use naive search.\n            for (let i = 0; i < lookupListIndexes.length; i++) {\n                lookupTable = allLookups[lookupListIndexes[i]];\n                if (lookupTable.lookupType === lookupType) {\n                    tables.push(lookupTable);\n                }\n            }\n            if (tables.length === 0 && create) {\n                lookupTable = {\n                    lookupType: lookupType,\n                    lookupFlag: 0,\n                    subtables: [],\n                    markFilteringSet: undefined\n                };\n                const index = allLookups.length;\n                allLookups.push(lookupTable);\n                lookupListIndexes.push(index);\n                return [lookupTable];\n            }\n        }\n        return tables;\n    },\n\n    /**\n     * Returns the list of glyph indexes of a coverage table.\n     * Format 1: the list is stored raw\n     * Format 2: compact list as range records.\n     * @instance\n     * @param  {Object} coverageTable\n     * @return {Array}\n     */\n    expandCoverage: function(coverageTable) {\n        if (coverageTable.format === 1) {\n            return coverageTable.glyphs;\n        } else {\n            const glyphs = [];\n            const ranges = coverageTable.ranges;\n            for (let i = 0; i < ranges.length; i++) {\n                const range = ranges[i];\n                const start = range.start;\n                const end = range.end;\n                for (let j = start; j <= end; j++) {\n                    glyphs.push(j);\n                }\n            }\n            return glyphs;\n        }\n    }\n\n};\n\n/* harmony default export */ var layout = (Layout);\n\n// CONCATENATED MODULE: ./node_modules/opentype.js/src/substitution.js\n// The Substitution object provides utility methods to manipulate\n// the GSUB substitution table.\n\n\n\n\n/**\n * @exports opentype.Substitution\n * @class\n * @extends opentype.Layout\n * @param {opentype.Font}\n * @constructor\n */\nfunction Substitution(font) {\n    layout.call(this, font, 'gsub');\n}\n\n// Check if 2 arrays of primitives are equal.\nfunction arraysEqual(ar1, ar2) {\n    const n = ar1.length;\n    if (n !== ar2.length) { return false; }\n    for (let i = 0; i < n; i++) {\n        if (ar1[i] !== ar2[i]) { return false; }\n    }\n    return true;\n}\n\n// Find the first subtable of a lookup table in a particular format.\nfunction getSubstFormat(lookupTable, format, defaultSubtable) {\n    const subtables = lookupTable.subtables;\n    for (let i = 0; i < subtables.length; i++) {\n        const subtable = subtables[i];\n        if (subtable.substFormat === format) {\n            return subtable;\n        }\n    }\n    if (defaultSubtable) {\n        subtables.push(defaultSubtable);\n        return defaultSubtable;\n    }\n    return undefined;\n}\n\nSubstitution.prototype = layout.prototype;\n\n/**\n * Create a default GSUB table.\n * @return {Object} gsub - The GSUB table.\n */\nSubstitution.prototype.createDefaultTable = function() {\n    // Generate a default empty GSUB table with just a DFLT script and dflt lang sys.\n    return {\n        version: 1,\n        scripts: [{\n            tag: 'DFLT',\n            script: {\n                defaultLangSys: { reserved: 0, reqFeatureIndex: 0xffff, featureIndexes: [] },\n                langSysRecords: []\n            }\n        }],\n        features: [],\n        lookups: []\n    };\n};\n\n/**\n * List all single substitutions (lookup type 1) for a given script, language, and feature.\n * @param {string} [script='DFLT']\n * @param {string} [language='dflt']\n * @param {string} feature - 4-character feature name ('aalt', 'salt', 'ss01'...)\n * @return {Array} substitutions - The list of substitutions.\n */\nSubstitution.prototype.getSingle = function(feature, script, language) {\n    const substitutions = [];\n    const lookupTables = this.getLookupTables(script, language, feature, 1);\n    for (let idx = 0; idx < lookupTables.length; idx++) {\n        const subtables = lookupTables[idx].subtables;\n        for (let i = 0; i < subtables.length; i++) {\n            const subtable = subtables[i];\n            const glyphs = this.expandCoverage(subtable.coverage);\n            let j;\n            if (subtable.substFormat === 1) {\n                const delta = subtable.deltaGlyphId;\n                for (j = 0; j < glyphs.length; j++) {\n                    const glyph = glyphs[j];\n                    substitutions.push({ sub: glyph, by: glyph + delta });\n                }\n            } else {\n                const substitute = subtable.substitute;\n                for (j = 0; j < glyphs.length; j++) {\n                    substitutions.push({ sub: glyphs[j], by: substitute[j] });\n                }\n            }\n        }\n    }\n    return substitutions;\n};\n\n/**\n * List all alternates (lookup type 3) for a given script, language, and feature.\n * @param {string} [script='DFLT']\n * @param {string} [language='dflt']\n * @param {string} feature - 4-character feature name ('aalt', 'salt'...)\n * @return {Array} alternates - The list of alternates\n */\nSubstitution.prototype.getAlternates = function(feature, script, language) {\n    const alternates = [];\n    const lookupTables = this.getLookupTables(script, language, feature, 3);\n    for (let idx = 0; idx < lookupTables.length; idx++) {\n        const subtables = lookupTables[idx].subtables;\n        for (let i = 0; i < subtables.length; i++) {\n            const subtable = subtables[i];\n            const glyphs = this.expandCoverage(subtable.coverage);\n            const alternateSets = subtable.alternateSets;\n            for (let j = 0; j < glyphs.length; j++) {\n                alternates.push({ sub: glyphs[j], by: alternateSets[j] });\n            }\n        }\n    }\n    return alternates;\n};\n\n/**\n * List all ligatures (lookup type 4) for a given script, language, and feature.\n * The result is an array of ligature objects like { sub: [ids], by: id }\n * @param {string} feature - 4-letter feature name ('liga', 'rlig', 'dlig'...)\n * @param {string} [script='DFLT']\n * @param {string} [language='dflt']\n * @return {Array} ligatures - The list of ligatures.\n */\nSubstitution.prototype.getLigatures = function(feature, script, language) {\n    const ligatures = [];\n    const lookupTables = this.getLookupTables(script, language, feature, 4);\n    for (let idx = 0; idx < lookupTables.length; idx++) {\n        const subtables = lookupTables[idx].subtables;\n        for (let i = 0; i < subtables.length; i++) {\n            const subtable = subtables[i];\n            const glyphs = this.expandCoverage(subtable.coverage);\n            const ligatureSets = subtable.ligatureSets;\n            for (let j = 0; j < glyphs.length; j++) {\n                const startGlyph = glyphs[j];\n                const ligSet = ligatureSets[j];\n                for (let k = 0; k < ligSet.length; k++) {\n                    const lig = ligSet[k];\n                    ligatures.push({\n                        sub: [startGlyph].concat(lig.components),\n                        by: lig.ligGlyph\n                    });\n                }\n            }\n        }\n    }\n    return ligatures;\n};\n\n/**\n * Add or modify a single substitution (lookup type 1)\n * Format 2, more flexible, is always used.\n * @param {string} feature - 4-letter feature name ('liga', 'rlig', 'dlig'...)\n * @param {Object} substitution - { sub: id, delta: number } for format 1 or { sub: id, by: id } for format 2.\n * @param {string} [script='DFLT']\n * @param {string} [language='dflt']\n */\nSubstitution.prototype.addSingle = function(feature, substitution, script, language) {\n    const lookupTable = this.getLookupTables(script, language, feature, 1, true)[0];\n    const subtable = getSubstFormat(lookupTable, 2, {                // lookup type 1 subtable, format 2, coverage format 1\n        substFormat: 2,\n        coverage: {format: 1, glyphs: []},\n        substitute: []\n    });\n    check.assert(subtable.coverage.format === 1, 'Ligature: unable to modify coverage table format ' + subtable.coverage.format);\n    const coverageGlyph = substitution.sub;\n    let pos = this.binSearch(subtable.coverage.glyphs, coverageGlyph);\n    if (pos < 0) {\n        pos = -1 - pos;\n        subtable.coverage.glyphs.splice(pos, 0, coverageGlyph);\n        subtable.substitute.splice(pos, 0, 0);\n    }\n    subtable.substitute[pos] = substitution.by;\n};\n\n/**\n * Add or modify an alternate substitution (lookup type 1)\n * @param {string} feature - 4-letter feature name ('liga', 'rlig', 'dlig'...)\n * @param {Object} substitution - { sub: id, by: [ids] }\n * @param {string} [script='DFLT']\n * @param {string} [language='dflt']\n */\nSubstitution.prototype.addAlternate = function(feature, substitution, script, language) {\n    const lookupTable = this.getLookupTables(script, language, feature, 3, true)[0];\n    const subtable = getSubstFormat(lookupTable, 1, {                // lookup type 3 subtable, format 1, coverage format 1\n        substFormat: 1,\n        coverage: {format: 1, glyphs: []},\n        alternateSets: []\n    });\n    check.assert(subtable.coverage.format === 1, 'Ligature: unable to modify coverage table format ' + subtable.coverage.format);\n    const coverageGlyph = substitution.sub;\n    let pos = this.binSearch(subtable.coverage.glyphs, coverageGlyph);\n    if (pos < 0) {\n        pos = -1 - pos;\n        subtable.coverage.glyphs.splice(pos, 0, coverageGlyph);\n        subtable.alternateSets.splice(pos, 0, 0);\n    }\n    subtable.alternateSets[pos] = substitution.by;\n};\n\n/**\n * Add a ligature (lookup type 4)\n * Ligatures with more components must be stored ahead of those with fewer components in order to be found\n * @param {string} feature - 4-letter feature name ('liga', 'rlig', 'dlig'...)\n * @param {Object} ligature - { sub: [ids], by: id }\n * @param {string} [script='DFLT']\n * @param {string} [language='dflt']\n */\nSubstitution.prototype.addLigature = function(feature, ligature, script, language) {\n    const lookupTable = this.getLookupTables(script, language, feature, 4, true)[0];\n    let subtable = lookupTable.subtables[0];\n    if (!subtable) {\n        subtable = {                // lookup type 4 subtable, format 1, coverage format 1\n            substFormat: 1,\n            coverage: { format: 1, glyphs: [] },\n            ligatureSets: []\n        };\n        lookupTable.subtables[0] = subtable;\n    }\n    check.assert(subtable.coverage.format === 1, 'Ligature: unable to modify coverage table format ' + subtable.coverage.format);\n    const coverageGlyph = ligature.sub[0];\n    const ligComponents = ligature.sub.slice(1);\n    const ligatureTable = {\n        ligGlyph: ligature.by,\n        components: ligComponents\n    };\n    let pos = this.binSearch(subtable.coverage.glyphs, coverageGlyph);\n    if (pos >= 0) {\n        // ligatureSet already exists\n        const ligatureSet = subtable.ligatureSets[pos];\n        for (let i = 0; i < ligatureSet.length; i++) {\n            // If ligature already exists, return.\n            if (arraysEqual(ligatureSet[i].components, ligComponents)) {\n                return;\n            }\n        }\n        // ligature does not exist: add it.\n        ligatureSet.push(ligatureTable);\n    } else {\n        // Create a new ligatureSet and add coverage for the first glyph.\n        pos = -1 - pos;\n        subtable.coverage.glyphs.splice(pos, 0, coverageGlyph);\n        subtable.ligatureSets.splice(pos, 0, [ligatureTable]);\n    }\n};\n\n/**\n * List all feature data for a given script and language.\n * @param {string} feature - 4-letter feature name\n * @param {string} [script='DFLT']\n * @param {string} [language='dflt']\n * @return {Array} substitutions - The list of substitutions.\n */\nSubstitution.prototype.getFeature = function(feature, script, language) {\n    if (/ss\\d\\d/.test(feature)) {               // ss01 - ss20\n        return this.getSingle(feature, script, language);\n    }\n    switch (feature) {\n        case 'aalt':\n        case 'salt':\n            return this.getSingle(feature, script, language)\n                    .concat(this.getAlternates(feature, script, language));\n        case 'dlig':\n        case 'liga':\n        case 'rlig': return this.getLigatures(feature, script, language);\n    }\n    return undefined;\n};\n\n/**\n * Add a substitution to a feature for a given script and language.\n * @param {string} feature - 4-letter feature name\n * @param {Object} sub - the substitution to add (an object like { sub: id or [ids], by: id or [ids] })\n * @param {string} [script='DFLT']\n * @param {string} [language='dflt']\n */\nSubstitution.prototype.add = function(feature, sub, script, language) {\n    if (/ss\\d\\d/.test(feature)) {               // ss01 - ss20\n        return this.addSingle(feature, sub, script, language);\n    }\n    switch (feature) {\n        case 'aalt':\n        case 'salt':\n            if (typeof sub.by === 'number') {\n                return this.addSingle(feature, sub, script, language);\n            }\n            return this.addAlternate(feature, sub, script, language);\n        case 'dlig':\n        case 'liga':\n        case 'rlig':\n            return this.addLigature(feature, sub, script, language);\n    }\n    return undefined;\n};\n\n/* harmony default export */ var src_substitution = (Substitution);\n\n// EXTERNAL MODULE: ./node_modules/opentype.js/src/util.js\nvar util = __webpack_require__(0);\n\n// CONCATENATED MODULE: ./node_modules/opentype.js/src/hintingtt.js\n/* A TrueType font hinting interpreter.\n*\n* (c) 2017 Axel Kittenberger\n*\n* This interpreter has been implemented according to this documentation:\n* https://developer.apple.com/fonts/TrueType-Reference-Manual/RM05/Chap5.html\n*\n* According to the documentation F24DOT6 values are used for pixels.\n* That means calculation is 1/64 pixel accurate and uses integer operations.\n* However, Javascript has floating point operations by default and only\n* those are available. One could make a case to simulate the 1/64 accuracy\n* exactly by truncating after every division operation\n* (for example with << 0) to get pixel exactly results as other TrueType\n* implementations. It may make sense since some fonts are pixel optimized\n* by hand using DELTAP instructions. The current implementation doesn't\n* and rather uses full floating point precision.\n*\n* xScale, yScale and rotation is currently ignored.\n*\n* A few non-trivial instructions are missing as I didn't encounter yet\n* a font that used them to test a possible implementation.\n*\n* Some fonts seem to use undocumented features regarding the twilight zone.\n* Only some of them are implemented as they were encountered.\n*\n* The exports.DEBUG statements are removed on the minified distribution file.\n*/\n\n\nlet instructionTable;\nlet exec;\nlet execGlyph;\nlet execComponent;\n\n/*\n* Creates a hinting object.\n*\n* There ought to be exactly one\n* for each truetype font that is used for hinting.\n*/\nfunction Hinting(font) {\n    // the font this hinting object is for\n    this.font = font;\n\n    // cached states\n    this._fpgmState  =\n    this._prepState  =\n        undefined;\n\n    // errorState\n    // 0 ... all okay\n    // 1 ... had an error in a glyf,\n    //       continue working but stop spamming\n    //       the console\n    // 2 ... error at prep, stop hinting at this ppem\n    // 3 ... error at fpeg, stop hinting for this font at all\n    this._errorState = 0;\n}\n\n/*\n* Not rounding.\n*/\nfunction roundOff(v) {\n    return v;\n}\n\n/*\n* Rounding to grid.\n*/\nfunction roundToGrid(v) {\n    //Rounding in TT is supposed to \"symmetrical around zero\"\n    return Math.sign(v) * Math.round(Math.abs(v));\n}\n\n/*\n* Rounding to double grid.\n*/\nfunction roundToDoubleGrid(v) {\n    return Math.sign(v) * Math.round(Math.abs(v * 2)) / 2;\n}\n\n/*\n* Rounding to half grid.\n*/\nfunction roundToHalfGrid(v) {\n    return Math.sign(v) * (Math.round(Math.abs(v) + 0.5) - 0.5);\n}\n\n/*\n* Rounding to up to grid.\n*/\nfunction roundUpToGrid(v) {\n    return Math.sign(v) * Math.ceil(Math.abs(v));\n}\n\n/*\n* Rounding to down to grid.\n*/\nfunction roundDownToGrid(v) {\n    return Math.sign(v) * Math.floor(Math.abs(v));\n}\n\n/*\n* Super rounding.\n*/\nconst roundSuper = function (v) {\n    const period = this.srPeriod;\n    let phase = this.srPhase;\n    const threshold = this.srThreshold;\n    let sign = 1;\n\n    if (v < 0) {\n        v = -v;\n        sign = -1;\n    }\n\n    v += threshold - phase;\n\n    v = Math.trunc(v / period) * period;\n\n    v += phase;\n\n    // according to http://xgridfit.sourceforge.net/round.html\n    if (sign > 0 && v < 0) return phase;\n    if (sign < 0 && v > 0) return -phase;\n\n    return v * sign;\n};\n\n/*\n* Unit vector of x-axis.\n*/\nconst xUnitVector = {\n    x: 1,\n\n    y: 0,\n\n    axis: 'x',\n\n    // Gets the projected distance between two points.\n    // o1/o2 ... if true, respective original position is used.\n    distance: function (p1, p2, o1, o2) {\n        return (o1 ? p1.xo : p1.x) - (o2 ? p2.xo : p2.x);\n    },\n\n    // Moves point p so the moved position has the same relative\n    // position to the moved positions of rp1 and rp2 than the\n    // original positions had.\n    //\n    // See APPENDIX on INTERPOLATE at the bottom of this file.\n    interpolate: function (p, rp1, rp2, pv) {\n        let do1;\n        let do2;\n        let doa1;\n        let doa2;\n        let dm1;\n        let dm2;\n        let dt;\n\n        if (!pv || pv === this) {\n            do1 = p.xo - rp1.xo;\n            do2 = p.xo - rp2.xo;\n            dm1 = rp1.x - rp1.xo;\n            dm2 = rp2.x - rp2.xo;\n            doa1 = Math.abs(do1);\n            doa2 = Math.abs(do2);\n            dt = doa1 + doa2;\n\n            if (dt === 0) {\n                p.x = p.xo + (dm1 + dm2) / 2;\n                return;\n            }\n\n            p.x = p.xo + (dm1 * doa2 + dm2 * doa1) / dt;\n            return;\n        }\n\n        do1 = pv.distance(p, rp1, true, true);\n        do2 = pv.distance(p, rp2, true, true);\n        dm1 = pv.distance(rp1, rp1, false, true);\n        dm2 = pv.distance(rp2, rp2, false, true);\n        doa1 = Math.abs(do1);\n        doa2 = Math.abs(do2);\n        dt = doa1 + doa2;\n\n        if (dt === 0) {\n            xUnitVector.setRelative(p, p, (dm1 + dm2) / 2, pv, true);\n            return;\n        }\n\n        xUnitVector.setRelative(p, p, (dm1 * doa2 + dm2 * doa1) / dt, pv, true);\n    },\n\n    // Slope of line normal to this\n    normalSlope: Number.NEGATIVE_INFINITY,\n\n    // Sets the point 'p' relative to point 'rp'\n    // by the distance 'd'.\n    //\n    // See APPENDIX on SETRELATIVE at the bottom of this file.\n    //\n    // p   ... point to set\n    // rp  ... reference point\n    // d   ... distance on projection vector\n    // pv  ... projection vector (undefined = this)\n    // org ... if true, uses the original position of rp as reference.\n    setRelative: function (p, rp, d, pv, org) {\n        if (!pv || pv === this) {\n            p.x = (org ? rp.xo : rp.x) + d;\n            return;\n        }\n\n        const rpx = org ? rp.xo : rp.x;\n        const rpy = org ? rp.yo : rp.y;\n        const rpdx = rpx + d * pv.x;\n        const rpdy = rpy + d * pv.y;\n\n        p.x = rpdx + (p.y - rpdy) / pv.normalSlope;\n    },\n\n    // Slope of vector line.\n    slope: 0,\n\n    // Touches the point p.\n    touch: function (p) {\n        p.xTouched = true;\n    },\n\n    // Tests if a point p is touched.\n    touched: function (p) {\n        return p.xTouched;\n    },\n\n    // Untouches the point p.\n    untouch: function (p) {\n        p.xTouched = false;\n    }\n};\n\n/*\n* Unit vector of y-axis.\n*/\nconst yUnitVector = {\n    x: 0,\n\n    y: 1,\n\n    axis: 'y',\n\n    // Gets the projected distance between two points.\n    // o1/o2 ... if true, respective original position is used.\n    distance: function (p1, p2, o1, o2) {\n        return (o1 ? p1.yo : p1.y) - (o2 ? p2.yo : p2.y);\n    },\n\n    // Moves point p so the moved position has the same relative\n    // position to the moved positions of rp1 and rp2 than the\n    // original positions had.\n    //\n    // See APPENDIX on INTERPOLATE at the bottom of this file.\n    interpolate: function (p, rp1, rp2, pv) {\n        let do1;\n        let do2;\n        let doa1;\n        let doa2;\n        let dm1;\n        let dm2;\n        let dt;\n\n        if (!pv || pv === this) {\n            do1 = p.yo - rp1.yo;\n            do2 = p.yo - rp2.yo;\n            dm1 = rp1.y - rp1.yo;\n            dm2 = rp2.y - rp2.yo;\n            doa1 = Math.abs(do1);\n            doa2 = Math.abs(do2);\n            dt = doa1 + doa2;\n\n            if (dt === 0) {\n                p.y = p.yo + (dm1 + dm2) / 2;\n                return;\n            }\n\n            p.y = p.yo + (dm1 * doa2 + dm2 * doa1) / dt;\n            return;\n        }\n\n        do1 = pv.distance(p, rp1, true, true);\n        do2 = pv.distance(p, rp2, true, true);\n        dm1 = pv.distance(rp1, rp1, false, true);\n        dm2 = pv.distance(rp2, rp2, false, true);\n        doa1 = Math.abs(do1);\n        doa2 = Math.abs(do2);\n        dt = doa1 + doa2;\n\n        if (dt === 0) {\n            yUnitVector.setRelative(p, p, (dm1 + dm2) / 2, pv, true);\n            return;\n        }\n\n        yUnitVector.setRelative(p, p, (dm1 * doa2 + dm2 * doa1) / dt, pv, true);\n    },\n\n    // Slope of line normal to this.\n    normalSlope: 0,\n\n    // Sets the point 'p' relative to point 'rp'\n    // by the distance 'd'\n    //\n    // See APPENDIX on SETRELATIVE at the bottom of this file.\n    //\n    // p   ... point to set\n    // rp  ... reference point\n    // d   ... distance on projection vector\n    // pv  ... projection vector (undefined = this)\n    // org ... if true, uses the original position of rp as reference.\n    setRelative: function (p, rp, d, pv, org) {\n        if (!pv || pv === this) {\n            p.y = (org ? rp.yo : rp.y) + d;\n            return;\n        }\n\n        const rpx = org ? rp.xo : rp.x;\n        const rpy = org ? rp.yo : rp.y;\n        const rpdx = rpx + d * pv.x;\n        const rpdy = rpy + d * pv.y;\n\n        p.y = rpdy + pv.normalSlope * (p.x - rpdx);\n    },\n\n    // Slope of vector line.\n    slope: Number.POSITIVE_INFINITY,\n\n    // Touches the point p.\n    touch: function (p) {\n        p.yTouched = true;\n    },\n\n    // Tests if a point p is touched.\n    touched: function (p) {\n        return p.yTouched;\n    },\n\n    // Untouches the point p.\n    untouch: function (p) {\n        p.yTouched = false;\n    }\n};\n\nObject.freeze(xUnitVector);\nObject.freeze(yUnitVector);\n\n/*\n* Creates a unit vector that is not x- or y-axis.\n*/\nfunction UnitVector(x, y) {\n    this.x = x;\n    this.y = y;\n    this.axis = undefined;\n    this.slope = y / x;\n    this.normalSlope = -x / y;\n    Object.freeze(this);\n}\n\n/*\n* Gets the projected distance between two points.\n* o1/o2 ... if true, respective original position is used.\n*/\nUnitVector.prototype.distance = function(p1, p2, o1, o2) {\n    return (\n        this.x * xUnitVector.distance(p1, p2, o1, o2) +\n        this.y * yUnitVector.distance(p1, p2, o1, o2)\n    );\n};\n\n/*\n* Moves point p so the moved position has the same relative\n* position to the moved positions of rp1 and rp2 than the\n* original positions had.\n*\n* See APPENDIX on INTERPOLATE at the bottom of this file.\n*/\nUnitVector.prototype.interpolate = function(p, rp1, rp2, pv) {\n    let dm1;\n    let dm2;\n    let do1;\n    let do2;\n    let doa1;\n    let doa2;\n    let dt;\n\n    do1 = pv.distance(p, rp1, true, true);\n    do2 = pv.distance(p, rp2, true, true);\n    dm1 = pv.distance(rp1, rp1, false, true);\n    dm2 = pv.distance(rp2, rp2, false, true);\n    doa1 = Math.abs(do1);\n    doa2 = Math.abs(do2);\n    dt = doa1 + doa2;\n\n    if (dt === 0) {\n        this.setRelative(p, p, (dm1 + dm2) / 2, pv, true);\n        return;\n    }\n\n    this.setRelative(p, p, (dm1 * doa2 + dm2 * doa1) / dt, pv, true);\n};\n\n/*\n* Sets the point 'p' relative to point 'rp'\n* by the distance 'd'\n*\n* See APPENDIX on SETRELATIVE at the bottom of this file.\n*\n* p   ...  point to set\n* rp  ... reference point\n* d   ... distance on projection vector\n* pv  ... projection vector (undefined = this)\n* org ... if true, uses the original position of rp as reference.\n*/\nUnitVector.prototype.setRelative = function(p, rp, d, pv, org) {\n    pv = pv || this;\n\n    const rpx = org ? rp.xo : rp.x;\n    const rpy = org ? rp.yo : rp.y;\n    const rpdx = rpx + d * pv.x;\n    const rpdy = rpy + d * pv.y;\n\n    const pvns = pv.normalSlope;\n    const fvs = this.slope;\n\n    const px = p.x;\n    const py = p.y;\n\n    p.x = (fvs * px - pvns * rpdx + rpdy - py) / (fvs - pvns);\n    p.y = fvs * (p.x - px) + py;\n};\n\n/*\n* Touches the point p.\n*/\nUnitVector.prototype.touch = function(p) {\n    p.xTouched = true;\n    p.yTouched = true;\n};\n\n/*\n* Returns a unit vector with x/y coordinates.\n*/\nfunction getUnitVector(x, y) {\n    const d = Math.sqrt(x * x + y * y);\n\n    x /= d;\n    y /= d;\n\n    if (x === 1 && y === 0) return xUnitVector;\n    else if (x === 0 && y === 1) return yUnitVector;\n    else return new UnitVector(x, y);\n}\n\n/*\n* Creates a point in the hinting engine.\n*/\nfunction HPoint(\n    x,\n    y,\n    lastPointOfContour,\n    onCurve\n) {\n    this.x = this.xo = Math.round(x * 64) / 64; // hinted x value and original x-value\n    this.y = this.yo = Math.round(y * 64) / 64; // hinted y value and original y-value\n\n    this.lastPointOfContour = lastPointOfContour;\n    this.onCurve = onCurve;\n    this.prevPointOnContour = undefined;\n    this.nextPointOnContour = undefined;\n    this.xTouched = false;\n    this.yTouched = false;\n\n    Object.preventExtensions(this);\n}\n\n/*\n* Returns the next touched point on the contour.\n*\n* v  ... unit vector to test touch axis.\n*/\nHPoint.prototype.nextTouched = function(v) {\n    let p = this.nextPointOnContour;\n\n    while (!v.touched(p) && p !== this) p = p.nextPointOnContour;\n\n    return p;\n};\n\n/*\n* Returns the previous touched point on the contour\n*\n* v  ... unit vector to test touch axis.\n*/\nHPoint.prototype.prevTouched = function(v) {\n    let p = this.prevPointOnContour;\n\n    while (!v.touched(p) && p !== this) p = p.prevPointOnContour;\n\n    return p;\n};\n\n/*\n* The zero point.\n*/\nconst HPZero = Object.freeze(new HPoint(0, 0));\n\n/*\n* The default state of the interpreter.\n*\n* Note: Freezing the defaultState and then deriving from it\n* makes the V8 Javascript engine going awkward,\n* so this is avoided, albeit the defaultState shouldn't\n* ever change.\n*/\nconst defaultState = {\n    cvCutIn: 17 / 16,    // control value cut in\n    deltaBase: 9,\n    deltaShift: 0.125,\n    loop: 1,             // loops some instructions\n    minDis: 1,           // minimum distance\n    autoFlip: true\n};\n\n/*\n* The current state of the interpreter.\n*\n* env  ... 'fpgm' or 'prep' or 'glyf'\n* prog ... the program\n*/\nfunction State(env, prog) {\n    this.env = env;\n    this.stack = [];\n    this.prog = prog;\n\n    switch (env) {\n        case 'glyf' :\n            this.zp0 = this.zp1 = this.zp2 = 1;\n            this.rp0 = this.rp1 = this.rp2 = 0;\n            /* fall through */\n        case 'prep' :\n            this.fv = this.pv = this.dpv = xUnitVector;\n            this.round = roundToGrid;\n    }\n}\n\n/*\n* Executes a glyph program.\n*\n* This does the hinting for each glyph.\n*\n* Returns an array of moved points.\n*\n* glyph: the glyph to hint\n* ppem: the size the glyph is rendered for\n*/\nHinting.prototype.exec = function(glyph, ppem) {\n    if (typeof ppem !== 'number') {\n        throw new Error('Point size is not a number!');\n    }\n\n    // Received a fatal error, don't do any hinting anymore.\n    if (this._errorState > 2) return;\n\n    const font = this.font;\n    let prepState = this._prepState;\n\n    if (!prepState || prepState.ppem !== ppem) {\n        let fpgmState = this._fpgmState;\n\n        if (!fpgmState) {\n            // Executes the fpgm state.\n            // This is used by fonts to define functions.\n            State.prototype = defaultState;\n\n            fpgmState =\n            this._fpgmState =\n                new State('fpgm', font.tables.fpgm);\n\n            fpgmState.funcs = [ ];\n            fpgmState.font = font;\n\n            if (exports.DEBUG) {\n                console.log('---EXEC FPGM---');\n                fpgmState.step = -1;\n            }\n\n            try {\n                exec(fpgmState);\n            } catch (e) {\n                console.log('Hinting error in FPGM:' + e);\n                this._errorState = 3;\n                return;\n            }\n        }\n\n        // Executes the prep program for this ppem setting.\n        // This is used by fonts to set cvt values\n        // depending on to be rendered font size.\n\n        State.prototype = fpgmState;\n        prepState =\n        this._prepState =\n            new State('prep', font.tables.prep);\n\n        prepState.ppem = ppem;\n\n        // Creates a copy of the cvt table\n        // and scales it to the current ppem setting.\n        const oCvt = font.tables.cvt;\n        if (oCvt) {\n            const cvt = prepState.cvt = new Array(oCvt.length);\n            const scale = ppem / font.unitsPerEm;\n            for (let c = 0; c < oCvt.length; c++) {\n                cvt[c] = oCvt[c] * scale;\n            }\n        } else {\n            prepState.cvt = [];\n        }\n\n        if (exports.DEBUG) {\n            console.log('---EXEC PREP---');\n            prepState.step = -1;\n        }\n\n        try {\n            exec(prepState);\n        } catch (e) {\n            if (this._errorState < 2) {\n                console.log('Hinting error in PREP:' + e);\n            }\n            this._errorState = 2;\n        }\n    }\n\n    if (this._errorState > 1) return;\n\n    try {\n        return execGlyph(glyph, prepState);\n    } catch (e) {\n        if (this._errorState < 1) {\n            console.log('Hinting error:' + e);\n            console.log('Note: further hinting errors are silenced');\n        }\n        this._errorState = 1;\n        return undefined;\n    }\n};\n\n/*\n* Executes the hinting program for a glyph.\n*/\nexecGlyph = function(glyph, prepState) {\n    // original point positions\n    const xScale = prepState.ppem / prepState.font.unitsPerEm;\n    const yScale = xScale;\n    let components = glyph.components;\n    let contours;\n    let gZone;\n    let state;\n\n    State.prototype = prepState;\n    if (!components) {\n        state = new State('glyf', glyph.instructions);\n        if (exports.DEBUG) {\n            console.log('---EXEC GLYPH---');\n            state.step = -1;\n        }\n        execComponent(glyph, state, xScale, yScale);\n        gZone = state.gZone;\n    } else {\n        const font = prepState.font;\n        gZone = [];\n        contours = [];\n        for (let i = 0; i < components.length; i++) {\n            const c = components[i];\n            const cg = font.glyphs.get(c.glyphIndex);\n\n            state = new State('glyf', cg.instructions);\n\n            if (exports.DEBUG) {\n                console.log('---EXEC COMP ' + i + '---');\n                state.step = -1;\n            }\n\n            execComponent(cg, state, xScale, yScale);\n            // appends the computed points to the result array\n            // post processes the component points\n            const dx = Math.round(c.dx * xScale);\n            const dy = Math.round(c.dy * yScale);\n            const gz = state.gZone;\n            const cc = state.contours;\n            for (let pi = 0; pi < gz.length; pi++) {\n                const p = gz[pi];\n                p.xTouched = p.yTouched = false;\n                p.xo = p.x = p.x + dx;\n                p.yo = p.y = p.y + dy;\n            }\n\n            const gLen = gZone.length;\n            gZone.push.apply(gZone, gz);\n            for (let j = 0; j < cc.length; j++) {\n                contours.push(cc[j] + gLen);\n            }\n        }\n\n        if (glyph.instructions && !state.inhibitGridFit) {\n            // the composite has instructions on its own\n            state = new State('glyf', glyph.instructions);\n\n            state.gZone = state.z0 = state.z1 = state.z2 = gZone;\n\n            state.contours = contours;\n\n            // note: HPZero cannot be used here, since\n            //       the point might be modified\n            gZone.push(\n                new HPoint(0, 0),\n                new HPoint(Math.round(glyph.advanceWidth * xScale), 0)\n            );\n\n            if (exports.DEBUG) {\n                console.log('---EXEC COMPOSITE---');\n                state.step = -1;\n            }\n\n            exec(state);\n\n            gZone.length -= 2;\n        }\n    }\n\n    return gZone;\n};\n\n/*\n* Executes the hinting program for a component of a multi-component glyph\n* or of the glyph itself by a non-component glyph.\n*/\nexecComponent = function(glyph, state, xScale, yScale)\n{\n    const points = glyph.points || [];\n    const pLen = points.length;\n    const gZone = state.gZone = state.z0 = state.z1 = state.z2 = [];\n    const contours = state.contours = [];\n\n    // Scales the original points and\n    // makes copies for the hinted points.\n    let cp; // current point\n    for (let i = 0; i < pLen; i++) {\n        cp = points[i];\n\n        gZone[i] = new HPoint(\n            cp.x * xScale,\n            cp.y * yScale,\n            cp.lastPointOfContour,\n            cp.onCurve\n        );\n    }\n\n    // Chain links the contours.\n    let sp; // start point\n    let np; // next point\n\n    for (let i = 0; i < pLen; i++) {\n        cp = gZone[i];\n\n        if (!sp) {\n            sp = cp;\n            contours.push(i);\n        }\n\n        if (cp.lastPointOfContour) {\n            cp.nextPointOnContour = sp;\n            sp.prevPointOnContour = cp;\n            sp = undefined;\n        } else {\n            np = gZone[i + 1];\n            cp.nextPointOnContour = np;\n            np.prevPointOnContour = cp;\n        }\n    }\n\n    if (state.inhibitGridFit) return;\n\n    gZone.push(\n        new HPoint(0, 0),\n        new HPoint(Math.round(glyph.advanceWidth * xScale), 0)\n    );\n\n    exec(state);\n\n    // Removes the extra points.\n    gZone.length -= 2;\n\n    if (exports.DEBUG) {\n        console.log('FINISHED GLYPH', state.stack);\n        for (let i = 0; i < pLen; i++) {\n            console.log(i, gZone[i].x, gZone[i].y);\n        }\n    }\n};\n\n/*\n* Executes the program loaded in state.\n*/\nexec = function(state) {\n    let prog = state.prog;\n\n    if (!prog) return;\n\n    const pLen = prog.length;\n    let ins;\n\n    for (state.ip = 0; state.ip < pLen; state.ip++) {\n        if (exports.DEBUG) state.step++;\n        ins = instructionTable[prog[state.ip]];\n\n        if (!ins) {\n            throw new Error(\n                'unknown instruction: 0x' +\n                Number(prog[state.ip]).toString(16)\n            );\n        }\n\n        ins(state);\n\n        // very extensive debugging for each step\n        /*\n        if (exports.DEBUG) {\n            var da;\n            if (state.gZone) {\n                da = [];\n                for (let i = 0; i < state.gZone.length; i++)\n                {\n                    da.push(i + ' ' +\n                        state.gZone[i].x * 64 + ' ' +\n                        state.gZone[i].y * 64 + ' ' +\n                        (state.gZone[i].xTouched ? 'x' : '') +\n                        (state.gZone[i].yTouched ? 'y' : '')\n                    );\n                }\n                console.log('GZ', da);\n            }\n\n            if (state.tZone) {\n                da = [];\n                for (let i = 0; i < state.tZone.length; i++) {\n                    da.push(i + ' ' +\n                        state.tZone[i].x * 64 + ' ' +\n                        state.tZone[i].y * 64 + ' ' +\n                        (state.tZone[i].xTouched ? 'x' : '') +\n                        (state.tZone[i].yTouched ? 'y' : '')\n                    );\n                }\n                console.log('TZ', da);\n            }\n\n            if (state.stack.length > 10) {\n                console.log(\n                    state.stack.length,\n                    '...', state.stack.slice(state.stack.length - 10)\n                );\n            } else {\n                console.log(state.stack.length, state.stack);\n            }\n        }\n        */\n    }\n};\n\n/*\n* Initializes the twilight zone.\n*\n* This is only done if a SZPx instruction\n* refers to the twilight zone.\n*/\nfunction initTZone(state)\n{\n    const tZone = state.tZone = new Array(state.gZone.length);\n\n    // no idea if this is actually correct...\n    for (let i = 0; i < tZone.length; i++)\n    {\n        tZone[i] = new HPoint(0, 0);\n    }\n}\n\n/*\n* Skips the instruction pointer ahead over an IF/ELSE block.\n* handleElse .. if true breaks on matching ELSE\n*/\nfunction skip(state, handleElse)\n{\n    const prog = state.prog;\n    let ip = state.ip;\n    let nesting = 1;\n    let ins;\n\n    do {\n        ins = prog[++ip];\n        if (ins === 0x58) // IF\n            nesting++;\n        else if (ins === 0x59) // EIF\n            nesting--;\n        else if (ins === 0x40) // NPUSHB\n            ip += prog[ip + 1] + 1;\n        else if (ins === 0x41) // NPUSHW\n            ip += 2 * prog[ip + 1] + 1;\n        else if (ins >= 0xB0 && ins <= 0xB7) // PUSHB\n            ip += ins - 0xB0 + 1;\n        else if (ins >= 0xB8 && ins <= 0xBF) // PUSHW\n            ip += (ins - 0xB8 + 1) * 2;\n        else if (handleElse && nesting === 1 && ins === 0x1B) // ELSE\n            break;\n    } while (nesting > 0);\n\n    state.ip = ip;\n}\n\n/*----------------------------------------------------------*\n*          And then a lot of instructions...                *\n*----------------------------------------------------------*/\n\n// SVTCA[a] Set freedom and projection Vectors To Coordinate Axis\n// 0x00-0x01\nfunction SVTCA(v, state) {\n    if (exports.DEBUG) console.log(state.step, 'SVTCA[' + v.axis + ']');\n\n    state.fv = state.pv = state.dpv = v;\n}\n\n// SPVTCA[a] Set Projection Vector to Coordinate Axis\n// 0x02-0x03\nfunction SPVTCA(v, state) {\n    if (exports.DEBUG) console.log(state.step, 'SPVTCA[' + v.axis + ']');\n\n    state.pv = state.dpv = v;\n}\n\n// SFVTCA[a] Set Freedom Vector to Coordinate Axis\n// 0x04-0x05\nfunction SFVTCA(v, state) {\n    if (exports.DEBUG) console.log(state.step, 'SFVTCA[' + v.axis + ']');\n\n    state.fv = v;\n}\n\n// SPVTL[a] Set Projection Vector To Line\n// 0x06-0x07\nfunction SPVTL(a, state) {\n    const stack = state.stack;\n    const p2i = stack.pop();\n    const p1i = stack.pop();\n    const p2 = state.z2[p2i];\n    const p1 = state.z1[p1i];\n\n    if (exports.DEBUG) console.log('SPVTL[' + a + ']', p2i, p1i);\n\n    let dx;\n    let dy;\n\n    if (!a) {\n        dx = p1.x - p2.x;\n        dy = p1.y - p2.y;\n    } else {\n        dx = p2.y - p1.y;\n        dy = p1.x - p2.x;\n    }\n\n    state.pv = state.dpv = getUnitVector(dx, dy);\n}\n\n// SFVTL[a] Set Freedom Vector To Line\n// 0x08-0x09\nfunction SFVTL(a, state) {\n    const stack = state.stack;\n    const p2i = stack.pop();\n    const p1i = stack.pop();\n    const p2 = state.z2[p2i];\n    const p1 = state.z1[p1i];\n\n    if (exports.DEBUG) console.log('SFVTL[' + a + ']', p2i, p1i);\n\n    let dx;\n    let dy;\n\n    if (!a) {\n        dx = p1.x - p2.x;\n        dy = p1.y - p2.y;\n    } else {\n        dx = p2.y - p1.y;\n        dy = p1.x - p2.x;\n    }\n\n    state.fv = getUnitVector(dx, dy);\n}\n\n// SPVFS[] Set Projection Vector From Stack\n// 0x0A\nfunction SPVFS(state) {\n    const stack = state.stack;\n    const y = stack.pop();\n    const x = stack.pop();\n\n    if (exports.DEBUG) console.log(state.step, 'SPVFS[]', y, x);\n\n    state.pv = state.dpv = getUnitVector(x, y);\n}\n\n// SFVFS[] Set Freedom Vector From Stack\n// 0x0B\nfunction SFVFS(state) {\n    const stack = state.stack;\n    const y = stack.pop();\n    const x = stack.pop();\n\n    if (exports.DEBUG) console.log(state.step, 'SPVFS[]', y, x);\n\n    state.fv = getUnitVector(x, y);\n}\n\n// GPV[] Get Projection Vector\n// 0x0C\nfunction GPV(state) {\n    const stack = state.stack;\n    const pv = state.pv;\n\n    if (exports.DEBUG) console.log(state.step, 'GPV[]');\n\n    stack.push(pv.x * 0x4000);\n    stack.push(pv.y * 0x4000);\n}\n\n// GFV[] Get Freedom Vector\n// 0x0C\nfunction GFV(state) {\n    const stack = state.stack;\n    const fv = state.fv;\n\n    if (exports.DEBUG) console.log(state.step, 'GFV[]');\n\n    stack.push(fv.x * 0x4000);\n    stack.push(fv.y * 0x4000);\n}\n\n// SFVTPV[] Set Freedom Vector To Projection Vector\n// 0x0E\nfunction SFVTPV(state) {\n    state.fv = state.pv;\n\n    if (exports.DEBUG) console.log(state.step, 'SFVTPV[]');\n}\n\n// ISECT[] moves point p to the InterSECTion of two lines\n// 0x0F\nfunction ISECT(state)\n{\n    const stack = state.stack;\n    const pa0i = stack.pop();\n    const pa1i = stack.pop();\n    const pb0i = stack.pop();\n    const pb1i = stack.pop();\n    const pi = stack.pop();\n    const z0 = state.z0;\n    const z1 = state.z1;\n    const pa0 = z0[pa0i];\n    const pa1 = z0[pa1i];\n    const pb0 = z1[pb0i];\n    const pb1 = z1[pb1i];\n    const p = state.z2[pi];\n\n    if (exports.DEBUG) console.log('ISECT[], ', pa0i, pa1i, pb0i, pb1i, pi);\n\n    // math from\n    // en.wikipedia.org/wiki/Line%E2%80%93line_intersection#Given_two_points_on_each_line\n\n    const x1 = pa0.x;\n    const y1 = pa0.y;\n    const x2 = pa1.x;\n    const y2 = pa1.y;\n    const x3 = pb0.x;\n    const y3 = pb0.y;\n    const x4 = pb1.x;\n    const y4 = pb1.y;\n\n    const div = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);\n    const f1 = x1 * y2 - y1 * x2;\n    const f2 = x3 * y4 - y3 * x4;\n\n    p.x = (f1 * (x3 - x4) - f2 * (x1 - x2)) / div;\n    p.y = (f1 * (y3 - y4) - f2 * (y1 - y2)) / div;\n}\n\n// SRP0[] Set Reference Point 0\n// 0x10\nfunction SRP0(state) {\n    state.rp0 = state.stack.pop();\n\n    if (exports.DEBUG) console.log(state.step, 'SRP0[]', state.rp0);\n}\n\n// SRP1[] Set Reference Point 1\n// 0x11\nfunction SRP1(state) {\n    state.rp1 = state.stack.pop();\n\n    if (exports.DEBUG) console.log(state.step, 'SRP1[]', state.rp1);\n}\n\n// SRP1[] Set Reference Point 2\n// 0x12\nfunction SRP2(state) {\n    state.rp2 = state.stack.pop();\n\n    if (exports.DEBUG) console.log(state.step, 'SRP2[]', state.rp2);\n}\n\n// SZP0[] Set Zone Pointer 0\n// 0x13\nfunction SZP0(state) {\n    const n = state.stack.pop();\n\n    if (exports.DEBUG) console.log(state.step, 'SZP0[]', n);\n\n    state.zp0 = n;\n\n    switch (n) {\n        case 0:\n            if (!state.tZone) initTZone(state);\n            state.z0 = state.tZone;\n            break;\n        case 1 :\n            state.z0 = state.gZone;\n            break;\n        default :\n            throw new Error('Invalid zone pointer');\n    }\n}\n\n// SZP1[] Set Zone Pointer 1\n// 0x14\nfunction SZP1(state) {\n    const n = state.stack.pop();\n\n    if (exports.DEBUG) console.log(state.step, 'SZP1[]', n);\n\n    state.zp1 = n;\n\n    switch (n) {\n        case 0:\n            if (!state.tZone) initTZone(state);\n            state.z1 = state.tZone;\n            break;\n        case 1 :\n            state.z1 = state.gZone;\n            break;\n        default :\n            throw new Error('Invalid zone pointer');\n    }\n}\n\n// SZP2[] Set Zone Pointer 2\n// 0x15\nfunction SZP2(state) {\n    const n = state.stack.pop();\n\n    if (exports.DEBUG) console.log(state.step, 'SZP2[]', n);\n\n    state.zp2 = n;\n\n    switch (n) {\n        case 0:\n            if (!state.tZone) initTZone(state);\n            state.z2 = state.tZone;\n            break;\n        case 1 :\n            state.z2 = state.gZone;\n            break;\n        default :\n            throw new Error('Invalid zone pointer');\n    }\n}\n\n// SZPS[] Set Zone PointerS\n// 0x16\nfunction SZPS(state) {\n    const n = state.stack.pop();\n\n    if (exports.DEBUG) console.log(state.step, 'SZPS[]', n);\n\n    state.zp0 = state.zp1 = state.zp2 = n;\n\n    switch (n) {\n        case 0:\n            if (!state.tZone) initTZone(state);\n            state.z0 = state.z1 = state.z2 = state.tZone;\n            break;\n        case 1 :\n            state.z0 = state.z1 = state.z2 = state.gZone;\n            break;\n        default :\n            throw new Error('Invalid zone pointer');\n    }\n}\n\n// SLOOP[] Set LOOP variable\n// 0x17\nfunction SLOOP(state) {\n    state.loop = state.stack.pop();\n\n    if (exports.DEBUG) console.log(state.step, 'SLOOP[]', state.loop);\n}\n\n// RTG[] Round To Grid\n// 0x18\nfunction RTG(state) {\n    if (exports.DEBUG) console.log(state.step, 'RTG[]');\n\n    state.round = roundToGrid;\n}\n\n// RTHG[] Round To Half Grid\n// 0x19\nfunction RTHG(state) {\n    if (exports.DEBUG) console.log(state.step, 'RTHG[]');\n\n    state.round = roundToHalfGrid;\n}\n\n// SMD[] Set Minimum Distance\n// 0x1A\nfunction SMD(state) {\n    const d = state.stack.pop();\n\n    if (exports.DEBUG) console.log(state.step, 'SMD[]', d);\n\n    state.minDis = d / 0x40;\n}\n\n// ELSE[] ELSE clause\n// 0x1B\nfunction ELSE(state) {\n    // This instruction has been reached by executing a then branch\n    // so it just skips ahead until matching EIF.\n    //\n    // In case the IF was negative the IF[] instruction already\n    // skipped forward over the ELSE[]\n\n    if (exports.DEBUG) console.log(state.step, 'ELSE[]');\n\n    skip(state, false);\n}\n\n// JMPR[] JuMP Relative\n// 0x1C\nfunction JMPR(state) {\n    const o = state.stack.pop();\n\n    if (exports.DEBUG) console.log(state.step, 'JMPR[]', o);\n\n    // A jump by 1 would do nothing.\n    state.ip += o - 1;\n}\n\n// SCVTCI[] Set Control Value Table Cut-In\n// 0x1D\nfunction SCVTCI(state) {\n    const n = state.stack.pop();\n\n    if (exports.DEBUG) console.log(state.step, 'SCVTCI[]', n);\n\n    state.cvCutIn = n / 0x40;\n}\n\n// DUP[] DUPlicate top stack element\n// 0x20\nfunction DUP(state) {\n    const stack = state.stack;\n\n    if (exports.DEBUG) console.log(state.step, 'DUP[]');\n\n    stack.push(stack[stack.length - 1]);\n}\n\n// POP[] POP top stack element\n// 0x21\nfunction POP(state) {\n    if (exports.DEBUG) console.log(state.step, 'POP[]');\n\n    state.stack.pop();\n}\n\n// CLEAR[] CLEAR the stack\n// 0x22\nfunction CLEAR(state) {\n    if (exports.DEBUG) console.log(state.step, 'CLEAR[]');\n\n    state.stack.length = 0;\n}\n\n// SWAP[] SWAP the top two elements on the stack\n// 0x23\nfunction SWAP(state) {\n    const stack = state.stack;\n\n    const a = stack.pop();\n    const b = stack.pop();\n\n    if (exports.DEBUG) console.log(state.step, 'SWAP[]');\n\n    stack.push(a);\n    stack.push(b);\n}\n\n// DEPTH[] DEPTH of the stack\n// 0x24\nfunction DEPTH(state) {\n    const stack = state.stack;\n\n    if (exports.DEBUG) console.log(state.step, 'DEPTH[]');\n\n    stack.push(stack.length);\n}\n\n// LOOPCALL[] LOOPCALL function\n// 0x2A\nfunction LOOPCALL(state) {\n    const stack = state.stack;\n    const fn = stack.pop();\n    const c = stack.pop();\n\n    if (exports.DEBUG) console.log(state.step, 'LOOPCALL[]', fn, c);\n\n    // saves callers program\n    const cip = state.ip;\n    const cprog = state.prog;\n\n    state.prog = state.funcs[fn];\n\n    // executes the function\n    for (let i = 0; i < c; i++) {\n        exec(state);\n\n        if (exports.DEBUG) console.log(\n            ++state.step,\n            i + 1 < c ? 'next loopcall' : 'done loopcall',\n            i\n        );\n    }\n\n    // restores the callers program\n    state.ip = cip;\n    state.prog = cprog;\n}\n\n// CALL[] CALL function\n// 0x2B\nfunction CALL(state) {\n    const fn = state.stack.pop();\n\n    if (exports.DEBUG) console.log(state.step, 'CALL[]', fn);\n\n    // saves callers program\n    const cip = state.ip;\n    const cprog = state.prog;\n\n    state.prog = state.funcs[fn];\n\n    // executes the function\n    exec(state);\n\n    // restores the callers program\n    state.ip = cip;\n    state.prog = cprog;\n\n    if (exports.DEBUG) console.log(++state.step, 'returning from', fn);\n}\n\n// CINDEX[] Copy the INDEXed element to the top of the stack\n// 0x25\nfunction CINDEX(state) {\n    const stack = state.stack;\n    const k = stack.pop();\n\n    if (exports.DEBUG) console.log(state.step, 'CINDEX[]', k);\n\n    // In case of k == 1, it copies the last element after popping\n    // thus stack.length - k.\n    stack.push(stack[stack.length - k]);\n}\n\n// MINDEX[] Move the INDEXed element to the top of the stack\n// 0x26\nfunction MINDEX(state) {\n    const stack = state.stack;\n    const k = stack.pop();\n\n    if (exports.DEBUG) console.log(state.step, 'MINDEX[]', k);\n\n    stack.push(stack.splice(stack.length - k, 1)[0]);\n}\n\n// FDEF[] Function DEFinition\n// 0x2C\nfunction FDEF(state) {\n    if (state.env !== 'fpgm') throw new Error('FDEF not allowed here');\n    const stack = state.stack;\n    const prog = state.prog;\n    let ip = state.ip;\n\n    const fn = stack.pop();\n    const ipBegin = ip;\n\n    if (exports.DEBUG) console.log(state.step, 'FDEF[]', fn);\n\n    while (prog[++ip] !== 0x2D);\n\n    state.ip = ip;\n    state.funcs[fn] = prog.slice(ipBegin + 1, ip);\n}\n\n// MDAP[a] Move Direct Absolute Point\n// 0x2E-0x2F\nfunction MDAP(round, state) {\n    const pi = state.stack.pop();\n    const p = state.z0[pi];\n    const fv = state.fv;\n    const pv = state.pv;\n\n    if (exports.DEBUG) console.log(state.step, 'MDAP[' + round + ']', pi);\n\n    let d = pv.distance(p, HPZero);\n\n    if (round) d = state.round(d);\n\n    fv.setRelative(p, HPZero, d, pv);\n    fv.touch(p);\n\n    state.rp0 = state.rp1 = pi;\n}\n\n// IUP[a] Interpolate Untouched Points through the outline\n// 0x30\nfunction IUP(v, state) {\n    const z2 = state.z2;\n    const pLen = z2.length - 2;\n    let cp;\n    let pp;\n    let np;\n\n    if (exports.DEBUG) console.log(state.step, 'IUP[' + v.axis + ']');\n\n    for (let i = 0; i < pLen; i++) {\n        cp = z2[i]; // current point\n\n        // if this point has been touched go on\n        if (v.touched(cp)) continue;\n\n        pp = cp.prevTouched(v);\n\n        // no point on the contour has been touched?\n        if (pp === cp) continue;\n\n        np = cp.nextTouched(v);\n\n        if (pp === np) {\n            // only one point on the contour has been touched\n            // so simply moves the point like that\n\n            v.setRelative(cp, cp, v.distance(pp, pp, false, true), v, true);\n        }\n\n        v.interpolate(cp, pp, np, v);\n    }\n}\n\n// SHP[] SHift Point using reference point\n// 0x32-0x33\nfunction SHP(a, state) {\n    const stack = state.stack;\n    const rpi = a ? state.rp1 : state.rp2;\n    const rp = (a ? state.z0 : state.z1)[rpi];\n    const fv = state.fv;\n    const pv = state.pv;\n    let loop = state.loop;\n    const z2 = state.z2;\n\n    while (loop--)\n    {\n        const pi = stack.pop();\n        const p = z2[pi];\n\n        const d = pv.distance(rp, rp, false, true);\n        fv.setRelative(p, p, d, pv);\n        fv.touch(p);\n\n        if (exports.DEBUG) {\n            console.log(\n                state.step,\n                (state.loop > 1 ?\n                   'loop ' + (state.loop - loop) + ': ' :\n                   ''\n                ) +\n                'SHP[' + (a ? 'rp1' : 'rp2') + ']', pi\n            );\n        }\n    }\n\n    state.loop = 1;\n}\n\n// SHC[] SHift Contour using reference point\n// 0x36-0x37\nfunction SHC(a, state) {\n    const stack = state.stack;\n    const rpi = a ? state.rp1 : state.rp2;\n    const rp = (a ? state.z0 : state.z1)[rpi];\n    const fv = state.fv;\n    const pv = state.pv;\n    const ci = stack.pop();\n    const sp = state.z2[state.contours[ci]];\n    let p = sp;\n\n    if (exports.DEBUG) console.log(state.step, 'SHC[' + a + ']', ci);\n\n    const d = pv.distance(rp, rp, false, true);\n\n    do {\n        if (p !== rp) fv.setRelative(p, p, d, pv);\n        p = p.nextPointOnContour;\n    } while (p !== sp);\n}\n\n// SHZ[] SHift Zone using reference point\n// 0x36-0x37\nfunction SHZ(a, state) {\n    const stack = state.stack;\n    const rpi = a ? state.rp1 : state.rp2;\n    const rp = (a ? state.z0 : state.z1)[rpi];\n    const fv = state.fv;\n    const pv = state.pv;\n\n    const e = stack.pop();\n\n    if (exports.DEBUG) console.log(state.step, 'SHZ[' + a + ']', e);\n\n    let z;\n    switch (e) {\n        case 0 : z = state.tZone; break;\n        case 1 : z = state.gZone; break;\n        default : throw new Error('Invalid zone');\n    }\n\n    let p;\n    const d = pv.distance(rp, rp, false, true);\n    const pLen = z.length - 2;\n    for (let i = 0; i < pLen; i++)\n    {\n        p = z[i];\n        if (p !== rp) fv.setRelative(p, p, d, pv);\n    }\n}\n\n// SHPIX[] SHift point by a PIXel amount\n// 0x38\nfunction SHPIX(state) {\n    const stack = state.stack;\n    let loop = state.loop;\n    const fv = state.fv;\n    const d = stack.pop() / 0x40;\n    const z2 = state.z2;\n\n    while (loop--) {\n        const pi = stack.pop();\n        const p = z2[pi];\n\n        if (exports.DEBUG) {\n            console.log(\n                state.step,\n                (state.loop > 1 ? 'loop ' + (state.loop - loop) + ': ' : '') +\n                'SHPIX[]', pi, d\n            );\n        }\n\n        fv.setRelative(p, p, d);\n        fv.touch(p);\n    }\n\n    state.loop = 1;\n}\n\n// IP[] Interpolate Point\n// 0x39\nfunction IP(state) {\n    const stack = state.stack;\n    const rp1i = state.rp1;\n    const rp2i = state.rp2;\n    let loop = state.loop;\n    const rp1 = state.z0[rp1i];\n    const rp2 = state.z1[rp2i];\n    const fv = state.fv;\n    const pv = state.dpv;\n    const z2 = state.z2;\n\n    while (loop--) {\n        const pi = stack.pop();\n        const p = z2[pi];\n\n        if (exports.DEBUG) {\n            console.log(\n                state.step,\n                (state.loop > 1 ? 'loop ' + (state.loop - loop) + ': ' : '') +\n                'IP[]', pi, rp1i, '<->', rp2i\n            );\n        }\n\n        fv.interpolate(p, rp1, rp2, pv);\n\n        fv.touch(p);\n    }\n\n    state.loop = 1;\n}\n\n// MSIRP[a] Move Stack Indirect Relative Point\n// 0x3A-0x3B\nfunction MSIRP(a, state) {\n    const stack = state.stack;\n    const d = stack.pop() / 64;\n    const pi = stack.pop();\n    const p = state.z1[pi];\n    const rp0 = state.z0[state.rp0];\n    const fv = state.fv;\n    const pv = state.pv;\n\n    fv.setRelative(p, rp0, d, pv);\n    fv.touch(p);\n\n    if (exports.DEBUG) console.log(state.step, 'MSIRP[' + a + ']', d, pi);\n\n    state.rp1 = state.rp0;\n    state.rp2 = pi;\n    if (a) state.rp0 = pi;\n}\n\n// ALIGNRP[] Align to reference point.\n// 0x3C\nfunction ALIGNRP(state) {\n    const stack = state.stack;\n    const rp0i = state.rp0;\n    const rp0 = state.z0[rp0i];\n    let loop = state.loop;\n    const fv = state.fv;\n    const pv = state.pv;\n    const z1 = state.z1;\n\n    while (loop--) {\n        const pi = stack.pop();\n        const p = z1[pi];\n\n        if (exports.DEBUG) {\n            console.log(\n                state.step,\n                (state.loop > 1 ? 'loop ' + (state.loop - loop) + ': ' : '') +\n                'ALIGNRP[]', pi\n            );\n        }\n\n        fv.setRelative(p, rp0, 0, pv);\n        fv.touch(p);\n    }\n\n    state.loop = 1;\n}\n\n// RTG[] Round To Double Grid\n// 0x3D\nfunction RTDG(state) {\n    if (exports.DEBUG) console.log(state.step, 'RTDG[]');\n\n    state.round = roundToDoubleGrid;\n}\n\n// MIAP[a] Move Indirect Absolute Point\n// 0x3E-0x3F\nfunction MIAP(round, state) {\n    const stack = state.stack;\n    const n = stack.pop();\n    const pi = stack.pop();\n    const p = state.z0[pi];\n    const fv = state.fv;\n    const pv = state.pv;\n    let cv = state.cvt[n];\n\n    // TODO cvtcutin should be considered here\n    if (round) cv = state.round(cv);\n\n    if (exports.DEBUG) {\n        console.log(\n            state.step,\n            'MIAP[' + round + ']',\n            n, '(', cv, ')', pi\n        );\n    }\n\n    fv.setRelative(p, HPZero, cv, pv);\n\n    if (state.zp0 === 0) {\n        p.xo = p.x;\n        p.yo = p.y;\n    }\n\n    fv.touch(p);\n\n    state.rp0 = state.rp1 = pi;\n}\n\n// NPUSB[] PUSH N Bytes\n// 0x40\nfunction NPUSHB(state) {\n    const prog = state.prog;\n    let ip = state.ip;\n    const stack = state.stack;\n\n    const n = prog[++ip];\n\n    if (exports.DEBUG) console.log(state.step, 'NPUSHB[]', n);\n\n    for (let i = 0; i < n; i++) stack.push(prog[++ip]);\n\n    state.ip = ip;\n}\n\n// NPUSHW[] PUSH N Words\n// 0x41\nfunction NPUSHW(state) {\n    let ip = state.ip;\n    const prog = state.prog;\n    const stack = state.stack;\n    const n = prog[++ip];\n\n    if (exports.DEBUG) console.log(state.step, 'NPUSHW[]', n);\n\n    for (let i = 0; i < n; i++) {\n        let w = (prog[++ip] << 8) | prog[++ip];\n        if (w & 0x8000) w = -((w ^ 0xffff) + 1);\n        stack.push(w);\n    }\n\n    state.ip = ip;\n}\n\n// WS[] Write Store\n// 0x42\nfunction WS(state) {\n    const stack = state.stack;\n    let store = state.store;\n\n    if (!store) store = state.store = [];\n\n    const v = stack.pop();\n    const l = stack.pop();\n\n    if (exports.DEBUG) console.log(state.step, 'WS', v, l);\n\n    store[l] = v;\n}\n\n// RS[] Read Store\n// 0x43\nfunction RS(state) {\n    const stack = state.stack;\n    const store = state.store;\n\n    const l = stack.pop();\n\n    if (exports.DEBUG) console.log(state.step, 'RS', l);\n\n    const v = (store && store[l]) || 0;\n\n    stack.push(v);\n}\n\n// WCVTP[] Write Control Value Table in Pixel units\n// 0x44\nfunction WCVTP(state) {\n    const stack = state.stack;\n\n    const v = stack.pop();\n    const l = stack.pop();\n\n    if (exports.DEBUG) console.log(state.step, 'WCVTP', v, l);\n\n    state.cvt[l] = v / 0x40;\n}\n\n// RCVT[] Read Control Value Table entry\n// 0x45\nfunction RCVT(state) {\n    const stack = state.stack;\n    const cvte = stack.pop();\n\n    if (exports.DEBUG) console.log(state.step, 'RCVT', cvte);\n\n    stack.push(state.cvt[cvte] * 0x40);\n}\n\n// GC[] Get Coordinate projected onto the projection vector\n// 0x46-0x47\nfunction GC(a, state) {\n    const stack = state.stack;\n    const pi = stack.pop();\n    const p = state.z2[pi];\n\n    if (exports.DEBUG) console.log(state.step, 'GC[' + a + ']', pi);\n\n    stack.push(state.dpv.distance(p, HPZero, a, false) * 0x40);\n}\n\n// MD[a] Measure Distance\n// 0x49-0x4A\nfunction MD(a, state) {\n    const stack = state.stack;\n    const pi2 = stack.pop();\n    const pi1 = stack.pop();\n    const p2 = state.z1[pi2];\n    const p1 = state.z0[pi1];\n    const d = state.dpv.distance(p1, p2, a, a);\n\n    if (exports.DEBUG) console.log(state.step, 'MD[' + a + ']', pi2, pi1, '->', d);\n\n    state.stack.push(Math.round(d * 64));\n}\n\n// MPPEM[] Measure Pixels Per EM\n// 0x4B\nfunction MPPEM(state) {\n    if (exports.DEBUG) console.log(state.step, 'MPPEM[]');\n    state.stack.push(state.ppem);\n}\n\n// FLIPON[] set the auto FLIP Boolean to ON\n// 0x4D\nfunction FLIPON(state) {\n    if (exports.DEBUG) console.log(state.step, 'FLIPON[]');\n    state.autoFlip = true;\n}\n\n// LT[] Less Than\n// 0x50\nfunction LT(state) {\n    const stack = state.stack;\n    const e2 = stack.pop();\n    const e1 = stack.pop();\n\n    if (exports.DEBUG) console.log(state.step, 'LT[]', e2, e1);\n\n    stack.push(e1 < e2 ? 1 : 0);\n}\n\n// LTEQ[] Less Than or EQual\n// 0x53\nfunction LTEQ(state) {\n    const stack = state.stack;\n    const e2 = stack.pop();\n    const e1 = stack.pop();\n\n    if (exports.DEBUG) console.log(state.step, 'LTEQ[]', e2, e1);\n\n    stack.push(e1 <= e2 ? 1 : 0);\n}\n\n// GTEQ[] Greater Than\n// 0x52\nfunction GT(state) {\n    const stack = state.stack;\n    const e2 = stack.pop();\n    const e1 = stack.pop();\n\n    if (exports.DEBUG) console.log(state.step, 'GT[]', e2, e1);\n\n    stack.push(e1 > e2 ? 1 : 0);\n}\n\n// GTEQ[] Greater Than or EQual\n// 0x53\nfunction GTEQ(state) {\n    const stack = state.stack;\n    const e2 = stack.pop();\n    const e1 = stack.pop();\n\n    if (exports.DEBUG) console.log(state.step, 'GTEQ[]', e2, e1);\n\n    stack.push(e1 >= e2 ? 1 : 0);\n}\n\n// EQ[] EQual\n// 0x54\nfunction EQ(state) {\n    const stack = state.stack;\n    const e2 = stack.pop();\n    const e1 = stack.pop();\n\n    if (exports.DEBUG) console.log(state.step, 'EQ[]', e2, e1);\n\n    stack.push(e2 === e1 ? 1 : 0);\n}\n\n// NEQ[] Not EQual\n// 0x55\nfunction NEQ(state) {\n    const stack = state.stack;\n    const e2 = stack.pop();\n    const e1 = stack.pop();\n\n    if (exports.DEBUG) console.log(state.step, 'NEQ[]', e2, e1);\n\n    stack.push(e2 !== e1 ? 1 : 0);\n}\n\n// ODD[] ODD\n// 0x56\nfunction ODD(state) {\n    const stack = state.stack;\n    const n = stack.pop();\n\n    if (exports.DEBUG) console.log(state.step, 'ODD[]', n);\n\n    stack.push(Math.trunc(n) % 2 ? 1 : 0);\n}\n\n// EVEN[] EVEN\n// 0x57\nfunction EVEN(state) {\n    const stack = state.stack;\n    const n = stack.pop();\n\n    if (exports.DEBUG) console.log(state.step, 'EVEN[]', n);\n\n    stack.push(Math.trunc(n) % 2 ? 0 : 1);\n}\n\n// IF[] IF test\n// 0x58\nfunction IF(state) {\n    let test = state.stack.pop();\n    let ins;\n\n    if (exports.DEBUG) console.log(state.step, 'IF[]', test);\n\n    // if test is true it just continues\n    // if not the ip is skipped until matching ELSE or EIF\n    if (!test) {\n        skip(state, true);\n\n        if (exports.DEBUG) console.log(state.step, ins === 0x1B ? 'ELSE[]' : 'EIF[]');\n    }\n}\n\n// EIF[] End IF\n// 0x59\nfunction EIF(state) {\n    // this can be reached normally when\n    // executing an else branch.\n    // -> just ignore it\n\n    if (exports.DEBUG) console.log(state.step, 'EIF[]');\n}\n\n// AND[] logical AND\n// 0x5A\nfunction AND(state) {\n    const stack = state.stack;\n    const e2 = stack.pop();\n    const e1 = stack.pop();\n\n    if (exports.DEBUG) console.log(state.step, 'AND[]', e2, e1);\n\n    stack.push(e2 && e1 ? 1 : 0);\n}\n\n// OR[] logical OR\n// 0x5B\nfunction OR(state) {\n    const stack = state.stack;\n    const e2 = stack.pop();\n    const e1 = stack.pop();\n\n    if (exports.DEBUG) console.log(state.step, 'OR[]', e2, e1);\n\n    stack.push(e2 || e1 ? 1 : 0);\n}\n\n// NOT[] logical NOT\n// 0x5C\nfunction NOT(state) {\n    const stack = state.stack;\n    const e = stack.pop();\n\n    if (exports.DEBUG) console.log(state.step, 'NOT[]', e);\n\n    stack.push(e ? 0 : 1);\n}\n\n// DELTAP1[] DELTA exception P1\n// DELTAP2[] DELTA exception P2\n// DELTAP3[] DELTA exception P3\n// 0x5D, 0x71, 0x72\nfunction DELTAP123(b, state) {\n    const stack = state.stack;\n    const n = stack.pop();\n    const fv = state.fv;\n    const pv = state.pv;\n    const ppem = state.ppem;\n    const base = state.deltaBase + (b - 1) * 16;\n    const ds = state.deltaShift;\n    const z0 = state.z0;\n\n    if (exports.DEBUG) console.log(state.step, 'DELTAP[' + b + ']', n, stack);\n\n    for (let i = 0; i < n; i++)\n    {\n        const pi = stack.pop();\n        const arg = stack.pop();\n        const appem = base + ((arg & 0xF0) >> 4);\n        if (appem !== ppem) continue;\n\n        let mag = (arg & 0x0F) - 8;\n        if (mag >= 0) mag++;\n        if (exports.DEBUG) console.log(state.step, 'DELTAPFIX', pi, 'by', mag * ds);\n\n        const p = z0[pi];\n        fv.setRelative(p, p, mag * ds, pv);\n    }\n}\n\n// SDB[] Set Delta Base in the graphics state\n// 0x5E\nfunction SDB(state) {\n    const stack = state.stack;\n    const n = stack.pop();\n\n    if (exports.DEBUG) console.log(state.step, 'SDB[]', n);\n\n    state.deltaBase = n;\n}\n\n// SDS[] Set Delta Shift in the graphics state\n// 0x5F\nfunction SDS(state) {\n    const stack = state.stack;\n    const n = stack.pop();\n\n    if (exports.DEBUG) console.log(state.step, 'SDS[]', n);\n\n    state.deltaShift = Math.pow(0.5, n);\n}\n\n// ADD[] ADD\n// 0x60\nfunction ADD(state) {\n    const stack = state.stack;\n    const n2 = stack.pop();\n    const n1 = stack.pop();\n\n    if (exports.DEBUG) console.log(state.step, 'ADD[]', n2, n1);\n\n    stack.push(n1 + n2);\n}\n\n// SUB[] SUB\n// 0x61\nfunction SUB(state) {\n    const stack = state.stack;\n    const n2 = stack.pop();\n    const n1 = stack.pop();\n\n    if (exports.DEBUG) console.log(state.step, 'SUB[]', n2, n1);\n\n    stack.push(n1 - n2);\n}\n\n// DIV[] DIV\n// 0x62\nfunction DIV(state) {\n    const stack = state.stack;\n    const n2 = stack.pop();\n    const n1 = stack.pop();\n\n    if (exports.DEBUG) console.log(state.step, 'DIV[]', n2, n1);\n\n    stack.push(n1 * 64 / n2);\n}\n\n// MUL[] MUL\n// 0x63\nfunction MUL(state) {\n    const stack = state.stack;\n    const n2 = stack.pop();\n    const n1 = stack.pop();\n\n    if (exports.DEBUG) console.log(state.step, 'MUL[]', n2, n1);\n\n    stack.push(n1 * n2 / 64);\n}\n\n// ABS[] ABSolute value\n// 0x64\nfunction ABS(state) {\n    const stack = state.stack;\n    const n = stack.pop();\n\n    if (exports.DEBUG) console.log(state.step, 'ABS[]', n);\n\n    stack.push(Math.abs(n));\n}\n\n// NEG[] NEGate\n// 0x65\nfunction NEG(state) {\n    const stack = state.stack;\n    let n = stack.pop();\n\n    if (exports.DEBUG) console.log(state.step, 'NEG[]', n);\n\n    stack.push(-n);\n}\n\n// FLOOR[] FLOOR\n// 0x66\nfunction FLOOR(state) {\n    const stack = state.stack;\n    const n = stack.pop();\n\n    if (exports.DEBUG) console.log(state.step, 'FLOOR[]', n);\n\n    stack.push(Math.floor(n / 0x40) * 0x40);\n}\n\n// CEILING[] CEILING\n// 0x67\nfunction CEILING(state) {\n    const stack = state.stack;\n    const n = stack.pop();\n\n    if (exports.DEBUG) console.log(state.step, 'CEILING[]', n);\n\n    stack.push(Math.ceil(n / 0x40) * 0x40);\n}\n\n// ROUND[ab] ROUND value\n// 0x68-0x6B\nfunction ROUND(dt, state) {\n    const stack = state.stack;\n    const n = stack.pop();\n\n    if (exports.DEBUG) console.log(state.step, 'ROUND[]');\n\n    stack.push(state.round(n / 0x40) * 0x40);\n}\n\n// WCVTF[] Write Control Value Table in Funits\n// 0x70\nfunction WCVTF(state) {\n    const stack = state.stack;\n    const v = stack.pop();\n    const l = stack.pop();\n\n    if (exports.DEBUG) console.log(state.step, 'WCVTF[]', v, l);\n\n    state.cvt[l] = v * state.ppem / state.font.unitsPerEm;\n}\n\n// DELTAC1[] DELTA exception C1\n// DELTAC2[] DELTA exception C2\n// DELTAC3[] DELTA exception C3\n// 0x73, 0x74, 0x75\nfunction DELTAC123(b, state) {\n    const stack = state.stack;\n    const n = stack.pop();\n    const ppem = state.ppem;\n    const base = state.deltaBase + (b - 1) * 16;\n    const ds = state.deltaShift;\n\n    if (exports.DEBUG) console.log(state.step, 'DELTAC[' + b + ']', n, stack);\n\n    for (let i = 0; i < n; i++) {\n        const c = stack.pop();\n        const arg = stack.pop();\n        const appem = base + ((arg & 0xF0) >> 4);\n        if (appem !== ppem) continue;\n\n        let mag = (arg & 0x0F) - 8;\n        if (mag >= 0) mag++;\n\n        const delta = mag * ds;\n\n        if (exports.DEBUG) console.log(state.step, 'DELTACFIX', c, 'by', delta);\n\n        state.cvt[c] += delta;\n    }\n}\n\n// SROUND[] Super ROUND\n// 0x76\nfunction SROUND(state) {\n    let n = state.stack.pop();\n\n    if (exports.DEBUG) console.log(state.step, 'SROUND[]', n);\n\n    state.round = roundSuper;\n\n    let period;\n\n    switch (n & 0xC0) {\n        case 0x00:\n            period = 0.5;\n            break;\n        case 0x40:\n            period = 1;\n            break;\n        case 0x80:\n            period = 2;\n            break;\n        default:\n            throw new Error('invalid SROUND value');\n    }\n\n    state.srPeriod = period;\n\n    switch (n & 0x30) {\n        case 0x00:\n            state.srPhase = 0;\n            break;\n        case 0x10:\n            state.srPhase = 0.25 * period;\n            break;\n        case 0x20:\n            state.srPhase = 0.5  * period;\n            break;\n        case 0x30:\n            state.srPhase = 0.75 * period;\n            break;\n        default: throw new Error('invalid SROUND value');\n    }\n\n    n &= 0x0F;\n\n    if (n === 0) state.srThreshold = 0;\n    else state.srThreshold = (n / 8 - 0.5) * period;\n}\n\n// S45ROUND[] Super ROUND 45 degrees\n// 0x77\nfunction S45ROUND(state) {\n    let n = state.stack.pop();\n\n    if (exports.DEBUG) console.log(state.step, 'S45ROUND[]', n);\n\n    state.round = roundSuper;\n\n    let period;\n\n    switch (n & 0xC0) {\n        case 0x00:\n            period = Math.sqrt(2) / 2;\n            break;\n        case 0x40:\n            period = Math.sqrt(2);\n            break;\n        case 0x80:\n            period = 2 * Math.sqrt(2);\n            break;\n        default:\n            throw new Error('invalid S45ROUND value');\n    }\n\n    state.srPeriod = period;\n\n    switch (n & 0x30) {\n        case 0x00:\n            state.srPhase = 0;\n            break;\n        case 0x10:\n            state.srPhase = 0.25 * period;\n            break;\n        case 0x20:\n            state.srPhase = 0.5  * period;\n            break;\n        case 0x30:\n            state.srPhase = 0.75 * period;\n            break;\n        default:\n            throw new Error('invalid S45ROUND value');\n    }\n\n    n &= 0x0F;\n\n    if (n === 0) state.srThreshold = 0;\n    else state.srThreshold = (n / 8 - 0.5) * period;\n}\n\n// ROFF[] Round Off\n// 0x7A\nfunction ROFF(state) {\n    if (exports.DEBUG) console.log(state.step, 'ROFF[]');\n\n    state.round = roundOff;\n}\n\n// RUTG[] Round Up To Grid\n// 0x7C\nfunction RUTG(state) {\n    if (exports.DEBUG) console.log(state.step, 'RUTG[]');\n\n    state.round = roundUpToGrid;\n}\n\n// RDTG[] Round Down To Grid\n// 0x7D\nfunction RDTG(state) {\n    if (exports.DEBUG) console.log(state.step, 'RDTG[]');\n\n    state.round = roundDownToGrid;\n}\n\n// SCANCTRL[] SCAN conversion ConTRoL\n// 0x85\nfunction SCANCTRL(state) {\n    const n = state.stack.pop();\n\n    // ignored by opentype.js\n\n    if (exports.DEBUG) console.log(state.step, 'SCANCTRL[]', n);\n}\n\n// SDPVTL[a] Set Dual Projection Vector To Line\n// 0x86-0x87\nfunction SDPVTL(a, state) {\n    const stack = state.stack;\n    const p2i = stack.pop();\n    const p1i = stack.pop();\n    const p2 = state.z2[p2i];\n    const p1 = state.z1[p1i];\n\n    if (exports.DEBUG) console.log('SDPVTL[' + a + ']', p2i, p1i);\n\n    let dx;\n    let dy;\n\n    if (!a) {\n        dx = p1.x - p2.x;\n        dy = p1.y - p2.y;\n    } else {\n        dx = p2.y - p1.y;\n        dy = p1.x - p2.x;\n    }\n\n    state.dpv = getUnitVector(dx, dy);\n}\n\n// GETINFO[] GET INFOrmation\n// 0x88\nfunction GETINFO(state) {\n    const stack = state.stack;\n    const sel = stack.pop();\n    let r = 0;\n\n    if (exports.DEBUG) console.log(state.step, 'GETINFO[]', sel);\n\n    // v35 as in no subpixel hinting\n    if (sel & 0x01) r = 35;\n\n    // TODO rotation and stretch currently not supported\n    // and thus those GETINFO are always 0.\n\n    // opentype.js is always gray scaling\n    if (sel & 0x20) r |= 0x1000;\n\n    stack.push(r);\n}\n\n// ROLL[] ROLL the top three stack elements\n// 0x8A\nfunction ROLL(state) {\n    const stack = state.stack;\n    const a = stack.pop();\n    const b = stack.pop();\n    const c = stack.pop();\n\n    if (exports.DEBUG) console.log(state.step, 'ROLL[]');\n\n    stack.push(b);\n    stack.push(a);\n    stack.push(c);\n}\n\n// MAX[] MAXimum of top two stack elements\n// 0x8B\nfunction MAX(state) {\n    const stack = state.stack;\n    const e2 = stack.pop();\n    const e1 = stack.pop();\n\n    if (exports.DEBUG) console.log(state.step, 'MAX[]', e2, e1);\n\n    stack.push(Math.max(e1, e2));\n}\n\n// MIN[] MINimum of top two stack elements\n// 0x8C\nfunction MIN(state) {\n    const stack = state.stack;\n    const e2 = stack.pop();\n    const e1 = stack.pop();\n\n    if (exports.DEBUG) console.log(state.step, 'MIN[]', e2, e1);\n\n    stack.push(Math.min(e1, e2));\n}\n\n// SCANTYPE[] SCANTYPE\n// 0x8D\nfunction SCANTYPE(state) {\n    const n = state.stack.pop();\n    // ignored by opentype.js\n    if (exports.DEBUG) console.log(state.step, 'SCANTYPE[]', n);\n}\n\n// INSTCTRL[] INSTCTRL\n// 0x8D\nfunction INSTCTRL(state) {\n    const s = state.stack.pop();\n    let v = state.stack.pop();\n\n    if (exports.DEBUG) console.log(state.step, 'INSTCTRL[]', s, v);\n\n    switch (s) {\n        case 1 : state.inhibitGridFit = !!v; return;\n        case 2 : state.ignoreCvt = !!v; return;\n        default: throw new Error('invalid INSTCTRL[] selector');\n    }\n}\n\n// PUSHB[abc] PUSH Bytes\n// 0xB0-0xB7\nfunction PUSHB(n, state) {\n    const stack = state.stack;\n    const prog = state.prog;\n    let ip = state.ip;\n\n    if (exports.DEBUG) console.log(state.step, 'PUSHB[' + n + ']');\n\n    for (let i = 0; i < n; i++) stack.push(prog[++ip]);\n\n    state.ip = ip;\n}\n\n// PUSHW[abc] PUSH Words\n// 0xB8-0xBF\nfunction PUSHW(n, state) {\n    let ip = state.ip;\n    const prog = state.prog;\n    const stack = state.stack;\n\n    if (exports.DEBUG) console.log(state.ip, 'PUSHW[' + n + ']');\n\n    for (let i = 0; i < n; i++) {\n        let w = (prog[++ip] << 8) | prog[++ip];\n        if (w & 0x8000) w = -((w ^ 0xffff) + 1);\n        stack.push(w);\n    }\n\n    state.ip = ip;\n}\n\n// MDRP[abcde] Move Direct Relative Point\n// 0xD0-0xEF\n// (if indirect is 0)\n//\n// and\n//\n// MIRP[abcde] Move Indirect Relative Point\n// 0xE0-0xFF\n// (if indirect is 1)\n\nfunction MDRP_MIRP(indirect, setRp0, keepD, ro, dt, state) {\n    const stack = state.stack;\n    const cvte = indirect && stack.pop();\n    const pi = stack.pop();\n    const rp0i = state.rp0;\n    const rp = state.z0[rp0i];\n    const p = state.z1[pi];\n\n    const md = state.minDis;\n    const fv = state.fv;\n    const pv = state.dpv;\n    let od; // original distance\n    let d; // moving distance\n    let sign; // sign of distance\n    let cv;\n\n    d = od = pv.distance(p, rp, true, true);\n    sign = d >= 0 ? 1 : -1; // Math.sign would be 0 in case of 0\n\n    // TODO consider autoFlip\n    d = Math.abs(d);\n\n    if (indirect) {\n        cv = state.cvt[cvte];\n\n        if (ro && Math.abs(d - cv) < state.cvCutIn) d = cv;\n    }\n\n    if (keepD && d < md) d = md;\n\n    if (ro) d = state.round(d);\n\n    fv.setRelative(p, rp, sign * d, pv);\n    fv.touch(p);\n\n    if (exports.DEBUG) {\n        console.log(\n            state.step,\n            (indirect ? 'MIRP[' : 'MDRP[') +\n            (setRp0 ? 'M' : 'm') +\n            (keepD ? '>' : '_') +\n            (ro ? 'R' : '_') +\n            (dt === 0 ? 'Gr' : (dt === 1 ? 'Bl' : (dt === 2 ? 'Wh' : ''))) +\n            ']',\n            indirect ?\n                cvte + '(' + state.cvt[cvte] + ',' +  cv + ')' :\n                '',\n            pi,\n            '(d =', od, '->', sign * d, ')'\n        );\n    }\n\n    state.rp1 = state.rp0;\n    state.rp2 = pi;\n    if (setRp0) state.rp0 = pi;\n}\n\n/*\n* The instruction table.\n*/\ninstructionTable = [\n    /* 0x00 */ SVTCA.bind(undefined, yUnitVector),\n    /* 0x01 */ SVTCA.bind(undefined, xUnitVector),\n    /* 0x02 */ SPVTCA.bind(undefined, yUnitVector),\n    /* 0x03 */ SPVTCA.bind(undefined, xUnitVector),\n    /* 0x04 */ SFVTCA.bind(undefined, yUnitVector),\n    /* 0x05 */ SFVTCA.bind(undefined, xUnitVector),\n    /* 0x06 */ SPVTL.bind(undefined, 0),\n    /* 0x07 */ SPVTL.bind(undefined, 1),\n    /* 0x08 */ SFVTL.bind(undefined, 0),\n    /* 0x09 */ SFVTL.bind(undefined, 1),\n    /* 0x0A */ SPVFS,\n    /* 0x0B */ SFVFS,\n    /* 0x0C */ GPV,\n    /* 0x0D */ GFV,\n    /* 0x0E */ SFVTPV,\n    /* 0x0F */ ISECT,\n    /* 0x10 */ SRP0,\n    /* 0x11 */ SRP1,\n    /* 0x12 */ SRP2,\n    /* 0x13 */ SZP0,\n    /* 0x14 */ SZP1,\n    /* 0x15 */ SZP2,\n    /* 0x16 */ SZPS,\n    /* 0x17 */ SLOOP,\n    /* 0x18 */ RTG,\n    /* 0x19 */ RTHG,\n    /* 0x1A */ SMD,\n    /* 0x1B */ ELSE,\n    /* 0x1C */ JMPR,\n    /* 0x1D */ SCVTCI,\n    /* 0x1E */ undefined,   // TODO SSWCI\n    /* 0x1F */ undefined,   // TODO SSW\n    /* 0x20 */ DUP,\n    /* 0x21 */ POP,\n    /* 0x22 */ CLEAR,\n    /* 0x23 */ SWAP,\n    /* 0x24 */ DEPTH,\n    /* 0x25 */ CINDEX,\n    /* 0x26 */ MINDEX,\n    /* 0x27 */ undefined,   // TODO ALIGNPTS\n    /* 0x28 */ undefined,\n    /* 0x29 */ undefined,   // TODO UTP\n    /* 0x2A */ LOOPCALL,\n    /* 0x2B */ CALL,\n    /* 0x2C */ FDEF,\n    /* 0x2D */ undefined,   // ENDF (eaten by FDEF)\n    /* 0x2E */ MDAP.bind(undefined, 0),\n    /* 0x2F */ MDAP.bind(undefined, 1),\n    /* 0x30 */ IUP.bind(undefined, yUnitVector),\n    /* 0x31 */ IUP.bind(undefined, xUnitVector),\n    /* 0x32 */ SHP.bind(undefined, 0),\n    /* 0x33 */ SHP.bind(undefined, 1),\n    /* 0x34 */ SHC.bind(undefined, 0),\n    /* 0x35 */ SHC.bind(undefined, 1),\n    /* 0x36 */ SHZ.bind(undefined, 0),\n    /* 0x37 */ SHZ.bind(undefined, 1),\n    /* 0x38 */ SHPIX,\n    /* 0x39 */ IP,\n    /* 0x3A */ MSIRP.bind(undefined, 0),\n    /* 0x3B */ MSIRP.bind(undefined, 1),\n    /* 0x3C */ ALIGNRP,\n    /* 0x3D */ RTDG,\n    /* 0x3E */ MIAP.bind(undefined, 0),\n    /* 0x3F */ MIAP.bind(undefined, 1),\n    /* 0x40 */ NPUSHB,\n    /* 0x41 */ NPUSHW,\n    /* 0x42 */ WS,\n    /* 0x43 */ RS,\n    /* 0x44 */ WCVTP,\n    /* 0x45 */ RCVT,\n    /* 0x46 */ GC.bind(undefined, 0),\n    /* 0x47 */ GC.bind(undefined, 1),\n    /* 0x48 */ undefined,   // TODO SCFS\n    /* 0x49 */ MD.bind(undefined, 0),\n    /* 0x4A */ MD.bind(undefined, 1),\n    /* 0x4B */ MPPEM,\n    /* 0x4C */ undefined,   // TODO MPS\n    /* 0x4D */ FLIPON,\n    /* 0x4E */ undefined,   // TODO FLIPOFF\n    /* 0x4F */ undefined,   // TODO DEBUG\n    /* 0x50 */ LT,\n    /* 0x51 */ LTEQ,\n    /* 0x52 */ GT,\n    /* 0x53 */ GTEQ,\n    /* 0x54 */ EQ,\n    /* 0x55 */ NEQ,\n    /* 0x56 */ ODD,\n    /* 0x57 */ EVEN,\n    /* 0x58 */ IF,\n    /* 0x59 */ EIF,\n    /* 0x5A */ AND,\n    /* 0x5B */ OR,\n    /* 0x5C */ NOT,\n    /* 0x5D */ DELTAP123.bind(undefined, 1),\n    /* 0x5E */ SDB,\n    /* 0x5F */ SDS,\n    /* 0x60 */ ADD,\n    /* 0x61 */ SUB,\n    /* 0x62 */ DIV,\n    /* 0x63 */ MUL,\n    /* 0x64 */ ABS,\n    /* 0x65 */ NEG,\n    /* 0x66 */ FLOOR,\n    /* 0x67 */ CEILING,\n    /* 0x68 */ ROUND.bind(undefined, 0),\n    /* 0x69 */ ROUND.bind(undefined, 1),\n    /* 0x6A */ ROUND.bind(undefined, 2),\n    /* 0x6B */ ROUND.bind(undefined, 3),\n    /* 0x6C */ undefined,   // TODO NROUND[ab]\n    /* 0x6D */ undefined,   // TODO NROUND[ab]\n    /* 0x6E */ undefined,   // TODO NROUND[ab]\n    /* 0x6F */ undefined,   // TODO NROUND[ab]\n    /* 0x70 */ WCVTF,\n    /* 0x71 */ DELTAP123.bind(undefined, 2),\n    /* 0x72 */ DELTAP123.bind(undefined, 3),\n    /* 0x73 */ DELTAC123.bind(undefined, 1),\n    /* 0x74 */ DELTAC123.bind(undefined, 2),\n    /* 0x75 */ DELTAC123.bind(undefined, 3),\n    /* 0x76 */ SROUND,\n    /* 0x77 */ S45ROUND,\n    /* 0x78 */ undefined,   // TODO JROT[]\n    /* 0x79 */ undefined,   // TODO JROF[]\n    /* 0x7A */ ROFF,\n    /* 0x7B */ undefined,\n    /* 0x7C */ RUTG,\n    /* 0x7D */ RDTG,\n    /* 0x7E */ POP, // actually SANGW, supposed to do only a pop though\n    /* 0x7F */ POP, // actually AA, supposed to do only a pop though\n    /* 0x80 */ undefined,   // TODO FLIPPT\n    /* 0x81 */ undefined,   // TODO FLIPRGON\n    /* 0x82 */ undefined,   // TODO FLIPRGOFF\n    /* 0x83 */ undefined,\n    /* 0x84 */ undefined,\n    /* 0x85 */ SCANCTRL,\n    /* 0x86 */ SDPVTL.bind(undefined, 0),\n    /* 0x87 */ SDPVTL.bind(undefined, 1),\n    /* 0x88 */ GETINFO,\n    /* 0x89 */ undefined,   // TODO IDEF\n    /* 0x8A */ ROLL,\n    /* 0x8B */ MAX,\n    /* 0x8C */ MIN,\n    /* 0x8D */ SCANTYPE,\n    /* 0x8E */ INSTCTRL,\n    /* 0x8F */ undefined,\n    /* 0x90 */ undefined,\n    /* 0x91 */ undefined,\n    /* 0x92 */ undefined,\n    /* 0x93 */ undefined,\n    /* 0x94 */ undefined,\n    /* 0x95 */ undefined,\n    /* 0x96 */ undefined,\n    /* 0x97 */ undefined,\n    /* 0x98 */ undefined,\n    /* 0x99 */ undefined,\n    /* 0x9A */ undefined,\n    /* 0x9B */ undefined,\n    /* 0x9C */ undefined,\n    /* 0x9D */ undefined,\n    /* 0x9E */ undefined,\n    /* 0x9F */ undefined,\n    /* 0xA0 */ undefined,\n    /* 0xA1 */ undefined,\n    /* 0xA2 */ undefined,\n    /* 0xA3 */ undefined,\n    /* 0xA4 */ undefined,\n    /* 0xA5 */ undefined,\n    /* 0xA6 */ undefined,\n    /* 0xA7 */ undefined,\n    /* 0xA8 */ undefined,\n    /* 0xA9 */ undefined,\n    /* 0xAA */ undefined,\n    /* 0xAB */ undefined,\n    /* 0xAC */ undefined,\n    /* 0xAD */ undefined,\n    /* 0xAE */ undefined,\n    /* 0xAF */ undefined,\n    /* 0xB0 */ PUSHB.bind(undefined, 1),\n    /* 0xB1 */ PUSHB.bind(undefined, 2),\n    /* 0xB2 */ PUSHB.bind(undefined, 3),\n    /* 0xB3 */ PUSHB.bind(undefined, 4),\n    /* 0xB4 */ PUSHB.bind(undefined, 5),\n    /* 0xB5 */ PUSHB.bind(undefined, 6),\n    /* 0xB6 */ PUSHB.bind(undefined, 7),\n    /* 0xB7 */ PUSHB.bind(undefined, 8),\n    /* 0xB8 */ PUSHW.bind(undefined, 1),\n    /* 0xB9 */ PUSHW.bind(undefined, 2),\n    /* 0xBA */ PUSHW.bind(undefined, 3),\n    /* 0xBB */ PUSHW.bind(undefined, 4),\n    /* 0xBC */ PUSHW.bind(undefined, 5),\n    /* 0xBD */ PUSHW.bind(undefined, 6),\n    /* 0xBE */ PUSHW.bind(undefined, 7),\n    /* 0xBF */ PUSHW.bind(undefined, 8),\n    /* 0xC0 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 0, 0),\n    /* 0xC1 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 0, 1),\n    /* 0xC2 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 0, 2),\n    /* 0xC3 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 0, 3),\n    /* 0xC4 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 1, 0),\n    /* 0xC5 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 1, 1),\n    /* 0xC6 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 1, 2),\n    /* 0xC7 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 1, 3),\n    /* 0xC8 */ MDRP_MIRP.bind(undefined, 0, 0, 1, 0, 0),\n    /* 0xC9 */ MDRP_MIRP.bind(undefined, 0, 0, 1, 0, 1),\n    /* 0xCA */ MDRP_MIRP.bind(undefined, 0, 0, 1, 0, 2),\n    /* 0xCB */ MDRP_MIRP.bind(undefined, 0, 0, 1, 0, 3),\n    /* 0xCC */ MDRP_MIRP.bind(undefined, 0, 0, 1, 1, 0),\n    /* 0xCD */ MDRP_MIRP.bind(undefined, 0, 0, 1, 1, 1),\n    /* 0xCE */ MDRP_MIRP.bind(undefined, 0, 0, 1, 1, 2),\n    /* 0xCF */ MDRP_MIRP.bind(undefined, 0, 0, 1, 1, 3),\n    /* 0xD0 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 0, 0),\n    /* 0xD1 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 0, 1),\n    /* 0xD2 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 0, 2),\n    /* 0xD3 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 0, 3),\n    /* 0xD4 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 1, 0),\n    /* 0xD5 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 1, 1),\n    /* 0xD6 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 1, 2),\n    /* 0xD7 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 1, 3),\n    /* 0xD8 */ MDRP_MIRP.bind(undefined, 0, 1, 1, 0, 0),\n    /* 0xD9 */ MDRP_MIRP.bind(undefined, 0, 1, 1, 0, 1),\n    /* 0xDA */ MDRP_MIRP.bind(undefined, 0, 1, 1, 0, 2),\n    /* 0xDB */ MDRP_MIRP.bind(undefined, 0, 1, 1, 0, 3),\n    /* 0xDC */ MDRP_MIRP.bind(undefined, 0, 1, 1, 1, 0),\n    /* 0xDD */ MDRP_MIRP.bind(undefined, 0, 1, 1, 1, 1),\n    /* 0xDE */ MDRP_MIRP.bind(undefined, 0, 1, 1, 1, 2),\n    /* 0xDF */ MDRP_MIRP.bind(undefined, 0, 1, 1, 1, 3),\n    /* 0xE0 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 0, 0),\n    /* 0xE1 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 0, 1),\n    /* 0xE2 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 0, 2),\n    /* 0xE3 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 0, 3),\n    /* 0xE4 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 1, 0),\n    /* 0xE5 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 1, 1),\n    /* 0xE6 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 1, 2),\n    /* 0xE7 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 1, 3),\n    /* 0xE8 */ MDRP_MIRP.bind(undefined, 1, 0, 1, 0, 0),\n    /* 0xE9 */ MDRP_MIRP.bind(undefined, 1, 0, 1, 0, 1),\n    /* 0xEA */ MDRP_MIRP.bind(undefined, 1, 0, 1, 0, 2),\n    /* 0xEB */ MDRP_MIRP.bind(undefined, 1, 0, 1, 0, 3),\n    /* 0xEC */ MDRP_MIRP.bind(undefined, 1, 0, 1, 1, 0),\n    /* 0xED */ MDRP_MIRP.bind(undefined, 1, 0, 1, 1, 1),\n    /* 0xEE */ MDRP_MIRP.bind(undefined, 1, 0, 1, 1, 2),\n    /* 0xEF */ MDRP_MIRP.bind(undefined, 1, 0, 1, 1, 3),\n    /* 0xF0 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 0, 0),\n    /* 0xF1 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 0, 1),\n    /* 0xF2 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 0, 2),\n    /* 0xF3 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 0, 3),\n    /* 0xF4 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 1, 0),\n    /* 0xF5 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 1, 1),\n    /* 0xF6 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 1, 2),\n    /* 0xF7 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 1, 3),\n    /* 0xF8 */ MDRP_MIRP.bind(undefined, 1, 1, 1, 0, 0),\n    /* 0xF9 */ MDRP_MIRP.bind(undefined, 1, 1, 1, 0, 1),\n    /* 0xFA */ MDRP_MIRP.bind(undefined, 1, 1, 1, 0, 2),\n    /* 0xFB */ MDRP_MIRP.bind(undefined, 1, 1, 1, 0, 3),\n    /* 0xFC */ MDRP_MIRP.bind(undefined, 1, 1, 1, 1, 0),\n    /* 0xFD */ MDRP_MIRP.bind(undefined, 1, 1, 1, 1, 1),\n    /* 0xFE */ MDRP_MIRP.bind(undefined, 1, 1, 1, 1, 2),\n    /* 0xFF */ MDRP_MIRP.bind(undefined, 1, 1, 1, 1, 3)\n];\n\n/* harmony default export */ var hintingtt = (Hinting);\n\n/*****************************\n  Mathematical Considerations\n******************************\n\nfv ... refers to freedom vector\npv ... refers to projection vector\nrp ... refers to reference point\np  ... refers to to point being operated on\nd  ... refers to distance\n\nSETRELATIVE:\n============\n\ncase freedom vector == x-axis:\n------------------------------\n\n                        (pv)\n                     .-'\n              rpd .-'\n               .-*\n          d .-'90°'\n         .-'       '\n      .-'           '\n   *-'               ' b\n  rp                  '\n                       '\n                        '\n            p *----------*-------------- (fv)\n                          pm\n\n  rpdx = rpx + d * pv.x\n  rpdy = rpy + d * pv.y\n\n  equation of line b\n\n   y - rpdy = pvns * (x- rpdx)\n\n   y = p.y\n\n   x = rpdx + ( p.y - rpdy ) / pvns\n\n\ncase freedom vector == y-axis:\n------------------------------\n\n    * pm\n    |\\\n    | \\\n    |  \\\n    |   \\\n    |    \\\n    |     \\\n    |      \\\n    |       \\\n    |        \\\n    |         \\ b\n    |          \\\n    |           \\\n    |            \\    .-' (pv)\n    |         90° \\.-'\n    |           .-'* rpd\n    |        .-'\n    *     *-'  d\n    p     rp\n\n  rpdx = rpx + d * pv.x\n  rpdy = rpy + d * pv.y\n\n  equation of line b:\n           pvns ... normal slope to pv\n\n   y - rpdy = pvns * (x - rpdx)\n\n   x = p.x\n\n   y = rpdy +  pvns * (p.x - rpdx)\n\n\n\ngeneric case:\n-------------\n\n\n                              .'(fv)\n                            .'\n                          .* pm\n                        .' !\n                      .'    .\n                    .'      !\n                  .'         . b\n                .'           !\n               *              .\n              p               !\n                         90°   .    ... (pv)\n                           ...-*-'''\n                  ...---'''    rpd\n         ...---'''   d\n   *--'''\n  rp\n\n    rpdx = rpx + d * pv.x\n    rpdy = rpy + d * pv.y\n\n equation of line b:\n    pvns... normal slope to pv\n\n    y - rpdy = pvns * (x - rpdx)\n\n equation of freedom vector line:\n    fvs ... slope of freedom vector (=fy/fx)\n\n    y - py = fvs * (x - px)\n\n\n  on pm both equations are true for same x/y\n\n    y - rpdy = pvns * (x - rpdx)\n\n    y - py = fvs * (x - px)\n\n  form to y and set equal:\n\n    pvns * (x - rpdx) + rpdy = fvs * (x - px) + py\n\n  expand:\n\n    pvns * x - pvns * rpdx + rpdy = fvs * x - fvs * px + py\n\n  switch:\n\n    fvs * x - fvs * px + py = pvns * x - pvns * rpdx + rpdy\n\n  solve for x:\n\n    fvs * x - pvns * x = fvs * px - pvns * rpdx - py + rpdy\n\n\n\n          fvs * px - pvns * rpdx + rpdy - py\n    x =  -----------------------------------\n                 fvs - pvns\n\n  and:\n\n    y = fvs * (x - px) + py\n\n\n\nINTERPOLATE:\n============\n\nExamples of point interpolation.\n\nThe weight of the movement of the reference point gets bigger\nthe further the other reference point is away, thus the safest\noption (that is avoiding 0/0 divisions) is to weight the\noriginal distance of the other point by the sum of both distances.\n\nIf the sum of both distances is 0, then move the point by the\narithmetic average of the movement of both reference points.\n\n\n\n\n           (+6)\n    rp1o *----\x3e*rp1\n         .     .                          (+12)\n         .     .                  rp2o *----------\x3e* rp2\n         .     .                       .           .\n         .     .                       .           .\n         .    10          20           .           .\n         |.........|...................|           .\n               .   .                               .\n               .   . (+8)                          .\n                po *------\x3e*p                      .\n               .           .                       .\n               .    12     .          24           .\n               |...........|.......................|\n                                  36\n\n\n-------\n\n\n\n           (+10)\n    rp1o *--------\x3e*rp1\n         .         .                      (-10)\n         .         .              rp2 *<---------* rpo2\n         .         .                   .         .\n         .         .                   .         .\n         .    10   .          30       .         .\n         |.........|.............................|\n                   .                   .\n                   . (+5)              .\n                po *---\x3e* p            .\n                   .    .              .\n                   .    .   20         .\n                   |....|..............|\n                     5        15\n\n\n-------\n\n\n           (+10)\n    rp1o *--------\x3e*rp1\n         .         .\n         .         .\n    rp2o *--------\x3e*rp2\n\n\n                               (+10)\n                          po *--------\x3e* p\n\n-------\n\n\n           (+10)\n    rp1o *--------\x3e*rp1\n         .         .\n         .         .(+30)\n    rp2o *----------------------------\x3e*rp2\n\n\n                                        (+25)\n                          po *-----------------------\x3e* p\n\n\n\nvim: set ts=4 sw=4 expandtab:\n*****/\n\n// CONCATENATED MODULE: ./node_modules/opentype.js/src/font.js\n// The Font object\n\n\n\n\n\n\n\n\n\n/**\n * @typedef FontOptions\n * @type Object\n * @property {Boolean} empty - whether to create a new empty font\n * @property {string} familyName\n * @property {string} styleName\n * @property {string=} fullName\n * @property {string=} postScriptName\n * @property {string=} designer\n * @property {string=} designerURL\n * @property {string=} manufacturer\n * @property {string=} manufacturerURL\n * @property {string=} license\n * @property {string=} licenseURL\n * @property {string=} version\n * @property {string=} description\n * @property {string=} copyright\n * @property {string=} trademark\n * @property {Number} unitsPerEm\n * @property {Number} ascender\n * @property {Number} descender\n * @property {Number} createdTimestamp\n * @property {string=} weightClass\n * @property {string=} widthClass\n * @property {string=} fsSelection\n */\n\n/**\n * A Font represents a loaded OpenType font file.\n * It contains a set of glyphs and methods to draw text on a drawing context,\n * or to get a path representing the text.\n * @exports opentype.Font\n * @class\n * @param {FontOptions}\n * @constructor\n */\nfunction Font(options) {\n    options = options || {};\n\n    if (!options.empty) {\n        // Check that we've provided the minimum set of names.\n        Object(util[\"b\" /* checkArgument */])(options.familyName, 'When creating a new Font object, familyName is required.');\n        Object(util[\"b\" /* checkArgument */])(options.styleName, 'When creating a new Font object, styleName is required.');\n        Object(util[\"b\" /* checkArgument */])(options.unitsPerEm, 'When creating a new Font object, unitsPerEm is required.');\n        Object(util[\"b\" /* checkArgument */])(options.ascender, 'When creating a new Font object, ascender is required.');\n        Object(util[\"b\" /* checkArgument */])(options.descender, 'When creating a new Font object, descender is required.');\n        Object(util[\"b\" /* checkArgument */])(options.descender < 0, 'Descender should be negative (e.g. -512).');\n\n        // OS X will complain if the names are empty, so we put a single space everywhere by default.\n        this.names = {\n            fontFamily: {en: options.familyName || ' '},\n            fontSubfamily: {en: options.styleName || ' '},\n            fullName: {en: options.fullName || options.familyName + ' ' + options.styleName},\n            postScriptName: {en: options.postScriptName || options.familyName + options.styleName},\n            designer: {en: options.designer || ' '},\n            designerURL: {en: options.designerURL || ' '},\n            manufacturer: {en: options.manufacturer || ' '},\n            manufacturerURL: {en: options.manufacturerURL || ' '},\n            license: {en: options.license || ' '},\n            licenseURL: {en: options.licenseURL || ' '},\n            version: {en: options.version || 'Version 0.1'},\n            description: {en: options.description || ' '},\n            copyright: {en: options.copyright || ' '},\n            trademark: {en: options.trademark || ' '}\n        };\n        this.unitsPerEm = options.unitsPerEm || 1000;\n        this.ascender = options.ascender;\n        this.descender = options.descender;\n        this.createdTimestamp = options.createdTimestamp;\n        this.tables = { os2: {\n            usWeightClass: options.weightClass || this.usWeightClasses.MEDIUM,\n            usWidthClass: options.widthClass || this.usWidthClasses.MEDIUM,\n            fsSelection: options.fsSelection || this.fsSelectionValues.REGULAR\n        } };\n    }\n\n    this.supported = true; // Deprecated: parseBuffer will throw an error if font is not supported.\n    this.glyphs = new glyphset.GlyphSet(this, options.glyphs || []);\n    this.encoding = new DefaultEncoding(this);\n    this.substitution = new src_substitution(this);\n    this.tables = this.tables || {};\n\n    Object.defineProperty(this, 'hinting', {\n        get: function() {\n            if (this._hinting) return this._hinting;\n            if (this.outlinesFormat === 'truetype') {\n                return (this._hinting = new hintingtt(this));\n            }\n        }\n    });\n}\n\n/**\n * Check if the font has a glyph for the given character.\n * @param  {string}\n * @return {Boolean}\n */\nFont.prototype.hasChar = function(c) {\n    return this.encoding.charToGlyphIndex(c) !== null;\n};\n\n/**\n * Convert the given character to a single glyph index.\n * Note that this function assumes that there is a one-to-one mapping between\n * the given character and a glyph; for complex scripts this might not be the case.\n * @param  {string}\n * @return {Number}\n */\nFont.prototype.charToGlyphIndex = function(s) {\n    return this.encoding.charToGlyphIndex(s);\n};\n\n/**\n * Convert the given character to a single Glyph object.\n * Note that this function assumes that there is a one-to-one mapping between\n * the given character and a glyph; for complex scripts this might not be the case.\n * @param  {string}\n * @return {opentype.Glyph}\n */\nFont.prototype.charToGlyph = function(c) {\n    const glyphIndex = this.charToGlyphIndex(c);\n    let glyph = this.glyphs.get(glyphIndex);\n    if (!glyph) {\n        // .notdef\n        glyph = this.glyphs.get(0);\n    }\n\n    return glyph;\n};\n\n/**\n * Convert the given text to a list of Glyph objects.\n * Note that there is no strict one-to-one mapping between characters and\n * glyphs, so the list of returned glyphs can be larger or smaller than the\n * length of the given string.\n * @param  {string}\n * @param  {GlyphRenderOptions} [options]\n * @return {opentype.Glyph[]}\n */\nFont.prototype.stringToGlyphs = function(s, options) {\n    options = options || this.defaultRenderOptions;\n    // Get glyph indexes\n    const indexes = [];\n    for (let i = 0; i < s.length; i += 1) {\n        const c = s[i];\n        indexes.push(this.charToGlyphIndex(c));\n    }\n    let length = indexes.length;\n\n    // Apply substitutions on glyph indexes\n    if (options.features) {\n        const script = options.script || this.substitution.getDefaultScriptName();\n        let manyToOne = [];\n        if (options.features.liga) manyToOne = manyToOne.concat(this.substitution.getFeature('liga', script, options.language));\n        if (options.features.rlig) manyToOne = manyToOne.concat(this.substitution.getFeature('rlig', script, options.language));\n        for (let i = 0; i < length; i += 1) {\n            for (let j = 0; j < manyToOne.length; j++) {\n                const ligature = manyToOne[j];\n                const components = ligature.sub;\n                const compCount = components.length;\n                let k = 0;\n                while (k < compCount && components[k] === indexes[i + k]) k++;\n                if (k === compCount) {\n                    indexes.splice(i, compCount, ligature.by);\n                    length = length - compCount + 1;\n                }\n            }\n        }\n    }\n\n    // convert glyph indexes to glyph objects\n    const glyphs = new Array(length);\n    const notdef = this.glyphs.get(0);\n    for (let i = 0; i < length; i += 1) {\n        glyphs[i] = this.glyphs.get(indexes[i]) || notdef;\n    }\n    return glyphs;\n};\n\n/**\n * @param  {string}\n * @return {Number}\n */\nFont.prototype.nameToGlyphIndex = function(name) {\n    return this.glyphNames.nameToGlyphIndex(name);\n};\n\n/**\n * @param  {string}\n * @return {opentype.Glyph}\n */\nFont.prototype.nameToGlyph = function(name) {\n    const glyphIndex = this.nameToGlyphIndex(name);\n    let glyph = this.glyphs.get(glyphIndex);\n    if (!glyph) {\n        // .notdef\n        glyph = this.glyphs.get(0);\n    }\n\n    return glyph;\n};\n\n/**\n * @param  {Number}\n * @return {String}\n */\nFont.prototype.glyphIndexToName = function(gid) {\n    if (!this.glyphNames.glyphIndexToName) {\n        return '';\n    }\n\n    return this.glyphNames.glyphIndexToName(gid);\n};\n\n/**\n * Retrieve the value of the kerning pair between the left glyph (or its index)\n * and the right glyph (or its index). If no kerning pair is found, return 0.\n * The kerning value gets added to the advance width when calculating the spacing\n * between glyphs.\n * @param  {opentype.Glyph} leftGlyph\n * @param  {opentype.Glyph} rightGlyph\n * @return {Number}\n */\nFont.prototype.getKerningValue = function(leftGlyph, rightGlyph) {\n    leftGlyph = leftGlyph.index || leftGlyph;\n    rightGlyph = rightGlyph.index || rightGlyph;\n    const gposKerning = this.getGposKerningValue;\n    return gposKerning ? gposKerning(leftGlyph, rightGlyph) :\n        (this.kerningPairs[leftGlyph + ',' + rightGlyph] || 0);\n};\n\n/**\n * @typedef GlyphRenderOptions\n * @type Object\n * @property {string} [script] - script used to determine which features to apply. By default, 'DFLT' or 'latn' is used.\n *                               See https://www.microsoft.com/typography/otspec/scripttags.htm\n * @property {string} [language='dflt'] - language system used to determine which features to apply.\n *                                        See https://www.microsoft.com/typography/developers/opentype/languagetags.aspx\n * @property {boolean} [kerning=true] - whether to include kerning values\n * @property {object} [features] - OpenType Layout feature tags. Used to enable or disable the features of the given script/language system.\n *                                 See https://www.microsoft.com/typography/otspec/featuretags.htm\n */\nFont.prototype.defaultRenderOptions = {\n    kerning: true,\n    features: {\n        liga: true,\n        rlig: true\n    }\n};\n\n/**\n * Helper function that invokes the given callback for each glyph in the given text.\n * The callback gets `(glyph, x, y, fontSize, options)`.* @param  {string} text\n * @param {string} text - The text to apply.\n * @param  {number} [x=0] - Horizontal position of the beginning of the text.\n * @param  {number} [y=0] - Vertical position of the *baseline* of the text.\n * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.\n * @param  {GlyphRenderOptions=} options\n * @param  {Function} callback\n */\nFont.prototype.forEachGlyph = function(text, x, y, fontSize, options, callback) {\n    x = x !== undefined ? x : 0;\n    y = y !== undefined ? y : 0;\n    fontSize = fontSize !== undefined ? fontSize : 72;\n    options = options || this.defaultRenderOptions;\n    const fontScale = 1 / this.unitsPerEm * fontSize;\n    const glyphs = this.stringToGlyphs(text, options);\n    for (let i = 0; i < glyphs.length; i += 1) {\n        const glyph = glyphs[i];\n        callback.call(this, glyph, x, y, fontSize, options);\n        if (glyph.advanceWidth) {\n            x += glyph.advanceWidth * fontScale;\n        }\n\n        if (options.kerning && i < glyphs.length - 1) {\n            const kerningValue = this.getKerningValue(glyph, glyphs[i + 1]);\n            x += kerningValue * fontScale;\n        }\n\n        if (options.letterSpacing) {\n            x += options.letterSpacing * fontSize;\n        } else if (options.tracking) {\n            x += (options.tracking / 1000) * fontSize;\n        }\n    }\n    return x;\n};\n\n/**\n * Create a Path object that represents the given text.\n * @param  {string} text - The text to create.\n * @param  {number} [x=0] - Horizontal position of the beginning of the text.\n * @param  {number} [y=0] - Vertical position of the *baseline* of the text.\n * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.\n * @param  {GlyphRenderOptions=} options\n * @return {opentype.Path}\n */\nFont.prototype.getPath = function(text, x, y, fontSize, options) {\n    const fullPath = new src_path();\n    this.forEachGlyph(text, x, y, fontSize, options, function(glyph, gX, gY, gFontSize) {\n        const glyphPath = glyph.getPath(gX, gY, gFontSize, options, this);\n        fullPath.extend(glyphPath);\n    });\n    return fullPath;\n};\n\n/**\n * Create an array of Path objects that represent the glyphs of a given text.\n * @param  {string} text - The text to create.\n * @param  {number} [x=0] - Horizontal position of the beginning of the text.\n * @param  {number} [y=0] - Vertical position of the *baseline* of the text.\n * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.\n * @param  {GlyphRenderOptions=} options\n * @return {opentype.Path[]}\n */\nFont.prototype.getPaths = function(text, x, y, fontSize, options) {\n    const glyphPaths = [];\n    this.forEachGlyph(text, x, y, fontSize, options, function(glyph, gX, gY, gFontSize) {\n        const glyphPath = glyph.getPath(gX, gY, gFontSize, options, this);\n        glyphPaths.push(glyphPath);\n    });\n\n    return glyphPaths;\n};\n\n/**\n * Returns the advance width of a text.\n *\n * This is something different than Path.getBoundingBox() as for example a\n * suffixed whitespace increases the advanceWidth but not the bounding box\n * or an overhanging letter like a calligraphic 'f' might have a quite larger\n * bounding box than its advance width.\n *\n * This corresponds to canvas2dContext.measureText(text).width\n *\n * @param  {string} text - The text to create.\n * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.\n * @param  {GlyphRenderOptions=} options\n * @return advance width\n */\nFont.prototype.getAdvanceWidth = function(text, fontSize, options) {\n    return this.forEachGlyph(text, 0, 0, fontSize, options, function() {});\n};\n\n/**\n * Draw the text on the given drawing context.\n * @param  {CanvasRenderingContext2D} ctx - A 2D drawing context, like Canvas.\n * @param  {string} text - The text to create.\n * @param  {number} [x=0] - Horizontal position of the beginning of the text.\n * @param  {number} [y=0] - Vertical position of the *baseline* of the text.\n * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.\n * @param  {GlyphRenderOptions=} options\n */\nFont.prototype.draw = function(ctx, text, x, y, fontSize, options) {\n    this.getPath(text, x, y, fontSize, options).draw(ctx);\n};\n\n/**\n * Draw the points of all glyphs in the text.\n * On-curve points will be drawn in blue, off-curve points will be drawn in red.\n * @param {CanvasRenderingContext2D} ctx - A 2D drawing context, like Canvas.\n * @param {string} text - The text to create.\n * @param {number} [x=0] - Horizontal position of the beginning of the text.\n * @param {number} [y=0] - Vertical position of the *baseline* of the text.\n * @param {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.\n * @param {GlyphRenderOptions=} options\n */\nFont.prototype.drawPoints = function(ctx, text, x, y, fontSize, options) {\n    this.forEachGlyph(text, x, y, fontSize, options, function(glyph, gX, gY, gFontSize) {\n        glyph.drawPoints(ctx, gX, gY, gFontSize);\n    });\n};\n\n/**\n * Draw lines indicating important font measurements for all glyphs in the text.\n * Black lines indicate the origin of the coordinate system (point 0,0).\n * Blue lines indicate the glyph bounding box.\n * Green line indicates the advance width of the glyph.\n * @param {CanvasRenderingContext2D} ctx - A 2D drawing context, like Canvas.\n * @param {string} text - The text to create.\n * @param {number} [x=0] - Horizontal position of the beginning of the text.\n * @param {number} [y=0] - Vertical position of the *baseline* of the text.\n * @param {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.\n * @param {GlyphRenderOptions=} options\n */\nFont.prototype.drawMetrics = function(ctx, text, x, y, fontSize, options) {\n    this.forEachGlyph(text, x, y, fontSize, options, function(glyph, gX, gY, gFontSize) {\n        glyph.drawMetrics(ctx, gX, gY, gFontSize);\n    });\n};\n\n/**\n * @param  {string}\n * @return {string}\n */\nFont.prototype.getEnglishName = function(name) {\n    const translations = this.names[name];\n    if (translations) {\n        return translations.en;\n    }\n};\n\n/**\n * Validate\n */\nFont.prototype.validate = function() {\n    const warnings = [];\n    const _this = this;\n\n    function assert(predicate, message) {\n        if (!predicate) {\n            warnings.push(message);\n        }\n    }\n\n    function assertNamePresent(name) {\n        const englishName = _this.getEnglishName(name);\n        assert(englishName && englishName.trim().length > 0,\n               'No English ' + name + ' specified.');\n    }\n\n    // Identification information\n    assertNamePresent('fontFamily');\n    assertNamePresent('weightName');\n    assertNamePresent('manufacturer');\n    assertNamePresent('copyright');\n    assertNamePresent('version');\n\n    // Dimension information\n    assert(this.unitsPerEm > 0, 'No unitsPerEm specified.');\n};\n\n/**\n * Convert the font object to a SFNT data structure.\n * This structure contains all the necessary tables and metadata to create a binary OTF file.\n * @return {opentype.Table}\n */\nFont.prototype.toTables = function() {\n    return tables_sfnt.fontToTable(this);\n};\n/**\n * @deprecated Font.toBuffer is deprecated. Use Font.toArrayBuffer instead.\n */\nFont.prototype.toBuffer = function() {\n    console.warn('Font.toBuffer is deprecated. Use Font.toArrayBuffer instead.');\n    return this.toArrayBuffer();\n};\n/**\n * Converts a `opentype.Font` into an `ArrayBuffer`\n * @return {ArrayBuffer}\n */\nFont.prototype.toArrayBuffer = function() {\n    const sfntTable = this.toTables();\n    const bytes = sfntTable.encode();\n    const buffer = new ArrayBuffer(bytes.length);\n    const intArray = new Uint8Array(buffer);\n    for (let i = 0; i < bytes.length; i++) {\n        intArray[i] = bytes[i];\n    }\n\n    return buffer;\n};\n\n/**\n * Initiate a download of the OpenType font.\n */\nFont.prototype.download = function(fileName) {\n    const familyName = this.getEnglishName('fontFamily');\n    const styleName = this.getEnglishName('fontSubfamily');\n    fileName = fileName || familyName.replace(/\\s/g, '') + '-' + styleName + '.otf';\n    const arrayBuffer = this.toArrayBuffer();\n\n    if (Object(util[\"c\" /* isBrowser */])()) {\n        window.requestFileSystem = window.requestFileSystem || window.webkitRequestFileSystem;\n        window.requestFileSystem(window.TEMPORARY, arrayBuffer.byteLength, function(fs) {\n            fs.root.getFile(fileName, {create: true}, function(fileEntry) {\n                fileEntry.createWriter(function(writer) {\n                    const dataView = new DataView(arrayBuffer);\n                    const blob = new Blob([dataView], {type: 'font/opentype'});\n                    writer.write(blob);\n\n                    writer.addEventListener('writeend', function() {\n                        // Navigating to the file will download it.\n                        location.href = fileEntry.toURL();\n                    }, false);\n                });\n            });\n        },\n        function(err) {\n            throw new Error(err.name + ': ' + err.message);\n        });\n    } else {\n        const fs = __webpack_require__(1);\n        const buffer = Object(util[\"a\" /* arrayBufferToNodeBuffer */])(arrayBuffer);\n        fs.writeFileSync(fileName, buffer);\n    }\n};\n/**\n * @private\n */\nFont.prototype.fsSelectionValues = {\n    ITALIC:              0x001, //1\n    UNDERSCORE:          0x002, //2\n    NEGATIVE:            0x004, //4\n    OUTLINED:            0x008, //8\n    STRIKEOUT:           0x010, //16\n    BOLD:                0x020, //32\n    REGULAR:             0x040, //64\n    USER_TYPO_METRICS:   0x080, //128\n    WWS:                 0x100, //256\n    OBLIQUE:             0x200  //512\n};\n\n/**\n * @private\n */\nFont.prototype.usWidthClasses = {\n    ULTRA_CONDENSED: 1,\n    EXTRA_CONDENSED: 2,\n    CONDENSED: 3,\n    SEMI_CONDENSED: 4,\n    MEDIUM: 5,\n    SEMI_EXPANDED: 6,\n    EXPANDED: 7,\n    EXTRA_EXPANDED: 8,\n    ULTRA_EXPANDED: 9\n};\n\n/**\n * @private\n */\nFont.prototype.usWeightClasses = {\n    THIN: 100,\n    EXTRA_LIGHT: 200,\n    LIGHT: 300,\n    NORMAL: 400,\n    MEDIUM: 500,\n    SEMI_BOLD: 600,\n    BOLD: 700,\n    EXTRA_BOLD: 800,\n    BLACK:    900\n};\n\n/* harmony default export */ var src_font = (Font);\n\n// CONCATENATED MODULE: ./node_modules/opentype.js/src/tables/fvar.js\n// The `fvar` table stores font variation axes and instances.\n// https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6fvar.html\n\n\n\n\n\nfunction addName(name, names) {\n    const nameString = JSON.stringify(name);\n    let nameID = 256;\n    for (let nameKey in names) {\n        let n = parseInt(nameKey);\n        if (!n || n < 256) {\n            continue;\n        }\n\n        if (JSON.stringify(names[nameKey]) === nameString) {\n            return n;\n        }\n\n        if (nameID <= n) {\n            nameID = n + 1;\n        }\n    }\n\n    names[nameID] = name;\n    return nameID;\n}\n\nfunction makeFvarAxis(n, axis, names) {\n    const nameID = addName(axis.name, names);\n    return [\n        {name: 'tag_' + n, type: 'TAG', value: axis.tag},\n        {name: 'minValue_' + n, type: 'FIXED', value: axis.minValue << 16},\n        {name: 'defaultValue_' + n, type: 'FIXED', value: axis.defaultValue << 16},\n        {name: 'maxValue_' + n, type: 'FIXED', value: axis.maxValue << 16},\n        {name: 'flags_' + n, type: 'USHORT', value: 0},\n        {name: 'nameID_' + n, type: 'USHORT', value: nameID}\n    ];\n}\n\nfunction parseFvarAxis(data, start, names) {\n    const axis = {};\n    const p = new src_parse.Parser(data, start);\n    axis.tag = p.parseTag();\n    axis.minValue = p.parseFixed();\n    axis.defaultValue = p.parseFixed();\n    axis.maxValue = p.parseFixed();\n    p.skip('uShort', 1);  // reserved for flags; no values defined\n    axis.name = names[p.parseUShort()] || {};\n    return axis;\n}\n\nfunction makeFvarInstance(n, inst, axes, names) {\n    const nameID = addName(inst.name, names);\n    const fields = [\n        {name: 'nameID_' + n, type: 'USHORT', value: nameID},\n        {name: 'flags_' + n, type: 'USHORT', value: 0}\n    ];\n\n    for (let i = 0; i < axes.length; ++i) {\n        const axisTag = axes[i].tag;\n        fields.push({\n            name: 'axis_' + n + ' ' + axisTag,\n            type: 'FIXED',\n            value: inst.coordinates[axisTag] << 16\n        });\n    }\n\n    return fields;\n}\n\nfunction parseFvarInstance(data, start, axes, names) {\n    const inst = {};\n    const p = new src_parse.Parser(data, start);\n    inst.name = names[p.parseUShort()] || {};\n    p.skip('uShort', 1);  // reserved for flags; no values defined\n\n    inst.coordinates = {};\n    for (let i = 0; i < axes.length; ++i) {\n        inst.coordinates[axes[i].tag] = p.parseFixed();\n    }\n\n    return inst;\n}\n\nfunction makeFvarTable(fvar, names) {\n    const result = new src_table.Table('fvar', [\n        {name: 'version', type: 'ULONG', value: 0x10000},\n        {name: 'offsetToData', type: 'USHORT', value: 0},\n        {name: 'countSizePairs', type: 'USHORT', value: 2},\n        {name: 'axisCount', type: 'USHORT', value: fvar.axes.length},\n        {name: 'axisSize', type: 'USHORT', value: 20},\n        {name: 'instanceCount', type: 'USHORT', value: fvar.instances.length},\n        {name: 'instanceSize', type: 'USHORT', value: 4 + fvar.axes.length * 4}\n    ]);\n    result.offsetToData = result.sizeOf();\n\n    for (let i = 0; i < fvar.axes.length; i++) {\n        result.fields = result.fields.concat(makeFvarAxis(i, fvar.axes[i], names));\n    }\n\n    for (let j = 0; j < fvar.instances.length; j++) {\n        result.fields = result.fields.concat(makeFvarInstance(j, fvar.instances[j], fvar.axes, names));\n    }\n\n    return result;\n}\n\nfunction parseFvarTable(data, start, names) {\n    const p = new src_parse.Parser(data, start);\n    const tableVersion = p.parseULong();\n    check.argument(tableVersion === 0x00010000, 'Unsupported fvar table version.');\n    const offsetToData = p.parseOffset16();\n    // Skip countSizePairs.\n    p.skip('uShort', 1);\n    const axisCount = p.parseUShort();\n    const axisSize = p.parseUShort();\n    const instanceCount = p.parseUShort();\n    const instanceSize = p.parseUShort();\n\n    const axes = [];\n    for (let i = 0; i < axisCount; i++) {\n        axes.push(parseFvarAxis(data, start + offsetToData + i * axisSize, names));\n    }\n\n    const instances = [];\n    const instanceStart = start + offsetToData + axisCount * axisSize;\n    for (let j = 0; j < instanceCount; j++) {\n        instances.push(parseFvarInstance(data, instanceStart + j * instanceSize, axes, names));\n    }\n\n    return {axes: axes, instances: instances};\n}\n\n/* harmony default export */ var tables_fvar = ({ make: makeFvarTable, parse: parseFvarTable });\n\n// CONCATENATED MODULE: ./node_modules/opentype.js/src/tables/gpos.js\n// The `GPOS` table contains kerning pairs, among other things.\n// https://www.microsoft.com/typography/OTSPEC/gpos.htm\n\n\n\n\n// Parse ScriptList and FeatureList tables of GPOS, GSUB, GDEF, BASE, JSTF tables.\n// These lists are unused by now, this function is just the basis for a real parsing.\nfunction parseTaggedListTable(data, start) {\n    const p = new src_parse.Parser(data, start);\n    const n = p.parseUShort();\n    const list = [];\n    for (let i = 0; i < n; i++) {\n        list[p.parseTag()] = { offset: p.parseUShort() };\n    }\n\n    return list;\n}\n\n// Parse a coverage table in a GSUB, GPOS or GDEF table.\n// Format 1 is a simple list of glyph ids,\n// Format 2 is a list of ranges. It is expanded in a list of glyphs, maybe not the best idea.\nfunction parseCoverageTable(data, start) {\n    const p = new src_parse.Parser(data, start);\n    const format = p.parseUShort();\n    let count = p.parseUShort();\n    if (format === 1) {\n        return p.parseUShortList(count);\n    } else if (format === 2) {\n        const coverage = [];\n        for (; count--;) {\n            const begin = p.parseUShort();\n            const end = p.parseUShort();\n            let index = p.parseUShort();\n            for (let i = begin; i <= end; i++) {\n                coverage[index++] = i;\n            }\n        }\n\n        return coverage;\n    }\n}\n\n// Parse a Class Definition Table in a GSUB, GPOS or GDEF table.\n// Returns a function that gets a class value from a glyph ID.\nfunction parseClassDefTable(data, start) {\n    const p = new src_parse.Parser(data, start);\n    const format = p.parseUShort();\n    if (format === 1) {\n        // Format 1 specifies a range of consecutive glyph indices, one class per glyph ID.\n        const startGlyph = p.parseUShort();\n        const glyphCount = p.parseUShort();\n        const classes = p.parseUShortList(glyphCount);\n        return function(glyphID) {\n            return classes[glyphID - startGlyph] || 0;\n        };\n    } else if (format === 2) {\n        // Format 2 defines multiple groups of glyph indices that belong to the same class.\n        const rangeCount = p.parseUShort();\n        const startGlyphs = [];\n        const endGlyphs = [];\n        const classValues = [];\n        for (let i = 0; i < rangeCount; i++) {\n            startGlyphs[i] = p.parseUShort();\n            endGlyphs[i] = p.parseUShort();\n            classValues[i] = p.parseUShort();\n        }\n\n        return function(glyphID) {\n            let l = 0;\n            let r = startGlyphs.length - 1;\n            while (l < r) {\n                const c = (l + r + 1) >> 1;\n                if (glyphID < startGlyphs[c]) {\n                    r = c - 1;\n                } else {\n                    l = c;\n                }\n            }\n\n            if (startGlyphs[l] <= glyphID && glyphID <= endGlyphs[l]) {\n                return classValues[l] || 0;\n            }\n\n            return 0;\n        };\n    }\n}\n\n// Parse a pair adjustment positioning subtable, format 1 or format 2\n// The subtable is returned in the form of a lookup function.\nfunction parsePairPosSubTable(data, start) {\n    const p = new src_parse.Parser(data, start);\n    // This part is common to format 1 and format 2 subtables\n    const format = p.parseUShort();\n    const coverageOffset = p.parseUShort();\n    const coverage = parseCoverageTable(data, start + coverageOffset);\n    // valueFormat 4: XAdvance only, 1: XPlacement only, 0: no ValueRecord for second glyph\n    // Only valueFormat1=4 and valueFormat2=0 is supported.\n    const valueFormat1 = p.parseUShort();\n    const valueFormat2 = p.parseUShort();\n    let value1;\n    let value2;\n    if (valueFormat1 !== 4 || valueFormat2 !== 0) return;\n    const sharedPairSets = {};\n    if (format === 1) {\n        // Pair Positioning Adjustment: Format 1\n        const pairSetCount = p.parseUShort();\n        const pairSet = [];\n        // Array of offsets to PairSet tables-from beginning of PairPos subtable-ordered by Coverage Index\n        const pairSetOffsets = p.parseOffset16List(pairSetCount);\n        for (let firstGlyph = 0; firstGlyph < pairSetCount; firstGlyph++) {\n            const pairSetOffset = pairSetOffsets[firstGlyph];\n            let sharedPairSet = sharedPairSets[pairSetOffset];\n            if (!sharedPairSet) {\n                // Parse a pairset table in a pair adjustment subtable format 1\n                sharedPairSet = {};\n                p.relativeOffset = pairSetOffset;\n                let pairValueCount = p.parseUShort();\n                for (; pairValueCount--;) {\n                    const secondGlyph = p.parseUShort();\n                    if (valueFormat1) value1 = p.parseShort();\n                    if (valueFormat2) value2 = p.parseShort();\n                    // We only support valueFormat1 = 4 and valueFormat2 = 0,\n                    // so value1 is the XAdvance and value2 is empty.\n                    sharedPairSet[secondGlyph] = value1;\n                }\n            }\n\n            pairSet[coverage[firstGlyph]] = sharedPairSet;\n        }\n\n        return function(leftGlyph, rightGlyph) {\n            const pairs = pairSet[leftGlyph];\n            if (pairs) return pairs[rightGlyph];\n        };\n    } else if (format === 2) {\n        // Pair Positioning Adjustment: Format 2\n        const classDef1Offset = p.parseUShort();\n        const classDef2Offset = p.parseUShort();\n        const class1Count = p.parseUShort();\n        const class2Count = p.parseUShort();\n        const getClass1 = parseClassDefTable(data, start + classDef1Offset);\n        const getClass2 = parseClassDefTable(data, start + classDef2Offset);\n\n        // Parse kerning values by class pair.\n        const kerningMatrix = [];\n        for (let i = 0; i < class1Count; i++) {\n            const kerningRow = kerningMatrix[i] = [];\n            for (let j = 0; j < class2Count; j++) {\n                if (valueFormat1) value1 = p.parseShort();\n                if (valueFormat2) value2 = p.parseShort();\n                // We only support valueFormat1 = 4 and valueFormat2 = 0,\n                // so value1 is the XAdvance and value2 is empty.\n                kerningRow[j] = value1;\n            }\n        }\n\n        // Convert coverage list to a hash\n        const covered = {};\n        for (let i = 0; i < coverage.length; i++) {\n            covered[coverage[i]] = 1;\n        }\n\n        // Get the kerning value for a specific glyph pair.\n        return function(leftGlyph, rightGlyph) {\n            if (!covered[leftGlyph]) return;\n            const class1 = getClass1(leftGlyph);\n            const class2 = getClass2(rightGlyph);\n            const kerningRow = kerningMatrix[class1];\n\n            if (kerningRow) {\n                return kerningRow[class2];\n            }\n        };\n    }\n}\n\n// Parse a LookupTable (present in of GPOS, GSUB, GDEF, BASE, JSTF tables).\nfunction parseLookupTable(data, start) {\n    const p = new src_parse.Parser(data, start);\n    const lookupType = p.parseUShort();\n    const lookupFlag = p.parseUShort();\n    const useMarkFilteringSet = lookupFlag & 0x10;\n    const subTableCount = p.parseUShort();\n    const subTableOffsets = p.parseOffset16List(subTableCount);\n    const table = {\n        lookupType: lookupType,\n        lookupFlag: lookupFlag,\n        markFilteringSet: useMarkFilteringSet ? p.parseUShort() : -1\n    };\n    // LookupType 2, Pair adjustment\n    if (lookupType === 2) {\n        const subtables = [];\n        for (let i = 0; i < subTableCount; i++) {\n            const pairPosSubTable = parsePairPosSubTable(data, start + subTableOffsets[i]);\n            if (pairPosSubTable) subtables.push(pairPosSubTable);\n        }\n        // Return a function which finds the kerning values in the subtables.\n        table.getKerningValue = function(leftGlyph, rightGlyph) {\n            for (let i = subtables.length; i--;) {\n                const value = subtables[i](leftGlyph, rightGlyph);\n                if (value !== undefined) return value;\n            }\n\n            return 0;\n        };\n    }\n\n    return table;\n}\n\n// Parse the `GPOS` table which contains, among other things, kerning pairs.\n// https://www.microsoft.com/typography/OTSPEC/gpos.htm\nfunction parseGposTable(data, start, font) {\n    const p = new src_parse.Parser(data, start);\n    const tableVersion = p.parseFixed();\n    check.argument(tableVersion === 1, 'Unsupported GPOS table version.');\n\n    // ScriptList and FeatureList - ignored for now\n    parseTaggedListTable(data, start + p.parseUShort());\n    // 'kern' is the feature we are looking for.\n    parseTaggedListTable(data, start + p.parseUShort());\n\n    // LookupList\n    const lookupListOffset = p.parseUShort();\n    p.relativeOffset = lookupListOffset;\n    const lookupCount = p.parseUShort();\n    const lookupTableOffsets = p.parseOffset16List(lookupCount);\n    const lookupListAbsoluteOffset = start + lookupListOffset;\n    for (let i = 0; i < lookupCount; i++) {\n        const table = parseLookupTable(data, lookupListAbsoluteOffset + lookupTableOffsets[i]);\n        if (table.lookupType === 2 && !font.getGposKerningValue) font.getGposKerningValue = table.getKerningValue;\n    }\n}\n\n/* harmony default export */ var gpos = ({ parse: parseGposTable });\n\n// CONCATENATED MODULE: ./node_modules/opentype.js/src/tables/kern.js\n// The `kern` table contains kerning pairs.\n// Note that some fonts use the GPOS OpenType layout table to specify kerning.\n// https://www.microsoft.com/typography/OTSPEC/kern.htm\n\n\n\n\nfunction parseWindowsKernTable(p) {\n    const pairs = {};\n    // Skip nTables.\n    p.skip('uShort');\n    const subtableVersion = p.parseUShort();\n    check.argument(subtableVersion === 0, 'Unsupported kern sub-table version.');\n    // Skip subtableLength, subtableCoverage\n    p.skip('uShort', 2);\n    const nPairs = p.parseUShort();\n    // Skip searchRange, entrySelector, rangeShift.\n    p.skip('uShort', 3);\n    for (let i = 0; i < nPairs; i += 1) {\n        const leftIndex = p.parseUShort();\n        const rightIndex = p.parseUShort();\n        const value = p.parseShort();\n        pairs[leftIndex + ',' + rightIndex] = value;\n    }\n    return pairs;\n}\n\nfunction parseMacKernTable(p) {\n    const pairs = {};\n    // The Mac kern table stores the version as a fixed (32 bits) but we only loaded the first 16 bits.\n    // Skip the rest.\n    p.skip('uShort');\n    const nTables = p.parseULong();\n    //check.argument(nTables === 1, 'Only 1 subtable is supported (got ' + nTables + ').');\n    if (nTables > 1) {\n        console.warn('Only the first kern subtable is supported.');\n    }\n    p.skip('uLong');\n    const coverage = p.parseUShort();\n    const subtableVersion = coverage & 0xFF;\n    p.skip('uShort');\n    if (subtableVersion === 0) {\n        const nPairs = p.parseUShort();\n        // Skip searchRange, entrySelector, rangeShift.\n        p.skip('uShort', 3);\n        for (let i = 0; i < nPairs; i += 1) {\n            const leftIndex = p.parseUShort();\n            const rightIndex = p.parseUShort();\n            const value = p.parseShort();\n            pairs[leftIndex + ',' + rightIndex] = value;\n        }\n    }\n    return pairs;\n}\n\n// Parse the `kern` table which contains kerning pairs.\nfunction parseKernTable(data, start) {\n    const p = new src_parse.Parser(data, start);\n    const tableVersion = p.parseUShort();\n    if (tableVersion === 0) {\n        return parseWindowsKernTable(p);\n    } else if (tableVersion === 1) {\n        return parseMacKernTable(p);\n    } else {\n        throw new Error('Unsupported kern table version (' + tableVersion + ').');\n    }\n}\n\n/* harmony default export */ var kern = ({ parse: parseKernTable });\n\n// CONCATENATED MODULE: ./node_modules/opentype.js/src/tables/loca.js\n// The `loca` table stores the offsets to the locations of the glyphs in the font.\n// https://www.microsoft.com/typography/OTSPEC/loca.htm\n\n\n\n// Parse the `loca` table. This table stores the offsets to the locations of the glyphs in the font,\n// relative to the beginning of the glyphData table.\n// The number of glyphs stored in the `loca` table is specified in the `maxp` table (under numGlyphs)\n// The loca table has two versions: a short version where offsets are stored as uShorts, and a long\n// version where offsets are stored as uLongs. The `head` table specifies which version to use\n// (under indexToLocFormat).\nfunction parseLocaTable(data, start, numGlyphs, shortVersion) {\n    const p = new src_parse.Parser(data, start);\n    const parseFn = shortVersion ? p.parseUShort : p.parseULong;\n    // There is an extra entry after the last index element to compute the length of the last glyph.\n    // That's why we use numGlyphs + 1.\n    const glyphOffsets = [];\n    for (let i = 0; i < numGlyphs + 1; i += 1) {\n        let glyphOffset = parseFn.call(p);\n        if (shortVersion) {\n            // The short table version stores the actual offset divided by 2.\n            glyphOffset *= 2;\n        }\n\n        glyphOffsets.push(glyphOffset);\n    }\n\n    return glyphOffsets;\n}\n\n/* harmony default export */ var tables_loca = ({ parse: parseLocaTable });\n\n// CONCATENATED MODULE: ./node_modules/opentype.js/src/opentype.js\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"parse\", function() { return parseBuffer; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"load\", function() { return load; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"loadSync\", function() { return loadSync; });\n/* concated harmony reexport Font */__webpack_require__.d(__webpack_exports__, \"Font\", function() { return src_font; });\n/* concated harmony reexport Glyph */__webpack_require__.d(__webpack_exports__, \"Glyph\", function() { return src_glyph; });\n/* concated harmony reexport Path */__webpack_require__.d(__webpack_exports__, \"Path\", function() { return src_path; });\n/* concated harmony reexport BoundingBox */__webpack_require__.d(__webpack_exports__, \"BoundingBox\", function() { return bbox; });\n/* concated harmony reexport _parse */__webpack_require__.d(__webpack_exports__, \"_parse\", function() { return src_parse; });\n// opentype.js\n// https://github.com/nodebox/opentype.js\n// (c) 2015 Frederik De Bleser\n// opentype.js may be freely distributed under the MIT license.\n\n/* global DataView, Uint8Array, XMLHttpRequest  */\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * The opentype library.\n * @namespace opentype\n */\n\n// File loaders /////////////////////////////////////////////////////////\n/**\n * Loads a font from a file. The callback throws an error message as the first parameter if it fails\n * and the font as an ArrayBuffer in the second parameter if it succeeds.\n * @param  {string} path - The path of the file\n * @param  {Function} callback - The function to call when the font load completes\n */\nfunction loadFromFile(path, callback) {\n    const fs = __webpack_require__(1);\n    fs.readFile(path, function(err, buffer) {\n        if (err) {\n            return callback(err.message);\n        }\n\n        callback(null, Object(util[\"d\" /* nodeBufferToArrayBuffer */])(buffer));\n    });\n}\n/**\n * Loads a font from a URL. The callback throws an error message as the first parameter if it fails\n * and the font as an ArrayBuffer in the second parameter if it succeeds.\n * @param  {string} url - The URL of the font file.\n * @param  {Function} callback - The function to call when the font load completes\n */\nfunction loadFromUrl(url, callback) {\n    const request = new XMLHttpRequest();\n    request.open('get', url, true);\n    request.responseType = 'arraybuffer';\n    request.onload = function() {\n        if (request.status !== 200) {\n            return callback('Font could not be loaded: ' + request.statusText);\n        }\n\n        return callback(null, request.response);\n    };\n\n    request.onerror = function () {\n        callback('Font could not be loaded');\n    };\n\n    request.send();\n}\n\n// Table Directory Entries //////////////////////////////////////////////\n/**\n * Parses OpenType table entries.\n * @param  {DataView}\n * @param  {Number}\n * @return {Object[]}\n */\nfunction parseOpenTypeTableEntries(data, numTables) {\n    const tableEntries = [];\n    let p = 12;\n    for (let i = 0; i < numTables; i += 1) {\n        const tag = src_parse.getTag(data, p);\n        const checksum = src_parse.getULong(data, p + 4);\n        const offset = src_parse.getULong(data, p + 8);\n        const length = src_parse.getULong(data, p + 12);\n        tableEntries.push({tag: tag, checksum: checksum, offset: offset, length: length, compression: false});\n        p += 16;\n    }\n\n    return tableEntries;\n}\n\n/**\n * Parses WOFF table entries.\n * @param  {DataView}\n * @param  {Number}\n * @return {Object[]}\n */\nfunction parseWOFFTableEntries(data, numTables) {\n    const tableEntries = [];\n    let p = 44; // offset to the first table directory entry.\n    for (let i = 0; i < numTables; i += 1) {\n        const tag = src_parse.getTag(data, p);\n        const offset = src_parse.getULong(data, p + 4);\n        const compLength = src_parse.getULong(data, p + 8);\n        const origLength = src_parse.getULong(data, p + 12);\n        let compression;\n        if (compLength < origLength) {\n            compression = 'WOFF';\n        } else {\n            compression = false;\n        }\n\n        tableEntries.push({tag: tag, offset: offset, compression: compression,\n            compressedLength: compLength, length: origLength});\n        p += 20;\n    }\n\n    return tableEntries;\n}\n\n/**\n * @typedef TableData\n * @type Object\n * @property {DataView} data - The DataView\n * @property {number} offset - The data offset.\n */\n\n/**\n * @param  {DataView}\n * @param  {Object}\n * @return {TableData}\n */\nfunction uncompressTable(data, tableEntry) {\n    if (tableEntry.compression === 'WOFF') {\n        const inBuffer = new Uint8Array(data.buffer, tableEntry.offset + 2, tableEntry.compressedLength - 2);\n        const outBuffer = new Uint8Array(tableEntry.length);\n        tiny_inflate_default()(inBuffer, outBuffer);\n        if (outBuffer.byteLength !== tableEntry.length) {\n            throw new Error('Decompression error: ' + tableEntry.tag + ' decompressed length doesn\\'t match recorded length');\n        }\n\n        const view = new DataView(outBuffer.buffer, 0);\n        return {data: view, offset: 0};\n    } else {\n        return {data: data, offset: tableEntry.offset};\n    }\n}\n\n// Public API ///////////////////////////////////////////////////////////\n\n/**\n * Parse the OpenType file data (as an ArrayBuffer) and return a Font object.\n * Throws an error if the font could not be parsed.\n * @param  {ArrayBuffer}\n * @return {opentype.Font}\n */\nfunction parseBuffer(buffer) {\n    let indexToLocFormat;\n    let ltagTable;\n\n    // Since the constructor can also be called to create new fonts from scratch, we indicate this\n    // should be an empty font that we'll fill with our own data.\n    const font = new src_font({empty: true});\n\n    // OpenType fonts use big endian byte ordering.\n    // We can't rely on typed array view types, because they operate with the endianness of the host computer.\n    // Instead we use DataViews where we can specify endianness.\n    const data = new DataView(buffer, 0);\n    let numTables;\n    let tableEntries = [];\n    const signature = src_parse.getTag(data, 0);\n    if (signature === String.fromCharCode(0, 1, 0, 0) || signature === 'true' || signature === 'typ1') {\n        font.outlinesFormat = 'truetype';\n        numTables = src_parse.getUShort(data, 4);\n        tableEntries = parseOpenTypeTableEntries(data, numTables);\n    } else if (signature === 'OTTO') {\n        font.outlinesFormat = 'cff';\n        numTables = src_parse.getUShort(data, 4);\n        tableEntries = parseOpenTypeTableEntries(data, numTables);\n    } else if (signature === 'wOFF') {\n        const flavor = src_parse.getTag(data, 4);\n        if (flavor === String.fromCharCode(0, 1, 0, 0)) {\n            font.outlinesFormat = 'truetype';\n        } else if (flavor === 'OTTO') {\n            font.outlinesFormat = 'cff';\n        } else {\n            throw new Error('Unsupported OpenType flavor ' + signature);\n        }\n\n        numTables = src_parse.getUShort(data, 12);\n        tableEntries = parseWOFFTableEntries(data, numTables);\n    } else {\n        throw new Error('Unsupported OpenType signature ' + signature);\n    }\n\n    let cffTableEntry;\n    let fvarTableEntry;\n    let glyfTableEntry;\n    let gposTableEntry;\n    let gsubTableEntry;\n    let hmtxTableEntry;\n    let kernTableEntry;\n    let locaTableEntry;\n    let nameTableEntry;\n    let metaTableEntry;\n    let p;\n\n    for (let i = 0; i < numTables; i += 1) {\n        const tableEntry = tableEntries[i];\n        let table;\n        switch (tableEntry.tag) {\n            case 'cmap':\n                table = uncompressTable(data, tableEntry);\n                font.tables.cmap = tables_cmap.parse(table.data, table.offset);\n                font.encoding = new CmapEncoding(font.tables.cmap);\n                break;\n            case 'cvt ' :\n                table = uncompressTable(data, tableEntry);\n                p = new src_parse.Parser(table.data, table.offset);\n                font.tables.cvt = p.parseShortList(tableEntry.length / 2);\n                break;\n            case 'fvar':\n                fvarTableEntry = tableEntry;\n                break;\n            case 'fpgm' :\n                table = uncompressTable(data, tableEntry);\n                p = new src_parse.Parser(table.data, table.offset);\n                font.tables.fpgm = p.parseByteList(tableEntry.length);\n                break;\n            case 'head':\n                table = uncompressTable(data, tableEntry);\n                font.tables.head = tables_head.parse(table.data, table.offset);\n                font.unitsPerEm = font.tables.head.unitsPerEm;\n                indexToLocFormat = font.tables.head.indexToLocFormat;\n                break;\n            case 'hhea':\n                table = uncompressTable(data, tableEntry);\n                font.tables.hhea = tables_hhea.parse(table.data, table.offset);\n                font.ascender = font.tables.hhea.ascender;\n                font.descender = font.tables.hhea.descender;\n                font.numberOfHMetrics = font.tables.hhea.numberOfHMetrics;\n                break;\n            case 'hmtx':\n                hmtxTableEntry = tableEntry;\n                break;\n            case 'ltag':\n                table = uncompressTable(data, tableEntry);\n                ltagTable = tables_ltag.parse(table.data, table.offset);\n                break;\n            case 'maxp':\n                table = uncompressTable(data, tableEntry);\n                font.tables.maxp = tables_maxp.parse(table.data, table.offset);\n                font.numGlyphs = font.tables.maxp.numGlyphs;\n                break;\n            case 'name':\n                nameTableEntry = tableEntry;\n                break;\n            case 'OS/2':\n                table = uncompressTable(data, tableEntry);\n                font.tables.os2 = tables_os2.parse(table.data, table.offset);\n                break;\n            case 'post':\n                table = uncompressTable(data, tableEntry);\n                font.tables.post = tables_post.parse(table.data, table.offset);\n                font.glyphNames = new GlyphNames(font.tables.post);\n                break;\n            case 'prep' :\n                table = uncompressTable(data, tableEntry);\n                p = new src_parse.Parser(table.data, table.offset);\n                font.tables.prep = p.parseByteList(tableEntry.length);\n                break;\n            case 'glyf':\n                glyfTableEntry = tableEntry;\n                break;\n            case 'loca':\n                locaTableEntry = tableEntry;\n                break;\n            case 'CFF ':\n                cffTableEntry = tableEntry;\n                break;\n            case 'kern':\n                kernTableEntry = tableEntry;\n                break;\n            case 'GPOS':\n                gposTableEntry = tableEntry;\n                break;\n            case 'GSUB':\n                gsubTableEntry = tableEntry;\n                break;\n            case 'meta':\n                metaTableEntry = tableEntry;\n                break;\n        }\n    }\n\n    const nameTable = uncompressTable(data, nameTableEntry);\n    font.tables.name = tables_name.parse(nameTable.data, nameTable.offset, ltagTable);\n    font.names = font.tables.name;\n\n    if (glyfTableEntry && locaTableEntry) {\n        const shortVersion = indexToLocFormat === 0;\n        const locaTable = uncompressTable(data, locaTableEntry);\n        const locaOffsets = tables_loca.parse(locaTable.data, locaTable.offset, font.numGlyphs, shortVersion);\n        const glyfTable = uncompressTable(data, glyfTableEntry);\n        font.glyphs = glyf.parse(glyfTable.data, glyfTable.offset, locaOffsets, font);\n    } else if (cffTableEntry) {\n        const cffTable = uncompressTable(data, cffTableEntry);\n        cff.parse(cffTable.data, cffTable.offset, font);\n    } else {\n        throw new Error('Font doesn\\'t contain TrueType or CFF outlines.');\n    }\n\n    const hmtxTable = uncompressTable(data, hmtxTableEntry);\n    hmtx.parse(hmtxTable.data, hmtxTable.offset, font.numberOfHMetrics, font.numGlyphs, font.glyphs);\n    addGlyphNames(font);\n\n    if (kernTableEntry) {\n        const kernTable = uncompressTable(data, kernTableEntry);\n        font.kerningPairs = kern.parse(kernTable.data, kernTable.offset);\n    } else {\n        font.kerningPairs = {};\n    }\n\n    if (gposTableEntry) {\n        const gposTable = uncompressTable(data, gposTableEntry);\n        gpos.parse(gposTable.data, gposTable.offset, font);\n    }\n\n    if (gsubTableEntry) {\n        const gsubTable = uncompressTable(data, gsubTableEntry);\n        font.tables.gsub = tables_gsub.parse(gsubTable.data, gsubTable.offset);\n    }\n\n    if (fvarTableEntry) {\n        const fvarTable = uncompressTable(data, fvarTableEntry);\n        font.tables.fvar = tables_fvar.parse(fvarTable.data, fvarTable.offset, font.names);\n    }\n\n    if (metaTableEntry) {\n        const metaTable = uncompressTable(data, metaTableEntry);\n        font.tables.meta = meta.parse(metaTable.data, metaTable.offset);\n        font.metas = font.tables.meta;\n    }\n\n    return font;\n}\n\n/**\n * Asynchronously load the font from a URL or a filesystem. When done, call the callback\n * with two arguments `(err, font)`. The `err` will be null on success,\n * the `font` is a Font object.\n * We use the node.js callback convention so that\n * opentype.js can integrate with frameworks like async.js.\n * @alias opentype.load\n * @param  {string} url - The URL of the font to load.\n * @param  {Function} callback - The callback.\n */\nfunction load(url, callback) {\n    const isNode = typeof window === 'undefined';\n    const loadFn = isNode ? loadFromFile : loadFromUrl;\n    loadFn(url, function(err, arrayBuffer) {\n        if (err) {\n            return callback(err);\n        }\n        let font;\n        try {\n            font = parseBuffer(arrayBuffer);\n        } catch (e) {\n            return callback(e, null);\n        }\n        return callback(null, font);\n    });\n}\n\n/**\n * Synchronously load the font from a URL or file.\n * When done, returns the font object or throws an error.\n * @alias opentype.loadSync\n * @param  {string} url - The URL of the font to load.\n * @return {opentype.Font}\n */\nfunction loadSync(url) {\n    const fs = __webpack_require__(1);\n    const buffer = fs.readFileSync(url);\n    return parseBuffer(Object(util[\"d\" /* nodeBufferToArrayBuffer */])(buffer));\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Xcml0aW5nQW5pbWF0aW9uLy4vbm9kZV9tb2R1bGVzL29wZW50eXBlLmpzL3NyYy9iYm94LmpzPzM4M2EiLCJ3ZWJwYWNrOi8vV3JpdGluZ0FuaW1hdGlvbi8uL25vZGVfbW9kdWxlcy9vcGVudHlwZS5qcy9zcmMvcGF0aC5qcz8zYWY5Iiwid2VicGFjazovL1dyaXRpbmdBbmltYXRpb24vLi9ub2RlX21vZHVsZXMvb3BlbnR5cGUuanMvc3JjL2NoZWNrLmpzPzgyZmEiLCJ3ZWJwYWNrOi8vV3JpdGluZ0FuaW1hdGlvbi8uL25vZGVfbW9kdWxlcy9vcGVudHlwZS5qcy9zcmMvdHlwZXMuanM/MGI5OSIsIndlYnBhY2s6Ly9Xcml0aW5nQW5pbWF0aW9uLy4vbm9kZV9tb2R1bGVzL29wZW50eXBlLmpzL3NyYy90YWJsZS5qcz9mMTAwIiwid2VicGFjazovL1dyaXRpbmdBbmltYXRpb24vLi9ub2RlX21vZHVsZXMvb3BlbnR5cGUuanMvc3JjL3BhcnNlLmpzPzNhYmIiLCJ3ZWJwYWNrOi8vV3JpdGluZ0FuaW1hdGlvbi8uL25vZGVfbW9kdWxlcy9vcGVudHlwZS5qcy9zcmMvdGFibGVzL2NtYXAuanM/NDhhNSIsIndlYnBhY2s6Ly9Xcml0aW5nQW5pbWF0aW9uLy4vbm9kZV9tb2R1bGVzL29wZW50eXBlLmpzL3NyYy9lbmNvZGluZy5qcz83MDQwIiwid2VicGFjazovL1dyaXRpbmdBbmltYXRpb24vLi9ub2RlX21vZHVsZXMvb3BlbnR5cGUuanMvc3JjL2RyYXcuanM/YzZlYiIsIndlYnBhY2s6Ly9Xcml0aW5nQW5pbWF0aW9uLy4vbm9kZV9tb2R1bGVzL29wZW50eXBlLmpzL3NyYy90YWJsZXMvZ2x5Zi5qcz80MmRmIiwid2VicGFjazovL1dyaXRpbmdBbmltYXRpb24vLi9ub2RlX21vZHVsZXMvb3BlbnR5cGUuanMvc3JjL2dseXBoLmpzPzVmYTciLCJ3ZWJwYWNrOi8vV3JpdGluZ0FuaW1hdGlvbi8uL25vZGVfbW9kdWxlcy9vcGVudHlwZS5qcy9zcmMvZ2x5cGhzZXQuanM/MWU5NiIsIndlYnBhY2s6Ly9Xcml0aW5nQW5pbWF0aW9uLy4vbm9kZV9tb2R1bGVzL29wZW50eXBlLmpzL3NyYy90YWJsZXMvY2ZmLmpzPzY1M2QiLCJ3ZWJwYWNrOi8vV3JpdGluZ0FuaW1hdGlvbi8uL25vZGVfbW9kdWxlcy9vcGVudHlwZS5qcy9zcmMvdGFibGVzL2hlYWQuanM/YjhiZCIsIndlYnBhY2s6Ly9Xcml0aW5nQW5pbWF0aW9uLy4vbm9kZV9tb2R1bGVzL29wZW50eXBlLmpzL3NyYy90YWJsZXMvaGhlYS5qcz84NzYzIiwid2VicGFjazovL1dyaXRpbmdBbmltYXRpb24vLi9ub2RlX21vZHVsZXMvb3BlbnR5cGUuanMvc3JjL3RhYmxlcy9obXR4LmpzPzEyNWEiLCJ3ZWJwYWNrOi8vV3JpdGluZ0FuaW1hdGlvbi8uL25vZGVfbW9kdWxlcy9vcGVudHlwZS5qcy9zcmMvdGFibGVzL2x0YWcuanM/ZGI4OSIsIndlYnBhY2s6Ly9Xcml0aW5nQW5pbWF0aW9uLy4vbm9kZV9tb2R1bGVzL29wZW50eXBlLmpzL3NyYy90YWJsZXMvbWF4cC5qcz83YzFjIiwid2VicGFjazovL1dyaXRpbmdBbmltYXRpb24vLi9ub2RlX21vZHVsZXMvb3BlbnR5cGUuanMvc3JjL3RhYmxlcy9uYW1lLmpzPzhmODYiLCJ3ZWJwYWNrOi8vV3JpdGluZ0FuaW1hdGlvbi8uL25vZGVfbW9kdWxlcy9vcGVudHlwZS5qcy9zcmMvdGFibGVzL29zMi5qcz9iOWVhIiwid2VicGFjazovL1dyaXRpbmdBbmltYXRpb24vLi9ub2RlX21vZHVsZXMvb3BlbnR5cGUuanMvc3JjL3RhYmxlcy9wb3N0LmpzPzdkZDYiLCJ3ZWJwYWNrOi8vV3JpdGluZ0FuaW1hdGlvbi8uL25vZGVfbW9kdWxlcy9vcGVudHlwZS5qcy9zcmMvdGFibGVzL2dzdWIuanM/ZThlNCIsIndlYnBhY2s6Ly9Xcml0aW5nQW5pbWF0aW9uLy4vbm9kZV9tb2R1bGVzL29wZW50eXBlLmpzL3NyYy90YWJsZXMvbWV0YS5qcz8wMTAxIiwid2VicGFjazovL1dyaXRpbmdBbmltYXRpb24vLi9ub2RlX21vZHVsZXMvb3BlbnR5cGUuanMvc3JjL3RhYmxlcy9zZm50LmpzPzllY2MiLCJ3ZWJwYWNrOi8vV3JpdGluZ0FuaW1hdGlvbi8uL25vZGVfbW9kdWxlcy9vcGVudHlwZS5qcy9zcmMvbGF5b3V0LmpzPzZiMTYiLCJ3ZWJwYWNrOi8vV3JpdGluZ0FuaW1hdGlvbi8uL25vZGVfbW9kdWxlcy9vcGVudHlwZS5qcy9zcmMvc3Vic3RpdHV0aW9uLmpzP2M4N2QiLCJ3ZWJwYWNrOi8vV3JpdGluZ0FuaW1hdGlvbi8uL25vZGVfbW9kdWxlcy9vcGVudHlwZS5qcy9zcmMvaGludGluZ3R0LmpzPzRlYjkiLCJ3ZWJwYWNrOi8vV3JpdGluZ0FuaW1hdGlvbi8uL25vZGVfbW9kdWxlcy9vcGVudHlwZS5qcy9zcmMvZm9udC5qcz9lZWNiIiwid2VicGFjazovL1dyaXRpbmdBbmltYXRpb24vLi9ub2RlX21vZHVsZXMvb3BlbnR5cGUuanMvc3JjL3RhYmxlcy9mdmFyLmpzPzQzZWQiLCJ3ZWJwYWNrOi8vV3JpdGluZ0FuaW1hdGlvbi8uL25vZGVfbW9kdWxlcy9vcGVudHlwZS5qcy9zcmMvdGFibGVzL2dwb3MuanM/MDU0MyIsIndlYnBhY2s6Ly9Xcml0aW5nQW5pbWF0aW9uLy4vbm9kZV9tb2R1bGVzL29wZW50eXBlLmpzL3NyYy90YWJsZXMva2Vybi5qcz9iMTY4Iiwid2VicGFjazovL1dyaXRpbmdBbmltYXRpb24vLi9ub2RlX21vZHVsZXMvb3BlbnR5cGUuanMvc3JjL3RhYmxlcy9sb2NhLmpzPzViOTEiLCJ3ZWJwYWNrOi8vV3JpdGluZ0FuaW1hdGlvbi8uL25vZGVfbW9kdWxlcy9vcGVudHlwZS5qcy9zcmMvb3BlbnR5cGUuanM/NWY3OCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxtQkFBbUIsUUFBUTtBQUMzQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFZSxvREFBVyxFQUFDOzs7QUM3SjNCOztBQUVpQzs7QUFFakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLE9BQU87QUFDbkIsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBLFlBQVksT0FBTztBQUNuQixZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkIsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQixZQUFZLE9BQU87QUFDbkIsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQixZQUFZLE9BQU87QUFDbkIsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQixZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQixZQUFZLE9BQU87QUFDbkIsWUFBWSxPQUFPO0FBQ25COztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkIsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQixZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBLFlBQVksTUFBTTtBQUNs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QTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVztBQUNYLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVc7QUFDWCxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVztBQUNYLGFBQWE7QUFDYjtBQUNBO0FBQ0EsSUFBSSxLQUFLO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXO0FBQ1gsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFF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Q0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQSxlQUFlLFdBQVc7QUFDMUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUyxzQkFBa0I7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsUUFBSTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNEO0FBQ3RELHNEQUFzRDtBQUN0RCxzREFBc0Q7QUFDdEQsc0RBQXNEO0FBQ3RELHNEQUFzRDtBQUN0RCxzREFBc0Q7QUFDdEQsc0RBQXNEO0FBQ3RELHNEQUFzRDtBQUN0RCxzREFBc0Q7QUFDdEQsc0RBQXNEO0FBQ3RELHNEQUFzRDtBQUN0RCxzREFBc0Q7QUFDdEQsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQsb0NBQW9DO0FBQ3BDLHNEQUFzRDtBQUN0RCxzREFBc0Q7QUFDdEQsc0RBQXNEO0FBQ3RELHNDQUFzQztBQUN0QyxzREFBc0Q7QUFDdEQsc0NBQXNDO0FBQ3RDLHNEQUFzRDtBQUN0RCxvQ0FBb0M7QUFDcEMsb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQsc0RBQXNEO0FBQ3RELHNEQUFzRDtBQUN0RCxzREFBc0Q7QUFDdEQsc0RBQXNEO0FBQ3RELHNDQUFzQztBQUN0QyxzREFBc0Q7QUFDdEQsc0NBQXNDO0FBQ3RDLHNEQUFzRDtBQUN0RCxzREFBc0Q7QUFDdEQsb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQsc0RBQXNEO0FBQ3RELHNEQUFzRDtBQUN0RCxzREFBc0Q7QUFDdEQsc0RBQXNEO0FBQ3RELHNEQUFzRDtBQUN0RCxzREFBc0Q7QUFDdEQsc0RBQXNEO0FBQ3RELHNEQUFzRDtBQUN0RCxzREFBc0Q7QUFDdEQ7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxTQUFLO0FBQ3BCLFNBQVMsa0RBQWtEO0FBQzNELFNBQVM7QUFDVDtBQUNBOztBQUVlLGlEQUFDLDZDQUE2QyxFQUFDOzs7QUN2QzlEO0FBQ0E7O0FBRTBDO0FBQ2I7QUFDQTs7QUFFN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNB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RTdCO0FBQ0EsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSyw2QkFBNkI7QUFDbEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSyw2QkFBNkI7QUFDbEMsS0FBSyw2QkFBNkI7QUFDbEMsS0FBSyw2QkFBNkI7QUFDbEMsS0FBSyw2QkFBNkI7QUFDbEMsS0FBSyw2QkFBNkI7QUFDbEMsS0FBSyw2QkFBNkI7QUFDbEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSyw2QkFBNkI7QUFDbEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFBMkI7QUFDaEMsS0FBSywyQkFB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QUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0MsK0NBQStDOztBQUUvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixpQkFBaUI7QUFDNUM7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsdUJBQXVCO0FBQzlDO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsZ0JBQWdCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDJCQUEyQixlQUFlO0FBQzFDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsbUJBQW1CLFVBQVU7QUFDN0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXO0FBQ1gsV0FBVzs7QUFFWCxtQkFBbUIsVUFBVTtBQUM3Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVCQUF1QixVQUFVO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxzQkFBc0IsaUJBQWlCO0FBQ3ZDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQix3QkFBd0I7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLCtCQUErQix3QkFBd0I7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQixrQkFBa0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLG1CQUFtQixPQUFPO0FBQzFCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxtQkFBbUIsVUFBVTtBQUM3QixtQkFBbUI7O0FBRW5CO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakMsaUNBQWlDO0FBQ2pDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFVBQVU7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsbUJBQW1CLE9BQU87O0FBRTFCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsbUJBQW1CLE9BQU87QUFDMUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLG1CQUFtQixPQUFPO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxtQkFBbUIsT0FBTztBQUMxQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLDRDQUE0QztBQUM1Qyx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxtQkFBbUIsT0FBTzs7QUFFMUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsbUJBQW1CLE9BQU87QUFDMUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFVBQVU7QUFDVixhQUFhO0FBQ2I7O0FBRUE7QUFDQSwyQkFBMkI7O0FBRTNCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVlLHFEQUFPLEVBQUM7O0FBRXZCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7OztBQUlBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOzs7QUFHQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7OztBQUlBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7OztBQUlB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QUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CLFlBQVksU0FBUztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQixZQUFZO0FBQ1o7QUFDQTtBQUNBLGVBQWUsbUJBQU8sQ0FBQyxDQUFJO0FBQzNCO0FBQ0EsdUJBQXVCLCtDQUF1QjtBQUM5Qzs7QUFXRSIsImZpbGUiOiIyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gVGhlIEJvdW5kaW5nIEJveCBvYmplY3RcblxuZnVuY3Rpb24gZGVyaXZlKHYwLCB2MSwgdjIsIHYzLCB0KSB7XG4gICAgcmV0dXJuIE1hdGgucG93KDEgLSB0LCAzKSAqIHYwICtcbiAgICAgICAgMyAqIE1hdGgucG93KDEgLSB0LCAyKSAqIHQgKiB2MSArXG4gICAgICAgIDMgKiAoMSAtIHQpICogTWF0aC5wb3codCwgMikgKiB2MiArXG4gICAgICAgIE1hdGgucG93KHQsIDMpICogdjM7XG59XG4vKipcbiAqIEEgYm91bmRpbmcgYm94IGlzIGFuIGVuY2xvc2luZyBib3ggdGhhdCBkZXNjcmliZXMgdGhlIHNtYWxsZXN0IG1lYXN1cmUgd2l0aGluIHdoaWNoIGFsbCB0aGUgcG9pbnRzIGxpZS5cbiAqIEl0IGlzIHVzZWQgdG8gY2FsY3VsYXRlIHRoZSBib3VuZGluZyBib3ggb2YgYSBnbHlwaCBvciB0ZXh0IHBhdGguXG4gKlxuICogT24gaW5pdGlhbGl6YXRpb24sIHgxL3kxL3gyL3kyIHdpbGwgYmUgTmFOLiBDaGVjayBpZiB0aGUgYm91bmRpbmcgYm94IGlzIGVtcHR5IHVzaW5nIGBpc0VtcHR5KClgLlxuICpcbiAqIEBleHBvcnRzIG9wZW50eXBlLkJvdW5kaW5nQm94XG4gKiBAY2xhc3NcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBCb3VuZGluZ0JveCgpIHtcbiAgICB0aGlzLngxID0gTnVtYmVyLk5hTjtcbiAgICB0aGlzLnkxID0gTnVtYmVyLk5hTjtcbiAgICB0aGlzLngyID0gTnVtYmVyLk5hTjtcbiAgICB0aGlzLnkyID0gTnVtYmVyLk5hTjtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGJvdW5kaW5nIGJveCBpcyBlbXB0eSwgdGhhdCBpcywgbm8gcG9pbnRzIGhhdmUgYmVlbiBhZGRlZCB0byB0aGUgYm94IHlldC5cbiAqL1xuQm91bmRpbmdCb3gucHJvdG90eXBlLmlzRW1wdHkgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gaXNOYU4odGhpcy54MSkgfHwgaXNOYU4odGhpcy55MSkgfHwgaXNOYU4odGhpcy54MikgfHwgaXNOYU4odGhpcy55Mik7XG59O1xuXG4vKipcbiAqIEFkZCB0aGUgcG9pbnQgdG8gdGhlIGJvdW5kaW5nIGJveC5cbiAqIFRoZSB4MS95MS94Mi95MiBjb29yZGluYXRlcyBvZiB0aGUgYm91bmRpbmcgYm94IHdpbGwgbm93IGVuY29tcGFzcyB0aGUgZ2l2ZW4gcG9pbnQuXG4gKiBAcGFyYW0ge251bWJlcn0geCAtIFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIHBvaW50LlxuICogQHBhcmFtIHtudW1iZXJ9IHkgLSBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSBwb2ludC5cbiAqL1xuQm91bmRpbmdCb3gucHJvdG90eXBlLmFkZFBvaW50ID0gZnVuY3Rpb24oeCwgeSkge1xuICAgIGlmICh0eXBlb2YgeCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgaWYgKGlzTmFOKHRoaXMueDEpIHx8IGlzTmFOKHRoaXMueDIpKSB7XG4gICAgICAgICAgICB0aGlzLngxID0geDtcbiAgICAgICAgICAgIHRoaXMueDIgPSB4O1xuICAgICAgICB9XG4gICAgICAgIGlmICh4IDwgdGhpcy54MSkge1xuICAgICAgICAgICAgdGhpcy54MSA9IHg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHggPiB0aGlzLngyKSB7XG4gICAgICAgICAgICB0aGlzLngyID0geDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAodHlwZW9mIHkgPT09ICdudW1iZXInKSB7XG4gICAgICAgIGlmIChpc05hTih0aGlzLnkxKSB8fCBpc05hTih0aGlzLnkyKSkge1xuICAgICAgICAgICAgdGhpcy55MSA9IHk7XG4gICAgICAgICAgICB0aGlzLnkyID0geTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoeSA8IHRoaXMueTEpIHtcbiAgICAgICAgICAgIHRoaXMueTEgPSB5O1xuICAgICAgICB9XG4gICAgICAgIGlmICh5ID4gdGhpcy55Mikge1xuICAgICAgICAgICAgdGhpcy55MiA9IHk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4vKipcbiAqIEFkZCBhIFggY29vcmRpbmF0ZSB0byB0aGUgYm91bmRpbmcgYm94LlxuICogVGhpcyBleHRlbmRzIHRoZSBib3VuZGluZyBib3ggdG8gaW5jbHVkZSB0aGUgWCBjb29yZGluYXRlLlxuICogVGhpcyBmdW5jdGlvbiBpcyB1c2VkIGludGVybmFsbHkgaW5zaWRlIG9mIGFkZEJlemllci5cbiAqIEBwYXJhbSB7bnVtYmVyfSB4IC0gVGhlIFggY29vcmRpbmF0ZSBvZiB0aGUgcG9pbnQuXG4gKi9cbkJvdW5kaW5nQm94LnByb3RvdHlwZS5hZGRYID0gZnVuY3Rpb24oeCkge1xuICAgIHRoaXMuYWRkUG9pbnQoeCwgbnVsbCk7XG59O1xuXG4vKipcbiAqIEFkZCBhIFkgY29vcmRpbmF0ZSB0byB0aGUgYm91bmRpbmcgYm94LlxuICogVGhpcyBleHRlbmRzIHRoZSBib3VuZGluZyBib3ggdG8gaW5jbHVkZSB0aGUgWSBjb29yZGluYXRlLlxuICogVGhpcyBmdW5jdGlvbiBpcyB1c2VkIGludGVybmFsbHkgaW5zaWRlIG9mIGFkZEJlemllci5cbiAqIEBwYXJhbSB7bnVtYmVyfSB5IC0gVGhlIFkgY29vcmRpbmF0ZSBvZiB0aGUgcG9pbnQuXG4gKi9cbkJvdW5kaW5nQm94LnByb3RvdHlwZS5hZGRZID0gZnVuY3Rpb24oeSkge1xuICAgIHRoaXMuYWRkUG9pbnQobnVsbCwgeSk7XG59O1xuXG4vKipcbiAqIEFkZCBhIELDqXppZXIgY3VydmUgdG8gdGhlIGJvdW5kaW5nIGJveC5cbiAqIFRoaXMgZXh0ZW5kcyB0aGUgYm91bmRpbmcgYm94IHRvIGluY2x1ZGUgdGhlIGVudGlyZSBCw6l6aWVyLlxuICogQHBhcmFtIHtudW1iZXJ9IHgwIC0gVGhlIHN0YXJ0aW5nIFggY29vcmRpbmF0ZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB5MCAtIFRoZSBzdGFydGluZyBZIGNvb3JkaW5hdGUuXG4gKiBAcGFyYW0ge251bWJlcn0geDEgLSBUaGUgWCBjb29yZGluYXRlIG9mIHRoZSBmaXJzdCBjb250cm9sIHBvaW50LlxuICogQHBhcmFtIHtudW1iZXJ9IHkxIC0gVGhlIFkgY29vcmRpbmF0ZSBvZiB0aGUgZmlyc3QgY29udHJvbCBwb2ludC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB4MiAtIFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIHNlY29uZCBjb250cm9sIHBvaW50LlxuICogQHBhcmFtIHtudW1iZXJ9IHkyIC0gVGhlIFkgY29vcmRpbmF0ZSBvZiB0aGUgc2Vjb25kIGNvbnRyb2wgcG9pbnQuXG4gKiBAcGFyYW0ge251bWJlcn0geCAtIFRoZSBlbmRpbmcgWCBjb29yZGluYXRlLlxuICogQHBhcmFtIHtudW1iZXJ9IHkgLSBUaGUgZW5kaW5nIFkgY29vcmRpbmF0ZS5cbiAqL1xuQm91bmRpbmdCb3gucHJvdG90eXBlLmFkZEJlemllciA9IGZ1bmN0aW9uKHgwLCB5MCwgeDEsIHkxLCB4MiwgeTIsIHgsIHkpIHtcbiAgICAvLyBUaGlzIGNvZGUgaXMgYmFzZWQgb24gaHR0cDovL25pc2hpb2hpcm9rYXp1LmJsb2dzcG90LmNvbS8yMDA5LzA2L2hvdy10by1jYWxjdWxhdGUtYmV6aWVyLWN1cnZlcy1ib3VuZGluZy5odG1sXG4gICAgLy8gYW5kIGh0dHBzOi8vZ2l0aHViLmNvbS9pY29uczgvc3ZnLXBhdGgtYm91bmRpbmctYm94XG5cbiAgICBjb25zdCBwMCA9IFt4MCwgeTBdO1xuICAgIGNvbnN0IHAxID0gW3gxLCB5MV07XG4gICAgY29uc3QgcDIgPSBbeDIsIHkyXTtcbiAgICBjb25zdCBwMyA9IFt4LCB5XTtcblxuICAgIHRoaXMuYWRkUG9pbnQoeDAsIHkwKTtcbiAgICB0aGlzLmFkZFBvaW50KHgsIHkpO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPD0gMTsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGIgPSA2ICogcDBbaV0gLSAxMiAqIHAxW2ldICsgNiAqIHAyW2ldO1xuICAgICAgICBjb25zdCBhID0gLTMgKiBwMFtpXSArIDkgKiBwMVtpXSAtIDkgKiBwMltpXSArIDMgKiBwM1tpXTtcbiAgICAgICAgY29uc3QgYyA9IDMgKiBwMVtpXSAtIDMgKiBwMFtpXTtcblxuICAgICAgICBpZiAoYSA9PT0gMCkge1xuICAgICAgICAgICAgaWYgKGIgPT09IDApIGNvbnRpbnVlO1xuICAgICAgICAgICAgY29uc3QgdCA9IC1jIC8gYjtcbiAgICAgICAgICAgIGlmICgwIDwgdCAmJiB0IDwgMSkge1xuICAgICAgICAgICAgICAgIGlmIChpID09PSAwKSB0aGlzLmFkZFgoZGVyaXZlKHAwW2ldLCBwMVtpXSwgcDJbaV0sIHAzW2ldLCB0KSk7XG4gICAgICAgICAgICAgICAgaWYgKGkgPT09IDEpIHRoaXMuYWRkWShkZXJpdmUocDBbaV0sIHAxW2ldLCBwMltpXSwgcDNbaV0sIHQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgYjJhYyA9IE1hdGgucG93KGIsIDIpIC0gNCAqIGMgKiBhO1xuICAgICAgICBpZiAoYjJhYyA8IDApIGNvbnRpbnVlO1xuICAgICAgICBjb25zdCB0MSA9ICgtYiArIE1hdGguc3FydChiMmFjKSkgLyAoMiAqIGEpO1xuICAgICAgICBpZiAoMCA8IHQxICYmIHQxIDwgMSkge1xuICAgICAgICAgICAgaWYgKGkgPT09IDApIHRoaXMuYWRkWChkZXJpdmUocDBbaV0sIHAxW2ldLCBwMltpXSwgcDNbaV0sIHQxKSk7XG4gICAgICAgICAgICBpZiAoaSA9PT0gMSkgdGhpcy5hZGRZKGRlcml2ZShwMFtpXSwgcDFbaV0sIHAyW2ldLCBwM1tpXSwgdDEpKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0MiA9ICgtYiAtIE1hdGguc3FydChiMmFjKSkgLyAoMiAqIGEpO1xuICAgICAgICBpZiAoMCA8IHQyICYmIHQyIDwgMSkge1xuICAgICAgICAgICAgaWYgKGkgPT09IDApIHRoaXMuYWRkWChkZXJpdmUocDBbaV0sIHAxW2ldLCBwMltpXSwgcDNbaV0sIHQyKSk7XG4gICAgICAgICAgICBpZiAoaSA9PT0gMSkgdGhpcy5hZGRZKGRlcml2ZShwMFtpXSwgcDFbaV0sIHAyW2ldLCBwM1tpXSwgdDIpKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8qKlxuICogQWRkIGEgcXVhZHJhdGljIGN1cnZlIHRvIHRoZSBib3VuZGluZyBib3guXG4gKiBUaGlzIGV4dGVuZHMgdGhlIGJvdW5kaW5nIGJveCB0byBpbmNsdWRlIHRoZSBlbnRpcmUgcXVhZHJhdGljIGN1cnZlLlxuICogQHBhcmFtIHtudW1iZXJ9IHgwIC0gVGhlIHN0YXJ0aW5nIFggY29vcmRpbmF0ZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB5MCAtIFRoZSBzdGFydGluZyBZIGNvb3JkaW5hdGUuXG4gKiBAcGFyYW0ge251bWJlcn0geDEgLSBUaGUgWCBjb29yZGluYXRlIG9mIHRoZSBjb250cm9sIHBvaW50LlxuICogQHBhcmFtIHtudW1iZXJ9IHkxIC0gVGhlIFkgY29vcmRpbmF0ZSBvZiB0aGUgY29udHJvbCBwb2ludC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB4IC0gVGhlIGVuZGluZyBYIGNvb3JkaW5hdGUuXG4gKiBAcGFyYW0ge251bWJlcn0geSAtIFRoZSBlbmRpbmcgWSBjb29yZGluYXRlLlxuICovXG5Cb3VuZGluZ0JveC5wcm90b3R5cGUuYWRkUXVhZCA9IGZ1bmN0aW9uKHgwLCB5MCwgeDEsIHkxLCB4LCB5KSB7XG4gICAgY29uc3QgY3AxeCA9IHgwICsgMiAvIDMgKiAoeDEgLSB4MCk7XG4gICAgY29uc3QgY3AxeSA9IHkwICsgMiAvIDMgKiAoeTEgLSB5MCk7XG4gICAgY29uc3QgY3AyeCA9IGNwMXggKyAxIC8gMyAqICh4IC0geDApO1xuICAgIGNvbnN0IGNwMnkgPSBjcDF5ICsgMSAvIDMgKiAoeSAtIHkwKTtcbiAgICB0aGlzLmFkZEJlemllcih4MCwgeTAsIGNwMXgsIGNwMXksIGNwMngsIGNwMnksIHgsIHkpO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgQm91bmRpbmdCb3g7XG4iLCIvLyBHZW9tZXRyaWMgb2JqZWN0c1xuXG5pbXBvcnQgQm91bmRpbmdCb3ggZnJvbSAnLi9iYm94JztcblxuLyoqXG4gKiBBIGLDqXppZXIgcGF0aCBjb250YWluaW5nIGEgc2V0IG9mIHBhdGggY29tbWFuZHMgc2ltaWxhciB0byBhIFNWRyBwYXRoLlxuICogUGF0aHMgY2FuIGJlIGRyYXduIG9uIGEgY29udGV4dCB1c2luZyBgZHJhd2AuXG4gKiBAZXhwb3J0cyBvcGVudHlwZS5QYXRoXG4gKiBAY2xhc3NcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBQYXRoKCkge1xuICAgIHRoaXMuY29tbWFuZHMgPSBbXTtcbiAgICB0aGlzLmZpbGwgPSAnYmxhY2snO1xuICAgIHRoaXMuc3Ryb2tlID0gbnVsbDtcbiAgICB0aGlzLnN0cm9rZVdpZHRoID0gMTtcbn1cblxuLyoqXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHhcbiAqIEBwYXJhbSAge251bWJlcn0geVxuICovXG5QYXRoLnByb3RvdHlwZS5tb3ZlVG8gPSBmdW5jdGlvbih4LCB5KSB7XG4gICAgdGhpcy5jb21tYW5kcy5wdXNoKHtcbiAgICAgICAgdHlwZTogJ00nLFxuICAgICAgICB4OiB4LFxuICAgICAgICB5OiB5XG4gICAgfSk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSAge251bWJlcn0geFxuICogQHBhcmFtICB7bnVtYmVyfSB5XG4gKi9cblBhdGgucHJvdG90eXBlLmxpbmVUbyA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICB0aGlzLmNvbW1hbmRzLnB1c2goe1xuICAgICAgICB0eXBlOiAnTCcsXG4gICAgICAgIHg6IHgsXG4gICAgICAgIHk6IHlcbiAgICB9KTtcbn07XG5cbi8qKlxuICogRHJhd3MgY3ViaWMgY3VydmVcbiAqIEBmdW5jdGlvblxuICogY3VydmVUb1xuICogQG1lbWJlcm9mIG9wZW50eXBlLlBhdGgucHJvdG90eXBlXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHgxIC0geCBvZiBjb250cm9sIDFcbiAqIEBwYXJhbSAge251bWJlcn0geTEgLSB5IG9mIGNvbnRyb2wgMVxuICogQHBhcmFtICB7bnVtYmVyfSB4MiAtIHggb2YgY29udHJvbCAyXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHkyIC0geSBvZiBjb250cm9sIDJcbiAqIEBwYXJhbSAge251bWJlcn0geCAtIHggb2YgcGF0aCBwb2ludFxuICogQHBhcmFtICB7bnVtYmVyfSB5IC0geSBvZiBwYXRoIHBvaW50XG4gKi9cblxuLyoqXG4gKiBEcmF3cyBjdWJpYyBjdXJ2ZVxuICogQGZ1bmN0aW9uXG4gKiBiZXppZXJDdXJ2ZVRvXG4gKiBAbWVtYmVyb2Ygb3BlbnR5cGUuUGF0aC5wcm90b3R5cGVcbiAqIEBwYXJhbSAge251bWJlcn0geDEgLSB4IG9mIGNvbnRyb2wgMVxuICogQHBhcmFtICB7bnVtYmVyfSB5MSAtIHkgb2YgY29udHJvbCAxXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHgyIC0geCBvZiBjb250cm9sIDJcbiAqIEBwYXJhbSAge251bWJlcn0geTIgLSB5IG9mIGNvbnRyb2wgMlxuICogQHBhcmFtICB7bnVtYmVyfSB4IC0geCBvZiBwYXRoIHBvaW50XG4gKiBAcGFyYW0gIHtudW1iZXJ9IHkgLSB5IG9mIHBhdGggcG9pbnRcbiAqIEBzZWUgY3VydmVUb1xuICovXG5QYXRoLnByb3RvdHlwZS5jdXJ2ZVRvID0gUGF0aC5wcm90b3R5cGUuYmV6aWVyQ3VydmVUbyA9IGZ1bmN0aW9uKHgxLCB5MSwgeDIsIHkyLCB4LCB5KSB7XG4gICAgdGhpcy5jb21tYW5kcy5wdXNoKHtcbiAgICAgICAgdHlwZTogJ0MnLFxuICAgICAgICB4MTogeDEsXG4gICAgICAgIHkxOiB5MSxcbiAgICAgICAgeDI6IHgyLFxuICAgICAgICB5MjogeTIsXG4gICAgICAgIHg6IHgsXG4gICAgICAgIHk6IHlcbiAgICB9KTtcbn07XG5cbi8qKlxuICogRHJhd3MgcXVhZHJhdGljIGN1cnZlXG4gKiBAZnVuY3Rpb25cbiAqIHF1YWRyYXRpY0N1cnZlVG9cbiAqIEBtZW1iZXJvZiBvcGVudHlwZS5QYXRoLnByb3RvdHlwZVxuICogQHBhcmFtICB7bnVtYmVyfSB4MSAtIHggb2YgY29udHJvbFxuICogQHBhcmFtICB7bnVtYmVyfSB5MSAtIHkgb2YgY29udHJvbFxuICogQHBhcmFtICB7bnVtYmVyfSB4IC0geCBvZiBwYXRoIHBvaW50XG4gKiBAcGFyYW0gIHtudW1iZXJ9IHkgLSB5IG9mIHBhdGggcG9pbnRcbiAqL1xuXG4vKipcbiAqIERyYXdzIHF1YWRyYXRpYyBjdXJ2ZVxuICogQGZ1bmN0aW9uXG4gKiBxdWFkVG9cbiAqIEBtZW1iZXJvZiBvcGVudHlwZS5QYXRoLnByb3RvdHlwZVxuICogQHBhcmFtICB7bnVtYmVyfSB4MSAtIHggb2YgY29udHJvbFxuICogQHBhcmFtICB7bnVtYmVyfSB5MSAtIHkgb2YgY29udHJvbFxuICogQHBhcmFtICB7bnVtYmVyfSB4IC0geCBvZiBwYXRoIHBvaW50XG4gKiBAcGFyYW0gIHtudW1iZXJ9IHkgLSB5IG9mIHBhdGggcG9pbnRcbiAqL1xuUGF0aC5wcm90b3R5cGUucXVhZFRvID0gUGF0aC5wcm90b3R5cGUucXVhZHJhdGljQ3VydmVUbyA9IGZ1bmN0aW9uKHgxLCB5MSwgeCwgeSkge1xuICAgIHRoaXMuY29tbWFuZHMucHVzaCh7XG4gICAgICAgIHR5cGU6ICdRJyxcbiAgICAgICAgeDE6IHgxLFxuICAgICAgICB5MTogeTEsXG4gICAgICAgIHg6IHgsXG4gICAgICAgIHk6IHlcbiAgICB9KTtcbn07XG5cbi8qKlxuICogQ2xvc2VzIHRoZSBwYXRoXG4gKiBAZnVuY3Rpb24gY2xvc2VQYXRoXG4gKiBAbWVtYmVyb2Ygb3BlbnR5cGUuUGF0aC5wcm90b3R5cGVcbiAqL1xuXG4vKipcbiAqIENsb3NlIHRoZSBwYXRoXG4gKiBAZnVuY3Rpb24gY2xvc2VcbiAqIEBtZW1iZXJvZiBvcGVudHlwZS5QYXRoLnByb3RvdHlwZVxuICovXG5QYXRoLnByb3RvdHlwZS5jbG9zZSA9IFBhdGgucHJvdG90eXBlLmNsb3NlUGF0aCA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuY29tbWFuZHMucHVzaCh7XG4gICAgICAgIHR5cGU6ICdaJ1xuICAgIH0pO1xufTtcblxuLyoqXG4gKiBBZGQgdGhlIGdpdmVuIHBhdGggb3IgbGlzdCBvZiBjb21tYW5kcyB0byB0aGUgY29tbWFuZHMgb2YgdGhpcyBwYXRoLlxuICogQHBhcmFtICB7QXJyYXl9IHBhdGhPckNvbW1hbmRzIC0gYW5vdGhlciBvcGVudHlwZS5QYXRoLCBhbiBvcGVudHlwZS5Cb3VuZGluZ0JveCwgb3IgYW4gYXJyYXkgb2YgY29tbWFuZHMuXG4gKi9cblBhdGgucHJvdG90eXBlLmV4dGVuZCA9IGZ1bmN0aW9uKHBhdGhPckNvbW1hbmRzKSB7XG4gICAgaWYgKHBhdGhPckNvbW1hbmRzLmNvbW1hbmRzKSB7XG4gICAgICAgIHBhdGhPckNvbW1hbmRzID0gcGF0aE9yQ29tbWFuZHMuY29tbWFuZHM7XG4gICAgfSBlbHNlIGlmIChwYXRoT3JDb21tYW5kcyBpbnN0YW5jZW9mIEJvdW5kaW5nQm94KSB7XG4gICAgICAgIGNvbnN0IGJveCA9IHBhdGhPckNvbW1hbmRzO1xuICAgICAgICB0aGlzLm1vdmVUbyhib3gueDEsIGJveC55MSk7XG4gICAgICAgIHRoaXMubGluZVRvKGJveC54MiwgYm94LnkxKTtcbiAgICAgICAgdGhpcy5saW5lVG8oYm94LngyLCBib3gueTIpO1xuICAgICAgICB0aGlzLmxpbmVUbyhib3gueDEsIGJveC55Mik7XG4gICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KHRoaXMuY29tbWFuZHMsIHBhdGhPckNvbW1hbmRzKTtcbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlIHRoZSBib3VuZGluZyBib3ggb2YgdGhlIHBhdGguXG4gKiBAcmV0dXJucyB7b3BlbnR5cGUuQm91bmRpbmdCb3h9XG4gKi9cblBhdGgucHJvdG90eXBlLmdldEJvdW5kaW5nQm94ID0gZnVuY3Rpb24oKSB7XG4gICAgY29uc3QgYm94ID0gbmV3IEJvdW5kaW5nQm94KCk7XG5cbiAgICBsZXQgc3RhcnRYID0gMDtcbiAgICBsZXQgc3RhcnRZID0gMDtcbiAgICBsZXQgcHJldlggPSAwO1xuICAgIGxldCBwcmV2WSA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmNvbW1hbmRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGNtZCA9IHRoaXMuY29tbWFuZHNbaV07XG4gICAgICAgIHN3aXRjaCAoY21kLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ00nOlxuICAgICAgICAgICAgICAgIGJveC5hZGRQb2ludChjbWQueCwgY21kLnkpO1xuICAgICAgICAgICAgICAgIHN0YXJ0WCA9IHByZXZYID0gY21kLng7XG4gICAgICAgICAgICAgICAgc3RhcnRZID0gcHJldlkgPSBjbWQueTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ0wnOlxuICAgICAgICAgICAgICAgIGJveC5hZGRQb2ludChjbWQueCwgY21kLnkpO1xuICAgICAgICAgICAgICAgIHByZXZYID0gY21kLng7XG4gICAgICAgICAgICAgICAgcHJldlkgPSBjbWQueTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ1EnOlxuICAgICAgICAgICAgICAgIGJveC5hZGRRdWFkKHByZXZYLCBwcmV2WSwgY21kLngxLCBjbWQueTEsIGNtZC54LCBjbWQueSk7XG4gICAgICAgICAgICAgICAgcHJldlggPSBjbWQueDtcbiAgICAgICAgICAgICAgICBwcmV2WSA9IGNtZC55O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnQyc6XG4gICAgICAgICAgICAgICAgYm94LmFkZEJlemllcihwcmV2WCwgcHJldlksIGNtZC54MSwgY21kLnkxLCBjbWQueDIsIGNtZC55MiwgY21kLngsIGNtZC55KTtcbiAgICAgICAgICAgICAgICBwcmV2WCA9IGNtZC54O1xuICAgICAgICAgICAgICAgIHByZXZZID0gY21kLnk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdaJzpcbiAgICAgICAgICAgICAgICBwcmV2WCA9IHN0YXJ0WDtcbiAgICAgICAgICAgICAgICBwcmV2WSA9IHN0YXJ0WTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmV4cGVjdGVkIHBhdGggY29tbWFuZCAnICsgY21kLnR5cGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChib3guaXNFbXB0eSgpKSB7XG4gICAgICAgIGJveC5hZGRQb2ludCgwLCAwKTtcbiAgICB9XG4gICAgcmV0dXJuIGJveDtcbn07XG5cbi8qKlxuICogRHJhdyB0aGUgcGF0aCB0byBhIDJEIGNvbnRleHQuXG4gKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IC0gQSAyRCBkcmF3aW5nIGNvbnRleHQuXG4gKi9cblBhdGgucHJvdG90eXBlLmRyYXcgPSBmdW5jdGlvbihjdHgpIHtcbiAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmNvbW1hbmRzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGNvbnN0IGNtZCA9IHRoaXMuY29tbWFuZHNbaV07XG4gICAgICAgIGlmIChjbWQudHlwZSA9PT0gJ00nKSB7XG4gICAgICAgICAgICBjdHgubW92ZVRvKGNtZC54LCBjbWQueSk7XG4gICAgICAgIH0gZWxzZSBpZiAoY21kLnR5cGUgPT09ICdMJykge1xuICAgICAgICAgICAgY3R4LmxpbmVUbyhjbWQueCwgY21kLnkpO1xuICAgICAgICB9IGVsc2UgaWYgKGNtZC50eXBlID09PSAnQycpIHtcbiAgICAgICAgICAgIGN0eC5iZXppZXJDdXJ2ZVRvKGNtZC54MSwgY21kLnkxLCBjbWQueDIsIGNtZC55MiwgY21kLngsIGNtZC55KTtcbiAgICAgICAgfSBlbHNlIGlmIChjbWQudHlwZSA9PT0gJ1EnKSB7XG4gICAgICAgICAgICBjdHgucXVhZHJhdGljQ3VydmVUbyhjbWQueDEsIGNtZC55MSwgY21kLngsIGNtZC55KTtcbiAgICAgICAgfSBlbHNlIGlmIChjbWQudHlwZSA9PT0gJ1onKSB7XG4gICAgICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5maWxsKSB7XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSB0aGlzLmZpbGw7XG4gICAgICAgIGN0eC5maWxsKCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuc3Ryb2tlKSB7XG4gICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHRoaXMuc3Ryb2tlO1xuICAgICAgICBjdHgubGluZVdpZHRoID0gdGhpcy5zdHJva2VXaWR0aDtcbiAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgIH1cbn07XG5cbi8qKlxuICogQ29udmVydCB0aGUgUGF0aCB0byBhIHN0cmluZyBvZiBwYXRoIGRhdGEgaW5zdHJ1Y3Rpb25zXG4gKiBTZWUgaHR0cDovL3d3dy53My5vcmcvVFIvU1ZHL3BhdGhzLmh0bWwjUGF0aERhdGFcbiAqIEBwYXJhbSAge251bWJlcn0gW2RlY2ltYWxQbGFjZXM9Ml0gLSBUaGUgYW1vdW50IG9mIGRlY2ltYWwgcGxhY2VzIGZvciBmbG9hdGluZy1wb2ludCB2YWx1ZXNcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuUGF0aC5wcm90b3R5cGUudG9QYXRoRGF0YSA9IGZ1bmN0aW9uKGRlY2ltYWxQbGFjZXMpIHtcbiAgICBkZWNpbWFsUGxhY2VzID0gZGVjaW1hbFBsYWNlcyAhPT0gdW5kZWZpbmVkID8gZGVjaW1hbFBsYWNlcyA6IDI7XG5cbiAgICBmdW5jdGlvbiBmbG9hdFRvU3RyaW5nKHYpIHtcbiAgICAgICAgaWYgKE1hdGgucm91bmQodikgPT09IHYpIHtcbiAgICAgICAgICAgIHJldHVybiAnJyArIE1hdGgucm91bmQodik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdi50b0ZpeGVkKGRlY2ltYWxQbGFjZXMpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFja1ZhbHVlcygpIHtcbiAgICAgICAgbGV0IHMgPSAnJztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGNvbnN0IHYgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICBpZiAodiA+PSAwICYmIGkgPiAwKSB7XG4gICAgICAgICAgICAgICAgcyArPSAnICc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHMgKz0gZmxvYXRUb1N0cmluZyh2KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzO1xuICAgIH1cblxuICAgIGxldCBkID0gJyc7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmNvbW1hbmRzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGNvbnN0IGNtZCA9IHRoaXMuY29tbWFuZHNbaV07XG4gICAgICAgIGlmIChjbWQudHlwZSA9PT0gJ00nKSB7XG4gICAgICAgICAgICBkICs9ICdNJyArIHBhY2tWYWx1ZXMoY21kLngsIGNtZC55KTtcbiAgICAgICAgfSBlbHNlIGlmIChjbWQudHlwZSA9PT0gJ0wnKSB7XG4gICAgICAgICAgICBkICs9ICdMJyArIHBhY2tWYWx1ZXMoY21kLngsIGNtZC55KTtcbiAgICAgICAgfSBlbHNlIGlmIChjbWQudHlwZSA9PT0gJ0MnKSB7XG4gICAgICAgICAgICBkICs9ICdDJyArIHBhY2tWYWx1ZXMoY21kLngxLCBjbWQueTEsIGNtZC54MiwgY21kLnkyLCBjbWQueCwgY21kLnkpO1xuICAgICAgICB9IGVsc2UgaWYgKGNtZC50eXBlID09PSAnUScpIHtcbiAgICAgICAgICAgIGQgKz0gJ1EnICsgcGFja1ZhbHVlcyhjbWQueDEsIGNtZC55MSwgY21kLngsIGNtZC55KTtcbiAgICAgICAgfSBlbHNlIGlmIChjbWQudHlwZSA9PT0gJ1onKSB7XG4gICAgICAgICAgICBkICs9ICdaJztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBkO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0IHRoZSBwYXRoIHRvIGFuIFNWRyA8cGF0aD4gZWxlbWVudCwgYXMgYSBzdHJpbmcuXG4gKiBAcGFyYW0gIHtudW1iZXJ9IFtkZWNpbWFsUGxhY2VzPTJdIC0gVGhlIGFtb3VudCBvZiBkZWNpbWFsIHBsYWNlcyBmb3IgZmxvYXRpbmctcG9pbnQgdmFsdWVzXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cblBhdGgucHJvdG90eXBlLnRvU1ZHID0gZnVuY3Rpb24oZGVjaW1hbFBsYWNlcykge1xuICAgIGxldCBzdmcgPSAnPHBhdGggZD1cIic7XG4gICAgc3ZnICs9IHRoaXMudG9QYXRoRGF0YShkZWNpbWFsUGxhY2VzKTtcbiAgICBzdmcgKz0gJ1wiJztcbiAgICBpZiAodGhpcy5maWxsICYmIHRoaXMuZmlsbCAhPT0gJ2JsYWNrJykge1xuICAgICAgICBpZiAodGhpcy5maWxsID09PSBudWxsKSB7XG4gICAgICAgICAgICBzdmcgKz0gJyBmaWxsPVwibm9uZVwiJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN2ZyArPSAnIGZpbGw9XCInICsgdGhpcy5maWxsICsgJ1wiJztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLnN0cm9rZSkge1xuICAgICAgICBzdmcgKz0gJyBzdHJva2U9XCInICsgdGhpcy5zdHJva2UgKyAnXCIgc3Ryb2tlLXdpZHRoPVwiJyArIHRoaXMuc3Ryb2tlV2lkdGggKyAnXCInO1xuICAgIH1cblxuICAgIHN2ZyArPSAnLz4nO1xuICAgIHJldHVybiBzdmc7XG59O1xuXG4vKipcbiAqIENvbnZlcnQgdGhlIHBhdGggdG8gYSBET00gZWxlbWVudC5cbiAqIEBwYXJhbSAge251bWJlcn0gW2RlY2ltYWxQbGFjZXM9Ml0gLSBUaGUgYW1vdW50IG9mIGRlY2ltYWwgcGxhY2VzIGZvciBmbG9hdGluZy1wb2ludCB2YWx1ZXNcbiAqIEByZXR1cm4ge1NWR1BhdGhFbGVtZW50fVxuICovXG5QYXRoLnByb3RvdHlwZS50b0RPTUVsZW1lbnQgPSBmdW5jdGlvbihkZWNpbWFsUGxhY2VzKSB7XG4gICAgY29uc3QgdGVtcG9yYXJ5UGF0aCA9IHRoaXMudG9QYXRoRGF0YShkZWNpbWFsUGxhY2VzKTtcbiAgICBjb25zdCBuZXdQYXRoID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKCdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycsICdwYXRoJyk7XG5cbiAgICBuZXdQYXRoLnNldEF0dHJpYnV0ZSgnZCcsIHRlbXBvcmFyeVBhdGgpO1xuXG4gICAgcmV0dXJuIG5ld1BhdGg7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBQYXRoO1xuIiwiLy8gUnVuLXRpbWUgY2hlY2tpbmcgb2YgcHJlY29uZGl0aW9ucy5cblxuZnVuY3Rpb24gZmFpbChtZXNzYWdlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xufVxuXG4vLyBQcmVjb25kaXRpb24gZnVuY3Rpb24gdGhhdCBjaGVja3MgaWYgdGhlIGdpdmVuIHByZWRpY2F0ZSBpcyB0cnVlLlxuLy8gSWYgbm90LCBpdCB3aWxsIHRocm93IGFuIGVycm9yLlxuZnVuY3Rpb24gYXJndW1lbnQocHJlZGljYXRlLCBtZXNzYWdlKSB7XG4gICAgaWYgKCFwcmVkaWNhdGUpIHtcbiAgICAgICAgZmFpbChtZXNzYWdlKTtcbiAgICB9XG59XG5cbmV4cG9ydCB7IGZhaWwsIGFyZ3VtZW50LCBhcmd1bWVudCBhcyBhc3NlcnQgfTtcbmV4cG9ydCBkZWZhdWx0IHsgZmFpbCwgYXJndW1lbnQsIGFzc2VydDogYXJndW1lbnQgfTtcbiIsIi8vIERhdGEgdHlwZXMgdXNlZCBpbiB0aGUgT3BlblR5cGUgZm9udCBmaWxlLlxuLy8gQWxsIE9wZW5UeXBlIGZvbnRzIHVzZSBNb3Rvcm9sYS1zdHlsZSBieXRlIG9yZGVyaW5nIChCaWcgRW5kaWFuKVxuXG5pbXBvcnQgY2hlY2sgZnJvbSAnLi9jaGVjayc7XG5cbmNvbnN0IExJTUlUMTYgPSAzMjc2ODsgLy8gVGhlIGxpbWl0IGF0IHdoaWNoIGEgMTYtYml0IG51bWJlciBzd2l0Y2hlcyBzaWducyA9PSAyXjE1XG5jb25zdCBMSU1JVDMyID0gMjE0NzQ4MzY0ODsgLy8gVGhlIGxpbWl0IGF0IHdoaWNoIGEgMzItYml0IG51bWJlciBzd2l0Y2hlcyBzaWducyA9PSAyIF4gMzFcblxuLyoqXG4gKiBAZXhwb3J0cyBvcGVudHlwZS5kZWNvZGVcbiAqIEBjbGFzc1xuICovXG5jb25zdCBkZWNvZGUgPSB7fTtcbi8qKlxuICogQGV4cG9ydHMgb3BlbnR5cGUuZW5jb2RlXG4gKiBAY2xhc3NcbiAqL1xuY29uc3QgZW5jb2RlID0ge307XG4vKipcbiAqIEBleHBvcnRzIG9wZW50eXBlLnNpemVPZlxuICogQGNsYXNzXG4gKi9cbmNvbnN0IHNpemVPZiA9IHt9O1xuXG4vLyBSZXR1cm4gYSBmdW5jdGlvbiB0aGF0IGFsd2F5cyByZXR1cm5zIHRoZSBzYW1lIHZhbHVlLlxuZnVuY3Rpb24gY29uc3RhbnQodikge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHY7XG4gICAgfTtcbn1cblxuLy8gT3BlblR5cGUgZGF0YSB0eXBlcyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuLyoqXG4gKiBDb252ZXJ0IGFuIDgtYml0IHVuc2lnbmVkIGludGVnZXIgdG8gYSBsaXN0IG9mIDEgYnl0ZS5cbiAqIEBwYXJhbSB7bnVtYmVyfVxuICogQHJldHVybnMge0FycmF5fVxuICovXG5lbmNvZGUuQllURSA9IGZ1bmN0aW9uKHYpIHtcbiAgICBjaGVjay5hcmd1bWVudCh2ID49IDAgJiYgdiA8PSAyNTUsICdCeXRlIHZhbHVlIHNob3VsZCBiZSBiZXR3ZWVuIDAgYW5kIDI1NS4nKTtcbiAgICByZXR1cm4gW3ZdO1xufTtcbi8qKlxuICogQGNvbnN0YW50XG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG5zaXplT2YuQllURSA9IGNvbnN0YW50KDEpO1xuXG4vKipcbiAqIENvbnZlcnQgYSA4LWJpdCBzaWduZWQgaW50ZWdlciB0byBhIGxpc3Qgb2YgMSBieXRlLlxuICogQHBhcmFtIHtzdHJpbmd9XG4gKiBAcmV0dXJucyB7QXJyYXl9XG4gKi9cbmVuY29kZS5DSEFSID0gZnVuY3Rpb24odikge1xuICAgIHJldHVybiBbdi5jaGFyQ29kZUF0KDApXTtcbn07XG5cbi8qKlxuICogQGNvbnN0YW50XG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG5zaXplT2YuQ0hBUiA9IGNvbnN0YW50KDEpO1xuXG4vKipcbiAqIENvbnZlcnQgYW4gQVNDSUkgc3RyaW5nIHRvIGEgbGlzdCBvZiBieXRlcy5cbiAqIEBwYXJhbSB7c3RyaW5nfVxuICogQHJldHVybnMge0FycmF5fVxuICovXG5lbmNvZGUuQ0hBUkFSUkFZID0gZnVuY3Rpb24odikge1xuICAgIGNvbnN0IGIgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHYubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgYltpXSA9IHYuY2hhckNvZGVBdChpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYjtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtBcnJheX1cbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbnNpemVPZi5DSEFSQVJSQVkgPSBmdW5jdGlvbih2KSB7XG4gICAgcmV0dXJuIHYubGVuZ3RoO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0IGEgMTYtYml0IHVuc2lnbmVkIGludGVnZXIgdG8gYSBsaXN0IG9mIDIgYnl0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn1cbiAqIEByZXR1cm5zIHtBcnJheX1cbiAqL1xuZW5jb2RlLlVTSE9SVCA9IGZ1bmN0aW9uKHYpIHtcbiAgICByZXR1cm4gWyh2ID4+IDgpICYgMHhGRiwgdiAmIDB4RkZdO1xufTtcblxuLyoqXG4gKiBAY29uc3RhbnRcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbnNpemVPZi5VU0hPUlQgPSBjb25zdGFudCgyKTtcblxuLyoqXG4gKiBDb252ZXJ0IGEgMTYtYml0IHNpZ25lZCBpbnRlZ2VyIHRvIGEgbGlzdCBvZiAyIGJ5dGVzLlxuICogQHBhcmFtIHtudW1iZXJ9XG4gKiBAcmV0dXJucyB7QXJyYXl9XG4gKi9cbmVuY29kZS5TSE9SVCA9IGZ1bmN0aW9uKHYpIHtcbiAgICAvLyBUd28ncyBjb21wbGVtZW50XG4gICAgaWYgKHYgPj0gTElNSVQxNikge1xuICAgICAgICB2ID0gLSgyICogTElNSVQxNiAtIHYpO1xuICAgIH1cblxuICAgIHJldHVybiBbKHYgPj4gOCkgJiAweEZGLCB2ICYgMHhGRl07XG59O1xuXG4vKipcbiAqIEBjb25zdGFudFxuICogQHR5cGUge251bWJlcn1cbiAqL1xuc2l6ZU9mLlNIT1JUID0gY29uc3RhbnQoMik7XG5cbi8qKlxuICogQ29udmVydCBhIDI0LWJpdCB1bnNpZ25lZCBpbnRlZ2VyIHRvIGEgbGlzdCBvZiAzIGJ5dGVzLlxuICogQHBhcmFtIHtudW1iZXJ9XG4gKiBAcmV0dXJucyB7QXJyYXl9XG4gKi9cbmVuY29kZS5VSU5UMjQgPSBmdW5jdGlvbih2KSB7XG4gICAgcmV0dXJuIFsodiA+PiAxNikgJiAweEZGLCAodiA+PiA4KSAmIDB4RkYsIHYgJiAweEZGXTtcbn07XG5cbi8qKlxuICogQGNvbnN0YW50XG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG5zaXplT2YuVUlOVDI0ID0gY29uc3RhbnQoMyk7XG5cbi8qKlxuICogQ29udmVydCBhIDMyLWJpdCB1bnNpZ25lZCBpbnRlZ2VyIHRvIGEgbGlzdCBvZiA0IGJ5dGVzLlxuICogQHBhcmFtIHtudW1iZXJ9XG4gKiBAcmV0dXJucyB7QXJyYXl9XG4gKi9cbmVuY29kZS5VTE9ORyA9IGZ1bmN0aW9uKHYpIHtcbiAgICByZXR1cm4gWyh2ID4+IDI0KSAmIDB4RkYsICh2ID4+IDE2KSAmIDB4RkYsICh2ID4+IDgpICYgMHhGRiwgdiAmIDB4RkZdO1xufTtcblxuLyoqXG4gKiBAY29uc3RhbnRcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbnNpemVPZi5VTE9ORyA9IGNvbnN0YW50KDQpO1xuXG4vKipcbiAqIENvbnZlcnQgYSAzMi1iaXQgdW5zaWduZWQgaW50ZWdlciB0byBhIGxpc3Qgb2YgNCBieXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfVxuICogQHJldHVybnMge0FycmF5fVxuICovXG5lbmNvZGUuTE9ORyA9IGZ1bmN0aW9uKHYpIHtcbiAgICAvLyBUd28ncyBjb21wbGVtZW50XG4gICAgaWYgKHYgPj0gTElNSVQzMikge1xuICAgICAgICB2ID0gLSgyICogTElNSVQzMiAtIHYpO1xuICAgIH1cblxuICAgIHJldHVybiBbKHYgPj4gMjQpICYgMHhGRiwgKHYgPj4gMTYpICYgMHhGRiwgKHYgPj4gOCkgJiAweEZGLCB2ICYgMHhGRl07XG59O1xuXG4vKipcbiAqIEBjb25zdGFudFxuICogQHR5cGUge251bWJlcn1cbiAqL1xuc2l6ZU9mLkxPTkcgPSBjb25zdGFudCg0KTtcblxuZW5jb2RlLkZJWEVEID0gZW5jb2RlLlVMT05HO1xuc2l6ZU9mLkZJWEVEID0gc2l6ZU9mLlVMT05HO1xuXG5lbmNvZGUuRldPUkQgPSBlbmNvZGUuU0hPUlQ7XG5zaXplT2YuRldPUkQgPSBzaXplT2YuU0hPUlQ7XG5cbmVuY29kZS5VRldPUkQgPSBlbmNvZGUuVVNIT1JUO1xuc2l6ZU9mLlVGV09SRCA9IHNpemVPZi5VU0hPUlQ7XG5cbi8qKlxuICogQ29udmVydCBhIDMyLWJpdCBBcHBsZSBNYWMgdGltZXN0YW1wIGludGVnZXIgdG8gYSBsaXN0IG9mIDggYnl0ZXMsIDY0LWJpdCB0aW1lc3RhbXAuXG4gKiBAcGFyYW0ge251bWJlcn1cbiAqIEByZXR1cm5zIHtBcnJheX1cbiAqL1xuZW5jb2RlLkxPTkdEQVRFVElNRSA9IGZ1bmN0aW9uKHYpIHtcbiAgICByZXR1cm4gWzAsIDAsIDAsIDAsICh2ID4+IDI0KSAmIDB4RkYsICh2ID4+IDE2KSAmIDB4RkYsICh2ID4+IDgpICYgMHhGRiwgdiAmIDB4RkZdO1xufTtcblxuLyoqXG4gKiBAY29uc3RhbnRcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbnNpemVPZi5MT05HREFURVRJTUUgPSBjb25zdGFudCg4KTtcblxuLyoqXG4gKiBDb252ZXJ0IGEgNC1jaGFyIHRhZyB0byBhIGxpc3Qgb2YgNCBieXRlcy5cbiAqIEBwYXJhbSB7c3RyaW5nfVxuICogQHJldHVybnMge0FycmF5fVxuICovXG5lbmNvZGUuVEFHID0gZnVuY3Rpb24odikge1xuICAgIGNoZWNrLmFyZ3VtZW50KHYubGVuZ3RoID09PSA0LCAnVGFnIHNob3VsZCBiZSBleGFjdGx5IDQgQVNDSUkgY2hhcmFjdGVycy4nKTtcbiAgICByZXR1cm4gW3YuY2hhckNvZGVBdCgwKSxcbiAgICAgICAgICAgIHYuY2hhckNvZGVBdCgxKSxcbiAgICAgICAgICAgIHYuY2hhckNvZGVBdCgyKSxcbiAgICAgICAgICAgIHYuY2hhckNvZGVBdCgzKV07XG59O1xuXG4vKipcbiAqIEBjb25zdGFudFxuICogQHR5cGUge251bWJlcn1cbiAqL1xuc2l6ZU9mLlRBRyA9IGNvbnN0YW50KDQpO1xuXG4vLyBDRkYgZGF0YSB0eXBlcyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG5lbmNvZGUuQ2FyZDggPSBlbmNvZGUuQllURTtcbnNpemVPZi5DYXJkOCA9IHNpemVPZi5CWVRFO1xuXG5lbmNvZGUuQ2FyZDE2ID0gZW5jb2RlLlVTSE9SVDtcbnNpemVPZi5DYXJkMTYgPSBzaXplT2YuVVNIT1JUO1xuXG5lbmNvZGUuT2ZmU2l6ZSA9IGVuY29kZS5CWVRFO1xuc2l6ZU9mLk9mZlNpemUgPSBzaXplT2YuQllURTtcblxuZW5jb2RlLlNJRCA9IGVuY29kZS5VU0hPUlQ7XG5zaXplT2YuU0lEID0gc2l6ZU9mLlVTSE9SVDtcblxuLy8gQ29udmVydCBhIG51bWVyaWMgb3BlcmFuZCBvciBjaGFyc3RyaW5nIG51bWJlciB0byBhIHZhcmlhYmxlLXNpemUgbGlzdCBvZiBieXRlcy5cbi8qKlxuICogQ29udmVydCBhIG51bWVyaWMgb3BlcmFuZCBvciBjaGFyc3RyaW5nIG51bWJlciB0byBhIHZhcmlhYmxlLXNpemUgbGlzdCBvZiBieXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfVxuICogQHJldHVybnMge0FycmF5fVxuICovXG5lbmNvZGUuTlVNQkVSID0gZnVuY3Rpb24odikge1xuICAgIGlmICh2ID49IC0xMDcgJiYgdiA8PSAxMDcpIHtcbiAgICAgICAgcmV0dXJuIFt2ICsgMTM5XTtcbiAgICB9IGVsc2UgaWYgKHYgPj0gMTA4ICYmIHYgPD0gMTEzMSkge1xuICAgICAgICB2ID0gdiAtIDEwODtcbiAgICAgICAgcmV0dXJuIFsodiA+PiA4KSArIDI0NywgdiAmIDB4RkZdO1xuICAgIH0gZWxzZSBpZiAodiA+PSAtMTEzMSAmJiB2IDw9IC0xMDgpIHtcbiAgICAgICAgdiA9IC12IC0gMTA4O1xuICAgICAgICByZXR1cm4gWyh2ID4+IDgpICsgMjUxLCB2ICYgMHhGRl07XG4gICAgfSBlbHNlIGlmICh2ID49IC0zMjc2OCAmJiB2IDw9IDMyNzY3KSB7XG4gICAgICAgIHJldHVybiBlbmNvZGUuTlVNQkVSMTYodik7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGVuY29kZS5OVU1CRVIzMih2KTtcbiAgICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfVxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuc2l6ZU9mLk5VTUJFUiA9IGZ1bmN0aW9uKHYpIHtcbiAgICByZXR1cm4gZW5jb2RlLk5VTUJFUih2KS5sZW5ndGg7XG59O1xuXG4vKipcbiAqIENvbnZlcnQgYSBzaWduZWQgbnVtYmVyIGJldHdlZW4gLTMyNzY4IGFuZCArMzI3NjcgdG8gYSB0aHJlZS1ieXRlIHZhbHVlLlxuICogVGhpcyBlbnN1cmVzIHdlIGFsd2F5cyB1c2UgdGhyZWUgYnl0ZXMsIGJ1dCBpcyBub3QgdGhlIG1vc3QgY29tcGFjdCBmb3JtYXQuXG4gKiBAcGFyYW0ge251bWJlcn1cbiAqIEByZXR1cm5zIHtBcnJheX1cbiAqL1xuZW5jb2RlLk5VTUJFUjE2ID0gZnVuY3Rpb24odikge1xuICAgIHJldHVybiBbMjgsICh2ID4+IDgpICYgMHhGRiwgdiAmIDB4RkZdO1xufTtcblxuLyoqXG4gKiBAY29uc3RhbnRcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbnNpemVPZi5OVU1CRVIxNiA9IGNvbnN0YW50KDMpO1xuXG4vKipcbiAqIENvbnZlcnQgYSBzaWduZWQgbnVtYmVyIGJldHdlZW4gLSgyXjMxKSBhbmQgKygyXjMxLTEpIHRvIGEgZml2ZS1ieXRlIHZhbHVlLlxuICogVGhpcyBpcyB1c2VmdWwgaWYgeW91IHdhbnQgdG8gYmUgc3VyZSB5b3UgYWx3YXlzIHVzZSBmb3VyIGJ5dGVzLFxuICogYXQgdGhlIGV4cGVuc2Ugb2Ygd2FzdGluZyBhIGZldyBieXRlcyBmb3Igc21hbGxlciBudW1iZXJzLlxuICogQHBhcmFtIHtudW1iZXJ9XG4gKiBAcmV0dXJucyB7QXJyYXl9XG4gKi9cbmVuY29kZS5OVU1CRVIzMiA9IGZ1bmN0aW9uKHYpIHtcbiAgICByZXR1cm4gWzI5LCAodiA+PiAyNCkgJiAweEZGLCAodiA+PiAxNikgJiAweEZGLCAodiA+PiA4KSAmIDB4RkYsIHYgJiAweEZGXTtcbn07XG5cbi8qKlxuICogQGNvbnN0YW50XG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG5zaXplT2YuTlVNQkVSMzIgPSBjb25zdGFudCg1KTtcblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn1cbiAqIEByZXR1cm5zIHtBcnJheX1cbiAqL1xuZW5jb2RlLlJFQUwgPSBmdW5jdGlvbih2KSB7XG4gICAgbGV0IHZhbHVlID0gdi50b1N0cmluZygpO1xuXG4gICAgLy8gU29tZSBudW1iZXJzIHVzZSBhbiBlcHNpbG9uIHRvIGVuY29kZSB0aGUgdmFsdWUuIChlLmcuIEphdmFTY3JpcHQgd2lsbCBzdG9yZSAwLjAwMDAwMDEgYXMgMWUtNylcbiAgICAvLyBUaGlzIGNvZGUgY29udmVydHMgaXQgYmFjayB0byBhIG51bWJlciB3aXRob3V0IHRoZSBlcHNpbG9uLlxuICAgIGNvbnN0IG0gPSAvXFwuKFxcZCo/KSg/Ojl7NSwyMH18MHs1LDIwfSlcXGR7MCwyfSg/OmUoLispfCQpLy5leGVjKHZhbHVlKTtcbiAgICBpZiAobSkge1xuICAgICAgICBjb25zdCBlcHNpbG9uID0gcGFyc2VGbG9hdCgnMWUnICsgKChtWzJdID8gK21bMl0gOiAwKSArIG1bMV0ubGVuZ3RoKSk7XG4gICAgICAgIHZhbHVlID0gKE1hdGgucm91bmQodiAqIGVwc2lsb24pIC8gZXBzaWxvbikudG9TdHJpbmcoKTtcbiAgICB9XG5cbiAgICBsZXQgbmliYmxlcyA9ICcnO1xuICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IHZhbHVlLmxlbmd0aDsgaSA8IGlpOyBpICs9IDEpIHtcbiAgICAgICAgY29uc3QgYyA9IHZhbHVlW2ldO1xuICAgICAgICBpZiAoYyA9PT0gJ2UnKSB7XG4gICAgICAgICAgICBuaWJibGVzICs9IHZhbHVlWysraV0gPT09ICctJyA/ICdjJyA6ICdiJztcbiAgICAgICAgfSBlbHNlIGlmIChjID09PSAnLicpIHtcbiAgICAgICAgICAgIG5pYmJsZXMgKz0gJ2EnO1xuICAgICAgICB9IGVsc2UgaWYgKGMgPT09ICctJykge1xuICAgICAgICAgICAgbmliYmxlcyArPSAnZSc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuaWJibGVzICs9IGM7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBuaWJibGVzICs9IChuaWJibGVzLmxlbmd0aCAmIDEpID8gJ2YnIDogJ2ZmJztcbiAgICBjb25zdCBvdXQgPSBbMzBdO1xuICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IG5pYmJsZXMubGVuZ3RoOyBpIDwgaWk7IGkgKz0gMikge1xuICAgICAgICBvdXQucHVzaChwYXJzZUludChuaWJibGVzLnN1YnN0cihpLCAyKSwgMTYpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn1cbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbnNpemVPZi5SRUFMID0gZnVuY3Rpb24odikge1xuICAgIHJldHVybiBlbmNvZGUuUkVBTCh2KS5sZW5ndGg7XG59O1xuXG5lbmNvZGUuTkFNRSA9IGVuY29kZS5DSEFSQVJSQVk7XG5zaXplT2YuTkFNRSA9IHNpemVPZi5DSEFSQVJSQVk7XG5cbmVuY29kZS5TVFJJTkcgPSBlbmNvZGUuQ0hBUkFSUkFZO1xuc2l6ZU9mLlNUUklORyA9IHNpemVPZi5DSEFSQVJSQVk7XG5cbi8qKlxuICogQHBhcmFtIHtEYXRhVmlld30gZGF0YVxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxuICogQHBhcmFtIHtudW1iZXJ9IG51bUJ5dGVzXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5kZWNvZGUuVVRGOCA9IGZ1bmN0aW9uKGRhdGEsIG9mZnNldCwgbnVtQnl0ZXMpIHtcbiAgICBjb25zdCBjb2RlUG9pbnRzID0gW107XG4gICAgY29uc3QgbnVtQ2hhcnMgPSBudW1CeXRlcztcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IG51bUNoYXJzOyBqKyssIG9mZnNldCArPSAxKSB7XG4gICAgICAgIGNvZGVQb2ludHNbal0gPSBkYXRhLmdldFVpbnQ4KG9mZnNldCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgY29kZVBvaW50cyk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7RGF0YVZpZXd9IGRhdGFcbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAqIEBwYXJhbSB7bnVtYmVyfSBudW1CeXRlc1xuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZGVjb2RlLlVURjE2ID0gZnVuY3Rpb24oZGF0YSwgb2Zmc2V0LCBudW1CeXRlcykge1xuICAgIGNvbnN0IGNvZGVQb2ludHMgPSBbXTtcbiAgICBjb25zdCBudW1DaGFycyA9IG51bUJ5dGVzIC8gMjtcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IG51bUNoYXJzOyBqKyssIG9mZnNldCArPSAyKSB7XG4gICAgICAgIGNvZGVQb2ludHNbal0gPSBkYXRhLmdldFVpbnQxNihvZmZzZXQpO1xuICAgIH1cblxuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIGNvZGVQb2ludHMpO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0IGEgSmF2YVNjcmlwdCBzdHJpbmcgdG8gVVRGMTYtQkUuXG4gKiBAcGFyYW0ge3N0cmluZ31cbiAqIEByZXR1cm5zIHtBcnJheX1cbiAqL1xuZW5jb2RlLlVURjE2ID0gZnVuY3Rpb24odikge1xuICAgIGNvbnN0IGIgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHYubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgY29uc3QgY29kZXBvaW50ID0gdi5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBiW2IubGVuZ3RoXSA9IChjb2RlcG9pbnQgPj4gOCkgJiAweEZGO1xuICAgICAgICBiW2IubGVuZ3RoXSA9IGNvZGVwb2ludCAmIDB4RkY7XG4gICAgfVxuXG4gICAgcmV0dXJuIGI7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfVxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuc2l6ZU9mLlVURjE2ID0gZnVuY3Rpb24odikge1xuICAgIHJldHVybiB2Lmxlbmd0aCAqIDI7XG59O1xuXG4vLyBEYXRhIGZvciBjb252ZXJ0aW5nIG9sZCBlaWdodC1iaXQgTWFjaW50b3NoIGVuY29kaW5ncyB0byBVbmljb2RlLlxuLy8gVGhpcyByZXByZXNlbnRhdGlvbiBpcyBvcHRpbWl6ZWQgZm9yIGRlY29kaW5nOyBlbmNvZGluZyBpcyBzbG93ZXJcbi8vIGFuZCBuZWVkcyBtb3JlIG1lbW9yeS4gVGhlIGFzc3VtcHRpb24gaXMgdGhhdCBhbGwgb3BlbnR5cGUuanMgdXNlcnNcbi8vIHdhbnQgdG8gb3BlbiBmb250cywgYnV0IHNhdmluZyBhIGZvbnQgd2lsbCBiZSBjb21wYXJhdGl2ZWx5IHJhcmVcbi8vIHNvIGl0IGNhbiBiZSBtb3JlIGV4cGVuc2l2ZS4gS2V5ZWQgYnkgSUFOQSBjaGFyYWN0ZXIgc2V0IG5hbWUuXG4vL1xuLy8gUHl0aG9uIHNjcmlwdCBmb3IgZ2VuZXJhdGluZyB0aGVzZSBzdHJpbmdzOlxuLy9cbi8vICAgICBzID0gdScnLmpvaW4oW2NocihjKS5kZWNvZGUoJ21hY19ncmVlaycpIGZvciBjIGluIHJhbmdlKDEyOCwgMjU2KV0pXG4vLyAgICAgcHJpbnQocy5lbmNvZGUoJ3V0Zi04JykpXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmNvbnN0IGVpZ2h0Qml0TWFjRW5jb2RpbmdzID0ge1xuICAgICd4LW1hYy1jcm9hdGlhbic6ICAvLyBQeXRob246ICdtYWNfY3JvYXRpYW4nXG4gICAgJ8OEw4XDh8OJw5HDlsOcw6HDoMOiw6TDo8Olw6fDqcOow6rDq8Otw6zDrsOvw7HDs8Oyw7TDtsO1w7rDucO7w7zigKDCsMKiwqPCp+KAosK2w5/CrsWg4oSiwrTCqOKJoMW9w5jiiJ7CseKJpOKJpeKIhsK14oiC4oiR4oiPxaHiiKvCqsK6zqnFvsO4JyArXG4gICAgJ8K/wqHCrOKImsaS4omIxIbCq8SM4oCmwqDDgMODw5XFksWTxJDigJTigJzigJ3igJjigJnDt+KXiu+jv8Kp4oGE4oKs4oC54oC6w4bCu+KAk8K34oCa4oCe4oCww4LEh8OBxI3DiMONw47Dj8OMw5PDlMSRw5LDmsObw5nEscuGy5zCr8+Aw4vLmsK4w4rDpsuHJyxcbiAgICAneC1tYWMtY3lyaWxsaWMnOiAgLy8gUHl0aG9uOiAnbWFjX2N5cmlsbGljJ1xuICAgICfQkNCR0JLQk9CU0JXQltCX0JjQmdCa0JvQnNCd0J7Qn9Cg0KHQotCj0KTQpdCm0KfQqNCp0KrQq9Cs0K3QrtCv4oCgwrDSkMKjwqfigKLCttCGwq7CqeKEotCC0ZLiiaDQg9GT4oiewrHiiaTiiaXRlsK10pHQiNCE0ZTQh9GX0InRmdCK0ZonICtcbiAgICAn0ZjQhcKs4oiaxpLiiYjiiIbCq8K74oCmwqDQi9Gb0IzRnNGV4oCT4oCU4oCc4oCd4oCY4oCZw7figJ7QjtGe0I/Rn+KEltCB0ZHRj9Cw0LHQstCz0LTQtdC20LfQuNC50LrQu9C80L3QvtC/0YDRgdGC0YPRhNGF0YbRh9GI0YnRitGL0YzRjdGOJyxcbiAgICAneC1tYWMtZ2FlbGljJzogLy8gaHR0cDovL3VuaWNvZGUub3JnL1B1YmxpYy9NQVBQSU5HUy9WRU5ET1JTL0FQUExFL0dBRUxJQy5UWFRcbiAgICAnw4TDhcOHw4nDkcOWw5zDocOgw6LDpMOjw6XDp8Opw6jDqsOrw63DrMOuw6/DscOzw7LDtMO2w7XDusO5w7vDvOKAoMKwwqLCo8Kn4oCiwrbDn8KuwqnihKLCtMKo4omgw4bDmOG4gsKx4omk4oml4biDxIrEi+G4iuG4i+G4nuG4n8SgxKHhuYDDpsO4JyArXG4gICAgJ+G5geG5luG5l8m8xpLFv+G5oMKrwrvigKbCoMOAw4PDlcWSxZPigJPigJTigJzigJ3igJjigJnhuaHhupvDv8W44bmq4oKs4oC54oC6xbbFt+G5q8K34buy4buz4oGKw4LDisOBw4vDiMONw47Dj8OMw5PDlOKZo8OSw5rDm8OZxLHDncO9xbTFteG6hOG6heG6gOG6geG6guG6gycsXG4gICAgJ3gtbWFjLWdyZWVrJzogIC8vIFB5dGhvbjogJ21hY19ncmVlaydcbiAgICAnw4TCucKyw4nCs8OWw5zOhcOgw6LDpM6EwqjDp8Opw6jDqsOrwqPihKLDrsOv4oCiwr3igLDDtMO2wqbigqzDucO7w7zigKDOk86UzpjOm86ezqDDn8KuwqnOo86qwqfiiaDCsMK3zpHCseKJpOKJpcKlzpLOlc6WzpfOmc6azpzOps6rzqjOqScgK1xuICAgICfOrM6dwqzOn86h4omIzqTCq8K74oCmwqDOpc6nzobOiMWT4oCT4oCV4oCc4oCd4oCY4oCZw7fOic6KzozOjs6tzq7Or8+Mzo/Pjc6xzrLPiM60zrXPhs6zzrfOuc6+zrrOu868zr3Ov8+Az47Pgc+Dz4TOuM+Jz4LPh8+FzrbPis+LzpDOsFxcdTAwQUQnLFxuICAgICd4LW1hYy1pY2VsYW5kaWMnOiAgLy8gUHl0aG9uOiAnbWFjX2ljZWxhbmQnXG4gICAgJ8OEw4XDh8OJw5HDlsOcw6HDoMOiw6TDo8Olw6fDqcOow6rDq8Otw6zDrsOvw7HDs8Oyw7TDtsO1w7rDucO7w7zDncKwwqLCo8Kn4oCiwrbDn8KuwqnihKLCtMKo4omgw4bDmOKInsKx4omk4omlwqXCteKIguKIkeKIj8+A4oirwqrCus6pw6bDuCcgK1xuICAgICfCv8KhwqziiJrGkuKJiOKIhsKrwrvigKbCoMOAw4PDlcWSxZPigJPigJTigJzigJ3igJjigJnDt+KXisO/xbjigYTigqzDkMOww57DvsO9wrfigJrigJ7igLDDgsOKw4HDi8OIw43DjsOPw4zDk8OU76O/w5LDmsObw5nEscuGy5zCr8uYy5nLmsK4y53Lm8uHJyxcbiAgICAneC1tYWMtaW51aXQnOiAvLyBodHRwOi8vdW5pY29kZS5vcmcvUHVibGljL01BUFBJTkdTL1ZFTkRPUlMvQVBQTEUvSU5VSVQuVFhUXG4gICAgJ+GQg+GQhOGQheGQhuGQiuGQi+GQseGQsuGQs+GQtOGQuOGQueGRieGRjuGRj+GRkOGRkeGRleGRluGRpuGRreGRruGRr+GRsOGRsuGRs+GSg+GSi+GSjOGSjeGSjuGSkOGSkcKw4ZKh4ZKl4ZKm4oCiwrbhkqfCrsKp4oSi4ZKo4ZKq4ZKr4ZK74ZOC4ZOD4ZOE4ZOF4ZOH4ZOI4ZOQ4ZOv4ZOw4ZOx4ZOy4ZO04ZO14ZSF4ZOV4ZOW4ZOXJyArXG4gICAgJ+GTmOGTmuGTm+GTquGUqOGUqeGUquGUq+GUreKApsKg4ZSu4ZS+4ZWV4ZWW4ZWX4oCT4oCU4oCc4oCd4oCY4oCZ4ZWY4ZWZ4ZWa4ZWd4ZWG4ZWH4ZWI4ZWJ4ZWL4ZWM4ZWQ4ZW/4ZaA4ZaB4ZaC4ZaD4ZaE4ZaF4ZaP4ZaQ4ZaR4ZaS4ZaT4ZaU4ZaV4Zmx4Zmy4Zmz4Zm04Zm14Zm24ZaW4Zag4Zah4Zai4Zaj4Zak4Zal4Zam4ZW8xYHFgicsXG4gICAgJ3gtbWFjLWNlJzogIC8vIFB5dGhvbjogJ21hY19sYXRpbjInXG4gICAgJ8OExIDEgcOJxITDlsOcw6HEhcSMw6TEjcSGxIfDqcW5xbrEjsOtxI/EksSTxJbDs8SXw7TDtsO1w7rEmsSbw7zigKDCsMSYwqPCp+KAosK2w5/CrsKp4oSixJnCqOKJoMSjxK7Er8Sq4omk4omlxKvEtuKIguKIkcWCxLvEvMS9xL7EucS6xYUnICtcbiAgICAnxYbFg8Ks4oiaxYTFh+KIhsKrwrvigKbCoMWIxZDDlcWRxYzigJPigJTigJzigJ3igJjigJnDt+KXisWNxZTFlcWY4oC54oC6xZnFlsWXxaDigJrigJ7FocWaxZvDgcWkxaXDjcW9xb7FqsOTw5TFq8Wuw5rFr8WwxbHFssWzw53DvcS3xbvFgcW8xKLLhycsXG4gICAgbWFjaW50b3NoOiAgLy8gUHl0aG9uOiAnbWFjX3JvbWFuJ1xuICAgICfDhMOFw4fDicORw5bDnMOhw6DDosOkw6PDpcOnw6nDqMOqw6vDrcOsw67Dr8Oxw7PDssO0w7bDtcO6w7nDu8O84oCgwrDCosKjwqfigKLCtsOfwq7CqeKEosK0wqjiiaDDhsOY4oiewrHiiaTiiaXCpcK14oiC4oiR4oiPz4DiiKvCqsK6zqnDpsO4JyArXG4gICAgJ8K/wqHCrOKImsaS4omI4oiGwqvCu+KApsKgw4DDg8OVxZLFk+KAk+KAlOKAnOKAneKAmOKAmcO34peKw7/FuOKBhOKCrOKAueKAuu+sge+sguKAocK34oCa4oCe4oCww4LDisOBw4vDiMONw47Dj8OMw5PDlO+jv8OSw5rDm8OZxLHLhsucwq/LmMuZy5rCuMudy5vLhycsXG4gICAgJ3gtbWFjLXJvbWFuaWFuJzogIC8vIFB5dGhvbjogJ21hY19yb21hbmlhbidcbiAgICAnw4TDhcOHw4nDkcOWw5zDocOgw6LDpMOjw6XDp8Opw6jDqsOrw63DrMOuw6/DscOzw7LDtMO2w7XDusO5w7vDvOKAoMKwwqLCo8Kn4oCiwrbDn8KuwqnihKLCtMKo4omgxILImOKInsKx4omk4omlwqXCteKIguKIkeKIj8+A4oirwqrCus6pxIPImScgK1xuICAgICfCv8KhwqziiJrGkuKJiOKIhsKrwrvigKbCoMOAw4PDlcWSxZPigJPigJTigJzigJ3igJjigJnDt+KXisO/xbjigYTigqzigLnigLrImsib4oChwrfigJrigJ7igLDDgsOKw4HDi8OIw43DjsOPw4zDk8OU76O/w5LDmsObw5nEscuGy5zCr8uYy5nLmsK4y53Lm8uHJyxcbiAgICAneC1tYWMtdHVya2lzaCc6ICAvLyBQeXRob246ICdtYWNfdHVya2lzaCdcbiAgICAnw4TDhcOHw4nDkcOWw5zDocOgw6LDpMOjw6XDp8Opw6jDqsOrw63DrMOuw6/DscOzw7LDtMO2w7XDusO5w7vDvOKAoMKwwqLCo8Kn4oCiwrbDn8KuwqnihKLCtMKo4omgw4bDmOKInsKx4omk4omlwqXCteKIguKIkeKIj8+A4oirwqrCus6pw6bDuCcgK1xuICAgICfCv8KhwqziiJrGkuKJiOKIhsKrwrvigKbCoMOAw4PDlcWSxZPigJPigJTigJzigJ3igJjigJnDt+KXisO/xbjEnsSfxLDEscWexZ/igKHCt+KAmuKAnuKAsMOCw4rDgcOLw4jDjcOOw4/DjMOTw5Tvo7/DksOaw5vDme+ioMuGy5zCr8uYy5nLmsK4y53Lm8uHJ1xufTtcblxuLyoqXG4gKiBEZWNvZGVzIGFuIG9sZC1zdHlsZSBNYWNpbnRvc2ggc3RyaW5nLiBSZXR1cm5zIGVpdGhlciBhIFVuaWNvZGUgSmF2YVNjcmlwdFxuICogc3RyaW5nLCBvciAndW5kZWZpbmVkJyBpZiB0aGUgZW5jb2RpbmcgaXMgdW5zdXBwb3J0ZWQuIEZvciBleGFtcGxlLCB3ZSBkb1xuICogbm90IHN1cHBvcnQgQ2hpbmVzZSwgSmFwYW5lc2Ugb3IgS29yZWFuIGJlY2F1c2UgdGhlc2Ugd291bGQgbmVlZCBsYXJnZVxuICogbWFwcGluZyB0YWJsZXMuXG4gKiBAcGFyYW0ge0RhdGFWaWV3fSBkYXRhVmlld1xuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxuICogQHBhcmFtIHtudW1iZXJ9IGRhdGFMZW5ndGhcbiAqIEBwYXJhbSB7c3RyaW5nfSBlbmNvZGluZ1xuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZGVjb2RlLk1BQ1NUUklORyA9IGZ1bmN0aW9uKGRhdGFWaWV3LCBvZmZzZXQsIGRhdGFMZW5ndGgsIGVuY29kaW5nKSB7XG4gICAgY29uc3QgdGFibGUgPSBlaWdodEJpdE1hY0VuY29kaW5nc1tlbmNvZGluZ107XG4gICAgaWYgKHRhYmxlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBsZXQgcmVzdWx0ID0gJyc7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgYyA9IGRhdGFWaWV3LmdldFVpbnQ4KG9mZnNldCArIGkpO1xuICAgICAgICAvLyBJbiBhbGwgZWlnaHQtYml0IE1hYyBlbmNvZGluZ3MsIHRoZSBjaGFyYWN0ZXJzIDB4MDAuLjB4N0YgYXJlXG4gICAgICAgIC8vIG1hcHBlZCB0byBVKzAwMDAuLlUrMDA3Rjsgd2Ugb25seSBuZWVkIHRvIGxvb2sgdXAgdGhlIG90aGVycy5cbiAgICAgICAgaWYgKGMgPD0gMHg3Rikge1xuICAgICAgICAgICAgcmVzdWx0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gdGFibGVbYyAmIDB4N0ZdO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8vIEhlbHBlciBmdW5jdGlvbiBmb3IgZW5jb2RlLk1BQ1NUUklORy4gUmV0dXJucyBhIGRpY3Rpb25hcnkgZm9yIG1hcHBpbmdcbi8vIFVuaWNvZGUgY2hhcmFjdGVyIGNvZGVzIHRvIHRoZWlyIDgtYml0IE1hY09TIGVxdWl2YWxlbnQuIFRoaXMgdGFibGVcbi8vIGlzIG5vdCBleGFjdGx5IGEgc3VwZXIgY2hlYXAgZGF0YSBzdHJ1Y3R1cmUsIGJ1dCB3ZSBkbyBub3QgY2FyZSBiZWNhdXNlXG4vLyBlbmNvZGluZyBNYWNpbnRvc2ggc3RyaW5ncyBpcyBvbmx5IHJhcmVseSBuZWVkZWQgaW4gdHlwaWNhbCBhcHBsaWNhdGlvbnMuXG5jb25zdCBtYWNFbmNvZGluZ1RhYmxlQ2FjaGUgPSB0eXBlb2YgV2Vha01hcCA9PT0gJ2Z1bmN0aW9uJyAmJiBuZXcgV2Vha01hcCgpO1xubGV0IG1hY0VuY29kaW5nQ2FjaGVLZXlzO1xuY29uc3QgZ2V0TWFjRW5jb2RpbmdUYWJsZSA9IGZ1bmN0aW9uIChlbmNvZGluZykge1xuICAgIC8vIFNpbmNlIHdlIHVzZSBlbmNvZGluZyBhcyBhIGNhY2hlIGtleSBmb3IgV2Vha01hcCwgaXQgaGFzIHRvIGJlXG4gICAgLy8gYSBTdHJpbmcgb2JqZWN0IGFuZCBub3QgYSBsaXRlcmFsLiBBbmQgYXQgbGVhc3Qgb24gTm9kZUpTIDIuMTAuMSxcbiAgICAvLyBXZWFrTWFwIHJlcXVpcmVzIHRoYXQgdGhlIHNhbWUgU3RyaW5nIGluc3RhbmNlIGlzIHBhc3NlZCBmb3IgY2FjaGUgaGl0cy5cbiAgICBpZiAoIW1hY0VuY29kaW5nQ2FjaGVLZXlzKSB7XG4gICAgICAgIG1hY0VuY29kaW5nQ2FjaGVLZXlzID0ge307XG4gICAgICAgIGZvciAobGV0IGUgaW4gZWlnaHRCaXRNYWNFbmNvZGluZ3MpIHtcbiAgICAgICAgICAgIC8qanNoaW50IC1XMDUzICovICAvLyBTdXBwcmVzcyBcIkRvIG5vdCB1c2UgU3RyaW5nIGFzIGEgY29uc3RydWN0b3IuXCJcbiAgICAgICAgICAgIG1hY0VuY29kaW5nQ2FjaGVLZXlzW2VdID0gbmV3IFN0cmluZyhlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGNhY2hlS2V5ID0gbWFjRW5jb2RpbmdDYWNoZUtleXNbZW5jb2RpbmddO1xuICAgIGlmIChjYWNoZUtleSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLy8gV2UgY2FuJ3QgZG8gXCJpZiAoY2FjaGUuaGFzKGtleSkpIHtyZXR1cm4gY2FjaGUuZ2V0KGtleSl9XCIgaGVyZTpcbiAgICAvLyBzaW5jZSBnYXJiYWdlIGNvbGxlY3Rpb24gbWF5IHJ1biBhdCBhbnkgdGltZSwgaXQgY291bGQgYWxzbyBraWNrIGluXG4gICAgLy8gYmV0d2VlbiB0aGUgY2FsbHMgdG8gY2FjaGUuaGFzKCkgYW5kIGNhY2hlLmdldCgpLiBJbiB0aGF0IGNhc2UsXG4gICAgLy8gd2Ugd291bGQgcmV0dXJuICd1bmRlZmluZWQnIGV2ZW4gdGhvdWdoIHdlIGRvIHN1cHBvcnQgdGhlIGVuY29kaW5nLlxuICAgIGlmIChtYWNFbmNvZGluZ1RhYmxlQ2FjaGUpIHtcbiAgICAgICAgY29uc3QgY2FjaGVkVGFibGUgPSBtYWNFbmNvZGluZ1RhYmxlQ2FjaGUuZ2V0KGNhY2hlS2V5KTtcbiAgICAgICAgaWYgKGNhY2hlZFRhYmxlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRUYWJsZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGRlY29kaW5nVGFibGUgPSBlaWdodEJpdE1hY0VuY29kaW5nc1tlbmNvZGluZ107XG4gICAgaWYgKGRlY29kaW5nVGFibGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGNvbnN0IGVuY29kaW5nVGFibGUgPSB7fTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRlY29kaW5nVGFibGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZW5jb2RpbmdUYWJsZVtkZWNvZGluZ1RhYmxlLmNoYXJDb2RlQXQoaSldID0gaSArIDB4ODA7XG4gICAgfVxuXG4gICAgaWYgKG1hY0VuY29kaW5nVGFibGVDYWNoZSkge1xuICAgICAgICBtYWNFbmNvZGluZ1RhYmxlQ2FjaGUuc2V0KGNhY2hlS2V5LCBlbmNvZGluZ1RhYmxlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZW5jb2RpbmdUYWJsZTtcbn07XG5cbi8qKlxuICogRW5jb2RlcyBhbiBvbGQtc3R5bGUgTWFjaW50b3NoIHN0cmluZy4gUmV0dXJucyBhIGJ5dGUgYXJyYXkgdXBvbiBzdWNjZXNzLlxuICogSWYgdGhlIHJlcXVlc3RlZCBlbmNvZGluZyBpcyB1bnN1cHBvcnRlZCwgb3IgaWYgdGhlIGlucHV0IHN0cmluZyBjb250YWluc1xuICogYSBjaGFyYWN0ZXIgdGhhdCBjYW5ub3QgYmUgZXhwcmVzc2VkIGluIHRoZSBlbmNvZGluZywgdGhlIGZ1bmN0aW9uIHJldHVybnNcbiAqICd1bmRlZmluZWQnLlxuICogQHBhcmFtIHtzdHJpbmd9IHN0clxuICogQHBhcmFtIHtzdHJpbmd9IGVuY29kaW5nXG4gKiBAcmV0dXJucyB7QXJyYXl9XG4gKi9cbmVuY29kZS5NQUNTVFJJTkcgPSBmdW5jdGlvbihzdHIsIGVuY29kaW5nKSB7XG4gICAgY29uc3QgdGFibGUgPSBnZXRNYWNFbmNvZGluZ1RhYmxlKGVuY29kaW5nKTtcbiAgICBpZiAodGFibGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBjID0gc3RyLmNoYXJDb2RlQXQoaSk7XG5cbiAgICAgICAgLy8gSW4gYWxsIGVpZ2h0LWJpdCBNYWMgZW5jb2RpbmdzLCB0aGUgY2hhcmFjdGVycyAweDAwLi4weDdGIGFyZVxuICAgICAgICAvLyBtYXBwZWQgdG8gVSswMDAwLi5VKzAwN0Y7IHdlIG9ubHkgbmVlZCB0byBsb29rIHVwIHRoZSBvdGhlcnMuXG4gICAgICAgIGlmIChjID49IDB4ODApIHtcbiAgICAgICAgICAgIGMgPSB0YWJsZVtjXTtcbiAgICAgICAgICAgIGlmIChjID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBzdHIgY29udGFpbnMgYSBVbmljb2RlIGNoYXJhY3RlciB0aGF0IGNhbm5vdCBiZSBlbmNvZGVkXG4gICAgICAgICAgICAgICAgLy8gaW4gdGhlIHJlcXVlc3RlZCBlbmNvZGluZy5cbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJlc3VsdFtpXSA9IGM7XG4gICAgICAgIC8vIHJlc3VsdC5wdXNoKGMpO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBlbmNvZGluZ1xuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuc2l6ZU9mLk1BQ1NUUklORyA9IGZ1bmN0aW9uKHN0ciwgZW5jb2RpbmcpIHtcbiAgICBjb25zdCBiID0gZW5jb2RlLk1BQ1NUUklORyhzdHIsIGVuY29kaW5nKTtcbiAgICBpZiAoYiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBiLmxlbmd0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG59O1xuXG4vLyBIZWxwZXIgZm9yIGVuY29kZS5WQVJERUxUQVNcbmZ1bmN0aW9uIGlzQnl0ZUVuY29kYWJsZSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSA+PSAtMTI4ICYmIHZhbHVlIDw9IDEyNztcbn1cblxuLy8gSGVscGVyIGZvciBlbmNvZGUuVkFSREVMVEFTXG5mdW5jdGlvbiBlbmNvZGVWYXJEZWx0YVJ1bkFzWmVyb2VzKGRlbHRhcywgcG9zLCByZXN1bHQpIHtcbiAgICBsZXQgcnVuTGVuZ3RoID0gMDtcbiAgICBjb25zdCBudW1EZWx0YXMgPSBkZWx0YXMubGVuZ3RoO1xuICAgIHdoaWxlIChwb3MgPCBudW1EZWx0YXMgJiYgcnVuTGVuZ3RoIDwgNjQgJiYgZGVsdGFzW3Bvc10gPT09IDApIHtcbiAgICAgICAgKytwb3M7XG4gICAgICAgICsrcnVuTGVuZ3RoO1xuICAgIH1cbiAgICByZXN1bHQucHVzaCgweDgwIHwgKHJ1bkxlbmd0aCAtIDEpKTtcbiAgICByZXR1cm4gcG9zO1xufVxuXG4vLyBIZWxwZXIgZm9yIGVuY29kZS5WQVJERUxUQVNcbmZ1bmN0aW9uIGVuY29kZVZhckRlbHRhUnVuQXNCeXRlcyhkZWx0YXMsIG9mZnNldCwgcmVzdWx0KSB7XG4gICAgbGV0IHJ1bkxlbmd0aCA9IDA7XG4gICAgY29uc3QgbnVtRGVsdGFzID0gZGVsdGFzLmxlbmd0aDtcbiAgICBsZXQgcG9zID0gb2Zmc2V0O1xuICAgIHdoaWxlIChwb3MgPCBudW1EZWx0YXMgJiYgcnVuTGVuZ3RoIDwgNjQpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBkZWx0YXNbcG9zXTtcbiAgICAgICAgaWYgKCFpc0J5dGVFbmNvZGFibGUodmFsdWUpKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFdpdGhpbiBhIGJ5dGUtZW5jb2RlZCBydW4gb2YgZGVsdGFzLCBhIHNpbmdsZSB6ZXJvIGlzIGJlc3RcbiAgICAgICAgLy8gc3RvcmVkIGxpdGVyYWxseSBhcyAweDAwIHZhbHVlLiBIb3dldmVyLCBpZiB3ZSBoYXZlIHR3byBvclxuICAgICAgICAvLyBtb3JlIHplcm9lcyBpbiBhIHNlcXVlbmNlLCBpdCBpcyBiZXR0ZXIgdG8gc3RhcnQgYSBuZXcgcnVuLlxuICAgICAgICAvLyBGb3JlIGV4YW1wbGUsIHRoZSBzZXF1ZW5jZSBvZiBkZWx0YXMgWzE1LCAxNSwgMCwgMTUsIDE1XVxuICAgICAgICAvLyBiZWNvbWVzIDYgYnl0ZXMgKDA0IDBGIDBGIDAwIDBGIDBGKSB3aGVuIHN0b3JpbmcgdGhlIHplcm9cbiAgICAgICAgLy8gd2l0aGluIHRoZSBjdXJyZW50IHJ1biwgYnV0IDcgYnl0ZXMgKDAxIDBGIDBGIDgwIDAxIDBGIDBGKVxuICAgICAgICAvLyB3aGVuIHN0YXJ0aW5nIGEgbmV3IHJ1bi5cbiAgICAgICAgaWYgKHZhbHVlID09PSAwICYmIHBvcyArIDEgPCBudW1EZWx0YXMgJiYgZGVsdGFzW3BvcyArIDFdID09PSAwKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgICsrcG9zO1xuICAgICAgICArK3J1bkxlbmd0aDtcbiAgICB9XG4gICAgcmVzdWx0LnB1c2gocnVuTGVuZ3RoIC0gMSk7XG4gICAgZm9yIChsZXQgaSA9IG9mZnNldDsgaSA8IHBvczsgKytpKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKChkZWx0YXNbaV0gKyAyNTYpICYgMHhmZik7XG4gICAgfVxuICAgIHJldHVybiBwb3M7XG59XG5cbi8vIEhlbHBlciBmb3IgZW5jb2RlLlZBUkRFTFRBU1xuZnVuY3Rpb24gZW5jb2RlVmFyRGVsdGFSdW5Bc1dvcmRzKGRlbHRhcywgb2Zmc2V0LCByZXN1bHQpIHtcbiAgICBsZXQgcnVuTGVuZ3RoID0gMDtcbiAgICBjb25zdCBudW1EZWx0YXMgPSBkZWx0YXMubGVuZ3RoO1xuICAgIGxldCBwb3MgPSBvZmZzZXQ7XG4gICAgd2hpbGUgKHBvcyA8IG51bURlbHRhcyAmJiBydW5MZW5ndGggPCA2NCkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGRlbHRhc1twb3NdO1xuXG4gICAgICAgIC8vIFdpdGhpbiBhIHdvcmQtZW5jb2RlZCBydW4gb2YgZGVsdGFzLCBpdCBpcyBlYXNpZXN0IHRvIHN0YXJ0XG4gICAgICAgIC8vIGEgbmV3IHJ1biAod2l0aCBhIGRpZmZlcmVudCBlbmNvZGluZykgd2hlbmV2ZXIgd2UgZW5jb3VudGVyXG4gICAgICAgIC8vIGEgemVybyB2YWx1ZS4gRm9yIGV4YW1wbGUsIHRoZSBzZXF1ZW5jZSBbMHg2NjY2LCAwLCAweDc3NzddXG4gICAgICAgIC8vIG5lZWRzIDcgYnl0ZXMgd2hlbiBzdG9yaW5nIHRoZSB6ZXJvIGluc2lkZSB0aGUgY3VycmVudCBydW5cbiAgICAgICAgLy8gKDQyIDY2IDY2IDAwIDAwIDc3IDc3KSwgYW5kIGVxdWFsbHkgNyBieXRlcyB3aGVuIHN0YXJ0aW5nIGFcbiAgICAgICAgLy8gbmV3IHJ1biAoNDAgNjYgNjYgODAgNDAgNzcgNzcpLlxuICAgICAgICBpZiAodmFsdWUgPT09IDApIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gV2l0aGluIGEgd29yZC1lbmNvZGVkIHJ1biBvZiBkZWx0YXMsIGEgc2luZ2xlIHZhbHVlIGluIHRoZVxuICAgICAgICAvLyByYW5nZSAoLTEyOC4uMTI3KSBzaG91bGQgYmUgZW5jb2RlZCB3aXRoaW4gdGhlIGN1cnJlbnQgcnVuXG4gICAgICAgIC8vIGJlY2F1c2UgaXQgaXMgbW9yZSBjb21wYWN0LiBGb3IgZXhhbXBsZSwgdGhlIHNlcXVlbmNlXG4gICAgICAgIC8vIFsweDY2NjYsIDIsIDB4Nzc3N10gYmVjb21lcyA3IGJ5dGVzIHdoZW4gc3RvcmluZyB0aGUgdmFsdWVcbiAgICAgICAgLy8gbGl0ZXJhbGx5ICg0MiA2NiA2NiAwMCAwMiA3NyA3NyksIGJ1dCA4IGJ5dGVzIHdoZW4gc3RhcnRpbmdcbiAgICAgICAgLy8gYSBuZXcgcnVuICg0MCA2NiA2NiAwMCAwMiA0MCA3NyA3NykuXG4gICAgICAgIGlmIChpc0J5dGVFbmNvZGFibGUodmFsdWUpICYmIHBvcyArIDEgPCBudW1EZWx0YXMgJiYgaXNCeXRlRW5jb2RhYmxlKGRlbHRhc1twb3MgKyAxXSkpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgKytwb3M7XG4gICAgICAgICsrcnVuTGVuZ3RoO1xuICAgIH1cbiAgICByZXN1bHQucHVzaCgweDQwIHwgKHJ1bkxlbmd0aCAtIDEpKTtcbiAgICBmb3IgKGxldCBpID0gb2Zmc2V0OyBpIDwgcG9zOyArK2kpIHtcbiAgICAgICAgY29uc3QgdmFsID0gZGVsdGFzW2ldO1xuICAgICAgICByZXN1bHQucHVzaCgoKHZhbCArIDB4MTAwMDApID4+IDgpICYgMHhmZiwgKHZhbCArIDB4MTAwKSAmIDB4ZmYpO1xuICAgIH1cbiAgICByZXR1cm4gcG9zO1xufVxuXG4vKipcbiAqIEVuY29kZSBhIGxpc3Qgb2YgdmFyaWF0aW9uIGFkanVzdG1lbnQgZGVsdGFzLlxuICpcbiAqIFZhcmlhdGlvbiBhZGp1c3RtZW50IGRlbHRhcyBhcmUgdXNlZCBpbiDigJhndmFy4oCZIGFuZCDigJhjdmFy4oCZIHRhYmxlcy5cbiAqIFRoZXkgaW5kaWNhdGUgaG93IHBvaW50cyAoaW4g4oCYZ3ZhcuKAmSkgb3IgdmFsdWVzIChpbiDigJhjdmFy4oCZKSBnZXQgYWRqdXN0ZWRcbiAqIHdoZW4gZ2VuZXJhdGluZyBpbnN0YW5jZXMgb2YgdmFyaWF0aW9uIGZvbnRzLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly93d3cubWljcm9zb2Z0LmNvbS90eXBvZ3JhcGh5L290c3BlYy9ndmFyLmh0bVxuICogQHNlZSBodHRwczovL2RldmVsb3Blci5hcHBsZS5jb20vZm9udHMvVHJ1ZVR5cGUtUmVmZXJlbmNlLU1hbnVhbC9STTA2L0NoYXA2Z3Zhci5odG1sXG4gKiBAcGFyYW0ge0FycmF5fVxuICogQHJldHVybiB7QXJyYXl9XG4gKi9cbmVuY29kZS5WQVJERUxUQVMgPSBmdW5jdGlvbihkZWx0YXMpIHtcbiAgICBsZXQgcG9zID0gMDtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICB3aGlsZSAocG9zIDwgZGVsdGFzLmxlbmd0aCkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGRlbHRhc1twb3NdO1xuICAgICAgICBpZiAodmFsdWUgPT09IDApIHtcbiAgICAgICAgICAgIHBvcyA9IGVuY29kZVZhckRlbHRhUnVuQXNaZXJvZXMoZGVsdGFzLCBwb3MsIHJlc3VsdCk7XG4gICAgICAgIH0gZWxzZSBpZiAodmFsdWUgPj0gLTEyOCAmJiB2YWx1ZSA8PSAxMjcpIHtcbiAgICAgICAgICAgIHBvcyA9IGVuY29kZVZhckRlbHRhUnVuQXNCeXRlcyhkZWx0YXMsIHBvcywgcmVzdWx0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBvcyA9IGVuY29kZVZhckRlbHRhUnVuQXNXb3JkcyhkZWx0YXMsIHBvcywgcmVzdWx0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuLy8gQ29udmVydCBhIGxpc3Qgb2YgdmFsdWVzIHRvIGEgQ0ZGIElOREVYIHN0cnVjdHVyZS5cbi8vIFRoZSB2YWx1ZXMgc2hvdWxkIGJlIG9iamVjdHMgY29udGFpbmluZyBuYW1lIC8gdHlwZSAvIHZhbHVlLlxuLyoqXG4gKiBAcGFyYW0ge0FycmF5fSBsXG4gKiBAcmV0dXJucyB7QXJyYXl9XG4gKi9cbmVuY29kZS5JTkRFWCA9IGZ1bmN0aW9uKGwpIHtcbiAgICAvL3ZhciBvZmZzZXQsIG9mZnNldHMsIG9mZnNldEVuY29kZXIsIGVuY29kZWRPZmZzZXRzLCBlbmNvZGVkT2Zmc2V0LCBkYXRhLFxuICAgIC8vICAgIGksIHY7XG4gICAgLy8gQmVjYXVzZSB3ZSBoYXZlIHRvIGtub3cgd2hpY2ggZGF0YSB0eXBlIHRvIHVzZSB0byBlbmNvZGUgdGhlIG9mZnNldHMsXG4gICAgLy8gd2UgaGF2ZSB0byBnbyB0aHJvdWdoIHRoZSB2YWx1ZXMgdHdpY2U6IG9uY2UgdG8gZW5jb2RlIHRoZSBkYXRhIGFuZFxuICAgIC8vIGNhbGN1bGF0ZSB0aGUgb2Zmc2V0cywgdGhlbiBhZ2FpbiB0byBlbmNvZGUgdGhlIG9mZnNldHMgdXNpbmcgdGhlIGZpdHRpbmcgZGF0YSB0eXBlLlxuICAgIGxldCBvZmZzZXQgPSAxOyAvLyBGaXJzdCBvZmZzZXQgaXMgYWx3YXlzIDEuXG4gICAgY29uc3Qgb2Zmc2V0cyA9IFtvZmZzZXRdO1xuICAgIGNvbnN0IGRhdGEgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGwubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgY29uc3QgdiA9IGVuY29kZS5PQkpFQ1QobFtpXSk7XG4gICAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KGRhdGEsIHYpO1xuICAgICAgICBvZmZzZXQgKz0gdi5sZW5ndGg7XG4gICAgICAgIG9mZnNldHMucHVzaChvZmZzZXQpO1xuICAgIH1cblxuICAgIGlmIChkYXRhLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gWzAsIDBdO1xuICAgIH1cblxuICAgIGNvbnN0IGVuY29kZWRPZmZzZXRzID0gW107XG4gICAgY29uc3Qgb2ZmU2l6ZSA9ICgxICsgTWF0aC5mbG9vcihNYXRoLmxvZyhvZmZzZXQpIC8gTWF0aC5sb2coMikpIC8gOCkgfCAwO1xuICAgIGNvbnN0IG9mZnNldEVuY29kZXIgPSBbdW5kZWZpbmVkLCBlbmNvZGUuQllURSwgZW5jb2RlLlVTSE9SVCwgZW5jb2RlLlVJTlQyNCwgZW5jb2RlLlVMT05HXVtvZmZTaXplXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG9mZnNldHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgY29uc3QgZW5jb2RlZE9mZnNldCA9IG9mZnNldEVuY29kZXIob2Zmc2V0c1tpXSk7XG4gICAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KGVuY29kZWRPZmZzZXRzLCBlbmNvZGVkT2Zmc2V0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLmNvbmNhdChlbmNvZGUuQ2FyZDE2KGwubGVuZ3RoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuY29kZS5PZmZTaXplKG9mZlNpemUpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5jb2RlZE9mZnNldHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhKTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtBcnJheX1cbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbnNpemVPZi5JTkRFWCA9IGZ1bmN0aW9uKHYpIHtcbiAgICByZXR1cm4gZW5jb2RlLklOREVYKHYpLmxlbmd0aDtcbn07XG5cbi8qKlxuICogQ29udmVydCBhbiBvYmplY3QgdG8gYSBDRkYgRElDVCBzdHJ1Y3R1cmUuXG4gKiBUaGUga2V5cyBzaG91bGQgYmUgbnVtZXJpYy5cbiAqIFRoZSB2YWx1ZXMgc2hvdWxkIGJlIG9iamVjdHMgY29udGFpbmluZyBuYW1lIC8gdHlwZSAvIHZhbHVlLlxuICogQHBhcmFtIHtPYmplY3R9IG1cbiAqIEByZXR1cm5zIHtBcnJheX1cbiAqL1xuZW5jb2RlLkRJQ1QgPSBmdW5jdGlvbihtKSB7XG4gICAgbGV0IGQgPSBbXTtcbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMobSk7XG4gICAgY29uc3QgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIC8vIE9iamVjdC5rZXlzKCkgcmV0dXJuIHN0cmluZyBrZXlzLCBidXQgb3VyIGtleXMgYXJlIGFsd2F5cyBudW1lcmljLlxuICAgICAgICBjb25zdCBrID0gcGFyc2VJbnQoa2V5c1tpXSwgMCk7XG4gICAgICAgIGNvbnN0IHYgPSBtW2tdO1xuICAgICAgICAvLyBWYWx1ZSBjb21lcyBiZWZvcmUgdGhlIGtleS5cbiAgICAgICAgZCA9IGQuY29uY2F0KGVuY29kZS5PUEVSQU5EKHYudmFsdWUsIHYudHlwZSkpO1xuICAgICAgICBkID0gZC5jb25jYXQoZW5jb2RlLk9QRVJBVE9SKGspKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZDtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtPYmplY3R9XG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5zaXplT2YuRElDVCA9IGZ1bmN0aW9uKG0pIHtcbiAgICByZXR1cm4gZW5jb2RlLkRJQ1QobSkubGVuZ3RoO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn1cbiAqIEByZXR1cm5zIHtBcnJheX1cbiAqL1xuZW5jb2RlLk9QRVJBVE9SID0gZnVuY3Rpb24odikge1xuICAgIGlmICh2IDwgMTIwMCkge1xuICAgICAgICByZXR1cm4gW3ZdO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBbMTIsIHYgLSAxMjAwXTtcbiAgICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXl9IHZcbiAqIEBwYXJhbSB7c3RyaW5nfVxuICogQHJldHVybnMge0FycmF5fVxuICovXG5lbmNvZGUuT1BFUkFORCA9IGZ1bmN0aW9uKHYsIHR5cGUpIHtcbiAgICBsZXQgZCA9IFtdO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHR5cGUpKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdHlwZS5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgY2hlY2suYXJndW1lbnQodi5sZW5ndGggPT09IHR5cGUubGVuZ3RoLCAnTm90IGVub3VnaCBhcmd1bWVudHMgZ2l2ZW4gZm9yIHR5cGUnICsgdHlwZSk7XG4gICAgICAgICAgICBkID0gZC5jb25jYXQoZW5jb2RlLk9QRVJBTkQodltpXSwgdHlwZVtpXSkpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHR5cGUgPT09ICdTSUQnKSB7XG4gICAgICAgICAgICBkID0gZC5jb25jYXQoZW5jb2RlLk5VTUJFUih2KSk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ29mZnNldCcpIHtcbiAgICAgICAgICAgIC8vIFdlIG1ha2UgaXQgZWFzeSBmb3Igb3Vyc2VsdmVzIGFuZCBhbHdheXMgZW5jb2RlIG9mZnNldHMgYXNcbiAgICAgICAgICAgIC8vIDQgYnl0ZXMuIFRoaXMgbWFrZXMgb2Zmc2V0IGNhbGN1bGF0aW9uIGZvciB0aGUgdG9wIGRpY3QgZWFzaWVyLlxuICAgICAgICAgICAgZCA9IGQuY29uY2F0KGVuY29kZS5OVU1CRVIzMih2KSk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIGQgPSBkLmNvbmNhdChlbmNvZGUuTlVNQkVSKHYpKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAncmVhbCcpIHtcbiAgICAgICAgICAgIGQgPSBkLmNvbmNhdChlbmNvZGUuUkVBTCh2KSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gb3BlcmFuZCB0eXBlICcgKyB0eXBlKTtcbiAgICAgICAgICAgIC8vIEZJWE1FIEFkZCBzdXBwb3J0IGZvciBib29sZWFuc1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGQ7XG59O1xuXG5lbmNvZGUuT1AgPSBlbmNvZGUuQllURTtcbnNpemVPZi5PUCA9IHNpemVPZi5CWVRFO1xuXG4vLyBtZW1vaXplIGNoYXJzdHJpbmcgZW5jb2RpbmcgdXNpbmcgV2Vha01hcCBpZiBhdmFpbGFibGVcbmNvbnN0IHdtbSA9IHR5cGVvZiBXZWFrTWFwID09PSAnZnVuY3Rpb24nICYmIG5ldyBXZWFrTWFwKCk7XG5cbi8qKlxuICogQ29udmVydCBhIGxpc3Qgb2YgQ2hhclN0cmluZyBvcGVyYXRpb25zIHRvIGJ5dGVzLlxuICogQHBhcmFtIHtBcnJheX1cbiAqIEByZXR1cm5zIHtBcnJheX1cbiAqL1xuZW5jb2RlLkNIQVJTVFJJTkcgPSBmdW5jdGlvbihvcHMpIHtcbiAgICAvLyBTZWUgZW5jb2RlLk1BQ1NUUklORyBmb3Igd2h5IHdlIGRvbid0IGRvIFwiaWYgKHdtbSAmJiB3bW0uaGFzKG9wcykpXCIuXG4gICAgaWYgKHdtbSkge1xuICAgICAgICBjb25zdCBjYWNoZWRWYWx1ZSA9IHdtbS5nZXQob3BzKTtcbiAgICAgICAgaWYgKGNhY2hlZFZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRWYWx1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGxldCBkID0gW107XG4gICAgY29uc3QgbGVuZ3RoID0gb3BzLmxlbmd0aDtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgY29uc3Qgb3AgPSBvcHNbaV07XG4gICAgICAgIGQgPSBkLmNvbmNhdChlbmNvZGVbb3AudHlwZV0ob3AudmFsdWUpKTtcbiAgICB9XG5cbiAgICBpZiAod21tKSB7XG4gICAgICAgIHdtbS5zZXQob3BzLCBkKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZDtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtBcnJheX1cbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbnNpemVPZi5DSEFSU1RSSU5HID0gZnVuY3Rpb24ob3BzKSB7XG4gICAgcmV0dXJuIGVuY29kZS5DSEFSU1RSSU5HKG9wcykubGVuZ3RoO1xufTtcblxuLy8gVXRpbGl0eSBmdW5jdGlvbnMgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuLyoqXG4gKiBDb252ZXJ0IGFuIG9iamVjdCBjb250YWluaW5nIG5hbWUgLyB0eXBlIC8gdmFsdWUgdG8gYnl0ZXMuXG4gKiBAcGFyYW0ge09iamVjdH1cbiAqIEByZXR1cm5zIHtBcnJheX1cbiAqL1xuZW5jb2RlLk9CSkVDVCA9IGZ1bmN0aW9uKHYpIHtcbiAgICBjb25zdCBlbmNvZGluZ0Z1bmN0aW9uID0gZW5jb2RlW3YudHlwZV07XG4gICAgY2hlY2suYXJndW1lbnQoZW5jb2RpbmdGdW5jdGlvbiAhPT0gdW5kZWZpbmVkLCAnTm8gZW5jb2RpbmcgZnVuY3Rpb24gZm9yIHR5cGUgJyArIHYudHlwZSk7XG4gICAgcmV0dXJuIGVuY29kaW5nRnVuY3Rpb24odi52YWx1ZSk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7T2JqZWN0fVxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuc2l6ZU9mLk9CSkVDVCA9IGZ1bmN0aW9uKHYpIHtcbiAgICBjb25zdCBzaXplT2ZGdW5jdGlvbiA9IHNpemVPZlt2LnR5cGVdO1xuICAgIGNoZWNrLmFyZ3VtZW50KHNpemVPZkZ1bmN0aW9uICE9PSB1bmRlZmluZWQsICdObyBzaXplT2YgZnVuY3Rpb24gZm9yIHR5cGUgJyArIHYudHlwZSk7XG4gICAgcmV0dXJuIHNpemVPZkZ1bmN0aW9uKHYudmFsdWUpO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0IGEgdGFibGUgb2JqZWN0IHRvIGJ5dGVzLlxuICogQSB0YWJsZSBjb250YWlucyBhIGxpc3Qgb2YgZmllbGRzIGNvbnRhaW5pbmcgdGhlIG1ldGFkYXRhIChuYW1lLCB0eXBlIGFuZCBkZWZhdWx0IHZhbHVlKS5cbiAqIFRoZSB0YWJsZSBpdHNlbGYgaGFzIHRoZSBmaWVsZCB2YWx1ZXMgc2V0IGFzIGF0dHJpYnV0ZXMuXG4gKiBAcGFyYW0ge29wZW50eXBlLlRhYmxlfVxuICogQHJldHVybnMge0FycmF5fVxuICovXG5lbmNvZGUuVEFCTEUgPSBmdW5jdGlvbih0YWJsZSkge1xuICAgIGxldCBkID0gW107XG4gICAgY29uc3QgbGVuZ3RoID0gdGFibGUuZmllbGRzLmxlbmd0aDtcbiAgICBjb25zdCBzdWJ0YWJsZXMgPSBbXTtcbiAgICBjb25zdCBzdWJ0YWJsZU9mZnNldHMgPSBbXTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgY29uc3QgZmllbGQgPSB0YWJsZS5maWVsZHNbaV07XG4gICAgICAgIGNvbnN0IGVuY29kaW5nRnVuY3Rpb24gPSBlbmNvZGVbZmllbGQudHlwZV07XG4gICAgICAgIGNoZWNrLmFyZ3VtZW50KGVuY29kaW5nRnVuY3Rpb24gIT09IHVuZGVmaW5lZCwgJ05vIGVuY29kaW5nIGZ1bmN0aW9uIGZvciBmaWVsZCB0eXBlICcgKyBmaWVsZC50eXBlICsgJyAoJyArIGZpZWxkLm5hbWUgKyAnKScpO1xuICAgICAgICBsZXQgdmFsdWUgPSB0YWJsZVtmaWVsZC5uYW1lXTtcbiAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHZhbHVlID0gZmllbGQudmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBieXRlcyA9IGVuY29kaW5nRnVuY3Rpb24odmFsdWUpO1xuXG4gICAgICAgIGlmIChmaWVsZC50eXBlID09PSAnVEFCTEUnKSB7XG4gICAgICAgICAgICBzdWJ0YWJsZU9mZnNldHMucHVzaChkLmxlbmd0aCk7XG4gICAgICAgICAgICBkID0gZC5jb25jYXQoWzAsIDBdKTtcbiAgICAgICAgICAgIHN1YnRhYmxlcy5wdXNoKGJ5dGVzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGQgPSBkLmNvbmNhdChieXRlcyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN1YnRhYmxlcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBjb25zdCBvID0gc3VidGFibGVPZmZzZXRzW2ldO1xuICAgICAgICBjb25zdCBvZmZzZXQgPSBkLmxlbmd0aDtcbiAgICAgICAgY2hlY2suYXJndW1lbnQob2Zmc2V0IDwgNjU1MzYsICdUYWJsZSAnICsgdGFibGUudGFibGVOYW1lICsgJyB0b28gYmlnLicpO1xuICAgICAgICBkW29dID0gb2Zmc2V0ID4+IDg7XG4gICAgICAgIGRbbyArIDFdID0gb2Zmc2V0ICYgMHhmZjtcbiAgICAgICAgZCA9IGQuY29uY2F0KHN1YnRhYmxlc1tpXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGQ7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b3BlbnR5cGUuVGFibGV9XG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5zaXplT2YuVEFCTEUgPSBmdW5jdGlvbih0YWJsZSkge1xuICAgIGxldCBudW1CeXRlcyA9IDA7XG4gICAgY29uc3QgbGVuZ3RoID0gdGFibGUuZmllbGRzLmxlbmd0aDtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgY29uc3QgZmllbGQgPSB0YWJsZS5maWVsZHNbaV07XG4gICAgICAgIGNvbnN0IHNpemVPZkZ1bmN0aW9uID0gc2l6ZU9mW2ZpZWxkLnR5cGVdO1xuICAgICAgICBjaGVjay5hcmd1bWVudChzaXplT2ZGdW5jdGlvbiAhPT0gdW5kZWZpbmVkLCAnTm8gc2l6ZU9mIGZ1bmN0aW9uIGZvciBmaWVsZCB0eXBlICcgKyBmaWVsZC50eXBlICsgJyAoJyArIGZpZWxkLm5hbWUgKyAnKScpO1xuICAgICAgICBsZXQgdmFsdWUgPSB0YWJsZVtmaWVsZC5uYW1lXTtcbiAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHZhbHVlID0gZmllbGQudmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICBudW1CeXRlcyArPSBzaXplT2ZGdW5jdGlvbih2YWx1ZSk7XG5cbiAgICAgICAgLy8gU3VidGFibGVzIHRha2UgMiBtb3JlIGJ5dGVzIGZvciBvZmZzZXRzLlxuICAgICAgICBpZiAoZmllbGQudHlwZSA9PT0gJ1RBQkxFJykge1xuICAgICAgICAgICAgbnVtQnl0ZXMgKz0gMjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudW1CeXRlcztcbn07XG5cbmVuY29kZS5SRUNPUkQgPSBlbmNvZGUuVEFCTEU7XG5zaXplT2YuUkVDT1JEID0gc2l6ZU9mLlRBQkxFO1xuXG4vLyBNZXJnZSBpbiBhIGxpc3Qgb2YgYnl0ZXMuXG5lbmNvZGUuTElURVJBTCA9IGZ1bmN0aW9uKHYpIHtcbiAgICByZXR1cm4gdjtcbn07XG5cbnNpemVPZi5MSVRFUkFMID0gZnVuY3Rpb24odikge1xuICAgIHJldHVybiB2Lmxlbmd0aDtcbn07XG5cbmV4cG9ydCB7IGRlY29kZSwgZW5jb2RlLCBzaXplT2YgfTtcbiIsIi8vIFRhYmxlIG1ldGFkYXRhXG5cbmltcG9ydCBjaGVjayBmcm9tICcuL2NoZWNrJztcbmltcG9ydCB7IGVuY29kZSwgc2l6ZU9mIH0gZnJvbSAnLi90eXBlcyc7XG5cbi8qKlxuICogQGV4cG9ydHMgb3BlbnR5cGUuVGFibGVcbiAqIEBjbGFzc1xuICogQHBhcmFtIHtzdHJpbmd9IHRhYmxlTmFtZVxuICogQHBhcmFtIHtBcnJheX0gZmllbGRzXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIFRhYmxlKHRhYmxlTmFtZSwgZmllbGRzLCBvcHRpb25zKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmaWVsZHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgY29uc3QgZmllbGQgPSBmaWVsZHNbaV07XG4gICAgICAgIHRoaXNbZmllbGQubmFtZV0gPSBmaWVsZC52YWx1ZTtcbiAgICB9XG5cbiAgICB0aGlzLnRhYmxlTmFtZSA9IHRhYmxlTmFtZTtcbiAgICB0aGlzLmZpZWxkcyA9IGZpZWxkcztcbiAgICBpZiAob3B0aW9ucykge1xuICAgICAgICBjb25zdCBvcHRpb25LZXlzID0gT2JqZWN0LmtleXMob3B0aW9ucyk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3B0aW9uS2V5cy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgY29uc3QgayA9IG9wdGlvbktleXNbaV07XG4gICAgICAgICAgICBjb25zdCB2ID0gb3B0aW9uc1trXTtcbiAgICAgICAgICAgIGlmICh0aGlzW2tdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzW2tdID0gdjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cblxuLyoqXG4gKiBFbmNvZGVzIHRoZSB0YWJsZSBhbmQgcmV0dXJucyBhbiBhcnJheSBvZiBieXRlc1xuICogQHJldHVybiB7QXJyYXl9XG4gKi9cblRhYmxlLnByb3RvdHlwZS5lbmNvZGUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZW5jb2RlLlRBQkxFKHRoaXMpO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIHNpemUgb2YgdGhlIHRhYmxlLlxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5UYWJsZS5wcm90b3R5cGUuc2l6ZU9mID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHNpemVPZi5UQUJMRSh0aGlzKTtcbn07XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gdXNob3J0TGlzdChpdGVtTmFtZSwgbGlzdCwgY291bnQpIHtcbiAgICBpZiAoY291bnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb3VudCA9IGxpc3QubGVuZ3RoO1xuICAgIH1cbiAgICBjb25zdCBmaWVsZHMgPSBuZXcgQXJyYXkobGlzdC5sZW5ndGggKyAxKTtcbiAgICBmaWVsZHNbMF0gPSB7bmFtZTogaXRlbU5hbWUgKyAnQ291bnQnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IGNvdW50fTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZmllbGRzW2kgKyAxXSA9IHtuYW1lOiBpdGVtTmFtZSArIGksIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogbGlzdFtpXX07XG4gICAgfVxuICAgIHJldHVybiBmaWVsZHM7XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gdGFibGVMaXN0KGl0ZW1OYW1lLCByZWNvcmRzLCBpdGVtQ2FsbGJhY2spIHtcbiAgICBjb25zdCBjb3VudCA9IHJlY29yZHMubGVuZ3RoO1xuICAgIGNvbnN0IGZpZWxkcyA9IG5ldyBBcnJheShjb3VudCArIDEpO1xuICAgIGZpZWxkc1swXSA9IHtuYW1lOiBpdGVtTmFtZSArICdDb3VudCcsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogY291bnR9O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICBmaWVsZHNbaSArIDFdID0ge25hbWU6IGl0ZW1OYW1lICsgaSwgdHlwZTogJ1RBQkxFJywgdmFsdWU6IGl0ZW1DYWxsYmFjayhyZWNvcmRzW2ldLCBpKX07XG4gICAgfVxuICAgIHJldHVybiBmaWVsZHM7XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcmVjb3JkTGlzdChpdGVtTmFtZSwgcmVjb3JkcywgaXRlbUNhbGxiYWNrKSB7XG4gICAgY29uc3QgY291bnQgPSByZWNvcmRzLmxlbmd0aDtcbiAgICBsZXQgZmllbGRzID0gW107XG4gICAgZmllbGRzWzBdID0ge25hbWU6IGl0ZW1OYW1lICsgJ0NvdW50JywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiBjb3VudH07XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgIGZpZWxkcyA9IGZpZWxkcy5jb25jYXQoaXRlbUNhbGxiYWNrKHJlY29yZHNbaV0sIGkpKTtcbiAgICB9XG4gICAgcmV0dXJuIGZpZWxkcztcbn1cblxuLy8gQ29tbW9uIExheW91dCBUYWJsZXNcblxuLyoqXG4gKiBAZXhwb3J0cyBvcGVudHlwZS5Db3ZlcmFnZVxuICogQGNsYXNzXG4gKiBAcGFyYW0ge29wZW50eXBlLlRhYmxlfVxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBvcGVudHlwZS5UYWJsZVxuICovXG5mdW5jdGlvbiBDb3ZlcmFnZShjb3ZlcmFnZVRhYmxlKSB7XG4gICAgaWYgKGNvdmVyYWdlVGFibGUuZm9ybWF0ID09PSAxKSB7XG4gICAgICAgIFRhYmxlLmNhbGwodGhpcywgJ2NvdmVyYWdlVGFibGUnLFxuICAgICAgICAgICAgW3tuYW1lOiAnY292ZXJhZ2VGb3JtYXQnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDF9XVxuICAgICAgICAgICAgLmNvbmNhdCh1c2hvcnRMaXN0KCdnbHlwaCcsIGNvdmVyYWdlVGFibGUuZ2x5cGhzKSlcbiAgICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBjaGVjay5hc3NlcnQoZmFsc2UsICdDYW5cXCd0IGNyZWF0ZSBjb3ZlcmFnZSB0YWJsZSBmb3JtYXQgMiB5ZXQuJyk7XG4gICAgfVxufVxuQ292ZXJhZ2UucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShUYWJsZS5wcm90b3R5cGUpO1xuQ292ZXJhZ2UucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ292ZXJhZ2U7XG5cbmZ1bmN0aW9uIFNjcmlwdExpc3Qoc2NyaXB0TGlzdFRhYmxlKSB7XG4gICAgVGFibGUuY2FsbCh0aGlzLCAnc2NyaXB0TGlzdFRhYmxlJyxcbiAgICAgICAgcmVjb3JkTGlzdCgnc2NyaXB0UmVjb3JkJywgc2NyaXB0TGlzdFRhYmxlLCBmdW5jdGlvbihzY3JpcHRSZWNvcmQsIGkpIHtcbiAgICAgICAgICAgIGNvbnN0IHNjcmlwdCA9IHNjcmlwdFJlY29yZC5zY3JpcHQ7XG4gICAgICAgICAgICBsZXQgZGVmYXVsdExhbmdTeXMgPSBzY3JpcHQuZGVmYXVsdExhbmdTeXM7XG4gICAgICAgICAgICBjaGVjay5hc3NlcnQoISFkZWZhdWx0TGFuZ1N5cywgJ1VuYWJsZSB0byB3cml0ZSBHU1VCOiBzY3JpcHQgJyArIHNjcmlwdFJlY29yZC50YWcgKyAnIGhhcyBubyBkZWZhdWx0IGxhbmd1YWdlIHN5c3RlbS4nKTtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAge25hbWU6ICdzY3JpcHRUYWcnICsgaSwgdHlwZTogJ1RBRycsIHZhbHVlOiBzY3JpcHRSZWNvcmQudGFnfSxcbiAgICAgICAgICAgICAgICB7bmFtZTogJ3NjcmlwdCcgKyBpLCB0eXBlOiAnVEFCTEUnLCB2YWx1ZTogbmV3IFRhYmxlKCdzY3JpcHRUYWJsZScsIFtcbiAgICAgICAgICAgICAgICAgICAge25hbWU6ICdkZWZhdWx0TGFuZ1N5cycsIHR5cGU6ICdUQUJMRScsIHZhbHVlOiBuZXcgVGFibGUoJ2RlZmF1bHRMYW5nU3lzJywgW1xuICAgICAgICAgICAgICAgICAgICAgICAge25hbWU6ICdsb29rdXBPcmRlcicsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogMH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7bmFtZTogJ3JlcUZlYXR1cmVJbmRleCcsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogZGVmYXVsdExhbmdTeXMucmVxRmVhdHVyZUluZGV4fV1cbiAgICAgICAgICAgICAgICAgICAgICAgIC5jb25jYXQodXNob3J0TGlzdCgnZmVhdHVyZUluZGV4JywgZGVmYXVsdExhbmdTeXMuZmVhdHVyZUluZGV4ZXMpKSl9XG4gICAgICAgICAgICAgICAgICAgIF0uY29uY2F0KHJlY29yZExpc3QoJ2xhbmdTeXMnLCBzY3JpcHQubGFuZ1N5c1JlY29yZHMsIGZ1bmN0aW9uKGxhbmdTeXNSZWNvcmQsIGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGxhbmdTeXMgPSBsYW5nU3lzUmVjb3JkLmxhbmdTeXM7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtuYW1lOiAnbGFuZ1N5c1RhZycgKyBpLCB0eXBlOiAnVEFHJywgdmFsdWU6IGxhbmdTeXNSZWNvcmQudGFnfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7bmFtZTogJ2xhbmdTeXMnICsgaSwgdHlwZTogJ1RBQkxFJywgdmFsdWU6IG5ldyBUYWJsZSgnbGFuZ1N5cycsIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge25hbWU6ICdsb29rdXBPcmRlcicsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogMH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtuYW1lOiAncmVxRmVhdHVyZUluZGV4JywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiBsYW5nU3lzLnJlcUZlYXR1cmVJbmRleH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXS5jb25jYXQodXNob3J0TGlzdCgnZmVhdHVyZUluZGV4JywgbGFuZ1N5cy5mZWF0dXJlSW5kZXhlcykpKX1cbiAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgIH0pKSl9XG4gICAgICAgICAgICBdO1xuICAgICAgICB9KVxuICAgICk7XG59XG5TY3JpcHRMaXN0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoVGFibGUucHJvdG90eXBlKTtcblNjcmlwdExpc3QucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU2NyaXB0TGlzdDtcblxuLyoqXG4gKiBAZXhwb3J0cyBvcGVudHlwZS5GZWF0dXJlTGlzdFxuICogQGNsYXNzXG4gKiBAcGFyYW0ge29wZW50eXBlLlRhYmxlfVxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBvcGVudHlwZS5UYWJsZVxuICovXG5mdW5jdGlvbiBGZWF0dXJlTGlzdChmZWF0dXJlTGlzdFRhYmxlKSB7XG4gICAgVGFibGUuY2FsbCh0aGlzLCAnZmVhdHVyZUxpc3RUYWJsZScsXG4gICAgICAgIHJlY29yZExpc3QoJ2ZlYXR1cmVSZWNvcmQnLCBmZWF0dXJlTGlzdFRhYmxlLCBmdW5jdGlvbihmZWF0dXJlUmVjb3JkLCBpKSB7XG4gICAgICAgICAgICBjb25zdCBmZWF0dXJlID0gZmVhdHVyZVJlY29yZC5mZWF0dXJlO1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICB7bmFtZTogJ2ZlYXR1cmVUYWcnICsgaSwgdHlwZTogJ1RBRycsIHZhbHVlOiBmZWF0dXJlUmVjb3JkLnRhZ30sXG4gICAgICAgICAgICAgICAge25hbWU6ICdmZWF0dXJlJyArIGksIHR5cGU6ICdUQUJMRScsIHZhbHVlOiBuZXcgVGFibGUoJ2ZlYXR1cmVUYWJsZScsIFtcbiAgICAgICAgICAgICAgICAgICAge25hbWU6ICdmZWF0dXJlUGFyYW1zJywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiBmZWF0dXJlLmZlYXR1cmVQYXJhbXN9LFxuICAgICAgICAgICAgICAgICAgICBdLmNvbmNhdCh1c2hvcnRMaXN0KCdsb29rdXBMaXN0SW5kZXgnLCBmZWF0dXJlLmxvb2t1cExpc3RJbmRleGVzKSkpfVxuICAgICAgICAgICAgXTtcbiAgICAgICAgfSlcbiAgICApO1xufVxuRmVhdHVyZUxpc3QucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShUYWJsZS5wcm90b3R5cGUpO1xuRmVhdHVyZUxpc3QucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRmVhdHVyZUxpc3Q7XG5cbi8qKlxuICogQGV4cG9ydHMgb3BlbnR5cGUuTG9va3VwTGlzdFxuICogQGNsYXNzXG4gKiBAcGFyYW0ge29wZW50eXBlLlRhYmxlfVxuICogQHBhcmFtIHtPYmplY3R9XG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIG9wZW50eXBlLlRhYmxlXG4gKi9cbmZ1bmN0aW9uIExvb2t1cExpc3QobG9va3VwTGlzdFRhYmxlLCBzdWJ0YWJsZU1ha2Vycykge1xuICAgIFRhYmxlLmNhbGwodGhpcywgJ2xvb2t1cExpc3RUYWJsZScsIHRhYmxlTGlzdCgnbG9va3VwJywgbG9va3VwTGlzdFRhYmxlLCBmdW5jdGlvbihsb29rdXBUYWJsZSkge1xuICAgICAgICBsZXQgc3VidGFibGVDYWxsYmFjayA9IHN1YnRhYmxlTWFrZXJzW2xvb2t1cFRhYmxlLmxvb2t1cFR5cGVdO1xuICAgICAgICBjaGVjay5hc3NlcnQoISFzdWJ0YWJsZUNhbGxiYWNrLCAnVW5hYmxlIHRvIHdyaXRlIEdTVUIgbG9va3VwIHR5cGUgJyArIGxvb2t1cFRhYmxlLmxvb2t1cFR5cGUgKyAnIHRhYmxlcy4nKTtcbiAgICAgICAgcmV0dXJuIG5ldyBUYWJsZSgnbG9va3VwVGFibGUnLCBbXG4gICAgICAgICAgICB7bmFtZTogJ2xvb2t1cFR5cGUnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IGxvb2t1cFRhYmxlLmxvb2t1cFR5cGV9LFxuICAgICAgICAgICAge25hbWU6ICdsb29rdXBGbGFnJywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiBsb29rdXBUYWJsZS5sb29rdXBGbGFnfVxuICAgICAgICBdLmNvbmNhdCh0YWJsZUxpc3QoJ3N1YnRhYmxlJywgbG9va3VwVGFibGUuc3VidGFibGVzLCBzdWJ0YWJsZUNhbGxiYWNrKSkpO1xuICAgIH0pKTtcbn1cbkxvb2t1cExpc3QucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShUYWJsZS5wcm90b3R5cGUpO1xuTG9va3VwTGlzdC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBMb29rdXBMaXN0O1xuXG4vLyBSZWNvcmQgPSBzYW1lIGFzIFRhYmxlLCBidXQgaW5saW5lZCAoYSBUYWJsZSBoYXMgYW4gb2Zmc2V0IGFuZCBpdHMgZGF0YSBpcyBmdXJ0aGVyIGluIHRoZSBzdHJlYW0pXG4vLyBEb24ndCB1c2Ugb2Zmc2V0cyBpbnNpZGUgUmVjb3JkcyAocHJvYmFibGUgYnVnKSwgb25seSBpbiBUYWJsZXMuXG5leHBvcnQgZGVmYXVsdCB7XG4gICAgVGFibGUsXG4gICAgUmVjb3JkOiBUYWJsZSxcbiAgICBDb3ZlcmFnZSxcbiAgICBTY3JpcHRMaXN0LFxuICAgIEZlYXR1cmVMaXN0LFxuICAgIExvb2t1cExpc3QsXG4gICAgdXNob3J0TGlzdCxcbiAgICB0YWJsZUxpc3QsXG4gICAgcmVjb3JkTGlzdCxcbn07XG4iLCIvLyBQYXJzaW5nIHV0aWxpdHkgZnVuY3Rpb25zXG5cbmltcG9ydCBjaGVjayBmcm9tICcuL2NoZWNrJztcblxuLy8gUmV0cmlldmUgYW4gdW5zaWduZWQgYnl0ZSBmcm9tIHRoZSBEYXRhVmlldy5cbmZ1bmN0aW9uIGdldEJ5dGUoZGF0YVZpZXcsIG9mZnNldCkge1xuICAgIHJldHVybiBkYXRhVmlldy5nZXRVaW50OChvZmZzZXQpO1xufVxuXG4vLyBSZXRyaWV2ZSBhbiB1bnNpZ25lZCAxNi1iaXQgc2hvcnQgZnJvbSB0aGUgRGF0YVZpZXcuXG4vLyBUaGUgdmFsdWUgaXMgc3RvcmVkIGluIGJpZyBlbmRpYW4uXG5mdW5jdGlvbiBnZXRVU2hvcnQoZGF0YVZpZXcsIG9mZnNldCkge1xuICAgIHJldHVybiBkYXRhVmlldy5nZXRVaW50MTYob2Zmc2V0LCBmYWxzZSk7XG59XG5cbi8vIFJldHJpZXZlIGEgc2lnbmVkIDE2LWJpdCBzaG9ydCBmcm9tIHRoZSBEYXRhVmlldy5cbi8vIFRoZSB2YWx1ZSBpcyBzdG9yZWQgaW4gYmlnIGVuZGlhbi5cbmZ1bmN0aW9uIGdldFNob3J0KGRhdGFWaWV3LCBvZmZzZXQpIHtcbiAgICByZXR1cm4gZGF0YVZpZXcuZ2V0SW50MTYob2Zmc2V0LCBmYWxzZSk7XG59XG5cbi8vIFJldHJpZXZlIGFuIHVuc2lnbmVkIDMyLWJpdCBsb25nIGZyb20gdGhlIERhdGFWaWV3LlxuLy8gVGhlIHZhbHVlIGlzIHN0b3JlZCBpbiBiaWcgZW5kaWFuLlxuZnVuY3Rpb24gZ2V0VUxvbmcoZGF0YVZpZXcsIG9mZnNldCkge1xuICAgIHJldHVybiBkYXRhVmlldy5nZXRVaW50MzIob2Zmc2V0LCBmYWxzZSk7XG59XG5cbi8vIFJldHJpZXZlIGEgMzItYml0IHNpZ25lZCBmaXhlZC1wb2ludCBudW1iZXIgKDE2LjE2KSBmcm9tIHRoZSBEYXRhVmlldy5cbi8vIFRoZSB2YWx1ZSBpcyBzdG9yZWQgaW4gYmlnIGVuZGlhbi5cbmZ1bmN0aW9uIGdldEZpeGVkKGRhdGFWaWV3LCBvZmZzZXQpIHtcbiAgICBjb25zdCBkZWNpbWFsID0gZGF0YVZpZXcuZ2V0SW50MTYob2Zmc2V0LCBmYWxzZSk7XG4gICAgY29uc3QgZnJhY3Rpb24gPSBkYXRhVmlldy5nZXRVaW50MTYob2Zmc2V0ICsgMiwgZmFsc2UpO1xuICAgIHJldHVybiBkZWNpbWFsICsgZnJhY3Rpb24gLyA2NTUzNTtcbn1cblxuLy8gUmV0cmlldmUgYSA0LWNoYXJhY3RlciB0YWcgZnJvbSB0aGUgRGF0YVZpZXcuXG4vLyBUYWdzIGFyZSB1c2VkIHRvIGlkZW50aWZ5IHRhYmxlcy5cbmZ1bmN0aW9uIGdldFRhZyhkYXRhVmlldywgb2Zmc2V0KSB7XG4gICAgbGV0IHRhZyA9ICcnO1xuICAgIGZvciAobGV0IGkgPSBvZmZzZXQ7IGkgPCBvZmZzZXQgKyA0OyBpICs9IDEpIHtcbiAgICAgICAgdGFnICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoZGF0YVZpZXcuZ2V0SW50OChpKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhZztcbn1cblxuLy8gUmV0cmlldmUgYW4gb2Zmc2V0IGZyb20gdGhlIERhdGFWaWV3LlxuLy8gT2Zmc2V0cyBhcmUgMSB0byA0IGJ5dGVzIGluIGxlbmd0aCwgZGVwZW5kaW5nIG9uIHRoZSBvZmZTaXplIGFyZ3VtZW50LlxuZnVuY3Rpb24gZ2V0T2Zmc2V0KGRhdGFWaWV3LCBvZmZzZXQsIG9mZlNpemUpIHtcbiAgICBsZXQgdiA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvZmZTaXplOyBpICs9IDEpIHtcbiAgICAgICAgdiA8PD0gODtcbiAgICAgICAgdiArPSBkYXRhVmlldy5nZXRVaW50OChvZmZzZXQgKyBpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdjtcbn1cblxuLy8gUmV0cmlldmUgYSBudW1iZXIgb2YgYnl0ZXMgZnJvbSBzdGFydCBvZmZzZXQgdG8gdGhlIGVuZCBvZmZzZXQgZnJvbSB0aGUgRGF0YVZpZXcuXG5mdW5jdGlvbiBnZXRCeXRlcyhkYXRhVmlldywgc3RhcnRPZmZzZXQsIGVuZE9mZnNldCkge1xuICAgIGNvbnN0IGJ5dGVzID0gW107XG4gICAgZm9yIChsZXQgaSA9IHN0YXJ0T2Zmc2V0OyBpIDwgZW5kT2Zmc2V0OyBpICs9IDEpIHtcbiAgICAgICAgYnl0ZXMucHVzaChkYXRhVmlldy5nZXRVaW50OChpKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGJ5dGVzO1xufVxuXG4vLyBDb252ZXJ0IHRoZSBsaXN0IG9mIGJ5dGVzIHRvIGEgc3RyaW5nLlxuZnVuY3Rpb24gYnl0ZXNUb1N0cmluZyhieXRlcykge1xuICAgIGxldCBzID0gJyc7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZXNbaV0pO1xuICAgIH1cblxuICAgIHJldHVybiBzO1xufVxuXG5jb25zdCB0eXBlT2Zmc2V0cyA9IHtcbiAgICBieXRlOiAxLFxuICAgIHVTaG9ydDogMixcbiAgICBzaG9ydDogMixcbiAgICB1TG9uZzogNCxcbiAgICBmaXhlZDogNCxcbiAgICBsb25nRGF0ZVRpbWU6IDgsXG4gICAgdGFnOiA0XG59O1xuXG4vLyBBIHN0YXRlZnVsIHBhcnNlciB0aGF0IGNoYW5nZXMgdGhlIG9mZnNldCB3aGVuZXZlciBhIHZhbHVlIGlzIHJldHJpZXZlZC5cbi8vIFRoZSBkYXRhIGlzIGEgRGF0YVZpZXcuXG5mdW5jdGlvbiBQYXJzZXIoZGF0YSwgb2Zmc2V0KSB7XG4gICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICB0aGlzLm9mZnNldCA9IG9mZnNldDtcbiAgICB0aGlzLnJlbGF0aXZlT2Zmc2V0ID0gMDtcbn1cblxuUGFyc2VyLnByb3RvdHlwZS5wYXJzZUJ5dGUgPSBmdW5jdGlvbigpIHtcbiAgICBjb25zdCB2ID0gdGhpcy5kYXRhLmdldFVpbnQ4KHRoaXMub2Zmc2V0ICsgdGhpcy5yZWxhdGl2ZU9mZnNldCk7XG4gICAgdGhpcy5yZWxhdGl2ZU9mZnNldCArPSAxO1xuICAgIHJldHVybiB2O1xufTtcblxuUGFyc2VyLnByb3RvdHlwZS5wYXJzZUNoYXIgPSBmdW5jdGlvbigpIHtcbiAgICBjb25zdCB2ID0gdGhpcy5kYXRhLmdldEludDgodGhpcy5vZmZzZXQgKyB0aGlzLnJlbGF0aXZlT2Zmc2V0KTtcbiAgICB0aGlzLnJlbGF0aXZlT2Zmc2V0ICs9IDE7XG4gICAgcmV0dXJuIHY7XG59O1xuXG5QYXJzZXIucHJvdG90eXBlLnBhcnNlQ2FyZDggPSBQYXJzZXIucHJvdG90eXBlLnBhcnNlQnl0ZTtcblxuUGFyc2VyLnByb3RvdHlwZS5wYXJzZVVTaG9ydCA9IGZ1bmN0aW9uKCkge1xuICAgIGNvbnN0IHYgPSB0aGlzLmRhdGEuZ2V0VWludDE2KHRoaXMub2Zmc2V0ICsgdGhpcy5yZWxhdGl2ZU9mZnNldCk7XG4gICAgdGhpcy5yZWxhdGl2ZU9mZnNldCArPSAyO1xuICAgIHJldHVybiB2O1xufTtcblxuUGFyc2VyLnByb3RvdHlwZS5wYXJzZUNhcmQxNiA9IFBhcnNlci5wcm90b3R5cGUucGFyc2VVU2hvcnQ7XG5QYXJzZXIucHJvdG90eXBlLnBhcnNlU0lEID0gUGFyc2VyLnByb3RvdHlwZS5wYXJzZVVTaG9ydDtcblBhcnNlci5wcm90b3R5cGUucGFyc2VPZmZzZXQxNiA9IFBhcnNlci5wcm90b3R5cGUucGFyc2VVU2hvcnQ7XG5cblBhcnNlci5wcm90b3R5cGUucGFyc2VTaG9ydCA9IGZ1bmN0aW9uKCkge1xuICAgIGNvbnN0IHYgPSB0aGlzLmRhdGEuZ2V0SW50MTYodGhpcy5vZmZzZXQgKyB0aGlzLnJlbGF0aXZlT2Zmc2V0KTtcbiAgICB0aGlzLnJlbGF0aXZlT2Zmc2V0ICs9IDI7XG4gICAgcmV0dXJuIHY7XG59O1xuXG5QYXJzZXIucHJvdG90eXBlLnBhcnNlRjJEb3QxNCA9IGZ1bmN0aW9uKCkge1xuICAgIGNvbnN0IHYgPSB0aGlzLmRhdGEuZ2V0SW50MTYodGhpcy5vZmZzZXQgKyB0aGlzLnJlbGF0aXZlT2Zmc2V0KSAvIDE2Mzg0O1xuICAgIHRoaXMucmVsYXRpdmVPZmZzZXQgKz0gMjtcbiAgICByZXR1cm4gdjtcbn07XG5cblBhcnNlci5wcm90b3R5cGUucGFyc2VVTG9uZyA9IGZ1bmN0aW9uKCkge1xuICAgIGNvbnN0IHYgPSBnZXRVTG9uZyh0aGlzLmRhdGEsIHRoaXMub2Zmc2V0ICsgdGhpcy5yZWxhdGl2ZU9mZnNldCk7XG4gICAgdGhpcy5yZWxhdGl2ZU9mZnNldCArPSA0O1xuICAgIHJldHVybiB2O1xufTtcblxuUGFyc2VyLnByb3RvdHlwZS5wYXJzZUZpeGVkID0gZnVuY3Rpb24oKSB7XG4gICAgY29uc3QgdiA9IGdldEZpeGVkKHRoaXMuZGF0YSwgdGhpcy5vZmZzZXQgKyB0aGlzLnJlbGF0aXZlT2Zmc2V0KTtcbiAgICB0aGlzLnJlbGF0aXZlT2Zmc2V0ICs9IDQ7XG4gICAgcmV0dXJuIHY7XG59O1xuXG5QYXJzZXIucHJvdG90eXBlLnBhcnNlU3RyaW5nID0gZnVuY3Rpb24obGVuZ3RoKSB7XG4gICAgY29uc3QgZGF0YVZpZXcgPSB0aGlzLmRhdGE7XG4gICAgY29uc3Qgb2Zmc2V0ID0gdGhpcy5vZmZzZXQgKyB0aGlzLnJlbGF0aXZlT2Zmc2V0O1xuICAgIGxldCBzdHJpbmcgPSAnJztcbiAgICB0aGlzLnJlbGF0aXZlT2Zmc2V0ICs9IGxlbmd0aDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHN0cmluZyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGRhdGFWaWV3LmdldFVpbnQ4KG9mZnNldCArIGkpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc3RyaW5nO1xufTtcblxuUGFyc2VyLnByb3RvdHlwZS5wYXJzZVRhZyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnBhcnNlU3RyaW5nKDQpO1xufTtcblxuLy8gTE9OR0RBVEVUSU1FIGlzIGEgNjQtYml0IGludGVnZXIuXG4vLyBKYXZhU2NyaXB0IGFuZCB1bml4IHRpbWVzdGFtcHMgdHJhZGl0aW9uYWxseSB1c2UgMzIgYml0cywgc28gd2Vcbi8vIG9ubHkgdGFrZSB0aGUgbGFzdCAzMiBiaXRzLlxuLy8gKyBTaW5jZSB1bnRpbCAyMDM4IHRob3NlIGJpdHMgd2lsbCBiZSBmaWxsZWQgYnkgemVyb3Mgd2UgY2FuIGlnbm9yZSB0aGVtLlxuUGFyc2VyLnByb3RvdHlwZS5wYXJzZUxvbmdEYXRlVGltZSA9IGZ1bmN0aW9uKCkge1xuICAgIGxldCB2ID0gZ2V0VUxvbmcodGhpcy5kYXRhLCB0aGlzLm9mZnNldCArIHRoaXMucmVsYXRpdmVPZmZzZXQgKyA0KTtcbiAgICAvLyBTdWJ0cmFjdCBzZWNvbmRzIGJldHdlZW4gMDEvMDEvMTkwNCBhbmQgMDEvMDEvMTk3MFxuICAgIC8vIHRvIGNvbnZlcnQgQXBwbGUgTWFjIHRpbWVzdGFtcCB0byBTdGFuZGFyZCBVbml4IHRpbWVzdGFtcFxuICAgIHYgLT0gMjA4Mjg0NDgwMDtcbiAgICB0aGlzLnJlbGF0aXZlT2Zmc2V0ICs9IDg7XG4gICAgcmV0dXJuIHY7XG59O1xuXG5QYXJzZXIucHJvdG90eXBlLnBhcnNlVmVyc2lvbiA9IGZ1bmN0aW9uKCkge1xuICAgIGNvbnN0IG1ham9yID0gZ2V0VVNob3J0KHRoaXMuZGF0YSwgdGhpcy5vZmZzZXQgKyB0aGlzLnJlbGF0aXZlT2Zmc2V0KTtcblxuICAgIC8vIEhvdyB0byBpbnRlcnByZXQgdGhlIG1pbm9yIHZlcnNpb24gaXMgdmVyeSB2YWd1ZSBpbiB0aGUgc3BlYy4gMHg1MDAwIGlzIDUsIDB4MTAwMCBpcyAxXG4gICAgLy8gVGhpcyByZXR1cm5zIHRoZSBjb3JyZWN0IG51bWJlciBpZiBtaW5vciA9IDB4TjAwMCB3aGVyZSBOIGlzIDAtOVxuICAgIGNvbnN0IG1pbm9yID0gZ2V0VVNob3J0KHRoaXMuZGF0YSwgdGhpcy5vZmZzZXQgKyB0aGlzLnJlbGF0aXZlT2Zmc2V0ICsgMik7XG4gICAgdGhpcy5yZWxhdGl2ZU9mZnNldCArPSA0O1xuICAgIHJldHVybiBtYWpvciArIG1pbm9yIC8gMHgxMDAwIC8gMTA7XG59O1xuXG5QYXJzZXIucHJvdG90eXBlLnNraXAgPSBmdW5jdGlvbih0eXBlLCBhbW91bnQpIHtcbiAgICBpZiAoYW1vdW50ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgYW1vdW50ID0gMTtcbiAgICB9XG5cbiAgICB0aGlzLnJlbGF0aXZlT2Zmc2V0ICs9IHR5cGVPZmZzZXRzW3R5cGVdICogYW1vdW50O1xufTtcblxuLy8vLy8gUGFyc2luZyBsaXN0cyBhbmQgcmVjb3JkcyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbi8vIFBhcnNlIGEgbGlzdCBvZiAxNiBiaXQgdW5zaWduZWQgaW50ZWdlcnMuIFRoZSBsZW5ndGggb2YgdGhlIGxpc3QgY2FuIGJlIHJlYWQgb24gdGhlIHN0cmVhbVxuLy8gb3IgcHJvdmlkZWQgYXMgYW4gYXJndW1lbnQuXG5QYXJzZXIucHJvdG90eXBlLnBhcnNlT2Zmc2V0MTZMaXN0ID1cblBhcnNlci5wcm90b3R5cGUucGFyc2VVU2hvcnRMaXN0ID0gZnVuY3Rpb24oY291bnQpIHtcbiAgICBpZiAoY291bnQgPT09IHVuZGVmaW5lZCkgeyBjb3VudCA9IHRoaXMucGFyc2VVU2hvcnQoKTsgfVxuICAgIGNvbnN0IG9mZnNldHMgPSBuZXcgQXJyYXkoY291bnQpO1xuICAgIGNvbnN0IGRhdGFWaWV3ID0gdGhpcy5kYXRhO1xuICAgIGxldCBvZmZzZXQgPSB0aGlzLm9mZnNldCArIHRoaXMucmVsYXRpdmVPZmZzZXQ7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgIG9mZnNldHNbaV0gPSBkYXRhVmlldy5nZXRVaW50MTYob2Zmc2V0KTtcbiAgICAgICAgb2Zmc2V0ICs9IDI7XG4gICAgfVxuXG4gICAgdGhpcy5yZWxhdGl2ZU9mZnNldCArPSBjb3VudCAqIDI7XG4gICAgcmV0dXJuIG9mZnNldHM7XG59O1xuXG4vLyBQYXJzZXMgYSBsaXN0IG9mIDE2IGJpdCBzaWduZWQgaW50ZWdlcnMuXG5QYXJzZXIucHJvdG90eXBlLnBhcnNlU2hvcnRMaXN0ID0gZnVuY3Rpb24oY291bnQpIHtcbiAgICBjb25zdCBsaXN0ID0gbmV3IEFycmF5KGNvdW50KTtcbiAgICBjb25zdCBkYXRhVmlldyA9IHRoaXMuZGF0YTtcbiAgICBsZXQgb2Zmc2V0ID0gdGhpcy5vZmZzZXQgKyB0aGlzLnJlbGF0aXZlT2Zmc2V0O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICBsaXN0W2ldID0gZGF0YVZpZXcuZ2V0SW50MTYob2Zmc2V0KTtcbiAgICAgICAgb2Zmc2V0ICs9IDI7XG4gICAgfVxuXG4gICAgdGhpcy5yZWxhdGl2ZU9mZnNldCArPSBjb3VudCAqIDI7XG4gICAgcmV0dXJuIGxpc3Q7XG59O1xuXG4vLyBQYXJzZXMgYSBsaXN0IG9mIGJ5dGVzLlxuUGFyc2VyLnByb3RvdHlwZS5wYXJzZUJ5dGVMaXN0ID0gZnVuY3Rpb24oY291bnQpIHtcbiAgICBjb25zdCBsaXN0ID0gbmV3IEFycmF5KGNvdW50KTtcbiAgICBjb25zdCBkYXRhVmlldyA9IHRoaXMuZGF0YTtcbiAgICBsZXQgb2Zmc2V0ID0gdGhpcy5vZmZzZXQgKyB0aGlzLnJlbGF0aXZlT2Zmc2V0O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICBsaXN0W2ldID0gZGF0YVZpZXcuZ2V0VWludDgob2Zmc2V0KyspO1xuICAgIH1cblxuICAgIHRoaXMucmVsYXRpdmVPZmZzZXQgKz0gY291bnQ7XG4gICAgcmV0dXJuIGxpc3Q7XG59O1xuXG4vKipcbiAqIFBhcnNlIGEgbGlzdCBvZiBpdGVtcy5cbiAqIFJlY29yZCBjb3VudCBpcyBvcHRpb25hbCwgaWYgb21pdHRlZCBpdCBpcyByZWFkIGZyb20gdGhlIHN0cmVhbS5cbiAqIGl0ZW1DYWxsYmFjayBpcyBvbmUgb2YgdGhlIFBhcnNlciBtZXRob2RzLlxuICovXG5QYXJzZXIucHJvdG90eXBlLnBhcnNlTGlzdCA9IGZ1bmN0aW9uKGNvdW50LCBpdGVtQ2FsbGJhY2spIHtcbiAgICBpZiAoIWl0ZW1DYWxsYmFjaykge1xuICAgICAgICBpdGVtQ2FsbGJhY2sgPSBjb3VudDtcbiAgICAgICAgY291bnQgPSB0aGlzLnBhcnNlVVNob3J0KCk7XG4gICAgfVxuICAgIGNvbnN0IGxpc3QgPSBuZXcgQXJyYXkoY291bnQpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICBsaXN0W2ldID0gaXRlbUNhbGxiYWNrLmNhbGwodGhpcyk7XG4gICAgfVxuICAgIHJldHVybiBsaXN0O1xufTtcblxuLyoqXG4gKiBQYXJzZSBhIGxpc3Qgb2YgcmVjb3Jkcy5cbiAqIFJlY29yZCBjb3VudCBpcyBvcHRpb25hbCwgaWYgb21pdHRlZCBpdCBpcyByZWFkIGZyb20gdGhlIHN0cmVhbS5cbiAqIEV4YW1wbGUgb2YgcmVjb3JkRGVzY3JpcHRpb246IHsgc2VxdWVuY2VJbmRleDogUGFyc2VyLnVTaG9ydCwgbG9va3VwTGlzdEluZGV4OiBQYXJzZXIudVNob3J0IH1cbiAqL1xuUGFyc2VyLnByb3RvdHlwZS5wYXJzZVJlY29yZExpc3QgPSBmdW5jdGlvbihjb3VudCwgcmVjb3JkRGVzY3JpcHRpb24pIHtcbiAgICAvLyBJZiB0aGUgY291bnQgYXJndW1lbnQgaXMgYWJzZW50LCByZWFkIGl0IGluIHRoZSBzdHJlYW0uXG4gICAgaWYgKCFyZWNvcmREZXNjcmlwdGlvbikge1xuICAgICAgICByZWNvcmREZXNjcmlwdGlvbiA9IGNvdW50O1xuICAgICAgICBjb3VudCA9IHRoaXMucGFyc2VVU2hvcnQoKTtcbiAgICB9XG4gICAgY29uc3QgcmVjb3JkcyA9IG5ldyBBcnJheShjb3VudCk7XG4gICAgY29uc3QgZmllbGRzID0gT2JqZWN0LmtleXMocmVjb3JkRGVzY3JpcHRpb24pO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICBjb25zdCByZWMgPSB7fTtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBmaWVsZHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGZpZWxkTmFtZSA9IGZpZWxkc1tqXTtcbiAgICAgICAgICAgIGNvbnN0IGZpZWxkVHlwZSA9IHJlY29yZERlc2NyaXB0aW9uW2ZpZWxkTmFtZV07XG4gICAgICAgICAgICByZWNbZmllbGROYW1lXSA9IGZpZWxkVHlwZS5jYWxsKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHJlY29yZHNbaV0gPSByZWM7XG4gICAgfVxuICAgIHJldHVybiByZWNvcmRzO1xufTtcblxuLy8gUGFyc2UgYSBkYXRhIHN0cnVjdHVyZSBpbnRvIGFuIG9iamVjdFxuLy8gRXhhbXBsZSBvZiBkZXNjcmlwdGlvbjogeyBzZXF1ZW5jZUluZGV4OiBQYXJzZXIudVNob3J0LCBsb29rdXBMaXN0SW5kZXg6IFBhcnNlci51U2hvcnQgfVxuUGFyc2VyLnByb3RvdHlwZS5wYXJzZVN0cnVjdCA9IGZ1bmN0aW9uKGRlc2NyaXB0aW9uKSB7XG4gICAgaWYgKHR5cGVvZiBkZXNjcmlwdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gZGVzY3JpcHRpb24uY2FsbCh0aGlzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBmaWVsZHMgPSBPYmplY3Qua2V5cyhkZXNjcmlwdGlvbik7XG4gICAgICAgIGNvbnN0IHN0cnVjdCA9IHt9O1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGZpZWxkcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgY29uc3QgZmllbGROYW1lID0gZmllbGRzW2pdO1xuICAgICAgICAgICAgY29uc3QgZmllbGRUeXBlID0gZGVzY3JpcHRpb25bZmllbGROYW1lXTtcbiAgICAgICAgICAgIHN0cnVjdFtmaWVsZE5hbWVdID0gZmllbGRUeXBlLmNhbGwodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0cnVjdDtcbiAgICB9XG59O1xuXG5QYXJzZXIucHJvdG90eXBlLnBhcnNlUG9pbnRlciA9IGZ1bmN0aW9uKGRlc2NyaXB0aW9uKSB7XG4gICAgY29uc3Qgc3RydWN0T2Zmc2V0ID0gdGhpcy5wYXJzZU9mZnNldDE2KCk7XG4gICAgaWYgKHN0cnVjdE9mZnNldCA+IDApIHsgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTlVMTCBvZmZzZXQgPT4gcmV0dXJuIHVuZGVmaW5lZFxuICAgICAgICByZXR1cm4gbmV3IFBhcnNlcih0aGlzLmRhdGEsIHRoaXMub2Zmc2V0ICsgc3RydWN0T2Zmc2V0KS5wYXJzZVN0cnVjdChkZXNjcmlwdGlvbik7XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59O1xuXG4vKipcbiAqIFBhcnNlIGEgbGlzdCBvZiBvZmZzZXRzIHRvIGxpc3RzIG9mIDE2LWJpdCBpbnRlZ2VycyxcbiAqIG9yIGEgbGlzdCBvZiBvZmZzZXRzIHRvIGxpc3RzIG9mIG9mZnNldHMgdG8gYW55IGtpbmQgb2YgaXRlbXMuXG4gKiBJZiBpdGVtQ2FsbGJhY2sgaXMgbm90IHByb3ZpZGVkLCBhIGxpc3Qgb2YgbGlzdCBvZiBVU2hvcnQgaXMgYXNzdW1lZC5cbiAqIElmIHByb3ZpZGVkLCBpdGVtQ2FsbGJhY2sgaXMgY2FsbGVkIG9uIGVhY2ggaXRlbSBhbmQgbXVzdCBwYXJzZSB0aGUgaXRlbS5cbiAqIFNlZSBleGFtcGxlcyBpbiB0YWJsZXMvZ3N1Yi5qc1xuICovXG5QYXJzZXIucHJvdG90eXBlLnBhcnNlTGlzdE9mTGlzdHMgPSBmdW5jdGlvbihpdGVtQ2FsbGJhY2spIHtcbiAgICBjb25zdCBvZmZzZXRzID0gdGhpcy5wYXJzZU9mZnNldDE2TGlzdCgpO1xuICAgIGNvbnN0IGNvdW50ID0gb2Zmc2V0cy5sZW5ndGg7XG4gICAgY29uc3QgcmVsYXRpdmVPZmZzZXQgPSB0aGlzLnJlbGF0aXZlT2Zmc2V0O1xuICAgIGNvbnN0IGxpc3QgPSBuZXcgQXJyYXkoY291bnQpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICBjb25zdCBzdGFydCA9IG9mZnNldHNbaV07XG4gICAgICAgIGlmIChzdGFydCA9PT0gMCkgeyAgICAgICAgICAgICAgICAgIC8vIE5VTEwgb2Zmc2V0XG4gICAgICAgICAgICBsaXN0W2ldID0gdW5kZWZpbmVkOyAgICAgICAgICAgIC8vIEFkZCBpIGFzIG93bmVkIHByb3BlcnR5IHRvIGxpc3QuIENvbnZlbmllbnQgd2l0aCBhc3NlcnQuXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlbGF0aXZlT2Zmc2V0ID0gc3RhcnQ7XG4gICAgICAgIGlmIChpdGVtQ2FsbGJhY2spIHtcbiAgICAgICAgICAgIGNvbnN0IHN1Yk9mZnNldHMgPSB0aGlzLnBhcnNlT2Zmc2V0MTZMaXN0KCk7XG4gICAgICAgICAgICBjb25zdCBzdWJMaXN0ID0gbmV3IEFycmF5KHN1Yk9mZnNldHMubGVuZ3RoKTtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgc3ViT2Zmc2V0cy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIHRoaXMucmVsYXRpdmVPZmZzZXQgPSBzdGFydCArIHN1Yk9mZnNldHNbal07XG4gICAgICAgICAgICAgICAgc3ViTGlzdFtqXSA9IGl0ZW1DYWxsYmFjay5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGlzdFtpXSA9IHN1Ykxpc3Q7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsaXN0W2ldID0gdGhpcy5wYXJzZVVTaG9ydExpc3QoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnJlbGF0aXZlT2Zmc2V0ID0gcmVsYXRpdmVPZmZzZXQ7XG4gICAgcmV0dXJuIGxpc3Q7XG59O1xuXG4vLy8vLyBDb21wbGV4IHRhYmxlcyBwYXJzaW5nIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuLy8gUGFyc2UgYSBjb3ZlcmFnZSB0YWJsZSBpbiBhIEdTVUIsIEdQT1Mgb3IgR0RFRiB0YWJsZS5cbi8vIGh0dHBzOi8vd3d3Lm1pY3Jvc29mdC5jb20vdHlwb2dyYXBoeS9PVFNQRUMvY2hhcHRlcjIuaHRtXG4vLyBwYXJzZXIub2Zmc2V0IG11c3QgcG9pbnQgdG8gdGhlIHN0YXJ0IG9mIHRoZSB0YWJsZSBjb250YWluaW5nIHRoZSBjb3ZlcmFnZS5cblBhcnNlci5wcm90b3R5cGUucGFyc2VDb3ZlcmFnZSA9IGZ1bmN0aW9uKCkge1xuICAgIGNvbnN0IHN0YXJ0T2Zmc2V0ID0gdGhpcy5vZmZzZXQgKyB0aGlzLnJlbGF0aXZlT2Zmc2V0O1xuICAgIGNvbnN0IGZvcm1hdCA9IHRoaXMucGFyc2VVU2hvcnQoKTtcbiAgICBjb25zdCBjb3VudCA9IHRoaXMucGFyc2VVU2hvcnQoKTtcbiAgICBpZiAoZm9ybWF0ID09PSAxKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBmb3JtYXQ6IDEsXG4gICAgICAgICAgICBnbHlwaHM6IHRoaXMucGFyc2VVU2hvcnRMaXN0KGNvdW50KVxuICAgICAgICB9O1xuICAgIH0gZWxzZSBpZiAoZm9ybWF0ID09PSAyKSB7XG4gICAgICAgIGNvbnN0IHJhbmdlcyA9IG5ldyBBcnJheShjb3VudCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICAgICAgcmFuZ2VzW2ldID0ge1xuICAgICAgICAgICAgICAgIHN0YXJ0OiB0aGlzLnBhcnNlVVNob3J0KCksXG4gICAgICAgICAgICAgICAgZW5kOiB0aGlzLnBhcnNlVVNob3J0KCksXG4gICAgICAgICAgICAgICAgaW5kZXg6IHRoaXMucGFyc2VVU2hvcnQoKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZm9ybWF0OiAyLFxuICAgICAgICAgICAgcmFuZ2VzOiByYW5nZXNcbiAgICAgICAgfTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCcweCcgKyBzdGFydE9mZnNldC50b1N0cmluZygxNikgKyAnOiBDb3ZlcmFnZSBmb3JtYXQgbXVzdCBiZSAxIG9yIDIuJyk7XG59O1xuXG4vLyBQYXJzZSBhIENsYXNzIERlZmluaXRpb24gVGFibGUgaW4gYSBHU1VCLCBHUE9TIG9yIEdERUYgdGFibGUuXG4vLyBodHRwczovL3d3dy5taWNyb3NvZnQuY29tL3R5cG9ncmFwaHkvT1RTUEVDL2NoYXB0ZXIyLmh0bVxuUGFyc2VyLnByb3RvdHlwZS5wYXJzZUNsYXNzRGVmID0gZnVuY3Rpb24oKSB7XG4gICAgY29uc3Qgc3RhcnRPZmZzZXQgPSB0aGlzLm9mZnNldCArIHRoaXMucmVsYXRpdmVPZmZzZXQ7XG4gICAgY29uc3QgZm9ybWF0ID0gdGhpcy5wYXJzZVVTaG9ydCgpO1xuICAgIGlmIChmb3JtYXQgPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGZvcm1hdDogMSxcbiAgICAgICAgICAgIHN0YXJ0R2x5cGg6IHRoaXMucGFyc2VVU2hvcnQoKSxcbiAgICAgICAgICAgIGNsYXNzZXM6IHRoaXMucGFyc2VVU2hvcnRMaXN0KClcbiAgICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKGZvcm1hdCA9PT0gMikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZm9ybWF0OiAyLFxuICAgICAgICAgICAgcmFuZ2VzOiB0aGlzLnBhcnNlUmVjb3JkTGlzdCh7XG4gICAgICAgICAgICAgICAgc3RhcnQ6IFBhcnNlci51U2hvcnQsXG4gICAgICAgICAgICAgICAgZW5kOiBQYXJzZXIudVNob3J0LFxuICAgICAgICAgICAgICAgIGNsYXNzSWQ6IFBhcnNlci51U2hvcnRcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH07XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcignMHgnICsgc3RhcnRPZmZzZXQudG9TdHJpbmcoMTYpICsgJzogQ2xhc3NEZWYgZm9ybWF0IG11c3QgYmUgMSBvciAyLicpO1xufTtcblxuLy8vLy8gU3RhdGljIG1ldGhvZHMgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFRoZXNlIGNvbnZlbmllbmNlIG1ldGhvZHMgY2FuIGJlIHVzZWQgYXMgY2FsbGJhY2tzIGFuZCBzaG91bGQgYmUgY2FsbGVkIHdpdGggXCJ0aGlzXCIgY29udGV4dCBzZXQgdG8gYSBQYXJzZXIgaW5zdGFuY2UuXG5cblBhcnNlci5saXN0ID0gZnVuY3Rpb24oY291bnQsIGl0ZW1DYWxsYmFjaykge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VMaXN0KGNvdW50LCBpdGVtQ2FsbGJhY2spO1xuICAgIH07XG59O1xuXG5QYXJzZXIucmVjb3JkTGlzdCA9IGZ1bmN0aW9uKGNvdW50LCByZWNvcmREZXNjcmlwdGlvbikge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VSZWNvcmRMaXN0KGNvdW50LCByZWNvcmREZXNjcmlwdGlvbik7XG4gICAgfTtcbn07XG5cblBhcnNlci5wb2ludGVyID0gZnVuY3Rpb24oZGVzY3JpcHRpb24pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlUG9pbnRlcihkZXNjcmlwdGlvbik7XG4gICAgfTtcbn07XG5cblBhcnNlci50YWcgPSBQYXJzZXIucHJvdG90eXBlLnBhcnNlVGFnO1xuUGFyc2VyLmJ5dGUgPSBQYXJzZXIucHJvdG90eXBlLnBhcnNlQnl0ZTtcblBhcnNlci51U2hvcnQgPSBQYXJzZXIub2Zmc2V0MTYgPSBQYXJzZXIucHJvdG90eXBlLnBhcnNlVVNob3J0O1xuUGFyc2VyLnVTaG9ydExpc3QgPSBQYXJzZXIucHJvdG90eXBlLnBhcnNlVVNob3J0TGlzdDtcblBhcnNlci5zdHJ1Y3QgPSBQYXJzZXIucHJvdG90eXBlLnBhcnNlU3RydWN0O1xuUGFyc2VyLmNvdmVyYWdlID0gUGFyc2VyLnByb3RvdHlwZS5wYXJzZUNvdmVyYWdlO1xuUGFyc2VyLmNsYXNzRGVmID0gUGFyc2VyLnByb3RvdHlwZS5wYXJzZUNsYXNzRGVmO1xuXG4vLy8vLyBTY3JpcHQsIEZlYXR1cmUsIExvb2t1cCBsaXN0cyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gaHR0cHM6Ly93d3cubWljcm9zb2Z0LmNvbS90eXBvZ3JhcGh5L09UU1BFQy9jaGFwdGVyMi5odG1cblxuY29uc3QgbGFuZ1N5c1RhYmxlID0ge1xuICAgIHJlc2VydmVkOiBQYXJzZXIudVNob3J0LFxuICAgIHJlcUZlYXR1cmVJbmRleDogUGFyc2VyLnVTaG9ydCxcbiAgICBmZWF0dXJlSW5kZXhlczogUGFyc2VyLnVTaG9ydExpc3Rcbn07XG5cblBhcnNlci5wcm90b3R5cGUucGFyc2VTY3JpcHRMaXN0ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMucGFyc2VQb2ludGVyKFBhcnNlci5yZWNvcmRMaXN0KHtcbiAgICAgICAgdGFnOiBQYXJzZXIudGFnLFxuICAgICAgICBzY3JpcHQ6IFBhcnNlci5wb2ludGVyKHtcbiAgICAgICAgICAgIGRlZmF1bHRMYW5nU3lzOiBQYXJzZXIucG9pbnRlcihsYW5nU3lzVGFibGUpLFxuICAgICAgICAgICAgbGFuZ1N5c1JlY29yZHM6IFBhcnNlci5yZWNvcmRMaXN0KHtcbiAgICAgICAgICAgICAgICB0YWc6IFBhcnNlci50YWcsXG4gICAgICAgICAgICAgICAgbGFuZ1N5czogUGFyc2VyLnBvaW50ZXIobGFuZ1N5c1RhYmxlKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfSlcbiAgICB9KSk7XG59O1xuXG5QYXJzZXIucHJvdG90eXBlLnBhcnNlRmVhdHVyZUxpc3QgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5wYXJzZVBvaW50ZXIoUGFyc2VyLnJlY29yZExpc3Qoe1xuICAgICAgICB0YWc6IFBhcnNlci50YWcsXG4gICAgICAgIGZlYXR1cmU6IFBhcnNlci5wb2ludGVyKHtcbiAgICAgICAgICAgIGZlYXR1cmVQYXJhbXM6IFBhcnNlci5vZmZzZXQxNixcbiAgICAgICAgICAgIGxvb2t1cExpc3RJbmRleGVzOiBQYXJzZXIudVNob3J0TGlzdFxuICAgICAgICB9KVxuICAgIH0pKTtcbn07XG5cblBhcnNlci5wcm90b3R5cGUucGFyc2VMb29rdXBMaXN0ID0gZnVuY3Rpb24obG9va3VwVGFibGVQYXJzZXJzKSB7XG4gICAgcmV0dXJuIHRoaXMucGFyc2VQb2ludGVyKFBhcnNlci5saXN0KFBhcnNlci5wb2ludGVyKGZ1bmN0aW9uKCkge1xuICAgICAgICBjb25zdCBsb29rdXBUeXBlID0gdGhpcy5wYXJzZVVTaG9ydCgpO1xuICAgICAgICBjaGVjay5hcmd1bWVudCgxIDw9IGxvb2t1cFR5cGUgJiYgbG9va3VwVHlwZSA8PSA4LCAnR1NVQiBsb29rdXAgdHlwZSAnICsgbG9va3VwVHlwZSArICcgdW5rbm93bi4nKTtcbiAgICAgICAgY29uc3QgbG9va3VwRmxhZyA9IHRoaXMucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgY29uc3QgdXNlTWFya0ZpbHRlcmluZ1NldCA9IGxvb2t1cEZsYWcgJiAweDEwO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbG9va3VwVHlwZTogbG9va3VwVHlwZSxcbiAgICAgICAgICAgIGxvb2t1cEZsYWc6IGxvb2t1cEZsYWcsXG4gICAgICAgICAgICBzdWJ0YWJsZXM6IHRoaXMucGFyc2VMaXN0KFBhcnNlci5wb2ludGVyKGxvb2t1cFRhYmxlUGFyc2Vyc1tsb29rdXBUeXBlXSkpLFxuICAgICAgICAgICAgbWFya0ZpbHRlcmluZ1NldDogdXNlTWFya0ZpbHRlcmluZ1NldCA/IHRoaXMucGFyc2VVU2hvcnQoKSA6IHVuZGVmaW5lZFxuICAgICAgICB9O1xuICAgIH0pKSk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gICAgZ2V0Qnl0ZSxcbiAgICBnZXRDYXJkODogZ2V0Qnl0ZSxcbiAgICBnZXRVU2hvcnQsXG4gICAgZ2V0Q2FyZDE2OiBnZXRVU2hvcnQsXG4gICAgZ2V0U2hvcnQsXG4gICAgZ2V0VUxvbmcsXG4gICAgZ2V0Rml4ZWQsXG4gICAgZ2V0VGFnLFxuICAgIGdldE9mZnNldCxcbiAgICBnZXRCeXRlcyxcbiAgICBieXRlc1RvU3RyaW5nLFxuICAgIFBhcnNlcixcbn07XG5cbmV4cG9ydCB7IFBhcnNlciB9O1xuIiwiLy8gVGhlIGBjbWFwYCB0YWJsZSBzdG9yZXMgdGhlIG1hcHBpbmdzIGZyb20gY2hhcmFjdGVycyB0byBnbHlwaHMuXG4vLyBodHRwczovL3d3dy5taWNyb3NvZnQuY29tL3R5cG9ncmFwaHkvT1RTUEVDL2NtYXAuaHRtXG5cbmltcG9ydCBjaGVjayBmcm9tICcuLi9jaGVjayc7XG5pbXBvcnQgcGFyc2UgZnJvbSAnLi4vcGFyc2UnO1xuaW1wb3J0IHRhYmxlIGZyb20gJy4uL3RhYmxlJztcblxuZnVuY3Rpb24gcGFyc2VDbWFwVGFibGVGb3JtYXQxMihjbWFwLCBwKSB7XG4gICAgLy9Ta2lwIHJlc2VydmVkLlxuICAgIHAucGFyc2VVU2hvcnQoKTtcblxuICAgIC8vIExlbmd0aCBpbiBieXRlcyBvZiB0aGUgc3ViLXRhYmxlcy5cbiAgICBjbWFwLmxlbmd0aCA9IHAucGFyc2VVTG9uZygpO1xuICAgIGNtYXAubGFuZ3VhZ2UgPSBwLnBhcnNlVUxvbmcoKTtcblxuICAgIGxldCBncm91cENvdW50O1xuICAgIGNtYXAuZ3JvdXBDb3VudCA9IGdyb3VwQ291bnQgPSBwLnBhcnNlVUxvbmcoKTtcbiAgICBjbWFwLmdseXBoSW5kZXhNYXAgPSB7fTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZ3JvdXBDb3VudDsgaSArPSAxKSB7XG4gICAgICAgIGNvbnN0IHN0YXJ0Q2hhckNvZGUgPSBwLnBhcnNlVUxvbmcoKTtcbiAgICAgICAgY29uc3QgZW5kQ2hhckNvZGUgPSBwLnBhcnNlVUxvbmcoKTtcbiAgICAgICAgbGV0IHN0YXJ0R2x5cGhJZCA9IHAucGFyc2VVTG9uZygpO1xuXG4gICAgICAgIGZvciAobGV0IGMgPSBzdGFydENoYXJDb2RlOyBjIDw9IGVuZENoYXJDb2RlOyBjICs9IDEpIHtcbiAgICAgICAgICAgIGNtYXAuZ2x5cGhJbmRleE1hcFtjXSA9IHN0YXJ0R2x5cGhJZDtcbiAgICAgICAgICAgIHN0YXJ0R2x5cGhJZCsrO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiBwYXJzZUNtYXBUYWJsZUZvcm1hdDQoY21hcCwgcCwgZGF0YSwgc3RhcnQsIG9mZnNldCkge1xuICAgIC8vIExlbmd0aCBpbiBieXRlcyBvZiB0aGUgc3ViLXRhYmxlcy5cbiAgICBjbWFwLmxlbmd0aCA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICBjbWFwLmxhbmd1YWdlID0gcC5wYXJzZVVTaG9ydCgpO1xuXG4gICAgLy8gc2VnQ291bnQgaXMgc3RvcmVkIHggMi5cbiAgICBsZXQgc2VnQ291bnQ7XG4gICAgY21hcC5zZWdDb3VudCA9IHNlZ0NvdW50ID0gcC5wYXJzZVVTaG9ydCgpID4+IDE7XG5cbiAgICAvLyBTa2lwIHNlYXJjaFJhbmdlLCBlbnRyeVNlbGVjdG9yLCByYW5nZVNoaWZ0LlxuICAgIHAuc2tpcCgndVNob3J0JywgMyk7XG5cbiAgICAvLyBUaGUgXCJ1bnJvbGxlZFwiIG1hcHBpbmcgZnJvbSBjaGFyYWN0ZXIgY29kZXMgdG8gZ2x5cGggaW5kaWNlcy5cbiAgICBjbWFwLmdseXBoSW5kZXhNYXAgPSB7fTtcbiAgICBjb25zdCBlbmRDb3VudFBhcnNlciA9IG5ldyBwYXJzZS5QYXJzZXIoZGF0YSwgc3RhcnQgKyBvZmZzZXQgKyAxNCk7XG4gICAgY29uc3Qgc3RhcnRDb3VudFBhcnNlciA9IG5ldyBwYXJzZS5QYXJzZXIoZGF0YSwgc3RhcnQgKyBvZmZzZXQgKyAxNiArIHNlZ0NvdW50ICogMik7XG4gICAgY29uc3QgaWREZWx0YVBhcnNlciA9IG5ldyBwYXJzZS5QYXJzZXIoZGF0YSwgc3RhcnQgKyBvZmZzZXQgKyAxNiArIHNlZ0NvdW50ICogNCk7XG4gICAgY29uc3QgaWRSYW5nZU9mZnNldFBhcnNlciA9IG5ldyBwYXJzZS5QYXJzZXIoZGF0YSwgc3RhcnQgKyBvZmZzZXQgKyAxNiArIHNlZ0NvdW50ICogNik7XG4gICAgbGV0IGdseXBoSW5kZXhPZmZzZXQgPSBzdGFydCArIG9mZnNldCArIDE2ICsgc2VnQ291bnQgKiA4O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2VnQ291bnQgLSAxOyBpICs9IDEpIHtcbiAgICAgICAgbGV0IGdseXBoSW5kZXg7XG4gICAgICAgIGNvbnN0IGVuZENvdW50ID0gZW5kQ291bnRQYXJzZXIucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgY29uc3Qgc3RhcnRDb3VudCA9IHN0YXJ0Q291bnRQYXJzZXIucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgY29uc3QgaWREZWx0YSA9IGlkRGVsdGFQYXJzZXIucGFyc2VTaG9ydCgpO1xuICAgICAgICBjb25zdCBpZFJhbmdlT2Zmc2V0ID0gaWRSYW5nZU9mZnNldFBhcnNlci5wYXJzZVVTaG9ydCgpO1xuICAgICAgICBmb3IgKGxldCBjID0gc3RhcnRDb3VudDsgYyA8PSBlbmRDb3VudDsgYyArPSAxKSB7XG4gICAgICAgICAgICBpZiAoaWRSYW5nZU9mZnNldCAhPT0gMCkge1xuICAgICAgICAgICAgICAgIC8vIFRoZSBpZFJhbmdlT2Zmc2V0IGlzIHJlbGF0aXZlIHRvIHRoZSBjdXJyZW50IHBvc2l0aW9uIGluIHRoZSBpZFJhbmdlT2Zmc2V0IGFycmF5LlxuICAgICAgICAgICAgICAgIC8vIFRha2UgdGhlIGN1cnJlbnQgb2Zmc2V0IGluIHRoZSBpZFJhbmdlT2Zmc2V0IGFycmF5LlxuICAgICAgICAgICAgICAgIGdseXBoSW5kZXhPZmZzZXQgPSAoaWRSYW5nZU9mZnNldFBhcnNlci5vZmZzZXQgKyBpZFJhbmdlT2Zmc2V0UGFyc2VyLnJlbGF0aXZlT2Zmc2V0IC0gMik7XG5cbiAgICAgICAgICAgICAgICAvLyBBZGQgdGhlIHZhbHVlIG9mIHRoZSBpZFJhbmdlT2Zmc2V0LCB3aGljaCB3aWxsIG1vdmUgdXMgaW50byB0aGUgZ2x5cGhJbmRleCBhcnJheS5cbiAgICAgICAgICAgICAgICBnbHlwaEluZGV4T2Zmc2V0ICs9IGlkUmFuZ2VPZmZzZXQ7XG5cbiAgICAgICAgICAgICAgICAvLyBUaGVuIGFkZCB0aGUgY2hhcmFjdGVyIGluZGV4IG9mIHRoZSBjdXJyZW50IHNlZ21lbnQsIG11bHRpcGxpZWQgYnkgMiBmb3IgVVNIT1JUcy5cbiAgICAgICAgICAgICAgICBnbHlwaEluZGV4T2Zmc2V0ICs9IChjIC0gc3RhcnRDb3VudCkgKiAyO1xuICAgICAgICAgICAgICAgIGdseXBoSW5kZXggPSBwYXJzZS5nZXRVU2hvcnQoZGF0YSwgZ2x5cGhJbmRleE9mZnNldCk7XG4gICAgICAgICAgICAgICAgaWYgKGdseXBoSW5kZXggIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZ2x5cGhJbmRleCA9IChnbHlwaEluZGV4ICsgaWREZWx0YSkgJiAweEZGRkY7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBnbHlwaEluZGV4ID0gKGMgKyBpZERlbHRhKSAmIDB4RkZGRjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY21hcC5nbHlwaEluZGV4TWFwW2NdID0gZ2x5cGhJbmRleDtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLy8gUGFyc2UgdGhlIGBjbWFwYCB0YWJsZS4gVGhpcyB0YWJsZSBzdG9yZXMgdGhlIG1hcHBpbmdzIGZyb20gY2hhcmFjdGVycyB0byBnbHlwaHMuXG4vLyBUaGVyZSBhcmUgbWFueSBhdmFpbGFibGUgZm9ybWF0cywgYnV0IHdlIG9ubHkgc3VwcG9ydCB0aGUgV2luZG93cyBmb3JtYXQgNCBhbmQgMTIuXG4vLyBUaGlzIGZ1bmN0aW9uIHJldHVybnMgYSBgQ21hcEVuY29kaW5nYCBvYmplY3Qgb3IgbnVsbCBpZiBubyBzdXBwb3J0ZWQgZm9ybWF0IGNvdWxkIGJlIGZvdW5kLlxuZnVuY3Rpb24gcGFyc2VDbWFwVGFibGUoZGF0YSwgc3RhcnQpIHtcbiAgICBjb25zdCBjbWFwID0ge307XG4gICAgY21hcC52ZXJzaW9uID0gcGFyc2UuZ2V0VVNob3J0KGRhdGEsIHN0YXJ0KTtcbiAgICBjaGVjay5hcmd1bWVudChjbWFwLnZlcnNpb24gPT09IDAsICdjbWFwIHRhYmxlIHZlcnNpb24gc2hvdWxkIGJlIDAuJyk7XG5cbiAgICAvLyBUaGUgY21hcCB0YWJsZSBjYW4gY29udGFpbiBtYW55IHN1Yi10YWJsZXMsIGVhY2ggd2l0aCB0aGVpciBvd24gZm9ybWF0LlxuICAgIC8vIFdlJ3JlIG9ubHkgaW50ZXJlc3RlZCBpbiBhIFwicGxhdGZvcm0gM1wiIHRhYmxlLiBUaGlzIGlzIGEgV2luZG93cyBmb3JtYXQuXG4gICAgY21hcC5udW1UYWJsZXMgPSBwYXJzZS5nZXRVU2hvcnQoZGF0YSwgc3RhcnQgKyAyKTtcbiAgICBsZXQgb2Zmc2V0ID0gLTE7XG4gICAgZm9yIChsZXQgaSA9IGNtYXAubnVtVGFibGVzIC0gMTsgaSA+PSAwOyBpIC09IDEpIHtcbiAgICAgICAgY29uc3QgcGxhdGZvcm1JZCA9IHBhcnNlLmdldFVTaG9ydChkYXRhLCBzdGFydCArIDQgKyAoaSAqIDgpKTtcbiAgICAgICAgY29uc3QgZW5jb2RpbmdJZCA9IHBhcnNlLmdldFVTaG9ydChkYXRhLCBzdGFydCArIDQgKyAoaSAqIDgpICsgMik7XG4gICAgICAgIGlmIChwbGF0Zm9ybUlkID09PSAzICYmIChlbmNvZGluZ0lkID09PSAwIHx8IGVuY29kaW5nSWQgPT09IDEgfHwgZW5jb2RpbmdJZCA9PT0gMTApKSB7XG4gICAgICAgICAgICBvZmZzZXQgPSBwYXJzZS5nZXRVTG9uZyhkYXRhLCBzdGFydCArIDQgKyAoaSAqIDgpICsgNCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChvZmZzZXQgPT09IC0xKSB7XG4gICAgICAgIC8vIFRoZXJlIGlzIG5vIGNtYXAgdGFibGUgaW4gdGhlIGZvbnQgdGhhdCB3ZSBzdXBwb3J0LlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHZhbGlkIGNtYXAgc3ViLXRhYmxlcyBmb3VuZC4nKTtcbiAgICB9XG5cbiAgICBjb25zdCBwID0gbmV3IHBhcnNlLlBhcnNlcihkYXRhLCBzdGFydCArIG9mZnNldCk7XG4gICAgY21hcC5mb3JtYXQgPSBwLnBhcnNlVVNob3J0KCk7XG5cbiAgICBpZiAoY21hcC5mb3JtYXQgPT09IDEyKSB7XG4gICAgICAgIHBhcnNlQ21hcFRhYmxlRm9ybWF0MTIoY21hcCwgcCk7XG4gICAgfSBlbHNlIGlmIChjbWFwLmZvcm1hdCA9PT0gNCkge1xuICAgICAgICBwYXJzZUNtYXBUYWJsZUZvcm1hdDQoY21hcCwgcCwgZGF0YSwgc3RhcnQsIG9mZnNldCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdPbmx5IGZvcm1hdCA0IGFuZCAxMiBjbWFwIHRhYmxlcyBhcmUgc3VwcG9ydGVkIChmb3VuZCBmb3JtYXQgJyArIGNtYXAuZm9ybWF0ICsgJykuJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNtYXA7XG59XG5cbmZ1bmN0aW9uIGFkZFNlZ21lbnQodCwgY29kZSwgZ2x5cGhJbmRleCkge1xuICAgIHQuc2VnbWVudHMucHVzaCh7XG4gICAgICAgIGVuZDogY29kZSxcbiAgICAgICAgc3RhcnQ6IGNvZGUsXG4gICAgICAgIGRlbHRhOiAtKGNvZGUgLSBnbHlwaEluZGV4KSxcbiAgICAgICAgb2Zmc2V0OiAwXG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIGFkZFRlcm1pbmF0b3JTZWdtZW50KHQpIHtcbiAgICB0LnNlZ21lbnRzLnB1c2goe1xuICAgICAgICBlbmQ6IDB4RkZGRixcbiAgICAgICAgc3RhcnQ6IDB4RkZGRixcbiAgICAgICAgZGVsdGE6IDEsXG4gICAgICAgIG9mZnNldDogMFxuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBtYWtlQ21hcFRhYmxlKGdseXBocykge1xuICAgIGNvbnN0IHQgPSBuZXcgdGFibGUuVGFibGUoJ2NtYXAnLCBbXG4gICAgICAgIHtuYW1lOiAndmVyc2lvbicsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAnbnVtVGFibGVzJywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiAxfSxcbiAgICAgICAge25hbWU6ICdwbGF0Zm9ybUlEJywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiAzfSxcbiAgICAgICAge25hbWU6ICdlbmNvZGluZ0lEJywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiAxfSxcbiAgICAgICAge25hbWU6ICdvZmZzZXQnLCB0eXBlOiAnVUxPTkcnLCB2YWx1ZTogMTJ9LFxuICAgICAgICB7bmFtZTogJ2Zvcm1hdCcsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogNH0sXG4gICAgICAgIHtuYW1lOiAnbGVuZ3RoJywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICdsYW5ndWFnZScsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAnc2VnQ291bnRYMicsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAnc2VhcmNoUmFuZ2UnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ2VudHJ5U2VsZWN0b3InLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ3JhbmdlU2hpZnQnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDB9XG4gICAgXSk7XG5cbiAgICB0LnNlZ21lbnRzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBnbHlwaHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgY29uc3QgZ2x5cGggPSBnbHlwaHMuZ2V0KGkpO1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGdseXBoLnVuaWNvZGVzLmxlbmd0aDsgaiArPSAxKSB7XG4gICAgICAgICAgICBhZGRTZWdtZW50KHQsIGdseXBoLnVuaWNvZGVzW2pdLCBpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHQuc2VnbWVudHMgPSB0LnNlZ21lbnRzLnNvcnQoZnVuY3Rpb24oYSwgYikge1xuICAgICAgICAgICAgcmV0dXJuIGEuc3RhcnQgLSBiLnN0YXJ0O1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBhZGRUZXJtaW5hdG9yU2VnbWVudCh0KTtcblxuICAgIGxldCBzZWdDb3VudDtcbiAgICBzZWdDb3VudCA9IHQuc2VnbWVudHMubGVuZ3RoO1xuICAgIHQuc2VnQ291bnRYMiA9IHNlZ0NvdW50ICogMjtcbiAgICB0LnNlYXJjaFJhbmdlID0gTWF0aC5wb3coMiwgTWF0aC5mbG9vcihNYXRoLmxvZyhzZWdDb3VudCkgLyBNYXRoLmxvZygyKSkpICogMjtcbiAgICB0LmVudHJ5U2VsZWN0b3IgPSBNYXRoLmxvZyh0LnNlYXJjaFJhbmdlIC8gMikgLyBNYXRoLmxvZygyKTtcbiAgICB0LnJhbmdlU2hpZnQgPSB0LnNlZ0NvdW50WDIgLSB0LnNlYXJjaFJhbmdlO1xuXG4gICAgLy8gU2V0IHVwIHBhcmFsbGVsIHNlZ21lbnQgYXJyYXlzLlxuICAgIGxldCBlbmRDb3VudHMgPSBbXTtcbiAgICBsZXQgc3RhcnRDb3VudHMgPSBbXTtcbiAgICBsZXQgaWREZWx0YXMgPSBbXTtcbiAgICBsZXQgaWRSYW5nZU9mZnNldHMgPSBbXTtcbiAgICBsZXQgZ2x5cGhJZHMgPSBbXTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2VnQ291bnQ7IGkgKz0gMSkge1xuICAgICAgICBjb25zdCBzZWdtZW50ID0gdC5zZWdtZW50c1tpXTtcbiAgICAgICAgZW5kQ291bnRzID0gZW5kQ291bnRzLmNvbmNhdCh7bmFtZTogJ2VuZF8nICsgaSwgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiBzZWdtZW50LmVuZH0pO1xuICAgICAgICBzdGFydENvdW50cyA9IHN0YXJ0Q291bnRzLmNvbmNhdCh7bmFtZTogJ3N0YXJ0XycgKyBpLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IHNlZ21lbnQuc3RhcnR9KTtcbiAgICAgICAgaWREZWx0YXMgPSBpZERlbHRhcy5jb25jYXQoe25hbWU6ICdpZERlbHRhXycgKyBpLCB0eXBlOiAnU0hPUlQnLCB2YWx1ZTogc2VnbWVudC5kZWx0YX0pO1xuICAgICAgICBpZFJhbmdlT2Zmc2V0cyA9IGlkUmFuZ2VPZmZzZXRzLmNvbmNhdCh7bmFtZTogJ2lkUmFuZ2VPZmZzZXRfJyArIGksIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogc2VnbWVudC5vZmZzZXR9KTtcbiAgICAgICAgaWYgKHNlZ21lbnQuZ2x5cGhJZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBnbHlwaElkcyA9IGdseXBoSWRzLmNvbmNhdCh7bmFtZTogJ2dseXBoXycgKyBpLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IHNlZ21lbnQuZ2x5cGhJZH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdC5maWVsZHMgPSB0LmZpZWxkcy5jb25jYXQoZW5kQ291bnRzKTtcbiAgICB0LmZpZWxkcy5wdXNoKHtuYW1lOiAncmVzZXJ2ZWRQYWQnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDB9KTtcbiAgICB0LmZpZWxkcyA9IHQuZmllbGRzLmNvbmNhdChzdGFydENvdW50cyk7XG4gICAgdC5maWVsZHMgPSB0LmZpZWxkcy5jb25jYXQoaWREZWx0YXMpO1xuICAgIHQuZmllbGRzID0gdC5maWVsZHMuY29uY2F0KGlkUmFuZ2VPZmZzZXRzKTtcbiAgICB0LmZpZWxkcyA9IHQuZmllbGRzLmNvbmNhdChnbHlwaElkcyk7XG5cbiAgICB0Lmxlbmd0aCA9IDE0ICsgLy8gU3VidGFibGUgaGVhZGVyXG4gICAgICAgIGVuZENvdW50cy5sZW5ndGggKiAyICtcbiAgICAgICAgMiArIC8vIHJlc2VydmVkUGFkXG4gICAgICAgIHN0YXJ0Q291bnRzLmxlbmd0aCAqIDIgK1xuICAgICAgICBpZERlbHRhcy5sZW5ndGggKiAyICtcbiAgICAgICAgaWRSYW5nZU9mZnNldHMubGVuZ3RoICogMiArXG4gICAgICAgIGdseXBoSWRzLmxlbmd0aCAqIDI7XG5cbiAgICByZXR1cm4gdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgeyBwYXJzZTogcGFyc2VDbWFwVGFibGUsIG1ha2U6IG1ha2VDbWFwVGFibGUgfTtcbiIsIi8vIEdseXBoIGVuY29kaW5nXG5cbmNvbnN0IGNmZlN0YW5kYXJkU3RyaW5ncyA9IFtcbiAgICAnLm5vdGRlZicsICdzcGFjZScsICdleGNsYW0nLCAncXVvdGVkYmwnLCAnbnVtYmVyc2lnbicsICdkb2xsYXInLCAncGVyY2VudCcsICdhbXBlcnNhbmQnLCAncXVvdGVyaWdodCcsXG4gICAgJ3BhcmVubGVmdCcsICdwYXJlbnJpZ2h0JywgJ2FzdGVyaXNrJywgJ3BsdXMnLCAnY29tbWEnLCAnaHlwaGVuJywgJ3BlcmlvZCcsICdzbGFzaCcsICd6ZXJvJywgJ29uZScsICd0d28nLFxuICAgICd0aHJlZScsICdmb3VyJywgJ2ZpdmUnLCAnc2l4JywgJ3NldmVuJywgJ2VpZ2h0JywgJ25pbmUnLCAnY29sb24nLCAnc2VtaWNvbG9uJywgJ2xlc3MnLCAnZXF1YWwnLCAnZ3JlYXRlcicsXG4gICAgJ3F1ZXN0aW9uJywgJ2F0JywgJ0EnLCAnQicsICdDJywgJ0QnLCAnRScsICdGJywgJ0cnLCAnSCcsICdJJywgJ0onLCAnSycsICdMJywgJ00nLCAnTicsICdPJywgJ1AnLCAnUScsICdSJywgJ1MnLFxuICAgICdUJywgJ1UnLCAnVicsICdXJywgJ1gnLCAnWScsICdaJywgJ2JyYWNrZXRsZWZ0JywgJ2JhY2tzbGFzaCcsICdicmFja2V0cmlnaHQnLCAnYXNjaWljaXJjdW0nLCAndW5kZXJzY29yZScsXG4gICAgJ3F1b3RlbGVmdCcsICdhJywgJ2InLCAnYycsICdkJywgJ2UnLCAnZicsICdnJywgJ2gnLCAnaScsICdqJywgJ2snLCAnbCcsICdtJywgJ24nLCAnbycsICdwJywgJ3EnLCAncicsICdzJywgJ3QnLFxuICAgICd1JywgJ3YnLCAndycsICd4JywgJ3knLCAneicsICdicmFjZWxlZnQnLCAnYmFyJywgJ2JyYWNlcmlnaHQnLCAnYXNjaWl0aWxkZScsICdleGNsYW1kb3duJywgJ2NlbnQnLCAnc3RlcmxpbmcnLFxuICAgICdmcmFjdGlvbicsICd5ZW4nLCAnZmxvcmluJywgJ3NlY3Rpb24nLCAnY3VycmVuY3knLCAncXVvdGVzaW5nbGUnLCAncXVvdGVkYmxsZWZ0JywgJ2d1aWxsZW1vdGxlZnQnLFxuICAgICdndWlsc2luZ2xsZWZ0JywgJ2d1aWxzaW5nbHJpZ2h0JywgJ2ZpJywgJ2ZsJywgJ2VuZGFzaCcsICdkYWdnZXInLCAnZGFnZ2VyZGJsJywgJ3BlcmlvZGNlbnRlcmVkJywgJ3BhcmFncmFwaCcsXG4gICAgJ2J1bGxldCcsICdxdW90ZXNpbmdsYmFzZScsICdxdW90ZWRibGJhc2UnLCAncXVvdGVkYmxyaWdodCcsICdndWlsbGVtb3RyaWdodCcsICdlbGxpcHNpcycsICdwZXJ0aG91c2FuZCcsXG4gICAgJ3F1ZXN0aW9uZG93bicsICdncmF2ZScsICdhY3V0ZScsICdjaXJjdW1mbGV4JywgJ3RpbGRlJywgJ21hY3JvbicsICdicmV2ZScsICdkb3RhY2NlbnQnLCAnZGllcmVzaXMnLCAncmluZycsXG4gICAgJ2NlZGlsbGEnLCAnaHVuZ2FydW1sYXV0JywgJ29nb25laycsICdjYXJvbicsICdlbWRhc2gnLCAnQUUnLCAnb3JkZmVtaW5pbmUnLCAnTHNsYXNoJywgJ09zbGFzaCcsICdPRScsXG4gICAgJ29yZG1hc2N1bGluZScsICdhZScsICdkb3RsZXNzaScsICdsc2xhc2gnLCAnb3NsYXNoJywgJ29lJywgJ2dlcm1hbmRibHMnLCAnb25lc3VwZXJpb3InLCAnbG9naWNhbG5vdCcsICdtdScsXG4gICAgJ3RyYWRlbWFyaycsICdFdGgnLCAnb25laGFsZicsICdwbHVzbWludXMnLCAnVGhvcm4nLCAnb25lcXVhcnRlcicsICdkaXZpZGUnLCAnYnJva2VuYmFyJywgJ2RlZ3JlZScsICd0aG9ybicsXG4gICAgJ3RocmVlcXVhcnRlcnMnLCAndHdvc3VwZXJpb3InLCAncmVnaXN0ZXJlZCcsICdtaW51cycsICdldGgnLCAnbXVsdGlwbHknLCAndGhyZWVzdXBlcmlvcicsICdjb3B5cmlnaHQnLFxuICAgICdBYWN1dGUnLCAnQWNpcmN1bWZsZXgnLCAnQWRpZXJlc2lzJywgJ0FncmF2ZScsICdBcmluZycsICdBdGlsZGUnLCAnQ2NlZGlsbGEnLCAnRWFjdXRlJywgJ0VjaXJjdW1mbGV4JyxcbiAgICAnRWRpZXJlc2lzJywgJ0VncmF2ZScsICdJYWN1dGUnLCAnSWNpcmN1bWZsZXgnLCAnSWRpZXJlc2lzJywgJ0lncmF2ZScsICdOdGlsZGUnLCAnT2FjdXRlJywgJ09jaXJjdW1mbGV4JyxcbiAgICAnT2RpZXJlc2lzJywgJ09ncmF2ZScsICdPdGlsZGUnLCAnU2Nhcm9uJywgJ1VhY3V0ZScsICdVY2lyY3VtZmxleCcsICdVZGllcmVzaXMnLCAnVWdyYXZlJywgJ1lhY3V0ZScsXG4gICAgJ1lkaWVyZXNpcycsICdaY2Fyb24nLCAnYWFjdXRlJywgJ2FjaXJjdW1mbGV4JywgJ2FkaWVyZXNpcycsICdhZ3JhdmUnLCAnYXJpbmcnLCAnYXRpbGRlJywgJ2NjZWRpbGxhJywgJ2VhY3V0ZScsXG4gICAgJ2VjaXJjdW1mbGV4JywgJ2VkaWVyZXNpcycsICdlZ3JhdmUnLCAnaWFjdXRlJywgJ2ljaXJjdW1mbGV4JywgJ2lkaWVyZXNpcycsICdpZ3JhdmUnLCAnbnRpbGRlJywgJ29hY3V0ZScsXG4gICAgJ29jaXJjdW1mbGV4JywgJ29kaWVyZXNpcycsICdvZ3JhdmUnLCAnb3RpbGRlJywgJ3NjYXJvbicsICd1YWN1dGUnLCAndWNpcmN1bWZsZXgnLCAndWRpZXJlc2lzJywgJ3VncmF2ZScsXG4gICAgJ3lhY3V0ZScsICd5ZGllcmVzaXMnLCAnemNhcm9uJywgJ2V4Y2xhbXNtYWxsJywgJ0h1bmdhcnVtbGF1dHNtYWxsJywgJ2RvbGxhcm9sZHN0eWxlJywgJ2RvbGxhcnN1cGVyaW9yJyxcbiAgICAnYW1wZXJzYW5kc21hbGwnLCAnQWN1dGVzbWFsbCcsICdwYXJlbmxlZnRzdXBlcmlvcicsICdwYXJlbnJpZ2h0c3VwZXJpb3InLCAnMjY2IGZmJywgJ29uZWRvdGVubGVhZGVyJyxcbiAgICAnemVyb29sZHN0eWxlJywgJ29uZW9sZHN0eWxlJywgJ3R3b29sZHN0eWxlJywgJ3RocmVlb2xkc3R5bGUnLCAnZm91cm9sZHN0eWxlJywgJ2ZpdmVvbGRzdHlsZScsICdzaXhvbGRzdHlsZScsXG4gICAgJ3NldmVub2xkc3R5bGUnLCAnZWlnaHRvbGRzdHlsZScsICduaW5lb2xkc3R5bGUnLCAnY29tbWFzdXBlcmlvcicsICd0aHJlZXF1YXJ0ZXJzZW1kYXNoJywgJ3BlcmlvZHN1cGVyaW9yJyxcbiAgICAncXVlc3Rpb25zbWFsbCcsICdhc3VwZXJpb3InLCAnYnN1cGVyaW9yJywgJ2NlbnRzdXBlcmlvcicsICdkc3VwZXJpb3InLCAnZXN1cGVyaW9yJywgJ2lzdXBlcmlvcicsICdsc3VwZXJpb3InLFxuICAgICdtc3VwZXJpb3InLCAnbnN1cGVyaW9yJywgJ29zdXBlcmlvcicsICdyc3VwZXJpb3InLCAnc3N1cGVyaW9yJywgJ3RzdXBlcmlvcicsICdmZicsICdmZmknLCAnZmZsJyxcbiAgICAncGFyZW5sZWZ0aW5mZXJpb3InLCAncGFyZW5yaWdodGluZmVyaW9yJywgJ0NpcmN1bWZsZXhzbWFsbCcsICdoeXBoZW5zdXBlcmlvcicsICdHcmF2ZXNtYWxsJywgJ0FzbWFsbCcsXG4gICAgJ0JzbWFsbCcsICdDc21hbGwnLCAnRHNtYWxsJywgJ0VzbWFsbCcsICdGc21hbGwnLCAnR3NtYWxsJywgJ0hzbWFsbCcsICdJc21hbGwnLCAnSnNtYWxsJywgJ0tzbWFsbCcsICdMc21hbGwnLFxuICAgICdNc21hbGwnLCAnTnNtYWxsJywgJ09zbWFsbCcsICdQc21hbGwnLCAnUXNtYWxsJywgJ1JzbWFsbCcsICdTc21hbGwnLCAnVHNtYWxsJywgJ1VzbWFsbCcsICdWc21hbGwnLCAnV3NtYWxsJyxcbiAgICAnWHNtYWxsJywgJ1lzbWFsbCcsICdac21hbGwnLCAnY29sb25tb25ldGFyeScsICdvbmVmaXR0ZWQnLCAncnVwaWFoJywgJ1RpbGRlc21hbGwnLCAnZXhjbGFtZG93bnNtYWxsJyxcbiAgICAnY2VudG9sZHN0eWxlJywgJ0xzbGFzaHNtYWxsJywgJ1NjYXJvbnNtYWxsJywgJ1pjYXJvbnNtYWxsJywgJ0RpZXJlc2lzc21hbGwnLCAnQnJldmVzbWFsbCcsICdDYXJvbnNtYWxsJyxcbiAgICAnRG90YWNjZW50c21hbGwnLCAnTWFjcm9uc21hbGwnLCAnZmlndXJlZGFzaCcsICdoeXBoZW5pbmZlcmlvcicsICdPZ29uZWtzbWFsbCcsICdSaW5nc21hbGwnLCAnQ2VkaWxsYXNtYWxsJyxcbiAgICAncXVlc3Rpb25kb3duc21hbGwnLCAnb25lZWlnaHRoJywgJ3RocmVlZWlnaHRocycsICdmaXZlZWlnaHRocycsICdzZXZlbmVpZ2h0aHMnLCAnb25ldGhpcmQnLCAndHdvdGhpcmRzJyxcbiAgICAnemVyb3N1cGVyaW9yJywgJ2ZvdXJzdXBlcmlvcicsICdmaXZlc3VwZXJpb3InLCAnc2l4c3VwZXJpb3InLCAnc2V2ZW5zdXBlcmlvcicsICdlaWdodHN1cGVyaW9yJywgJ25pbmVzdXBlcmlvcicsXG4gICAgJ3plcm9pbmZlcmlvcicsICdvbmVpbmZlcmlvcicsICd0d29pbmZlcmlvcicsICd0aHJlZWluZmVyaW9yJywgJ2ZvdXJpbmZlcmlvcicsICdmaXZlaW5mZXJpb3InLCAnc2l4aW5mZXJpb3InLFxuICAgICdzZXZlbmluZmVyaW9yJywgJ2VpZ2h0aW5mZXJpb3InLCAnbmluZWluZmVyaW9yJywgJ2NlbnRpbmZlcmlvcicsICdkb2xsYXJpbmZlcmlvcicsICdwZXJpb2RpbmZlcmlvcicsXG4gICAgJ2NvbW1haW5mZXJpb3InLCAnQWdyYXZlc21hbGwnLCAnQWFjdXRlc21hbGwnLCAnQWNpcmN1bWZsZXhzbWFsbCcsICdBdGlsZGVzbWFsbCcsICdBZGllcmVzaXNzbWFsbCcsXG4gICAgJ0FyaW5nc21hbGwnLCAnQUVzbWFsbCcsICdDY2VkaWxsYXNtYWxsJywgJ0VncmF2ZXNtYWxsJywgJ0VhY3V0ZXNtYWxsJywgJ0VjaXJjdW1mbGV4c21hbGwnLCAnRWRpZXJlc2lzc21hbGwnLFxuICAgICdJZ3JhdmVzbWFsbCcsICdJYWN1dGVzbWFsbCcsICdJY2lyY3VtZmxleHNtYWxsJywgJ0lkaWVyZXNpc3NtYWxsJywgJ0V0aHNtYWxsJywgJ050aWxkZXNtYWxsJywgJ09ncmF2ZXNtYWxsJyxcbiAgICAnT2FjdXRlc21hbGwnLCAnT2NpcmN1bWZsZXhzbWFsbCcsICdPdGlsZGVzbWFsbCcsICdPZGllcmVzaXNzbWFsbCcsICdPRXNtYWxsJywgJ09zbGFzaHNtYWxsJywgJ1VncmF2ZXNtYWxsJyxcbiAgICAnVWFjdXRlc21hbGwnLCAnVWNpcmN1bWZsZXhzbWFsbCcsICdVZGllcmVzaXNzbWFsbCcsICdZYWN1dGVzbWFsbCcsICdUaG9ybnNtYWxsJywgJ1lkaWVyZXNpc3NtYWxsJywgJzAwMS4wMDAnLFxuICAgICcwMDEuMDAxJywgJzAwMS4wMDInLCAnMDAxLjAwMycsICdCbGFjaycsICdCb2xkJywgJ0Jvb2snLCAnTGlnaHQnLCAnTWVkaXVtJywgJ1JlZ3VsYXInLCAnUm9tYW4nLCAnU2VtaWJvbGQnXTtcblxuY29uc3QgY2ZmU3RhbmRhcmRFbmNvZGluZyA9IFtcbiAgICAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJyxcbiAgICAnJywgJycsICcnLCAnJywgJ3NwYWNlJywgJ2V4Y2xhbScsICdxdW90ZWRibCcsICdudW1iZXJzaWduJywgJ2RvbGxhcicsICdwZXJjZW50JywgJ2FtcGVyc2FuZCcsICdxdW90ZXJpZ2h0JyxcbiAgICAncGFyZW5sZWZ0JywgJ3BhcmVucmlnaHQnLCAnYXN0ZXJpc2snLCAncGx1cycsICdjb21tYScsICdoeXBoZW4nLCAncGVyaW9kJywgJ3NsYXNoJywgJ3plcm8nLCAnb25lJywgJ3R3bycsXG4gICAgJ3RocmVlJywgJ2ZvdXInLCAnZml2ZScsICdzaXgnLCAnc2V2ZW4nLCAnZWlnaHQnLCAnbmluZScsICdjb2xvbicsICdzZW1pY29sb24nLCAnbGVzcycsICdlcXVhbCcsICdncmVhdGVyJyxcbiAgICAncXVlc3Rpb24nLCAnYXQnLCAnQScsICdCJywgJ0MnLCAnRCcsICdFJywgJ0YnLCAnRycsICdIJywgJ0knLCAnSicsICdLJywgJ0wnLCAnTScsICdOJywgJ08nLCAnUCcsICdRJywgJ1InLCAnUycsXG4gICAgJ1QnLCAnVScsICdWJywgJ1cnLCAnWCcsICdZJywgJ1onLCAnYnJhY2tldGxlZnQnLCAnYmFja3NsYXNoJywgJ2JyYWNrZXRyaWdodCcsICdhc2NpaWNpcmN1bScsICd1bmRlcnNjb3JlJyxcbiAgICAncXVvdGVsZWZ0JywgJ2EnLCAnYicsICdjJywgJ2QnLCAnZScsICdmJywgJ2cnLCAnaCcsICdpJywgJ2onLCAnaycsICdsJywgJ20nLCAnbicsICdvJywgJ3AnLCAncScsICdyJywgJ3MnLCAndCcsXG4gICAgJ3UnLCAndicsICd3JywgJ3gnLCAneScsICd6JywgJ2JyYWNlbGVmdCcsICdiYXInLCAnYnJhY2VyaWdodCcsICdhc2NpaXRpbGRlJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLFxuICAgICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJyxcbiAgICAnZXhjbGFtZG93bicsICdjZW50JywgJ3N0ZXJsaW5nJywgJ2ZyYWN0aW9uJywgJ3llbicsICdmbG9yaW4nLCAnc2VjdGlvbicsICdjdXJyZW5jeScsICdxdW90ZXNpbmdsZScsXG4gICAgJ3F1b3RlZGJsbGVmdCcsICdndWlsbGVtb3RsZWZ0JywgJ2d1aWxzaW5nbGxlZnQnLCAnZ3VpbHNpbmdscmlnaHQnLCAnZmknLCAnZmwnLCAnJywgJ2VuZGFzaCcsICdkYWdnZXInLFxuICAgICdkYWdnZXJkYmwnLCAncGVyaW9kY2VudGVyZWQnLCAnJywgJ3BhcmFncmFwaCcsICdidWxsZXQnLCAncXVvdGVzaW5nbGJhc2UnLCAncXVvdGVkYmxiYXNlJywgJ3F1b3RlZGJscmlnaHQnLFxuICAgICdndWlsbGVtb3RyaWdodCcsICdlbGxpcHNpcycsICdwZXJ0aG91c2FuZCcsICcnLCAncXVlc3Rpb25kb3duJywgJycsICdncmF2ZScsICdhY3V0ZScsICdjaXJjdW1mbGV4JywgJ3RpbGRlJyxcbiAgICAnbWFjcm9uJywgJ2JyZXZlJywgJ2RvdGFjY2VudCcsICdkaWVyZXNpcycsICcnLCAncmluZycsICdjZWRpbGxhJywgJycsICdodW5nYXJ1bWxhdXQnLCAnb2dvbmVrJywgJ2Nhcm9uJyxcbiAgICAnZW1kYXNoJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICdBRScsICcnLCAnb3JkZmVtaW5pbmUnLCAnJywgJycsICcnLFxuICAgICcnLCAnTHNsYXNoJywgJ09zbGFzaCcsICdPRScsICdvcmRtYXNjdWxpbmUnLCAnJywgJycsICcnLCAnJywgJycsICdhZScsICcnLCAnJywgJycsICdkb3RsZXNzaScsICcnLCAnJyxcbiAgICAnbHNsYXNoJywgJ29zbGFzaCcsICdvZScsICdnZXJtYW5kYmxzJ107XG5cbmNvbnN0IGNmZkV4cGVydEVuY29kaW5nID0gW1xuICAgICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLFxuICAgICcnLCAnJywgJycsICcnLCAnc3BhY2UnLCAnZXhjbGFtc21hbGwnLCAnSHVuZ2FydW1sYXV0c21hbGwnLCAnJywgJ2RvbGxhcm9sZHN0eWxlJywgJ2RvbGxhcnN1cGVyaW9yJyxcbiAgICAnYW1wZXJzYW5kc21hbGwnLCAnQWN1dGVzbWFsbCcsICdwYXJlbmxlZnRzdXBlcmlvcicsICdwYXJlbnJpZ2h0c3VwZXJpb3InLCAndHdvZG90ZW5sZWFkZXInLCAnb25lZG90ZW5sZWFkZXInLFxuICAgICdjb21tYScsICdoeXBoZW4nLCAncGVyaW9kJywgJ2ZyYWN0aW9uJywgJ3plcm9vbGRzdHlsZScsICdvbmVvbGRzdHlsZScsICd0d29vbGRzdHlsZScsICd0aHJlZW9sZHN0eWxlJyxcbiAgICAnZm91cm9sZHN0eWxlJywgJ2ZpdmVvbGRzdHlsZScsICdzaXhvbGRzdHlsZScsICdzZXZlbm9sZHN0eWxlJywgJ2VpZ2h0b2xkc3R5bGUnLCAnbmluZW9sZHN0eWxlJywgJ2NvbG9uJyxcbiAgICAnc2VtaWNvbG9uJywgJ2NvbW1hc3VwZXJpb3InLCAndGhyZWVxdWFydGVyc2VtZGFzaCcsICdwZXJpb2RzdXBlcmlvcicsICdxdWVzdGlvbnNtYWxsJywgJycsICdhc3VwZXJpb3InLFxuICAgICdic3VwZXJpb3InLCAnY2VudHN1cGVyaW9yJywgJ2RzdXBlcmlvcicsICdlc3VwZXJpb3InLCAnJywgJycsICdpc3VwZXJpb3InLCAnJywgJycsICdsc3VwZXJpb3InLCAnbXN1cGVyaW9yJyxcbiAgICAnbnN1cGVyaW9yJywgJ29zdXBlcmlvcicsICcnLCAnJywgJ3JzdXBlcmlvcicsICdzc3VwZXJpb3InLCAndHN1cGVyaW9yJywgJycsICdmZicsICdmaScsICdmbCcsICdmZmknLCAnZmZsJyxcbiAgICAncGFyZW5sZWZ0aW5mZXJpb3InLCAnJywgJ3BhcmVucmlnaHRpbmZlcmlvcicsICdDaXJjdW1mbGV4c21hbGwnLCAnaHlwaGVuc3VwZXJpb3InLCAnR3JhdmVzbWFsbCcsICdBc21hbGwnLFxuICAgICdCc21hbGwnLCAnQ3NtYWxsJywgJ0RzbWFsbCcsICdFc21hbGwnLCAnRnNtYWxsJywgJ0dzbWFsbCcsICdIc21hbGwnLCAnSXNtYWxsJywgJ0pzbWFsbCcsICdLc21hbGwnLCAnTHNtYWxsJyxcbiAgICAnTXNtYWxsJywgJ05zbWFsbCcsICdPc21hbGwnLCAnUHNtYWxsJywgJ1FzbWFsbCcsICdSc21hbGwnLCAnU3NtYWxsJywgJ1RzbWFsbCcsICdVc21hbGwnLCAnVnNtYWxsJywgJ1dzbWFsbCcsXG4gICAgJ1hzbWFsbCcsICdZc21hbGwnLCAnWnNtYWxsJywgJ2NvbG9ubW9uZXRhcnknLCAnb25lZml0dGVkJywgJ3J1cGlhaCcsICdUaWxkZXNtYWxsJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsXG4gICAgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJyxcbiAgICAnZXhjbGFtZG93bnNtYWxsJywgJ2NlbnRvbGRzdHlsZScsICdMc2xhc2hzbWFsbCcsICcnLCAnJywgJ1NjYXJvbnNtYWxsJywgJ1pjYXJvbnNtYWxsJywgJ0RpZXJlc2lzc21hbGwnLFxuICAgICdCcmV2ZXNtYWxsJywgJ0Nhcm9uc21hbGwnLCAnJywgJ0RvdGFjY2VudHNtYWxsJywgJycsICcnLCAnTWFjcm9uc21hbGwnLCAnJywgJycsICdmaWd1cmVkYXNoJywgJ2h5cGhlbmluZmVyaW9yJyxcbiAgICAnJywgJycsICdPZ29uZWtzbWFsbCcsICdSaW5nc21hbGwnLCAnQ2VkaWxsYXNtYWxsJywgJycsICcnLCAnJywgJ29uZXF1YXJ0ZXInLCAnb25laGFsZicsICd0aHJlZXF1YXJ0ZXJzJyxcbiAgICAncXVlc3Rpb25kb3duc21hbGwnLCAnb25lZWlnaHRoJywgJ3RocmVlZWlnaHRocycsICdmaXZlZWlnaHRocycsICdzZXZlbmVpZ2h0aHMnLCAnb25ldGhpcmQnLCAndHdvdGhpcmRzJywgJycsXG4gICAgJycsICd6ZXJvc3VwZXJpb3InLCAnb25lc3VwZXJpb3InLCAndHdvc3VwZXJpb3InLCAndGhyZWVzdXBlcmlvcicsICdmb3Vyc3VwZXJpb3InLCAnZml2ZXN1cGVyaW9yJyxcbiAgICAnc2l4c3VwZXJpb3InLCAnc2V2ZW5zdXBlcmlvcicsICdlaWdodHN1cGVyaW9yJywgJ25pbmVzdXBlcmlvcicsICd6ZXJvaW5mZXJpb3InLCAnb25laW5mZXJpb3InLCAndHdvaW5mZXJpb3InLFxuICAgICd0aHJlZWluZmVyaW9yJywgJ2ZvdXJpbmZlcmlvcicsICdmaXZlaW5mZXJpb3InLCAnc2l4aW5mZXJpb3InLCAnc2V2ZW5pbmZlcmlvcicsICdlaWdodGluZmVyaW9yJyxcbiAgICAnbmluZWluZmVyaW9yJywgJ2NlbnRpbmZlcmlvcicsICdkb2xsYXJpbmZlcmlvcicsICdwZXJpb2RpbmZlcmlvcicsICdjb21tYWluZmVyaW9yJywgJ0FncmF2ZXNtYWxsJyxcbiAgICAnQWFjdXRlc21hbGwnLCAnQWNpcmN1bWZsZXhzbWFsbCcsICdBdGlsZGVzbWFsbCcsICdBZGllcmVzaXNzbWFsbCcsICdBcmluZ3NtYWxsJywgJ0FFc21hbGwnLCAnQ2NlZGlsbGFzbWFsbCcsXG4gICAgJ0VncmF2ZXNtYWxsJywgJ0VhY3V0ZXNtYWxsJywgJ0VjaXJjdW1mbGV4c21hbGwnLCAnRWRpZXJlc2lzc21hbGwnLCAnSWdyYXZlc21hbGwnLCAnSWFjdXRlc21hbGwnLFxuICAgICdJY2lyY3VtZmxleHNtYWxsJywgJ0lkaWVyZXNpc3NtYWxsJywgJ0V0aHNtYWxsJywgJ050aWxkZXNtYWxsJywgJ09ncmF2ZXNtYWxsJywgJ09hY3V0ZXNtYWxsJyxcbiAgICAnT2NpcmN1bWZsZXhzbWFsbCcsICdPdGlsZGVzbWFsbCcsICdPZGllcmVzaXNzbWFsbCcsICdPRXNtYWxsJywgJ09zbGFzaHNtYWxsJywgJ1VncmF2ZXNtYWxsJywgJ1VhY3V0ZXNtYWxsJyxcbiAgICAnVWNpcmN1bWZsZXhzbWFsbCcsICdVZGllcmVzaXNzbWFsbCcsICdZYWN1dGVzbWFsbCcsICdUaG9ybnNtYWxsJywgJ1lkaWVyZXNpc3NtYWxsJ107XG5cbmNvbnN0IHN0YW5kYXJkTmFtZXMgPSBbXG4gICAgJy5ub3RkZWYnLCAnLm51bGwnLCAnbm9ubWFya2luZ3JldHVybicsICdzcGFjZScsICdleGNsYW0nLCAncXVvdGVkYmwnLCAnbnVtYmVyc2lnbicsICdkb2xsYXInLCAncGVyY2VudCcsXG4gICAgJ2FtcGVyc2FuZCcsICdxdW90ZXNpbmdsZScsICdwYXJlbmxlZnQnLCAncGFyZW5yaWdodCcsICdhc3RlcmlzaycsICdwbHVzJywgJ2NvbW1hJywgJ2h5cGhlbicsICdwZXJpb2QnLCAnc2xhc2gnLFxuICAgICd6ZXJvJywgJ29uZScsICd0d28nLCAndGhyZWUnLCAnZm91cicsICdmaXZlJywgJ3NpeCcsICdzZXZlbicsICdlaWdodCcsICduaW5lJywgJ2NvbG9uJywgJ3NlbWljb2xvbicsICdsZXNzJyxcbiAgICAnZXF1YWwnLCAnZ3JlYXRlcicsICdxdWVzdGlvbicsICdhdCcsICdBJywgJ0InLCAnQycsICdEJywgJ0UnLCAnRicsICdHJywgJ0gnLCAnSScsICdKJywgJ0snLCAnTCcsICdNJywgJ04nLCAnTycsXG4gICAgJ1AnLCAnUScsICdSJywgJ1MnLCAnVCcsICdVJywgJ1YnLCAnVycsICdYJywgJ1knLCAnWicsICdicmFja2V0bGVmdCcsICdiYWNrc2xhc2gnLCAnYnJhY2tldHJpZ2h0JyxcbiAgICAnYXNjaWljaXJjdW0nLCAndW5kZXJzY29yZScsICdncmF2ZScsICdhJywgJ2InLCAnYycsICdkJywgJ2UnLCAnZicsICdnJywgJ2gnLCAnaScsICdqJywgJ2snLCAnbCcsICdtJywgJ24nLCAnbycsXG4gICAgJ3AnLCAncScsICdyJywgJ3MnLCAndCcsICd1JywgJ3YnLCAndycsICd4JywgJ3knLCAneicsICdicmFjZWxlZnQnLCAnYmFyJywgJ2JyYWNlcmlnaHQnLCAnYXNjaWl0aWxkZScsXG4gICAgJ0FkaWVyZXNpcycsICdBcmluZycsICdDY2VkaWxsYScsICdFYWN1dGUnLCAnTnRpbGRlJywgJ09kaWVyZXNpcycsICdVZGllcmVzaXMnLCAnYWFjdXRlJywgJ2FncmF2ZScsXG4gICAgJ2FjaXJjdW1mbGV4JywgJ2FkaWVyZXNpcycsICdhdGlsZGUnLCAnYXJpbmcnLCAnY2NlZGlsbGEnLCAnZWFjdXRlJywgJ2VncmF2ZScsICdlY2lyY3VtZmxleCcsICdlZGllcmVzaXMnLFxuICAgICdpYWN1dGUnLCAnaWdyYXZlJywgJ2ljaXJjdW1mbGV4JywgJ2lkaWVyZXNpcycsICdudGlsZGUnLCAnb2FjdXRlJywgJ29ncmF2ZScsICdvY2lyY3VtZmxleCcsICdvZGllcmVzaXMnLFxuICAgICdvdGlsZGUnLCAndWFjdXRlJywgJ3VncmF2ZScsICd1Y2lyY3VtZmxleCcsICd1ZGllcmVzaXMnLCAnZGFnZ2VyJywgJ2RlZ3JlZScsICdjZW50JywgJ3N0ZXJsaW5nJywgJ3NlY3Rpb24nLFxuICAgICdidWxsZXQnLCAncGFyYWdyYXBoJywgJ2dlcm1hbmRibHMnLCAncmVnaXN0ZXJlZCcsICdjb3B5cmlnaHQnLCAndHJhZGVtYXJrJywgJ2FjdXRlJywgJ2RpZXJlc2lzJywgJ25vdGVxdWFsJyxcbiAgICAnQUUnLCAnT3NsYXNoJywgJ2luZmluaXR5JywgJ3BsdXNtaW51cycsICdsZXNzZXF1YWwnLCAnZ3JlYXRlcmVxdWFsJywgJ3llbicsICdtdScsICdwYXJ0aWFsZGlmZicsICdzdW1tYXRpb24nLFxuICAgICdwcm9kdWN0JywgJ3BpJywgJ2ludGVncmFsJywgJ29yZGZlbWluaW5lJywgJ29yZG1hc2N1bGluZScsICdPbWVnYScsICdhZScsICdvc2xhc2gnLCAncXVlc3Rpb25kb3duJyxcbiAgICAnZXhjbGFtZG93bicsICdsb2dpY2Fsbm90JywgJ3JhZGljYWwnLCAnZmxvcmluJywgJ2FwcHJveGVxdWFsJywgJ0RlbHRhJywgJ2d1aWxsZW1vdGxlZnQnLCAnZ3VpbGxlbW90cmlnaHQnLFxuICAgICdlbGxpcHNpcycsICdub25icmVha2luZ3NwYWNlJywgJ0FncmF2ZScsICdBdGlsZGUnLCAnT3RpbGRlJywgJ09FJywgJ29lJywgJ2VuZGFzaCcsICdlbWRhc2gnLCAncXVvdGVkYmxsZWZ0JyxcbiAgICAncXVvdGVkYmxyaWdodCcsICdxdW90ZWxlZnQnLCAncXVvdGVyaWdodCcsICdkaXZpZGUnLCAnbG96ZW5nZScsICd5ZGllcmVzaXMnLCAnWWRpZXJlc2lzJywgJ2ZyYWN0aW9uJyxcbiAgICAnY3VycmVuY3knLCAnZ3VpbHNpbmdsbGVmdCcsICdndWlsc2luZ2xyaWdodCcsICdmaScsICdmbCcsICdkYWdnZXJkYmwnLCAncGVyaW9kY2VudGVyZWQnLCAncXVvdGVzaW5nbGJhc2UnLFxuICAgICdxdW90ZWRibGJhc2UnLCAncGVydGhvdXNhbmQnLCAnQWNpcmN1bWZsZXgnLCAnRWNpcmN1bWZsZXgnLCAnQWFjdXRlJywgJ0VkaWVyZXNpcycsICdFZ3JhdmUnLCAnSWFjdXRlJyxcbiAgICAnSWNpcmN1bWZsZXgnLCAnSWRpZXJlc2lzJywgJ0lncmF2ZScsICdPYWN1dGUnLCAnT2NpcmN1bWZsZXgnLCAnYXBwbGUnLCAnT2dyYXZlJywgJ1VhY3V0ZScsICdVY2lyY3VtZmxleCcsXG4gICAgJ1VncmF2ZScsICdkb3RsZXNzaScsICdjaXJjdW1mbGV4JywgJ3RpbGRlJywgJ21hY3JvbicsICdicmV2ZScsICdkb3RhY2NlbnQnLCAncmluZycsICdjZWRpbGxhJywgJ2h1bmdhcnVtbGF1dCcsXG4gICAgJ29nb25laycsICdjYXJvbicsICdMc2xhc2gnLCAnbHNsYXNoJywgJ1NjYXJvbicsICdzY2Fyb24nLCAnWmNhcm9uJywgJ3pjYXJvbicsICdicm9rZW5iYXInLCAnRXRoJywgJ2V0aCcsXG4gICAgJ1lhY3V0ZScsICd5YWN1dGUnLCAnVGhvcm4nLCAndGhvcm4nLCAnbWludXMnLCAnbXVsdGlwbHknLCAnb25lc3VwZXJpb3InLCAndHdvc3VwZXJpb3InLCAndGhyZWVzdXBlcmlvcicsXG4gICAgJ29uZWhhbGYnLCAnb25lcXVhcnRlcicsICd0aHJlZXF1YXJ0ZXJzJywgJ2ZyYW5jJywgJ0dicmV2ZScsICdnYnJldmUnLCAnSWRvdGFjY2VudCcsICdTY2VkaWxsYScsICdzY2VkaWxsYScsXG4gICAgJ0NhY3V0ZScsICdjYWN1dGUnLCAnQ2Nhcm9uJywgJ2NjYXJvbicsICdkY3JvYXQnXTtcblxuLyoqXG4gKiBUaGlzIGlzIHRoZSBlbmNvZGluZyB1c2VkIGZvciBmb250cyBjcmVhdGVkIGZyb20gc2NyYXRjaC5cbiAqIEl0IGxvb3BzIHRocm91Z2ggYWxsIGdseXBocyBhbmQgZmluZHMgdGhlIGFwcHJvcHJpYXRlIHVuaWNvZGUgdmFsdWUuXG4gKiBTaW5jZSBpdCdzIGxpbmVhciB0aW1lLCBvdGhlciBlbmNvZGluZ3Mgd2lsbCBiZSBmYXN0ZXIuXG4gKiBAZXhwb3J0cyBvcGVudHlwZS5EZWZhdWx0RW5jb2RpbmdcbiAqIEBjbGFzc1xuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge29wZW50eXBlLkZvbnR9XG4gKi9cbmZ1bmN0aW9uIERlZmF1bHRFbmNvZGluZyhmb250KSB7XG4gICAgdGhpcy5mb250ID0gZm9udDtcbn1cblxuRGVmYXVsdEVuY29kaW5nLnByb3RvdHlwZS5jaGFyVG9HbHlwaEluZGV4ID0gZnVuY3Rpb24oYykge1xuICAgIGNvbnN0IGNvZGUgPSBjLmNoYXJDb2RlQXQoMCk7XG4gICAgY29uc3QgZ2x5cGhzID0gdGhpcy5mb250LmdseXBocztcbiAgICBpZiAoZ2x5cGhzKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZ2x5cGhzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICBjb25zdCBnbHlwaCA9IGdseXBocy5nZXQoaSk7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGdseXBoLnVuaWNvZGVzLmxlbmd0aDsgaiArPSAxKSB7XG4gICAgICAgICAgICAgICAgaWYgKGdseXBoLnVuaWNvZGVzW2pdID09PSBjb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn07XG5cbi8qKlxuICogQGV4cG9ydHMgb3BlbnR5cGUuQ21hcEVuY29kaW5nXG4gKiBAY2xhc3NcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtPYmplY3R9IGNtYXAgLSBhIG9iamVjdCB3aXRoIHRoZSBjbWFwIGVuY29kZWQgZGF0YVxuICovXG5mdW5jdGlvbiBDbWFwRW5jb2RpbmcoY21hcCkge1xuICAgIHRoaXMuY21hcCA9IGNtYXA7XG59XG5cbi8qKlxuICogQHBhcmFtICB7c3RyaW5nfSBjIC0gdGhlIGNoYXJhY3RlclxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgZ2x5cGggaW5kZXguXG4gKi9cbkNtYXBFbmNvZGluZy5wcm90b3R5cGUuY2hhclRvR2x5cGhJbmRleCA9IGZ1bmN0aW9uKGMpIHtcbiAgICByZXR1cm4gdGhpcy5jbWFwLmdseXBoSW5kZXhNYXBbYy5jaGFyQ29kZUF0KDApXSB8fCAwO1xufTtcblxuLyoqXG4gKiBAZXhwb3J0cyBvcGVudHlwZS5DZmZFbmNvZGluZ1xuICogQGNsYXNzXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7c3RyaW5nfSBlbmNvZGluZyAtIFRoZSBlbmNvZGluZ1xuICogQHBhcmFtIHtBcnJheX0gY2hhcnNldCAtIFRoZSBjaGFyYWN0ZXIgc2V0LlxuICovXG5mdW5jdGlvbiBDZmZFbmNvZGluZyhlbmNvZGluZywgY2hhcnNldCkge1xuICAgIHRoaXMuZW5jb2RpbmcgPSBlbmNvZGluZztcbiAgICB0aGlzLmNoYXJzZXQgPSBjaGFyc2V0O1xufVxuXG4vKipcbiAqIEBwYXJhbSAge3N0cmluZ30gcyAtIFRoZSBjaGFyYWN0ZXJcbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIGluZGV4LlxuICovXG5DZmZFbmNvZGluZy5wcm90b3R5cGUuY2hhclRvR2x5cGhJbmRleCA9IGZ1bmN0aW9uKHMpIHtcbiAgICBjb25zdCBjb2RlID0gcy5jaGFyQ29kZUF0KDApO1xuICAgIGNvbnN0IGNoYXJOYW1lID0gdGhpcy5lbmNvZGluZ1tjb2RlXTtcbiAgICByZXR1cm4gdGhpcy5jaGFyc2V0LmluZGV4T2YoY2hhck5hbWUpO1xufTtcblxuLyoqXG4gKiBAZXhwb3J0cyBvcGVudHlwZS5HbHlwaE5hbWVzXG4gKiBAY2xhc3NcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtPYmplY3R9IHBvc3RcbiAqL1xuZnVuY3Rpb24gR2x5cGhOYW1lcyhwb3N0KSB7XG4gICAgc3dpdGNoIChwb3N0LnZlcnNpb24pIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgdGhpcy5uYW1lcyA9IHN0YW5kYXJkTmFtZXMuc2xpY2UoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICB0aGlzLm5hbWVzID0gbmV3IEFycmF5KHBvc3QubnVtYmVyT2ZHbHlwaHMpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwb3N0Lm51bWJlck9mR2x5cGhzOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAocG9zdC5nbHlwaE5hbWVJbmRleFtpXSA8IHN0YW5kYXJkTmFtZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubmFtZXNbaV0gPSBzdGFuZGFyZE5hbWVzW3Bvc3QuZ2x5cGhOYW1lSW5kZXhbaV1dO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubmFtZXNbaV0gPSBwb3N0Lm5hbWVzW3Bvc3QuZ2x5cGhOYW1lSW5kZXhbaV0gLSBzdGFuZGFyZE5hbWVzLmxlbmd0aF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyLjU6XG4gICAgICAgICAgICB0aGlzLm5hbWVzID0gbmV3IEFycmF5KHBvc3QubnVtYmVyT2ZHbHlwaHMpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwb3N0Lm51bWJlck9mR2x5cGhzOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5hbWVzW2ldID0gc3RhbmRhcmROYW1lc1tpICsgcG9zdC5nbHlwaE5hbWVJbmRleFtpXV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICB0aGlzLm5hbWVzID0gW107XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRoaXMubmFtZXMgPSBbXTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBpbmRleCBvZiBhIGdseXBoIGJ5IG5hbWUuXG4gKiBAcGFyYW0gIHtzdHJpbmd9IG5hbWUgLSBUaGUgZ2x5cGggbmFtZVxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgaW5kZXhcbiAqL1xuR2x5cGhOYW1lcy5wcm90b3R5cGUubmFtZVRvR2x5cGhJbmRleCA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5uYW1lcy5pbmRleE9mKG5hbWUpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0gIHtudW1iZXJ9IGdpZFxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5HbHlwaE5hbWVzLnByb3RvdHlwZS5nbHlwaEluZGV4VG9OYW1lID0gZnVuY3Rpb24oZ2lkKSB7XG4gICAgcmV0dXJuIHRoaXMubmFtZXNbZ2lkXTtcbn07XG5cbi8qKlxuICogQGFsaWFzIG9wZW50eXBlLmFkZEdseXBoTmFtZXNcbiAqIEBwYXJhbSB7b3BlbnR5cGUuRm9udH1cbiAqL1xuZnVuY3Rpb24gYWRkR2x5cGhOYW1lcyhmb250KSB7XG4gICAgbGV0IGdseXBoO1xuICAgIGNvbnN0IGdseXBoSW5kZXhNYXAgPSBmb250LnRhYmxlcy5jbWFwLmdseXBoSW5kZXhNYXA7XG4gICAgY29uc3QgY2hhckNvZGVzID0gT2JqZWN0LmtleXMoZ2x5cGhJbmRleE1hcCk7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoYXJDb2Rlcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBjb25zdCBjID0gY2hhckNvZGVzW2ldO1xuICAgICAgICBjb25zdCBnbHlwaEluZGV4ID0gZ2x5cGhJbmRleE1hcFtjXTtcbiAgICAgICAgZ2x5cGggPSBmb250LmdseXBocy5nZXQoZ2x5cGhJbmRleCk7XG4gICAgICAgIGdseXBoLmFkZFVuaWNvZGUocGFyc2VJbnQoYykpO1xuICAgIH1cblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZm9udC5nbHlwaHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgZ2x5cGggPSBmb250LmdseXBocy5nZXQoaSk7XG4gICAgICAgIGlmIChmb250LmNmZkVuY29kaW5nKSB7XG4gICAgICAgICAgICBpZiAoZm9udC5pc0NJREZvbnQpIHtcbiAgICAgICAgICAgICAgICBnbHlwaC5uYW1lID0gJ2dpZCcgKyBpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBnbHlwaC5uYW1lID0gZm9udC5jZmZFbmNvZGluZy5jaGFyc2V0W2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGZvbnQuZ2x5cGhOYW1lcy5uYW1lcykge1xuICAgICAgICAgICAgZ2x5cGgubmFtZSA9IGZvbnQuZ2x5cGhOYW1lcy5nbHlwaEluZGV4VG9OYW1lKGkpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQge1xuICAgIGNmZlN0YW5kYXJkU3RyaW5ncyxcbiAgICBjZmZTdGFuZGFyZEVuY29kaW5nLFxuICAgIGNmZkV4cGVydEVuY29kaW5nLFxuICAgIHN0YW5kYXJkTmFtZXMsXG4gICAgRGVmYXVsdEVuY29kaW5nLFxuICAgIENtYXBFbmNvZGluZyxcbiAgICBDZmZFbmNvZGluZyxcbiAgICBHbHlwaE5hbWVzLFxuICAgIGFkZEdseXBoTmFtZXNcbn07XG4iLCIvLyBEcmF3aW5nIHV0aWxpdHkgZnVuY3Rpb25zLlxuXG4vLyBEcmF3IGEgbGluZSBvbiB0aGUgZ2l2ZW4gY29udGV4dCBmcm9tIHBvaW50IGB4MSx5MWAgdG8gcG9pbnQgYHgyLHkyYC5cbmZ1bmN0aW9uIGxpbmUoY3R4LCB4MSwgeTEsIHgyLCB5Mikge1xuICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICBjdHgubW92ZVRvKHgxLCB5MSk7XG4gICAgY3R4LmxpbmVUbyh4MiwgeTIpO1xuICAgIGN0eC5zdHJva2UoKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgeyBsaW5lIH07XG4iLCIvLyBUaGUgYGdseWZgIHRhYmxlIGRlc2NyaWJlcyB0aGUgZ2x5cGhzIGluIFRydWVUeXBlIG91dGxpbmUgZm9ybWF0LlxuLy8gaHR0cDovL3d3dy5taWNyb3NvZnQuY29tL3R5cG9ncmFwaHkvb3RzcGVjL2dseWYuaHRtXG5cbmltcG9ydCBjaGVjayBmcm9tICcuLi9jaGVjayc7XG5pbXBvcnQgZ2x5cGhzZXQgZnJvbSAnLi4vZ2x5cGhzZXQnO1xuaW1wb3J0IHBhcnNlIGZyb20gJy4uL3BhcnNlJztcbmltcG9ydCBQYXRoIGZyb20gJy4uL3BhdGgnO1xuXG4vLyBQYXJzZSB0aGUgY29vcmRpbmF0ZSBkYXRhIGZvciBhIGdseXBoLlxuZnVuY3Rpb24gcGFyc2VHbHlwaENvb3JkaW5hdGUocCwgZmxhZywgcHJldmlvdXNWYWx1ZSwgc2hvcnRWZWN0b3JCaXRNYXNrLCBzYW1lQml0TWFzaykge1xuICAgIGxldCB2O1xuICAgIGlmICgoZmxhZyAmIHNob3J0VmVjdG9yQml0TWFzaykgPiAwKSB7XG4gICAgICAgIC8vIFRoZSBjb29yZGluYXRlIGlzIDEgYnl0ZSBsb25nLlxuICAgICAgICB2ID0gcC5wYXJzZUJ5dGUoKTtcbiAgICAgICAgLy8gVGhlIGBzYW1lYCBiaXQgaXMgcmUtdXNlZCBmb3Igc2hvcnQgdmFsdWVzIHRvIHNpZ25pZnkgdGhlIHNpZ24gb2YgdGhlIHZhbHVlLlxuICAgICAgICBpZiAoKGZsYWcgJiBzYW1lQml0TWFzaykgPT09IDApIHtcbiAgICAgICAgICAgIHYgPSAtdjtcbiAgICAgICAgfVxuXG4gICAgICAgIHYgPSBwcmV2aW91c1ZhbHVlICsgdjtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyAgVGhlIGNvb3JkaW5hdGUgaXMgMiBieXRlcyBsb25nLlxuICAgICAgICAvLyBJZiB0aGUgYHNhbWVgIGJpdCBpcyBzZXQsIHRoZSBjb29yZGluYXRlIGlzIHRoZSBzYW1lIGFzIHRoZSBwcmV2aW91cyBjb29yZGluYXRlLlxuICAgICAgICBpZiAoKGZsYWcgJiBzYW1lQml0TWFzaykgPiAwKSB7XG4gICAgICAgICAgICB2ID0gcHJldmlvdXNWYWx1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFBhcnNlIHRoZSBjb29yZGluYXRlIGFzIGEgc2lnbmVkIDE2LWJpdCBkZWx0YSB2YWx1ZS5cbiAgICAgICAgICAgIHYgPSBwcmV2aW91c1ZhbHVlICsgcC5wYXJzZVNob3J0KCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdjtcbn1cblxuLy8gUGFyc2UgYSBUcnVlVHlwZSBnbHlwaC5cbmZ1bmN0aW9uIHBhcnNlR2x5cGgoZ2x5cGgsIGRhdGEsIHN0YXJ0KSB7XG4gICAgY29uc3QgcCA9IG5ldyBwYXJzZS5QYXJzZXIoZGF0YSwgc3RhcnQpO1xuICAgIGdseXBoLm51bWJlck9mQ29udG91cnMgPSBwLnBhcnNlU2hvcnQoKTtcbiAgICBnbHlwaC5feE1pbiA9IHAucGFyc2VTaG9ydCgpO1xuICAgIGdseXBoLl95TWluID0gcC5wYXJzZVNob3J0KCk7XG4gICAgZ2x5cGguX3hNYXggPSBwLnBhcnNlU2hvcnQoKTtcbiAgICBnbHlwaC5feU1heCA9IHAucGFyc2VTaG9ydCgpO1xuICAgIGxldCBmbGFncztcbiAgICBsZXQgZmxhZztcblxuICAgIGlmIChnbHlwaC5udW1iZXJPZkNvbnRvdXJzID4gMCkge1xuICAgICAgICAvLyBUaGlzIGdseXBoIGlzIG5vdCBhIGNvbXBvc2l0ZS5cbiAgICAgICAgY29uc3QgZW5kUG9pbnRJbmRpY2VzID0gZ2x5cGguZW5kUG9pbnRJbmRpY2VzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZ2x5cGgubnVtYmVyT2ZDb250b3VyczsgaSArPSAxKSB7XG4gICAgICAgICAgICBlbmRQb2ludEluZGljZXMucHVzaChwLnBhcnNlVVNob3J0KCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgZ2x5cGguaW5zdHJ1Y3Rpb25MZW5ndGggPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgIGdseXBoLmluc3RydWN0aW9ucyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGdseXBoLmluc3RydWN0aW9uTGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGdseXBoLmluc3RydWN0aW9ucy5wdXNoKHAucGFyc2VCeXRlKCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgbnVtYmVyT2ZDb29yZGluYXRlcyA9IGVuZFBvaW50SW5kaWNlc1tlbmRQb2ludEluZGljZXMubGVuZ3RoIC0gMV0gKyAxO1xuICAgICAgICBmbGFncyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bWJlck9mQ29vcmRpbmF0ZXM7IGkgKz0gMSkge1xuICAgICAgICAgICAgZmxhZyA9IHAucGFyc2VCeXRlKCk7XG4gICAgICAgICAgICBmbGFncy5wdXNoKGZsYWcpO1xuICAgICAgICAgICAgLy8gSWYgYml0IDMgaXMgc2V0LCB3ZSByZXBlYXQgdGhpcyBmbGFnIG4gdGltZXMsIHdoZXJlIG4gaXMgdGhlIG5leHQgYnl0ZS5cbiAgICAgICAgICAgIGlmICgoZmxhZyAmIDgpID4gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlcGVhdENvdW50ID0gcC5wYXJzZUJ5dGUoKTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHJlcGVhdENvdW50OyBqICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgZmxhZ3MucHVzaChmbGFnKTtcbiAgICAgICAgICAgICAgICAgICAgaSArPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNoZWNrLmFyZ3VtZW50KGZsYWdzLmxlbmd0aCA9PT0gbnVtYmVyT2ZDb29yZGluYXRlcywgJ0JhZCBmbGFncy4nKTtcblxuICAgICAgICBpZiAoZW5kUG9pbnRJbmRpY2VzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IHBvaW50cyA9IFtdO1xuICAgICAgICAgICAgbGV0IHBvaW50O1xuICAgICAgICAgICAgLy8gWC9ZIGNvb3JkaW5hdGVzIGFyZSByZWxhdGl2ZSB0byB0aGUgcHJldmlvdXMgcG9pbnQsIGV4Y2VwdCBmb3IgdGhlIGZpcnN0IHBvaW50IHdoaWNoIGlzIHJlbGF0aXZlIHRvIDAsMC5cbiAgICAgICAgICAgIGlmIChudW1iZXJPZkNvb3JkaW5hdGVzID4gMCkge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtYmVyT2ZDb29yZGluYXRlczsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGZsYWcgPSBmbGFnc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgcG9pbnQgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgcG9pbnQub25DdXJ2ZSA9ICEhKGZsYWcgJiAxKTtcbiAgICAgICAgICAgICAgICAgICAgcG9pbnQubGFzdFBvaW50T2ZDb250b3VyID0gZW5kUG9pbnRJbmRpY2VzLmluZGV4T2YoaSkgPj0gMDtcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRzLnB1c2gocG9pbnQpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGxldCBweCA9IDA7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1iZXJPZkNvb3JkaW5hdGVzOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgZmxhZyA9IGZsYWdzW2ldO1xuICAgICAgICAgICAgICAgICAgICBwb2ludCA9IHBvaW50c1tpXTtcbiAgICAgICAgICAgICAgICAgICAgcG9pbnQueCA9IHBhcnNlR2x5cGhDb29yZGluYXRlKHAsIGZsYWcsIHB4LCAyLCAxNik7XG4gICAgICAgICAgICAgICAgICAgIHB4ID0gcG9pbnQueDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBsZXQgcHkgPSAwO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtYmVyT2ZDb29yZGluYXRlczsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGZsYWcgPSBmbGFnc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgcG9pbnQgPSBwb2ludHNbaV07XG4gICAgICAgICAgICAgICAgICAgIHBvaW50LnkgPSBwYXJzZUdseXBoQ29vcmRpbmF0ZShwLCBmbGFnLCBweSwgNCwgMzIpO1xuICAgICAgICAgICAgICAgICAgICBweSA9IHBvaW50Lnk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBnbHlwaC5wb2ludHMgPSBwb2ludHM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnbHlwaC5wb2ludHMgPSBbXTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZ2x5cGgubnVtYmVyT2ZDb250b3VycyA9PT0gMCkge1xuICAgICAgICBnbHlwaC5wb2ludHMgPSBbXTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBnbHlwaC5pc0NvbXBvc2l0ZSA9IHRydWU7XG4gICAgICAgIGdseXBoLnBvaW50cyA9IFtdO1xuICAgICAgICBnbHlwaC5jb21wb25lbnRzID0gW107XG4gICAgICAgIGxldCBtb3JlQ29tcG9uZW50cyA9IHRydWU7XG4gICAgICAgIHdoaWxlIChtb3JlQ29tcG9uZW50cykge1xuICAgICAgICAgICAgZmxhZ3MgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgICAgICBjb25zdCBjb21wb25lbnQgPSB7XG4gICAgICAgICAgICAgICAgZ2x5cGhJbmRleDogcC5wYXJzZVVTaG9ydCgpLFxuICAgICAgICAgICAgICAgIHhTY2FsZTogMSxcbiAgICAgICAgICAgICAgICBzY2FsZTAxOiAwLFxuICAgICAgICAgICAgICAgIHNjYWxlMTA6IDAsXG4gICAgICAgICAgICAgICAgeVNjYWxlOiAxLFxuICAgICAgICAgICAgICAgIGR4OiAwLFxuICAgICAgICAgICAgICAgIGR5OiAwXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKChmbGFncyAmIDEpID4gMCkge1xuICAgICAgICAgICAgICAgIC8vIFRoZSBhcmd1bWVudHMgYXJlIHdvcmRzXG4gICAgICAgICAgICAgICAgaWYgKChmbGFncyAmIDIpID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAvLyB2YWx1ZXMgYXJlIG9mZnNldFxuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQuZHggPSBwLnBhcnNlU2hvcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50LmR5ID0gcC5wYXJzZVNob3J0KCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdmFsdWVzIGFyZSBtYXRjaGVkIHBvaW50c1xuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQubWF0Y2hlZFBvaW50cyA9IFtwLnBhcnNlVVNob3J0KCksIHAucGFyc2VVU2hvcnQoKV07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFRoZSBhcmd1bWVudHMgYXJlIGJ5dGVzXG4gICAgICAgICAgICAgICAgaWYgKChmbGFncyAmIDIpID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAvLyB2YWx1ZXMgYXJlIG9mZnNldFxuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQuZHggPSBwLnBhcnNlQ2hhcigpO1xuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQuZHkgPSBwLnBhcnNlQ2hhcigpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHZhbHVlcyBhcmUgbWF0Y2hlZCBwb2ludHNcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50Lm1hdGNoZWRQb2ludHMgPSBbcC5wYXJzZUJ5dGUoKSwgcC5wYXJzZUJ5dGUoKV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoKGZsYWdzICYgOCkgPiAwKSB7XG4gICAgICAgICAgICAgICAgLy8gV2UgaGF2ZSBhIHNjYWxlXG4gICAgICAgICAgICAgICAgY29tcG9uZW50LnhTY2FsZSA9IGNvbXBvbmVudC55U2NhbGUgPSBwLnBhcnNlRjJEb3QxNCgpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICgoZmxhZ3MgJiA2NCkgPiAwKSB7XG4gICAgICAgICAgICAgICAgLy8gV2UgaGF2ZSBhbiBYIC8gWSBzY2FsZVxuICAgICAgICAgICAgICAgIGNvbXBvbmVudC54U2NhbGUgPSBwLnBhcnNlRjJEb3QxNCgpO1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudC55U2NhbGUgPSBwLnBhcnNlRjJEb3QxNCgpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICgoZmxhZ3MgJiAxMjgpID4gMCkge1xuICAgICAgICAgICAgICAgIC8vIFdlIGhhdmUgYSAyeDIgdHJhbnNmb3JtYXRpb25cbiAgICAgICAgICAgICAgICBjb21wb25lbnQueFNjYWxlID0gcC5wYXJzZUYyRG90MTQoKTtcbiAgICAgICAgICAgICAgICBjb21wb25lbnQuc2NhbGUwMSA9IHAucGFyc2VGMkRvdDE0KCk7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50LnNjYWxlMTAgPSBwLnBhcnNlRjJEb3QxNCgpO1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudC55U2NhbGUgPSBwLnBhcnNlRjJEb3QxNCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBnbHlwaC5jb21wb25lbnRzLnB1c2goY29tcG9uZW50KTtcbiAgICAgICAgICAgIG1vcmVDb21wb25lbnRzID0gISEoZmxhZ3MgJiAzMik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZsYWdzICYgMHgxMDApIHtcbiAgICAgICAgICAgIC8vIFdlIGhhdmUgaW5zdHJ1Y3Rpb25zXG4gICAgICAgICAgICBnbHlwaC5pbnN0cnVjdGlvbkxlbmd0aCA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgICAgIGdseXBoLmluc3RydWN0aW9ucyA9IFtdO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBnbHlwaC5pbnN0cnVjdGlvbkxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgZ2x5cGguaW5zdHJ1Y3Rpb25zLnB1c2gocC5wYXJzZUJ5dGUoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8vIFRyYW5zZm9ybSBhbiBhcnJheSBvZiBwb2ludHMgYW5kIHJldHVybiBhIG5ldyBhcnJheS5cbmZ1bmN0aW9uIHRyYW5zZm9ybVBvaW50cyhwb2ludHMsIHRyYW5zZm9ybSkge1xuICAgIGNvbnN0IG5ld1BvaW50cyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGNvbnN0IHB0ID0gcG9pbnRzW2ldO1xuICAgICAgICBjb25zdCBuZXdQdCA9IHtcbiAgICAgICAgICAgIHg6IHRyYW5zZm9ybS54U2NhbGUgKiBwdC54ICsgdHJhbnNmb3JtLnNjYWxlMDEgKiBwdC55ICsgdHJhbnNmb3JtLmR4LFxuICAgICAgICAgICAgeTogdHJhbnNmb3JtLnNjYWxlMTAgKiBwdC54ICsgdHJhbnNmb3JtLnlTY2FsZSAqIHB0LnkgKyB0cmFuc2Zvcm0uZHksXG4gICAgICAgICAgICBvbkN1cnZlOiBwdC5vbkN1cnZlLFxuICAgICAgICAgICAgbGFzdFBvaW50T2ZDb250b3VyOiBwdC5sYXN0UG9pbnRPZkNvbnRvdXJcbiAgICAgICAgfTtcbiAgICAgICAgbmV3UG9pbnRzLnB1c2gobmV3UHQpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXdQb2ludHM7XG59XG5cbmZ1bmN0aW9uIGdldENvbnRvdXJzKHBvaW50cykge1xuICAgIGNvbnN0IGNvbnRvdXJzID0gW107XG4gICAgbGV0IGN1cnJlbnRDb250b3VyID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgY29uc3QgcHQgPSBwb2ludHNbaV07XG4gICAgICAgIGN1cnJlbnRDb250b3VyLnB1c2gocHQpO1xuICAgICAgICBpZiAocHQubGFzdFBvaW50T2ZDb250b3VyKSB7XG4gICAgICAgICAgICBjb250b3Vycy5wdXNoKGN1cnJlbnRDb250b3VyKTtcbiAgICAgICAgICAgIGN1cnJlbnRDb250b3VyID0gW107XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjaGVjay5hcmd1bWVudChjdXJyZW50Q29udG91ci5sZW5ndGggPT09IDAsICdUaGVyZSBhcmUgc3RpbGwgcG9pbnRzIGxlZnQgaW4gdGhlIGN1cnJlbnQgY29udG91ci4nKTtcbiAgICByZXR1cm4gY29udG91cnM7XG59XG5cbi8vIENvbnZlcnQgdGhlIFRydWVUeXBlIGdseXBoIG91dGxpbmUgdG8gYSBQYXRoLlxuZnVuY3Rpb24gZ2V0UGF0aChwb2ludHMpIHtcbiAgICBjb25zdCBwID0gbmV3IFBhdGgoKTtcbiAgICBpZiAoIXBvaW50cykge1xuICAgICAgICByZXR1cm4gcDtcbiAgICB9XG5cbiAgICBjb25zdCBjb250b3VycyA9IGdldENvbnRvdXJzKHBvaW50cyk7XG5cbiAgICBmb3IgKGxldCBjb250b3VySW5kZXggPSAwOyBjb250b3VySW5kZXggPCBjb250b3Vycy5sZW5ndGg7ICsrY29udG91ckluZGV4KSB7XG4gICAgICAgIGNvbnN0IGNvbnRvdXIgPSBjb250b3Vyc1tjb250b3VySW5kZXhdO1xuXG4gICAgICAgIGxldCBwcmV2ID0gbnVsbDtcbiAgICAgICAgbGV0IGN1cnIgPSBjb250b3VyW2NvbnRvdXIubGVuZ3RoIC0gMV07XG4gICAgICAgIGxldCBuZXh0ID0gY29udG91clswXTtcblxuICAgICAgICBpZiAoY3Vyci5vbkN1cnZlKSB7XG4gICAgICAgICAgICBwLm1vdmVUbyhjdXJyLngsIGN1cnIueSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAobmV4dC5vbkN1cnZlKSB7XG4gICAgICAgICAgICAgICAgcC5tb3ZlVG8obmV4dC54LCBuZXh0LnkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBJZiBib3RoIGZpcnN0IGFuZCBsYXN0IHBvaW50cyBhcmUgb2ZmLWN1cnZlLCBzdGFydCBhdCB0aGVpciBtaWRkbGUuXG4gICAgICAgICAgICAgICAgY29uc3Qgc3RhcnQgPSB7eDogKGN1cnIueCArIG5leHQueCkgKiAwLjUsIHk6IChjdXJyLnkgKyBuZXh0LnkpICogMC41fTtcbiAgICAgICAgICAgICAgICBwLm1vdmVUbyhzdGFydC54LCBzdGFydC55KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29udG91ci5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgcHJldiA9IGN1cnI7XG4gICAgICAgICAgICBjdXJyID0gbmV4dDtcbiAgICAgICAgICAgIG5leHQgPSBjb250b3VyWyhpICsgMSkgJSBjb250b3VyLmxlbmd0aF07XG5cbiAgICAgICAgICAgIGlmIChjdXJyLm9uQ3VydmUpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIGEgc3RyYWlnaHQgbGluZS5cbiAgICAgICAgICAgICAgICBwLmxpbmVUbyhjdXJyLngsIGN1cnIueSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBwcmV2MiA9IHByZXY7XG4gICAgICAgICAgICAgICAgbGV0IG5leHQyID0gbmV4dDtcblxuICAgICAgICAgICAgICAgIGlmICghcHJldi5vbkN1cnZlKSB7XG4gICAgICAgICAgICAgICAgICAgIHByZXYyID0geyB4OiAoY3Vyci54ICsgcHJldi54KSAqIDAuNSwgeTogKGN1cnIueSArIHByZXYueSkgKiAwLjUgfTtcbiAgICAgICAgICAgICAgICAgICAgcC5saW5lVG8ocHJldjIueCwgcHJldjIueSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCFuZXh0Lm9uQ3VydmUpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dDIgPSB7IHg6IChjdXJyLnggKyBuZXh0LngpICogMC41LCB5OiAoY3Vyci55ICsgbmV4dC55KSAqIDAuNSB9O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHAubGluZVRvKHByZXYyLngsIHByZXYyLnkpO1xuICAgICAgICAgICAgICAgIHAucXVhZHJhdGljQ3VydmVUbyhjdXJyLngsIGN1cnIueSwgbmV4dDIueCwgbmV4dDIueSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBwLmNsb3NlUGF0aCgpO1xuICAgIH1cbiAgICByZXR1cm4gcDtcbn1cblxuZnVuY3Rpb24gYnVpbGRQYXRoKGdseXBocywgZ2x5cGgpIHtcbiAgICBpZiAoZ2x5cGguaXNDb21wb3NpdGUpIHtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBnbHlwaC5jb21wb25lbnRzLmxlbmd0aDsgaiArPSAxKSB7XG4gICAgICAgICAgICBjb25zdCBjb21wb25lbnQgPSBnbHlwaC5jb21wb25lbnRzW2pdO1xuICAgICAgICAgICAgY29uc3QgY29tcG9uZW50R2x5cGggPSBnbHlwaHMuZ2V0KGNvbXBvbmVudC5nbHlwaEluZGV4KTtcbiAgICAgICAgICAgIC8vIEZvcmNlIHRoZSB0dGZHbHlwaExvYWRlciB0byBwYXJzZSB0aGUgZ2x5cGguXG4gICAgICAgICAgICBjb21wb25lbnRHbHlwaC5nZXRQYXRoKCk7XG4gICAgICAgICAgICBpZiAoY29tcG9uZW50R2x5cGgucG9pbnRzKSB7XG4gICAgICAgICAgICAgICAgbGV0IHRyYW5zZm9ybWVkUG9pbnRzO1xuICAgICAgICAgICAgICAgIGlmIChjb21wb25lbnQubWF0Y2hlZFBvaW50cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbXBvbmVudCBwb3NpdGlvbmVkIGJ5IG9mZnNldFxuICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm1lZFBvaW50cyA9IHRyYW5zZm9ybVBvaW50cyhjb21wb25lbnRHbHlwaC5wb2ludHMsIGNvbXBvbmVudCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gY29tcG9uZW50IHBvc2l0aW9uZWQgYnkgbWF0Y2hlZCBwb2ludHNcbiAgICAgICAgICAgICAgICAgICAgaWYgKChjb21wb25lbnQubWF0Y2hlZFBvaW50c1swXSA+IGdseXBoLnBvaW50cy5sZW5ndGggLSAxKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgKGNvbXBvbmVudC5tYXRjaGVkUG9pbnRzWzFdID4gY29tcG9uZW50R2x5cGgucG9pbnRzLmxlbmd0aCAtIDEpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcignTWF0Y2hlZCBwb2ludHMgb3V0IG9mIHJhbmdlIGluICcgKyBnbHlwaC5uYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBmaXJzdFB0ID0gZ2x5cGgucG9pbnRzW2NvbXBvbmVudC5tYXRjaGVkUG9pbnRzWzBdXTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHNlY29uZFB0ID0gY29tcG9uZW50R2x5cGgucG9pbnRzW2NvbXBvbmVudC5tYXRjaGVkUG9pbnRzWzFdXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdHJhbnNmb3JtID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgeFNjYWxlOiBjb21wb25lbnQueFNjYWxlLCBzY2FsZTAxOiBjb21wb25lbnQuc2NhbGUwMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjYWxlMTA6IGNvbXBvbmVudC5zY2FsZTEwLCB5U2NhbGU6IGNvbXBvbmVudC55U2NhbGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBkeDogMCwgZHk6IDBcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgc2Vjb25kUHQgPSB0cmFuc2Zvcm1Qb2ludHMoW3NlY29uZFB0XSwgdHJhbnNmb3JtKVswXTtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtLmR4ID0gZmlyc3RQdC54IC0gc2Vjb25kUHQueDtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtLmR5ID0gZmlyc3RQdC55IC0gc2Vjb25kUHQueTtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtZWRQb2ludHMgPSB0cmFuc2Zvcm1Qb2ludHMoY29tcG9uZW50R2x5cGgucG9pbnRzLCB0cmFuc2Zvcm0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBnbHlwaC5wb2ludHMgPSBnbHlwaC5wb2ludHMuY29uY2F0KHRyYW5zZm9ybWVkUG9pbnRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBnZXRQYXRoKGdseXBoLnBvaW50cyk7XG59XG5cbi8vIFBhcnNlIGFsbCB0aGUgZ2x5cGhzIGFjY29yZGluZyB0byB0aGUgb2Zmc2V0cyBmcm9tIHRoZSBgbG9jYWAgdGFibGUuXG5mdW5jdGlvbiBwYXJzZUdseWZUYWJsZShkYXRhLCBzdGFydCwgbG9jYSwgZm9udCkge1xuICAgIGNvbnN0IGdseXBocyA9IG5ldyBnbHlwaHNldC5HbHlwaFNldChmb250KTtcblxuICAgIC8vIFRoZSBsYXN0IGVsZW1lbnQgb2YgdGhlIGxvY2EgdGFibGUgaXMgaW52YWxpZC5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxvY2EubGVuZ3RoIC0gMTsgaSArPSAxKSB7XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IGxvY2FbaV07XG4gICAgICAgIGNvbnN0IG5leHRPZmZzZXQgPSBsb2NhW2kgKyAxXTtcbiAgICAgICAgaWYgKG9mZnNldCAhPT0gbmV4dE9mZnNldCkge1xuICAgICAgICAgICAgZ2x5cGhzLnB1c2goaSwgZ2x5cGhzZXQudHRmR2x5cGhMb2FkZXIoZm9udCwgaSwgcGFyc2VHbHlwaCwgZGF0YSwgc3RhcnQgKyBvZmZzZXQsIGJ1aWxkUGF0aCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ2x5cGhzLnB1c2goaSwgZ2x5cGhzZXQuZ2x5cGhMb2FkZXIoZm9udCwgaSkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGdseXBocztcbn1cblxuZXhwb3J0IGRlZmF1bHQgeyBnZXRQYXRoLCBwYXJzZTogcGFyc2VHbHlmVGFibGUgfTtcbiIsIi8vIFRoZSBHbHlwaCBvYmplY3RcblxuaW1wb3J0IGNoZWNrIGZyb20gJy4vY2hlY2snO1xuaW1wb3J0IGRyYXcgZnJvbSAnLi9kcmF3JztcbmltcG9ydCBQYXRoIGZyb20gJy4vcGF0aCc7XG5pbXBvcnQgZ2x5ZiBmcm9tICcuL3RhYmxlcy9nbHlmJztcblxuZnVuY3Rpb24gZ2V0UGF0aERlZmluaXRpb24oZ2x5cGgsIHBhdGgpIHtcbiAgICBsZXQgX3BhdGggPSBwYXRoIHx8IHtjb21tYW5kczogW119O1xuICAgIHJldHVybiB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblxuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBfcGF0aCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIF9wYXRoID0gX3BhdGgoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIF9wYXRoO1xuICAgICAgICB9LFxuXG4gICAgICAgIHNldDogZnVuY3Rpb24ocCkge1xuICAgICAgICAgICAgX3BhdGggPSBwO1xuICAgICAgICB9XG4gICAgfTtcbn1cbi8qKlxuICogQHR5cGVkZWYgR2x5cGhPcHRpb25zXG4gKiBAdHlwZSBPYmplY3RcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbbmFtZV0gLSBUaGUgZ2x5cGggbmFtZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IFt1bmljb2RlXVxuICogQHByb3BlcnR5IHtBcnJheX0gW3VuaWNvZGVzXVxuICogQHByb3BlcnR5IHtudW1iZXJ9IFt4TWluXVxuICogQHByb3BlcnR5IHtudW1iZXJ9IFt5TWluXVxuICogQHByb3BlcnR5IHtudW1iZXJ9IFt4TWF4XVxuICogQHByb3BlcnR5IHtudW1iZXJ9IFt5TWF4XVxuICogQHByb3BlcnR5IHtudW1iZXJ9IFthZHZhbmNlV2lkdGhdXG4gKi9cblxuLy8gQSBHbHlwaCBpcyBhbiBpbmRpdmlkdWFsIG1hcmsgdGhhdCBvZnRlbiBjb3JyZXNwb25kcyB0byBhIGNoYXJhY3Rlci5cbi8vIFNvbWUgZ2x5cGhzLCBzdWNoIGFzIGxpZ2F0dXJlcywgYXJlIGEgY29tYmluYXRpb24gb2YgbWFueSBjaGFyYWN0ZXJzLlxuLy8gR2x5cGhzIGFyZSB0aGUgYmFzaWMgYnVpbGRpbmcgYmxvY2tzIG9mIGEgZm9udC5cbi8vXG4vLyBUaGUgYEdseXBoYCBjbGFzcyBjb250YWlucyB1dGlsaXR5IG1ldGhvZHMgZm9yIGRyYXdpbmcgdGhlIHBhdGggYW5kIGl0cyBwb2ludHMuXG4vKipcbiAqIEBleHBvcnRzIG9wZW50eXBlLkdseXBoXG4gKiBAY2xhc3NcbiAqIEBwYXJhbSB7R2x5cGhPcHRpb25zfVxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIEdseXBoKG9wdGlvbnMpIHtcbiAgICAvLyBCeSBwdXR0aW5nIGFsbCB0aGUgY29kZSBvbiBhIHByb3RvdHlwZSBmdW5jdGlvbiAod2hpY2ggaXMgb25seSBkZWNsYXJlZCBvbmNlKVxuICAgIC8vIHdlIHJlZHVjZSB0aGUgbWVtb3J5IHJlcXVpcmVtZW50cyBmb3IgbGFyZ2VyIGZvbnRzIGJ5IHNvbWUgMiVcbiAgICB0aGlzLmJpbmRDb25zdHJ1Y3RvclZhbHVlcyhvcHRpb25zKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0gIHtHbHlwaE9wdGlvbnN9XG4gKi9cbkdseXBoLnByb3RvdHlwZS5iaW5kQ29uc3RydWN0b3JWYWx1ZXMgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgdGhpcy5pbmRleCA9IG9wdGlvbnMuaW5kZXggfHwgMDtcblxuICAgIC8vIFRoZXNlIHRocmVlIHZhbHVlcyBjYW5ub3QgYmUgZGVmZXJyZWQgZm9yIG1lbW9yeSBvcHRpbWl6YXRpb246XG4gICAgdGhpcy5uYW1lID0gb3B0aW9ucy5uYW1lIHx8IG51bGw7XG4gICAgdGhpcy51bmljb2RlID0gb3B0aW9ucy51bmljb2RlIHx8IHVuZGVmaW5lZDtcbiAgICB0aGlzLnVuaWNvZGVzID0gb3B0aW9ucy51bmljb2RlcyB8fCBvcHRpb25zLnVuaWNvZGUgIT09IHVuZGVmaW5lZCA/IFtvcHRpb25zLnVuaWNvZGVdIDogW107XG5cbiAgICAvLyBCdXQgYnkgYmluZGluZyB0aGVzZSB2YWx1ZXMgb25seSB3aGVuIG5lY2Vzc2FyeSwgd2UgcmVkdWNlIGNhblxuICAgIC8vIHRoZSBtZW1vcnkgcmVxdWlyZW1lbnRzIGJ5IGFsbW9zdCAzJSBmb3IgbGFyZ2VyIGZvbnRzLlxuICAgIGlmIChvcHRpb25zLnhNaW4pIHtcbiAgICAgICAgdGhpcy54TWluID0gb3B0aW9ucy54TWluO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLnlNaW4pIHtcbiAgICAgICAgdGhpcy55TWluID0gb3B0aW9ucy55TWluO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLnhNYXgpIHtcbiAgICAgICAgdGhpcy54TWF4ID0gb3B0aW9ucy54TWF4O1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLnlNYXgpIHtcbiAgICAgICAgdGhpcy55TWF4ID0gb3B0aW9ucy55TWF4O1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLmFkdmFuY2VXaWR0aCkge1xuICAgICAgICB0aGlzLmFkdmFuY2VXaWR0aCA9IG9wdGlvbnMuYWR2YW5jZVdpZHRoO1xuICAgIH1cblxuICAgIC8vIFRoZSBwYXRoIGZvciBhIGdseXBoIGlzIHRoZSBtb3N0IG1lbW9yeSBpbnRlbnNpdmUsIGFuZCBpcyBib3VuZCBhcyBhIHZhbHVlXG4gICAgLy8gd2l0aCBhIGdldHRlci9zZXR0ZXIgdG8gZW5zdXJlIHdlIGFjdHVhbGx5IGRvIHBhdGggcGFyc2luZyBvbmx5IG9uY2UgdGhlXG4gICAgLy8gcGF0aCBpcyBhY3R1YWxseSBuZWVkZWQgYnkgYW55dGhpbmcuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdwYXRoJywgZ2V0UGF0aERlZmluaXRpb24odGhpcywgb3B0aW9ucy5wYXRoKSk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfVxuICovXG5HbHlwaC5wcm90b3R5cGUuYWRkVW5pY29kZSA9IGZ1bmN0aW9uKHVuaWNvZGUpIHtcbiAgICBpZiAodGhpcy51bmljb2Rlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhpcy51bmljb2RlID0gdW5pY29kZTtcbiAgICB9XG5cbiAgICB0aGlzLnVuaWNvZGVzLnB1c2godW5pY29kZSk7XG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZSB0aGUgbWluaW11bSBib3VuZGluZyBib3ggZm9yIHRoaXMgZ2x5cGguXG4gKiBAcmV0dXJuIHtvcGVudHlwZS5Cb3VuZGluZ0JveH1cbiAqL1xuR2x5cGgucHJvdG90eXBlLmdldEJvdW5kaW5nQm94ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMucGF0aC5nZXRCb3VuZGluZ0JveCgpO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0IHRoZSBnbHlwaCB0byBhIFBhdGggd2UgY2FuIGRyYXcgb24gYSBkcmF3aW5nIGNvbnRleHQuXG4gKiBAcGFyYW0gIHtudW1iZXJ9IFt4PTBdIC0gSG9yaXpvbnRhbCBwb3NpdGlvbiBvZiB0aGUgYmVnaW5uaW5nIG9mIHRoZSB0ZXh0LlxuICogQHBhcmFtICB7bnVtYmVyfSBbeT0wXSAtIFZlcnRpY2FsIHBvc2l0aW9uIG9mIHRoZSAqYmFzZWxpbmUqIG9mIHRoZSB0ZXh0LlxuICogQHBhcmFtICB7bnVtYmVyfSBbZm9udFNpemU9NzJdIC0gRm9udCBzaXplIGluIHBpeGVscy4gV2Ugc2NhbGUgdGhlIGdseXBoIHVuaXRzIGJ5IGAxIC8gdW5pdHNQZXJFbSAqIGZvbnRTaXplYC5cbiAqIEBwYXJhbSAge09iamVjdD19IG9wdGlvbnMgLSB4U2NhbGUsIHlTY2FsZSB0byBzdHJldGNoIHRoZSBnbHlwaC5cbiAqIEBwYXJhbSAge29wZW50eXBlLkZvbnR9IGlmIGhpbnRpbmcgaXMgdG8gYmUgdXNlZCwgdGhlIGZvbnRcbiAqIEByZXR1cm4ge29wZW50eXBlLlBhdGh9XG4gKi9cbkdseXBoLnByb3RvdHlwZS5nZXRQYXRoID0gZnVuY3Rpb24oeCwgeSwgZm9udFNpemUsIG9wdGlvbnMsIGZvbnQpIHtcbiAgICB4ID0geCAhPT0gdW5kZWZpbmVkID8geCA6IDA7XG4gICAgeSA9IHkgIT09IHVuZGVmaW5lZCA/IHkgOiAwO1xuICAgIGZvbnRTaXplID0gZm9udFNpemUgIT09IHVuZGVmaW5lZCA/IGZvbnRTaXplIDogNzI7XG4gICAgbGV0IGNvbW1hbmRzO1xuICAgIGxldCBoUG9pbnRzO1xuICAgIGlmICghb3B0aW9ucykgb3B0aW9ucyA9IHsgfTtcbiAgICBsZXQgeFNjYWxlID0gb3B0aW9ucy54U2NhbGU7XG4gICAgbGV0IHlTY2FsZSA9IG9wdGlvbnMueVNjYWxlO1xuXG4gICAgaWYgKG9wdGlvbnMuaGludGluZyAmJiBmb250ICYmIGZvbnQuaGludGluZykge1xuICAgICAgICAvLyBpbiBjYXNlIG9mIGhpbnRpbmcsIHRoZSBoaW50aW5nIGVuZ2luZSB0YWtlcyBjYXJlXG4gICAgICAgIC8vIG9mIHNjYWxpbmcgdGhlIHBvaW50cyAobm90IHRoZSBwYXRoKSBiZWZvcmUgaGludGluZy5cbiAgICAgICAgaFBvaW50cyA9IHRoaXMucGF0aCAmJiBmb250LmhpbnRpbmcuZXhlYyh0aGlzLCBmb250U2l6ZSk7XG4gICAgICAgIC8vIGluIGNhc2UgdGhlIGhpbnRpbmcgZW5naW5lIGZhaWxlZCBoUG9pbnRzIGlzIHVuZGVmaW5lZFxuICAgICAgICAvLyBhbmQgdGh1cyByZXZlcnRzIHRvIHBsYWluIHJlbmRpbmdcbiAgICB9XG5cbiAgICBpZiAoaFBvaW50cykge1xuICAgICAgICBjb21tYW5kcyA9IGdseWYuZ2V0UGF0aChoUG9pbnRzKS5jb21tYW5kcztcbiAgICAgICAgeCA9IE1hdGgucm91bmQoeCk7XG4gICAgICAgIHkgPSBNYXRoLnJvdW5kKHkpO1xuICAgICAgICAvLyBUT0RPIGluIGNhc2Ugb2YgaGludGluZyB4eVNjYWxpbmcgaXMgbm90IHlldCBzdXBwb3J0ZWRcbiAgICAgICAgeFNjYWxlID0geVNjYWxlID0gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBjb21tYW5kcyA9IHRoaXMucGF0aC5jb21tYW5kcztcbiAgICAgICAgY29uc3Qgc2NhbGUgPSAxIC8gdGhpcy5wYXRoLnVuaXRzUGVyRW0gKiBmb250U2l6ZTtcbiAgICAgICAgaWYgKHhTY2FsZSA9PT0gdW5kZWZpbmVkKSB4U2NhbGUgPSBzY2FsZTtcbiAgICAgICAgaWYgKHlTY2FsZSA9PT0gdW5kZWZpbmVkKSB5U2NhbGUgPSBzY2FsZTtcbiAgICB9XG5cbiAgICBjb25zdCBwID0gbmV3IFBhdGgoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbW1hbmRzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGNvbnN0IGNtZCA9IGNvbW1hbmRzW2ldO1xuICAgICAgICBpZiAoY21kLnR5cGUgPT09ICdNJykge1xuICAgICAgICAgICAgcC5tb3ZlVG8oeCArIChjbWQueCAqIHhTY2FsZSksIHkgKyAoLWNtZC55ICogeVNjYWxlKSk7XG4gICAgICAgIH0gZWxzZSBpZiAoY21kLnR5cGUgPT09ICdMJykge1xuICAgICAgICAgICAgcC5saW5lVG8oeCArIChjbWQueCAqIHhTY2FsZSksIHkgKyAoLWNtZC55ICogeVNjYWxlKSk7XG4gICAgICAgIH0gZWxzZSBpZiAoY21kLnR5cGUgPT09ICdRJykge1xuICAgICAgICAgICAgcC5xdWFkcmF0aWNDdXJ2ZVRvKHggKyAoY21kLngxICogeFNjYWxlKSwgeSArICgtY21kLnkxICogeVNjYWxlKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4ICsgKGNtZC54ICogeFNjYWxlKSwgeSArICgtY21kLnkgKiB5U2NhbGUpKTtcbiAgICAgICAgfSBlbHNlIGlmIChjbWQudHlwZSA9PT0gJ0MnKSB7XG4gICAgICAgICAgICBwLmN1cnZlVG8oeCArIChjbWQueDEgKiB4U2NhbGUpLCB5ICsgKC1jbWQueTEgKiB5U2NhbGUpLFxuICAgICAgICAgICAgICAgICAgICAgIHggKyAoY21kLngyICogeFNjYWxlKSwgeSArICgtY21kLnkyICogeVNjYWxlKSxcbiAgICAgICAgICAgICAgICAgICAgICB4ICsgKGNtZC54ICogeFNjYWxlKSwgeSArICgtY21kLnkgKiB5U2NhbGUpKTtcbiAgICAgICAgfSBlbHNlIGlmIChjbWQudHlwZSA9PT0gJ1onKSB7XG4gICAgICAgICAgICBwLmNsb3NlUGF0aCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHA7XG59O1xuXG4vKipcbiAqIFNwbGl0IHRoZSBnbHlwaCBpbnRvIGNvbnRvdXJzLlxuICogVGhpcyBmdW5jdGlvbiBpcyBoZXJlIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSwgYW5kIHRvXG4gKiBwcm92aWRlIHJhdyBhY2Nlc3MgdG8gdGhlIFRydWVUeXBlIGdseXBoIG91dGxpbmVzLlxuICogQHJldHVybiB7QXJyYXl9XG4gKi9cbkdseXBoLnByb3RvdHlwZS5nZXRDb250b3VycyA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLnBvaW50cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICBjb25zdCBjb250b3VycyA9IFtdO1xuICAgIGxldCBjdXJyZW50Q29udG91ciA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5wb2ludHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgY29uc3QgcHQgPSB0aGlzLnBvaW50c1tpXTtcbiAgICAgICAgY3VycmVudENvbnRvdXIucHVzaChwdCk7XG4gICAgICAgIGlmIChwdC5sYXN0UG9pbnRPZkNvbnRvdXIpIHtcbiAgICAgICAgICAgIGNvbnRvdXJzLnB1c2goY3VycmVudENvbnRvdXIpO1xuICAgICAgICAgICAgY3VycmVudENvbnRvdXIgPSBbXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNoZWNrLmFyZ3VtZW50KGN1cnJlbnRDb250b3VyLmxlbmd0aCA9PT0gMCwgJ1RoZXJlIGFyZSBzdGlsbCBwb2ludHMgbGVmdCBpbiB0aGUgY3VycmVudCBjb250b3VyLicpO1xuICAgIHJldHVybiBjb250b3Vycztcbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlIHRoZSB4TWluL3lNaW4veE1heC95TWF4L2xzYi9yc2IgZm9yIGEgR2x5cGguXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cbkdseXBoLnByb3RvdHlwZS5nZXRNZXRyaWNzID0gZnVuY3Rpb24oKSB7XG4gICAgY29uc3QgY29tbWFuZHMgPSB0aGlzLnBhdGguY29tbWFuZHM7XG4gICAgY29uc3QgeENvb3JkcyA9IFtdO1xuICAgIGNvbnN0IHlDb29yZHMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbW1hbmRzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGNvbnN0IGNtZCA9IGNvbW1hbmRzW2ldO1xuICAgICAgICBpZiAoY21kLnR5cGUgIT09ICdaJykge1xuICAgICAgICAgICAgeENvb3Jkcy5wdXNoKGNtZC54KTtcbiAgICAgICAgICAgIHlDb29yZHMucHVzaChjbWQueSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY21kLnR5cGUgPT09ICdRJyB8fCBjbWQudHlwZSA9PT0gJ0MnKSB7XG4gICAgICAgICAgICB4Q29vcmRzLnB1c2goY21kLngxKTtcbiAgICAgICAgICAgIHlDb29yZHMucHVzaChjbWQueTEpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNtZC50eXBlID09PSAnQycpIHtcbiAgICAgICAgICAgIHhDb29yZHMucHVzaChjbWQueDIpO1xuICAgICAgICAgICAgeUNvb3Jkcy5wdXNoKGNtZC55Mik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBtZXRyaWNzID0ge1xuICAgICAgICB4TWluOiBNYXRoLm1pbi5hcHBseShudWxsLCB4Q29vcmRzKSxcbiAgICAgICAgeU1pbjogTWF0aC5taW4uYXBwbHkobnVsbCwgeUNvb3JkcyksXG4gICAgICAgIHhNYXg6IE1hdGgubWF4LmFwcGx5KG51bGwsIHhDb29yZHMpLFxuICAgICAgICB5TWF4OiBNYXRoLm1heC5hcHBseShudWxsLCB5Q29vcmRzKSxcbiAgICAgICAgbGVmdFNpZGVCZWFyaW5nOiB0aGlzLmxlZnRTaWRlQmVhcmluZ1xuICAgIH07XG5cbiAgICBpZiAoIWlzRmluaXRlKG1ldHJpY3MueE1pbikpIHtcbiAgICAgICAgbWV0cmljcy54TWluID0gMDtcbiAgICB9XG5cbiAgICBpZiAoIWlzRmluaXRlKG1ldHJpY3MueE1heCkpIHtcbiAgICAgICAgbWV0cmljcy54TWF4ID0gdGhpcy5hZHZhbmNlV2lkdGg7XG4gICAgfVxuXG4gICAgaWYgKCFpc0Zpbml0ZShtZXRyaWNzLnlNaW4pKSB7XG4gICAgICAgIG1ldHJpY3MueU1pbiA9IDA7XG4gICAgfVxuXG4gICAgaWYgKCFpc0Zpbml0ZShtZXRyaWNzLnlNYXgpKSB7XG4gICAgICAgIG1ldHJpY3MueU1heCA9IDA7XG4gICAgfVxuXG4gICAgbWV0cmljcy5yaWdodFNpZGVCZWFyaW5nID0gdGhpcy5hZHZhbmNlV2lkdGggLSBtZXRyaWNzLmxlZnRTaWRlQmVhcmluZyAtIChtZXRyaWNzLnhNYXggLSBtZXRyaWNzLnhNaW4pO1xuICAgIHJldHVybiBtZXRyaWNzO1xufTtcblxuLyoqXG4gKiBEcmF3IHRoZSBnbHlwaCBvbiB0aGUgZ2l2ZW4gY29udGV4dC5cbiAqIEBwYXJhbSAge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IC0gQSAyRCBkcmF3aW5nIGNvbnRleHQsIGxpa2UgQ2FudmFzLlxuICogQHBhcmFtICB7bnVtYmVyfSBbeD0wXSAtIEhvcml6b250YWwgcG9zaXRpb24gb2YgdGhlIGJlZ2lubmluZyBvZiB0aGUgdGV4dC5cbiAqIEBwYXJhbSAge251bWJlcn0gW3k9MF0gLSBWZXJ0aWNhbCBwb3NpdGlvbiBvZiB0aGUgKmJhc2VsaW5lKiBvZiB0aGUgdGV4dC5cbiAqIEBwYXJhbSAge251bWJlcn0gW2ZvbnRTaXplPTcyXSAtIEZvbnQgc2l6ZSBpbiBwaXhlbHMuIFdlIHNjYWxlIHRoZSBnbHlwaCB1bml0cyBieSBgMSAvIHVuaXRzUGVyRW0gKiBmb250U2l6ZWAuXG4gKiBAcGFyYW0gIHtPYmplY3Q9fSBvcHRpb25zIC0geFNjYWxlLCB5U2NhbGUgdG8gc3RyZXRjaCB0aGUgZ2x5cGguXG4gKi9cbkdseXBoLnByb3RvdHlwZS5kcmF3ID0gZnVuY3Rpb24oY3R4LCB4LCB5LCBmb250U2l6ZSwgb3B0aW9ucykge1xuICAgIHRoaXMuZ2V0UGF0aCh4LCB5LCBmb250U2l6ZSwgb3B0aW9ucykuZHJhdyhjdHgpO1xufTtcblxuLyoqXG4gKiBEcmF3IHRoZSBwb2ludHMgb2YgdGhlIGdseXBoLlxuICogT24tY3VydmUgcG9pbnRzIHdpbGwgYmUgZHJhd24gaW4gYmx1ZSwgb2ZmLWN1cnZlIHBvaW50cyB3aWxsIGJlIGRyYXduIGluIHJlZC5cbiAqIEBwYXJhbSAge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IC0gQSAyRCBkcmF3aW5nIGNvbnRleHQsIGxpa2UgQ2FudmFzLlxuICogQHBhcmFtICB7bnVtYmVyfSBbeD0wXSAtIEhvcml6b250YWwgcG9zaXRpb24gb2YgdGhlIGJlZ2lubmluZyBvZiB0aGUgdGV4dC5cbiAqIEBwYXJhbSAge251bWJlcn0gW3k9MF0gLSBWZXJ0aWNhbCBwb3NpdGlvbiBvZiB0aGUgKmJhc2VsaW5lKiBvZiB0aGUgdGV4dC5cbiAqIEBwYXJhbSAge251bWJlcn0gW2ZvbnRTaXplPTcyXSAtIEZvbnQgc2l6ZSBpbiBwaXhlbHMuIFdlIHNjYWxlIHRoZSBnbHlwaCB1bml0cyBieSBgMSAvIHVuaXRzUGVyRW0gKiBmb250U2l6ZWAuXG4gKi9cbkdseXBoLnByb3RvdHlwZS5kcmF3UG9pbnRzID0gZnVuY3Rpb24oY3R4LCB4LCB5LCBmb250U2l6ZSkge1xuICAgIGZ1bmN0aW9uIGRyYXdDaXJjbGVzKGwsIHgsIHksIHNjYWxlKSB7XG4gICAgICAgIGNvbnN0IFBJX1NRID0gTWF0aC5QSSAqIDI7XG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBsLmxlbmd0aDsgaiArPSAxKSB7XG4gICAgICAgICAgICBjdHgubW92ZVRvKHggKyAobFtqXS54ICogc2NhbGUpLCB5ICsgKGxbal0ueSAqIHNjYWxlKSk7XG4gICAgICAgICAgICBjdHguYXJjKHggKyAobFtqXS54ICogc2NhbGUpLCB5ICsgKGxbal0ueSAqIHNjYWxlKSwgMiwgMCwgUElfU1EsIGZhbHNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgICAgY3R4LmZpbGwoKTtcbiAgICB9XG5cbiAgICB4ID0geCAhPT0gdW5kZWZpbmVkID8geCA6IDA7XG4gICAgeSA9IHkgIT09IHVuZGVmaW5lZCA/IHkgOiAwO1xuICAgIGZvbnRTaXplID0gZm9udFNpemUgIT09IHVuZGVmaW5lZCA/IGZvbnRTaXplIDogMjQ7XG4gICAgY29uc3Qgc2NhbGUgPSAxIC8gdGhpcy5wYXRoLnVuaXRzUGVyRW0gKiBmb250U2l6ZTtcblxuICAgIGNvbnN0IGJsdWVDaXJjbGVzID0gW107XG4gICAgY29uc3QgcmVkQ2lyY2xlcyA9IFtdO1xuICAgIGNvbnN0IHBhdGggPSB0aGlzLnBhdGg7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXRoLmNvbW1hbmRzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGNvbnN0IGNtZCA9IHBhdGguY29tbWFuZHNbaV07XG4gICAgICAgIGlmIChjbWQueCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBibHVlQ2lyY2xlcy5wdXNoKHt4OiBjbWQueCwgeTogLWNtZC55fSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY21kLngxICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJlZENpcmNsZXMucHVzaCh7eDogY21kLngxLCB5OiAtY21kLnkxfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY21kLngyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJlZENpcmNsZXMucHVzaCh7eDogY21kLngyLCB5OiAtY21kLnkyfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjdHguZmlsbFN0eWxlID0gJ2JsdWUnO1xuICAgIGRyYXdDaXJjbGVzKGJsdWVDaXJjbGVzLCB4LCB5LCBzY2FsZSk7XG4gICAgY3R4LmZpbGxTdHlsZSA9ICdyZWQnO1xuICAgIGRyYXdDaXJjbGVzKHJlZENpcmNsZXMsIHgsIHksIHNjYWxlKTtcbn07XG5cbi8qKlxuICogRHJhdyBsaW5lcyBpbmRpY2F0aW5nIGltcG9ydGFudCBmb250IG1lYXN1cmVtZW50cy5cbiAqIEJsYWNrIGxpbmVzIGluZGljYXRlIHRoZSBvcmlnaW4gb2YgdGhlIGNvb3JkaW5hdGUgc3lzdGVtIChwb2ludCAwLDApLlxuICogQmx1ZSBsaW5lcyBpbmRpY2F0ZSB0aGUgZ2x5cGggYm91bmRpbmcgYm94LlxuICogR3JlZW4gbGluZSBpbmRpY2F0ZXMgdGhlIGFkdmFuY2Ugd2lkdGggb2YgdGhlIGdseXBoLlxuICogQHBhcmFtICB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggLSBBIDJEIGRyYXdpbmcgY29udGV4dCwgbGlrZSBDYW52YXMuXG4gKiBAcGFyYW0gIHtudW1iZXJ9IFt4PTBdIC0gSG9yaXpvbnRhbCBwb3NpdGlvbiBvZiB0aGUgYmVnaW5uaW5nIG9mIHRoZSB0ZXh0LlxuICogQHBhcmFtICB7bnVtYmVyfSBbeT0wXSAtIFZlcnRpY2FsIHBvc2l0aW9uIG9mIHRoZSAqYmFzZWxpbmUqIG9mIHRoZSB0ZXh0LlxuICogQHBhcmFtICB7bnVtYmVyfSBbZm9udFNpemU9NzJdIC0gRm9udCBzaXplIGluIHBpeGVscy4gV2Ugc2NhbGUgdGhlIGdseXBoIHVuaXRzIGJ5IGAxIC8gdW5pdHNQZXJFbSAqIGZvbnRTaXplYC5cbiAqL1xuR2x5cGgucHJvdG90eXBlLmRyYXdNZXRyaWNzID0gZnVuY3Rpb24oY3R4LCB4LCB5LCBmb250U2l6ZSkge1xuICAgIGxldCBzY2FsZTtcbiAgICB4ID0geCAhPT0gdW5kZWZpbmVkID8geCA6IDA7XG4gICAgeSA9IHkgIT09IHVuZGVmaW5lZCA/IHkgOiAwO1xuICAgIGZvbnRTaXplID0gZm9udFNpemUgIT09IHVuZGVmaW5lZCA/IGZvbnRTaXplIDogMjQ7XG4gICAgc2NhbGUgPSAxIC8gdGhpcy5wYXRoLnVuaXRzUGVyRW0gKiBmb250U2l6ZTtcbiAgICBjdHgubGluZVdpZHRoID0gMTtcblxuICAgIC8vIERyYXcgdGhlIG9yaWdpblxuICAgIGN0eC5zdHJva2VTdHlsZSA9ICdibGFjayc7XG4gICAgZHJhdy5saW5lKGN0eCwgeCwgLTEwMDAwLCB4LCAxMDAwMCk7XG4gICAgZHJhdy5saW5lKGN0eCwgLTEwMDAwLCB5LCAxMDAwMCwgeSk7XG5cbiAgICAvLyBUaGlzIGNvZGUgaXMgaGVyZSBkdWUgdG8gbWVtb3J5IG9wdGltaXphdGlvbjogYnkgbm90IHVzaW5nXG4gICAgLy8gZGVmYXVsdHMgaW4gdGhlIGNvbnN0cnVjdG9yLCB3ZSBzYXZlIGEgbm90YWJsZSBhbW91bnQgb2YgbWVtb3J5LlxuICAgIGNvbnN0IHhNaW4gPSB0aGlzLnhNaW4gfHwgMDtcbiAgICBsZXQgeU1pbiA9IHRoaXMueU1pbiB8fCAwO1xuICAgIGNvbnN0IHhNYXggPSB0aGlzLnhNYXggfHwgMDtcbiAgICBsZXQgeU1heCA9IHRoaXMueU1heCB8fCAwO1xuICAgIGNvbnN0IGFkdmFuY2VXaWR0aCA9IHRoaXMuYWR2YW5jZVdpZHRoIHx8IDA7XG5cbiAgICAvLyBEcmF3IHRoZSBnbHlwaCBib3hcbiAgICBjdHguc3Ryb2tlU3R5bGUgPSAnYmx1ZSc7XG4gICAgZHJhdy5saW5lKGN0eCwgeCArICh4TWluICogc2NhbGUpLCAtMTAwMDAsIHggKyAoeE1pbiAqIHNjYWxlKSwgMTAwMDApO1xuICAgIGRyYXcubGluZShjdHgsIHggKyAoeE1heCAqIHNjYWxlKSwgLTEwMDAwLCB4ICsgKHhNYXggKiBzY2FsZSksIDEwMDAwKTtcbiAgICBkcmF3LmxpbmUoY3R4LCAtMTAwMDAsIHkgKyAoLXlNaW4gKiBzY2FsZSksIDEwMDAwLCB5ICsgKC15TWluICogc2NhbGUpKTtcbiAgICBkcmF3LmxpbmUoY3R4LCAtMTAwMDAsIHkgKyAoLXlNYXggKiBzY2FsZSksIDEwMDAwLCB5ICsgKC15TWF4ICogc2NhbGUpKTtcblxuICAgIC8vIERyYXcgdGhlIGFkdmFuY2Ugd2lkdGhcbiAgICBjdHguc3Ryb2tlU3R5bGUgPSAnZ3JlZW4nO1xuICAgIGRyYXcubGluZShjdHgsIHggKyAoYWR2YW5jZVdpZHRoICogc2NhbGUpLCAtMTAwMDAsIHggKyAoYWR2YW5jZVdpZHRoICogc2NhbGUpLCAxMDAwMCk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBHbHlwaDtcbiIsIi8vIFRoZSBHbHlwaFNldCBvYmplY3RcblxuaW1wb3J0IEdseXBoIGZyb20gJy4vZ2x5cGgnO1xuXG4vLyBEZWZpbmUgYSBwcm9wZXJ0eSBvbiB0aGUgZ2x5cGggdGhhdCBkZXBlbmRzIG9uIHRoZSBwYXRoIGJlaW5nIGxvYWRlZC5cbmZ1bmN0aW9uIGRlZmluZURlcGVuZGVudFByb3BlcnR5KGdseXBoLCBleHRlcm5hbE5hbWUsIGludGVybmFsTmFtZSkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShnbHlwaCwgZXh0ZXJuYWxOYW1lLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAvLyBSZXF1ZXN0IHRoZSBwYXRoIHByb3BlcnR5IHRvIG1ha2Ugc3VyZSB0aGUgcGF0aCBpcyBsb2FkZWQuXG4gICAgICAgICAgICBnbHlwaC5wYXRoOyAvLyBqc2hpbnQgaWdub3JlOmxpbmVcbiAgICAgICAgICAgIHJldHVybiBnbHlwaFtpbnRlcm5hbE5hbWVdO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uKG5ld1ZhbHVlKSB7XG4gICAgICAgICAgICBnbHlwaFtpbnRlcm5hbE5hbWVdID0gbmV3VmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xufVxuXG4vKipcbiAqIEEgR2x5cGhTZXQgcmVwcmVzZW50cyBhbGwgZ2x5cGhzIGF2YWlsYWJsZSBpbiB0aGUgZm9udCwgYnV0IG1vZGVsbGVkIHVzaW5nXG4gKiBhIGRlZmVycmVkIGdseXBoIGxvYWRlciwgZm9yIHJldHJpZXZpbmcgZ2x5cGhzIG9ubHkgb25jZSB0aGV5IGFyZSBhYnNvbHV0ZWx5XG4gKiBuZWNlc3NhcnksIHRvIGtlZXAgdGhlIG1lbW9yeSBmb290cHJpbnQgZG93bi5cbiAqIEBleHBvcnRzIG9wZW50eXBlLkdseXBoU2V0XG4gKiBAY2xhc3NcbiAqIEBwYXJhbSB7b3BlbnR5cGUuRm9udH1cbiAqIEBwYXJhbSB7QXJyYXl9XG4gKi9cbmZ1bmN0aW9uIEdseXBoU2V0KGZvbnQsIGdseXBocykge1xuICAgIHRoaXMuZm9udCA9IGZvbnQ7XG4gICAgdGhpcy5nbHlwaHMgPSB7fTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShnbHlwaHMpKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZ2x5cGhzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLmdseXBoc1tpXSA9IGdseXBoc1tpXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMubGVuZ3RoID0gKGdseXBocyAmJiBnbHlwaHMubGVuZ3RoKSB8fCAwO1xufVxuXG4vKipcbiAqIEBwYXJhbSAge251bWJlcn0gaW5kZXhcbiAqIEByZXR1cm4ge29wZW50eXBlLkdseXBofVxuICovXG5HbHlwaFNldC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24oaW5kZXgpIHtcbiAgICBpZiAodHlwZW9mIHRoaXMuZ2x5cGhzW2luZGV4XSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aGlzLmdseXBoc1tpbmRleF0gPSB0aGlzLmdseXBoc1tpbmRleF0oKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5nbHlwaHNbaW5kZXhdO1xufTtcblxuLyoqXG4gKiBAcGFyYW0gIHtudW1iZXJ9IGluZGV4XG4gKiBAcGFyYW0gIHtPYmplY3R9XG4gKi9cbkdseXBoU2V0LnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24oaW5kZXgsIGxvYWRlcikge1xuICAgIHRoaXMuZ2x5cGhzW2luZGV4XSA9IGxvYWRlcjtcbiAgICB0aGlzLmxlbmd0aCsrO1xufTtcblxuLyoqXG4gKiBAYWxpYXMgb3BlbnR5cGUuZ2x5cGhMb2FkZXJcbiAqIEBwYXJhbSAge29wZW50eXBlLkZvbnR9IGZvbnRcbiAqIEBwYXJhbSAge251bWJlcn0gaW5kZXhcbiAqIEByZXR1cm4ge29wZW50eXBlLkdseXBofVxuICovXG5mdW5jdGlvbiBnbHlwaExvYWRlcihmb250LCBpbmRleCkge1xuICAgIHJldHVybiBuZXcgR2x5cGgoe2luZGV4OiBpbmRleCwgZm9udDogZm9udH0pO1xufVxuXG4vKipcbiAqIEdlbmVyYXRlIGEgc3R1YiBnbHlwaCB0aGF0IGNhbiBiZSBmaWxsZWQgd2l0aCBhbGwgbWV0YWRhdGEgKmV4Y2VwdCpcbiAqIHRoZSBcInBvaW50c1wiIGFuZCBcInBhdGhcIiBwcm9wZXJ0aWVzLCB3aGljaCBtdXN0IGJlIGxvYWRlZCBvbmx5IG9uY2VcbiAqIHRoZSBnbHlwaCdzIHBhdGggaXMgYWN0dWFsbHkgcmVxdWVzdGVkIGZvciB0ZXh0IHNoYXBpbmcuXG4gKiBAYWxpYXMgb3BlbnR5cGUudHRmR2x5cGhMb2FkZXJcbiAqIEBwYXJhbSAge29wZW50eXBlLkZvbnR9IGZvbnRcbiAqIEBwYXJhbSAge251bWJlcn0gaW5kZXhcbiAqIEBwYXJhbSAge0Z1bmN0aW9ufSBwYXJzZUdseXBoXG4gKiBAcGFyYW0gIHtPYmplY3R9IGRhdGFcbiAqIEBwYXJhbSAge251bWJlcn0gcG9zaXRpb25cbiAqIEBwYXJhbSAge0Z1bmN0aW9ufSBidWlsZFBhdGhcbiAqIEByZXR1cm4ge29wZW50eXBlLkdseXBofVxuICovXG5mdW5jdGlvbiB0dGZHbHlwaExvYWRlcihmb250LCBpbmRleCwgcGFyc2VHbHlwaCwgZGF0YSwgcG9zaXRpb24sIGJ1aWxkUGF0aCkge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgY29uc3QgZ2x5cGggPSBuZXcgR2x5cGgoe2luZGV4OiBpbmRleCwgZm9udDogZm9udH0pO1xuXG4gICAgICAgIGdseXBoLnBhdGggPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHBhcnNlR2x5cGgoZ2x5cGgsIGRhdGEsIHBvc2l0aW9uKTtcbiAgICAgICAgICAgIGNvbnN0IHBhdGggPSBidWlsZFBhdGgoZm9udC5nbHlwaHMsIGdseXBoKTtcbiAgICAgICAgICAgIHBhdGgudW5pdHNQZXJFbSA9IGZvbnQudW5pdHNQZXJFbTtcbiAgICAgICAgICAgIHJldHVybiBwYXRoO1xuICAgICAgICB9O1xuXG4gICAgICAgIGRlZmluZURlcGVuZGVudFByb3BlcnR5KGdseXBoLCAneE1pbicsICdfeE1pbicpO1xuICAgICAgICBkZWZpbmVEZXBlbmRlbnRQcm9wZXJ0eShnbHlwaCwgJ3hNYXgnLCAnX3hNYXgnKTtcbiAgICAgICAgZGVmaW5lRGVwZW5kZW50UHJvcGVydHkoZ2x5cGgsICd5TWluJywgJ195TWluJyk7XG4gICAgICAgIGRlZmluZURlcGVuZGVudFByb3BlcnR5KGdseXBoLCAneU1heCcsICdfeU1heCcpO1xuXG4gICAgICAgIHJldHVybiBnbHlwaDtcbiAgICB9O1xufVxuLyoqXG4gKiBAYWxpYXMgb3BlbnR5cGUuY2ZmR2x5cGhMb2FkZXJcbiAqIEBwYXJhbSAge29wZW50eXBlLkZvbnR9IGZvbnRcbiAqIEBwYXJhbSAge251bWJlcn0gaW5kZXhcbiAqIEBwYXJhbSAge0Z1bmN0aW9ufSBwYXJzZUNGRkNoYXJzdHJpbmdcbiAqIEBwYXJhbSAge3N0cmluZ30gY2hhcnN0cmluZ1xuICogQHJldHVybiB7b3BlbnR5cGUuR2x5cGh9XG4gKi9cbmZ1bmN0aW9uIGNmZkdseXBoTG9hZGVyKGZvbnQsIGluZGV4LCBwYXJzZUNGRkNoYXJzdHJpbmcsIGNoYXJzdHJpbmcpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIGNvbnN0IGdseXBoID0gbmV3IEdseXBoKHtpbmRleDogaW5kZXgsIGZvbnQ6IGZvbnR9KTtcblxuICAgICAgICBnbHlwaC5wYXRoID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBjb25zdCBwYXRoID0gcGFyc2VDRkZDaGFyc3RyaW5nKGZvbnQsIGdseXBoLCBjaGFyc3RyaW5nKTtcbiAgICAgICAgICAgIHBhdGgudW5pdHNQZXJFbSA9IGZvbnQudW5pdHNQZXJFbTtcbiAgICAgICAgICAgIHJldHVybiBwYXRoO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBnbHlwaDtcbiAgICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCB7IEdseXBoU2V0LCBnbHlwaExvYWRlciwgdHRmR2x5cGhMb2FkZXIsIGNmZkdseXBoTG9hZGVyIH07XG4iLCIvLyBUaGUgYENGRmAgdGFibGUgY29udGFpbnMgdGhlIGdseXBoIG91dGxpbmVzIGluIFBvc3RTY3JpcHQgZm9ybWF0LlxuLy8gaHR0cHM6Ly93d3cubWljcm9zb2Z0LmNvbS90eXBvZ3JhcGh5L09UU1BFQy9jZmYuaHRtXG4vLyBodHRwOi8vZG93bmxvYWQubWljcm9zb2Z0LmNvbS9kb3dubG9hZC84LzAvMS84MDFhMTkxYy0wMjlkLTRhZjMtOTY0Mi01NTVmNmZlNTE0ZWUvY2ZmLnBkZlxuLy8gaHR0cDovL2Rvd25sb2FkLm1pY3Jvc29mdC5jb20vZG93bmxvYWQvOC8wLzEvODAxYTE5MWMtMDI5ZC00YWYzLTk2NDItNTU1ZjZmZTUxNGVlL3R5cGUyLnBkZlxuXG5pbXBvcnQgeyBDZmZFbmNvZGluZywgY2ZmU3RhbmRhcmRFbmNvZGluZywgY2ZmRXhwZXJ0RW5jb2RpbmcsIGNmZlN0YW5kYXJkU3RyaW5ncyB9IGZyb20gJy4uL2VuY29kaW5nJztcbmltcG9ydCBnbHlwaHNldCBmcm9tICcuLi9nbHlwaHNldCc7XG5pbXBvcnQgcGFyc2UgZnJvbSAnLi4vcGFyc2UnO1xuaW1wb3J0IFBhdGggZnJvbSAnLi4vcGF0aCc7XG5pbXBvcnQgdGFibGUgZnJvbSAnLi4vdGFibGUnO1xuXG4vLyBDdXN0b20gZXF1YWxzIGZ1bmN0aW9uIHRoYXQgY2FuIGFsc28gY2hlY2sgbGlzdHMuXG5mdW5jdGlvbiBlcXVhbHMoYSwgYikge1xuICAgIGlmIChhID09PSBiKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShhKSAmJiBBcnJheS5pc0FycmF5KGIpKSB7XG4gICAgICAgIGlmIChhLmxlbmd0aCAhPT0gYi5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgaWYgKCFlcXVhbHMoYVtpXSwgYltpXSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuXG4vLyBTdWJyb3V0aW5lcyBhcmUgZW5jb2RlZCB1c2luZyB0aGUgbmVnYXRpdmUgaGFsZiBvZiB0aGUgbnVtYmVyIHNwYWNlLlxuLy8gU2VlIHR5cGUgMiBjaGFwdGVyIDQuNyBcIlN1YnJvdXRpbmUgb3BlcmF0b3JzXCIuXG5mdW5jdGlvbiBjYWxjQ0ZGU3Vicm91dGluZUJpYXMoc3VicnMpIHtcbiAgICBsZXQgYmlhcztcbiAgICBpZiAoc3VicnMubGVuZ3RoIDwgMTI0MCkge1xuICAgICAgICBiaWFzID0gMTA3O1xuICAgIH0gZWxzZSBpZiAoc3VicnMubGVuZ3RoIDwgMzM5MDApIHtcbiAgICAgICAgYmlhcyA9IDExMzE7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgYmlhcyA9IDMyNzY4O1xuICAgIH1cblxuICAgIHJldHVybiBiaWFzO1xufVxuXG4vLyBQYXJzZSBhIGBDRkZgIElOREVYIGFycmF5LlxuLy8gQW4gaW5kZXggYXJyYXkgY29uc2lzdHMgb2YgYSBsaXN0IG9mIG9mZnNldHMsIHRoZW4gYSBsaXN0IG9mIG9iamVjdHMgYXQgdGhvc2Ugb2Zmc2V0cy5cbmZ1bmN0aW9uIHBhcnNlQ0ZGSW5kZXgoZGF0YSwgc3RhcnQsIGNvbnZlcnNpb25Gbikge1xuICAgIGNvbnN0IG9mZnNldHMgPSBbXTtcbiAgICBjb25zdCBvYmplY3RzID0gW107XG4gICAgY29uc3QgY291bnQgPSBwYXJzZS5nZXRDYXJkMTYoZGF0YSwgc3RhcnQpO1xuICAgIGxldCBvYmplY3RPZmZzZXQ7XG4gICAgbGV0IGVuZE9mZnNldDtcbiAgICBpZiAoY291bnQgIT09IDApIHtcbiAgICAgICAgY29uc3Qgb2Zmc2V0U2l6ZSA9IHBhcnNlLmdldEJ5dGUoZGF0YSwgc3RhcnQgKyAyKTtcbiAgICAgICAgb2JqZWN0T2Zmc2V0ID0gc3RhcnQgKyAoKGNvdW50ICsgMSkgKiBvZmZzZXRTaXplKSArIDI7XG4gICAgICAgIGxldCBwb3MgPSBzdGFydCArIDM7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQgKyAxOyBpICs9IDEpIHtcbiAgICAgICAgICAgIG9mZnNldHMucHVzaChwYXJzZS5nZXRPZmZzZXQoZGF0YSwgcG9zLCBvZmZzZXRTaXplKSk7XG4gICAgICAgICAgICBwb3MgKz0gb2Zmc2V0U2l6ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRoZSB0b3RhbCBzaXplIG9mIHRoZSBpbmRleCBhcnJheSBpcyA0IGhlYWRlciBieXRlcyArIHRoZSB2YWx1ZSBvZiB0aGUgbGFzdCBvZmZzZXQuXG4gICAgICAgIGVuZE9mZnNldCA9IG9iamVjdE9mZnNldCArIG9mZnNldHNbY291bnRdO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGVuZE9mZnNldCA9IHN0YXJ0ICsgMjtcbiAgICB9XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG9mZnNldHMubGVuZ3RoIC0gMTsgaSArPSAxKSB7XG4gICAgICAgIGxldCB2YWx1ZSA9IHBhcnNlLmdldEJ5dGVzKGRhdGEsIG9iamVjdE9mZnNldCArIG9mZnNldHNbaV0sIG9iamVjdE9mZnNldCArIG9mZnNldHNbaSArIDFdKTtcbiAgICAgICAgaWYgKGNvbnZlcnNpb25Gbikge1xuICAgICAgICAgICAgdmFsdWUgPSBjb252ZXJzaW9uRm4odmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgb2JqZWN0cy5wdXNoKHZhbHVlKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge29iamVjdHM6IG9iamVjdHMsIHN0YXJ0T2Zmc2V0OiBzdGFydCwgZW5kT2Zmc2V0OiBlbmRPZmZzZXR9O1xufVxuXG4vLyBQYXJzZSBhIGBDRkZgIERJQ1QgcmVhbCB2YWx1ZS5cbmZ1bmN0aW9uIHBhcnNlRmxvYXRPcGVyYW5kKHBhcnNlcikge1xuICAgIGxldCBzID0gJyc7XG4gICAgY29uc3QgZW9mID0gMTU7XG4gICAgY29uc3QgbG9va3VwID0gWycwJywgJzEnLCAnMicsICczJywgJzQnLCAnNScsICc2JywgJzcnLCAnOCcsICc5JywgJy4nLCAnRScsICdFLScsIG51bGwsICctJ107XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgY29uc3QgYiA9IHBhcnNlci5wYXJzZUJ5dGUoKTtcbiAgICAgICAgY29uc3QgbjEgPSBiID4+IDQ7XG4gICAgICAgIGNvbnN0IG4yID0gYiAmIDE1O1xuXG4gICAgICAgIGlmIChuMSA9PT0gZW9mKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIHMgKz0gbG9va3VwW24xXTtcblxuICAgICAgICBpZiAobjIgPT09IGVvZikge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBzICs9IGxvb2t1cFtuMl07XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhcnNlRmxvYXQocyk7XG59XG5cbi8vIFBhcnNlIGEgYENGRmAgRElDVCBvcGVyYW5kLlxuZnVuY3Rpb24gcGFyc2VPcGVyYW5kKHBhcnNlciwgYjApIHtcbiAgICBsZXQgYjE7XG4gICAgbGV0IGIyO1xuICAgIGxldCBiMztcbiAgICBsZXQgYjQ7XG4gICAgaWYgKGIwID09PSAyOCkge1xuICAgICAgICBiMSA9IHBhcnNlci5wYXJzZUJ5dGUoKTtcbiAgICAgICAgYjIgPSBwYXJzZXIucGFyc2VCeXRlKCk7XG4gICAgICAgIHJldHVybiBiMSA8PCA4IHwgYjI7XG4gICAgfVxuXG4gICAgaWYgKGIwID09PSAyOSkge1xuICAgICAgICBiMSA9IHBhcnNlci5wYXJzZUJ5dGUoKTtcbiAgICAgICAgYjIgPSBwYXJzZXIucGFyc2VCeXRlKCk7XG4gICAgICAgIGIzID0gcGFyc2VyLnBhcnNlQnl0ZSgpO1xuICAgICAgICBiNCA9IHBhcnNlci5wYXJzZUJ5dGUoKTtcbiAgICAgICAgcmV0dXJuIGIxIDw8IDI0IHwgYjIgPDwgMTYgfCBiMyA8PCA4IHwgYjQ7XG4gICAgfVxuXG4gICAgaWYgKGIwID09PSAzMCkge1xuICAgICAgICByZXR1cm4gcGFyc2VGbG9hdE9wZXJhbmQocGFyc2VyKTtcbiAgICB9XG5cbiAgICBpZiAoYjAgPj0gMzIgJiYgYjAgPD0gMjQ2KSB7XG4gICAgICAgIHJldHVybiBiMCAtIDEzOTtcbiAgICB9XG5cbiAgICBpZiAoYjAgPj0gMjQ3ICYmIGIwIDw9IDI1MCkge1xuICAgICAgICBiMSA9IHBhcnNlci5wYXJzZUJ5dGUoKTtcbiAgICAgICAgcmV0dXJuIChiMCAtIDI0NykgKiAyNTYgKyBiMSArIDEwODtcbiAgICB9XG5cbiAgICBpZiAoYjAgPj0gMjUxICYmIGIwIDw9IDI1NCkge1xuICAgICAgICBiMSA9IHBhcnNlci5wYXJzZUJ5dGUoKTtcbiAgICAgICAgcmV0dXJuIC0oYjAgLSAyNTEpICogMjU2IC0gYjEgLSAxMDg7XG4gICAgfVxuXG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGIwICcgKyBiMCk7XG59XG5cbi8vIENvbnZlcnQgdGhlIGVudHJpZXMgcmV0dXJuZWQgYnkgYHBhcnNlRGljdGAgdG8gYSBwcm9wZXIgZGljdGlvbmFyeS5cbi8vIElmIGEgdmFsdWUgaXMgYSBsaXN0IG9mIG9uZSwgaXQgaXMgdW5wYWNrZWQuXG5mdW5jdGlvbiBlbnRyaWVzVG9PYmplY3QoZW50cmllcykge1xuICAgIGNvbnN0IG8gPSB7fTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGVudHJpZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgY29uc3Qga2V5ID0gZW50cmllc1tpXVswXTtcbiAgICAgICAgY29uc3QgdmFsdWVzID0gZW50cmllc1tpXVsxXTtcbiAgICAgICAgbGV0IHZhbHVlO1xuICAgICAgICBpZiAodmFsdWVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZXNbMF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlcztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvLmhhc093blByb3BlcnR5KGtleSkgJiYgIWlzTmFOKG9ba2V5XSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignT2JqZWN0ICcgKyBvICsgJyBhbHJlYWR5IGhhcyBrZXkgJyArIGtleSk7XG4gICAgICAgIH1cblxuICAgICAgICBvW2tleV0gPSB2YWx1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gbztcbn1cblxuLy8gUGFyc2UgYSBgQ0ZGYCBESUNUIG9iamVjdC5cbi8vIEEgZGljdGlvbmFyeSBjb250YWlucyBrZXktdmFsdWUgcGFpcnMgaW4gYSBjb21wYWN0IHRva2VuaXplZCBmb3JtYXQuXG5mdW5jdGlvbiBwYXJzZUNGRkRpY3QoZGF0YSwgc3RhcnQsIHNpemUpIHtcbiAgICBzdGFydCA9IHN0YXJ0ICE9PSB1bmRlZmluZWQgPyBzdGFydCA6IDA7XG4gICAgY29uc3QgcGFyc2VyID0gbmV3IHBhcnNlLlBhcnNlcihkYXRhLCBzdGFydCk7XG4gICAgY29uc3QgZW50cmllcyA9IFtdO1xuICAgIGxldCBvcGVyYW5kcyA9IFtdO1xuICAgIHNpemUgPSBzaXplICE9PSB1bmRlZmluZWQgPyBzaXplIDogZGF0YS5sZW5ndGg7XG5cbiAgICB3aGlsZSAocGFyc2VyLnJlbGF0aXZlT2Zmc2V0IDwgc2l6ZSkge1xuICAgICAgICBsZXQgb3AgPSBwYXJzZXIucGFyc2VCeXRlKCk7XG5cbiAgICAgICAgLy8gVGhlIGZpcnN0IGJ5dGUgZm9yIGVhY2ggZGljdCBpdGVtIGRpc3Rpbmd1aXNoZXMgYmV0d2VlbiBvcGVyYXRvciAoa2V5KSBhbmQgb3BlcmFuZCAodmFsdWUpLlxuICAgICAgICAvLyBWYWx1ZXMgPD0gMjEgYXJlIG9wZXJhdG9ycy5cbiAgICAgICAgaWYgKG9wIDw9IDIxKSB7XG4gICAgICAgICAgICAvLyBUd28tYnl0ZSBvcGVyYXRvcnMgaGF2ZSBhbiBpbml0aWFsIGVzY2FwZSBieXRlIG9mIDEyLlxuICAgICAgICAgICAgaWYgKG9wID09PSAxMikge1xuICAgICAgICAgICAgICAgIG9wID0gMTIwMCArIHBhcnNlci5wYXJzZUJ5dGUoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZW50cmllcy5wdXNoKFtvcCwgb3BlcmFuZHNdKTtcbiAgICAgICAgICAgIG9wZXJhbmRzID0gW107XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBTaW5jZSB0aGUgb3BlcmFuZHMgKHZhbHVlcykgY29tZSBiZWZvcmUgdGhlIG9wZXJhdG9ycyAoa2V5cyksIHdlIHN0b3JlIGFsbCBvcGVyYW5kcyBpbiBhIGxpc3RcbiAgICAgICAgICAgIC8vIHVudGlsIHdlIGVuY291bnRlciBhbiBvcGVyYXRvci5cbiAgICAgICAgICAgIG9wZXJhbmRzLnB1c2gocGFyc2VPcGVyYW5kKHBhcnNlciwgb3ApKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBlbnRyaWVzVG9PYmplY3QoZW50cmllcyk7XG59XG5cbi8vIEdpdmVuIGEgU3RyaW5nIEluZGV4IChTSUQpLCByZXR1cm4gdGhlIHZhbHVlIG9mIHRoZSBzdHJpbmcuXG4vLyBTdHJpbmdzIGJlbG93IGluZGV4IDM5MiBhcmUgc3RhbmRhcmQgQ0ZGIHN0cmluZ3MgYW5kIGFyZSBub3QgZW5jb2RlZCBpbiB0aGUgZm9udC5cbmZ1bmN0aW9uIGdldENGRlN0cmluZyhzdHJpbmdzLCBpbmRleCkge1xuICAgIGlmIChpbmRleCA8PSAzOTApIHtcbiAgICAgICAgaW5kZXggPSBjZmZTdGFuZGFyZFN0cmluZ3NbaW5kZXhdO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGluZGV4ID0gc3RyaW5nc1tpbmRleCAtIDM5MV07XG4gICAgfVxuXG4gICAgcmV0dXJuIGluZGV4O1xufVxuXG4vLyBJbnRlcnByZXQgYSBkaWN0aW9uYXJ5IGFuZCByZXR1cm4gYSBuZXcgZGljdGlvbmFyeSB3aXRoIHJlYWRhYmxlIGtleXMgYW5kIHZhbHVlcyBmb3IgbWlzc2luZyBlbnRyaWVzLlxuLy8gVGhpcyBmdW5jdGlvbiB0YWtlcyBgbWV0YWAgd2hpY2ggaXMgYSBsaXN0IG9mIG9iamVjdHMgY29udGFpbmluZyBgb3BlcmFuZGAsIGBuYW1lYCBhbmQgYGRlZmF1bHRgLlxuZnVuY3Rpb24gaW50ZXJwcmV0RGljdChkaWN0LCBtZXRhLCBzdHJpbmdzKSB7XG4gICAgY29uc3QgbmV3RGljdCA9IHt9O1xuICAgIGxldCB2YWx1ZTtcblxuICAgIC8vIEJlY2F1c2Ugd2UgYWxzbyB3YW50IHRvIGluY2x1ZGUgbWlzc2luZyB2YWx1ZXMsIHdlIHN0YXJ0IG91dCBmcm9tIHRoZSBtZXRhIGxpc3RcbiAgICAvLyBhbmQgbG9va3VwIHZhbHVlcyBpbiB0aGUgZGljdC5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1ldGEubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgY29uc3QgbSA9IG1ldGFbaV07XG5cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkobS50eXBlKSkge1xuICAgICAgICAgICAgY29uc3QgdmFsdWVzID0gW107XG4gICAgICAgICAgICB2YWx1ZXMubGVuZ3RoID0gbS50eXBlLmxlbmd0aDtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbS50eXBlLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBkaWN0W20ub3BdICE9PSB1bmRlZmluZWQgPyBkaWN0W20ub3BdW2pdIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gbS52YWx1ZSAhPT0gdW5kZWZpbmVkICYmIG0udmFsdWVbal0gIT09IHVuZGVmaW5lZCA/IG0udmFsdWVbal0gOiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobS50eXBlW2pdID09PSAnU0lEJykge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGdldENGRlN0cmluZyhzdHJpbmdzLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhbHVlc1tqXSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV3RGljdFttLm5hbWVdID0gdmFsdWVzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFsdWUgPSBkaWN0W20ub3BdO1xuICAgICAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IG0udmFsdWUgIT09IHVuZGVmaW5lZCA/IG0udmFsdWUgOiBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobS50eXBlID09PSAnU0lEJykge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gZ2V0Q0ZGU3RyaW5nKHN0cmluZ3MsIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5ld0RpY3RbbS5uYW1lXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ld0RpY3Q7XG59XG5cbi8vIFBhcnNlIHRoZSBDRkYgaGVhZGVyLlxuZnVuY3Rpb24gcGFyc2VDRkZIZWFkZXIoZGF0YSwgc3RhcnQpIHtcbiAgICBjb25zdCBoZWFkZXIgPSB7fTtcbiAgICBoZWFkZXIuZm9ybWF0TWFqb3IgPSBwYXJzZS5nZXRDYXJkOChkYXRhLCBzdGFydCk7XG4gICAgaGVhZGVyLmZvcm1hdE1pbm9yID0gcGFyc2UuZ2V0Q2FyZDgoZGF0YSwgc3RhcnQgKyAxKTtcbiAgICBoZWFkZXIuc2l6ZSA9IHBhcnNlLmdldENhcmQ4KGRhdGEsIHN0YXJ0ICsgMik7XG4gICAgaGVhZGVyLm9mZnNldFNpemUgPSBwYXJzZS5nZXRDYXJkOChkYXRhLCBzdGFydCArIDMpO1xuICAgIGhlYWRlci5zdGFydE9mZnNldCA9IHN0YXJ0O1xuICAgIGhlYWRlci5lbmRPZmZzZXQgPSBzdGFydCArIDQ7XG4gICAgcmV0dXJuIGhlYWRlcjtcbn1cblxuY29uc3QgVE9QX0RJQ1RfTUVUQSA9IFtcbiAgICB7bmFtZTogJ3ZlcnNpb24nLCBvcDogMCwgdHlwZTogJ1NJRCd9LFxuICAgIHtuYW1lOiAnbm90aWNlJywgb3A6IDEsIHR5cGU6ICdTSUQnfSxcbiAgICB7bmFtZTogJ2NvcHlyaWdodCcsIG9wOiAxMjAwLCB0eXBlOiAnU0lEJ30sXG4gICAge25hbWU6ICdmdWxsTmFtZScsIG9wOiAyLCB0eXBlOiAnU0lEJ30sXG4gICAge25hbWU6ICdmYW1pbHlOYW1lJywgb3A6IDMsIHR5cGU6ICdTSUQnfSxcbiAgICB7bmFtZTogJ3dlaWdodCcsIG9wOiA0LCB0eXBlOiAnU0lEJ30sXG4gICAge25hbWU6ICdpc0ZpeGVkUGl0Y2gnLCBvcDogMTIwMSwgdHlwZTogJ251bWJlcicsIHZhbHVlOiAwfSxcbiAgICB7bmFtZTogJ2l0YWxpY0FuZ2xlJywgb3A6IDEyMDIsIHR5cGU6ICdudW1iZXInLCB2YWx1ZTogMH0sXG4gICAge25hbWU6ICd1bmRlcmxpbmVQb3NpdGlvbicsIG9wOiAxMjAzLCB0eXBlOiAnbnVtYmVyJywgdmFsdWU6IC0xMDB9LFxuICAgIHtuYW1lOiAndW5kZXJsaW5lVGhpY2tuZXNzJywgb3A6IDEyMDQsIHR5cGU6ICdudW1iZXInLCB2YWx1ZTogNTB9LFxuICAgIHtuYW1lOiAncGFpbnRUeXBlJywgb3A6IDEyMDUsIHR5cGU6ICdudW1iZXInLCB2YWx1ZTogMH0sXG4gICAge25hbWU6ICdjaGFyc3RyaW5nVHlwZScsIG9wOiAxMjA2LCB0eXBlOiAnbnVtYmVyJywgdmFsdWU6IDJ9LFxuICAgIHtcbiAgICAgICAgbmFtZTogJ2ZvbnRNYXRyaXgnLFxuICAgICAgICBvcDogMTIwNyxcbiAgICAgICAgdHlwZTogWydyZWFsJywgJ3JlYWwnLCAncmVhbCcsICdyZWFsJywgJ3JlYWwnLCAncmVhbCddLFxuICAgICAgICB2YWx1ZTogWzAuMDAxLCAwLCAwLCAwLjAwMSwgMCwgMF1cbiAgICB9LFxuICAgIHtuYW1lOiAndW5pcXVlSWQnLCBvcDogMTMsIHR5cGU6ICdudW1iZXInfSxcbiAgICB7bmFtZTogJ2ZvbnRCQm94Jywgb3A6IDUsIHR5cGU6IFsnbnVtYmVyJywgJ251bWJlcicsICdudW1iZXInLCAnbnVtYmVyJ10sIHZhbHVlOiBbMCwgMCwgMCwgMF19LFxuICAgIHtuYW1lOiAnc3Ryb2tlV2lkdGgnLCBvcDogMTIwOCwgdHlwZTogJ251bWJlcicsIHZhbHVlOiAwfSxcbiAgICB7bmFtZTogJ3h1aWQnLCBvcDogMTQsIHR5cGU6IFtdLCB2YWx1ZTogbnVsbH0sXG4gICAge25hbWU6ICdjaGFyc2V0Jywgb3A6IDE1LCB0eXBlOiAnb2Zmc2V0JywgdmFsdWU6IDB9LFxuICAgIHtuYW1lOiAnZW5jb2RpbmcnLCBvcDogMTYsIHR5cGU6ICdvZmZzZXQnLCB2YWx1ZTogMH0sXG4gICAge25hbWU6ICdjaGFyU3RyaW5ncycsIG9wOiAxNywgdHlwZTogJ29mZnNldCcsIHZhbHVlOiAwfSxcbiAgICB7bmFtZTogJ3ByaXZhdGUnLCBvcDogMTgsIHR5cGU6IFsnbnVtYmVyJywgJ29mZnNldCddLCB2YWx1ZTogWzAsIDBdfSxcbiAgICB7bmFtZTogJ3JvcycsIG9wOiAxMjMwLCB0eXBlOiBbJ1NJRCcsICdTSUQnLCAnbnVtYmVyJ119LFxuICAgIHtuYW1lOiAnY2lkRm9udFZlcnNpb24nLCBvcDogMTIzMSwgdHlwZTogJ251bWJlcicsIHZhbHVlOiAwfSxcbiAgICB7bmFtZTogJ2NpZEZvbnRSZXZpc2lvbicsIG9wOiAxMjMyLCB0eXBlOiAnbnVtYmVyJywgdmFsdWU6IDB9LFxuICAgIHtuYW1lOiAnY2lkRm9udFR5cGUnLCBvcDogMTIzMywgdHlwZTogJ251bWJlcicsIHZhbHVlOiAwfSxcbiAgICB7bmFtZTogJ2NpZENvdW50Jywgb3A6IDEyMzQsIHR5cGU6ICdudW1iZXInLCB2YWx1ZTogODcyMH0sXG4gICAge25hbWU6ICd1aWRCYXNlJywgb3A6IDEyMzUsIHR5cGU6ICdudW1iZXInfSxcbiAgICB7bmFtZTogJ2ZkQXJyYXknLCBvcDogMTIzNiwgdHlwZTogJ29mZnNldCd9LFxuICAgIHtuYW1lOiAnZmRTZWxlY3QnLCBvcDogMTIzNywgdHlwZTogJ29mZnNldCd9LFxuICAgIHtuYW1lOiAnZm9udE5hbWUnLCBvcDogMTIzOCwgdHlwZTogJ1NJRCd9XG5dO1xuXG5jb25zdCBQUklWQVRFX0RJQ1RfTUVUQSA9IFtcbiAgICB7bmFtZTogJ3N1YnJzJywgb3A6IDE5LCB0eXBlOiAnb2Zmc2V0JywgdmFsdWU6IDB9LFxuICAgIHtuYW1lOiAnZGVmYXVsdFdpZHRoWCcsIG9wOiAyMCwgdHlwZTogJ251bWJlcicsIHZhbHVlOiAwfSxcbiAgICB7bmFtZTogJ25vbWluYWxXaWR0aFgnLCBvcDogMjEsIHR5cGU6ICdudW1iZXInLCB2YWx1ZTogMH1cbl07XG5cbi8vIFBhcnNlIHRoZSBDRkYgdG9wIGRpY3Rpb25hcnkuIEEgQ0ZGIHRhYmxlIGNhbiBjb250YWluIG11bHRpcGxlIGZvbnRzLCBlYWNoIHdpdGggdGhlaXIgb3duIHRvcCBkaWN0aW9uYXJ5LlxuLy8gVGhlIHRvcCBkaWN0aW9uYXJ5IGNvbnRhaW5zIHRoZSBlc3NlbnRpYWwgbWV0YWRhdGEgZm9yIHRoZSBmb250LCB0b2dldGhlciB3aXRoIHRoZSBwcml2YXRlIGRpY3Rpb25hcnkuXG5mdW5jdGlvbiBwYXJzZUNGRlRvcERpY3QoZGF0YSwgc3RyaW5ncykge1xuICAgIGNvbnN0IGRpY3QgPSBwYXJzZUNGRkRpY3QoZGF0YSwgMCwgZGF0YS5ieXRlTGVuZ3RoKTtcbiAgICByZXR1cm4gaW50ZXJwcmV0RGljdChkaWN0LCBUT1BfRElDVF9NRVRBLCBzdHJpbmdzKTtcbn1cblxuLy8gUGFyc2UgdGhlIENGRiBwcml2YXRlIGRpY3Rpb25hcnkuIFdlIGRvbid0IGZ1bGx5IHBhcnNlIG91dCBhbGwgdGhlIHZhbHVlcywgb25seSB0aGUgb25lcyB3ZSBuZWVkLlxuZnVuY3Rpb24gcGFyc2VDRkZQcml2YXRlRGljdChkYXRhLCBzdGFydCwgc2l6ZSwgc3RyaW5ncykge1xuICAgIGNvbnN0IGRpY3QgPSBwYXJzZUNGRkRpY3QoZGF0YSwgc3RhcnQsIHNpemUpO1xuICAgIHJldHVybiBpbnRlcnByZXREaWN0KGRpY3QsIFBSSVZBVEVfRElDVF9NRVRBLCBzdHJpbmdzKTtcbn1cblxuLy8gUmV0dXJucyBhIGxpc3Qgb2YgXCJUb3AgRElDVFwicyBmb3VuZCB1c2luZyBhbiBJTkRFWCBsaXN0LlxuLy8gVXNlZCB0byByZWFkIGJvdGggdGhlIHVzdWFsIGhpZ2gtbGV2ZWwgVG9wIERJQ1RzIGFuZCBhbHNvIHRoZSBGREFycmF5XG4vLyBkaXNjb3ZlcmVkIGluc2lkZSBDSUQta2V5ZWQgZm9udHMuICBXaGVuIGEgVG9wIERJQ1QgaGFzIGEgcmVmZXJlbmNlIHRvXG4vLyBhIFByaXZhdGUgRElDVCB0aGF0IGlzIHJlYWQgYW5kIHNhdmVkIGludG8gdGhlIFRvcCBESUNULlxuLy9cbi8vIEluIGFkZGl0aW9uIHRvIHRoZSBleHBlY3RlZC9vcHRpb25hbCB2YWx1ZXMgYXMgb3V0bGluZWQgaW4gVE9QX0RJQ1RfTUVUQVxuLy8gdGhlIGZvbGxvd2luZyB2YWx1ZXMgbWlnaHQgYmUgc2F2ZWQgaW50byB0aGUgVG9wIERJQ1QuXG4vL1xuLy8gICAgX3N1YnJzIFtdICAgICAgICBhcnJheSBvZiBsb2NhbCBDRkYgc3Vicm91dGluZXMgZnJvbSBQcml2YXRlIERJQ1Rcbi8vICAgIF9zdWJyc0JpYXMgICAgICAgYmlhcyB2YWx1ZSBjb21wdXRlZCBmcm9tIG51bWJlciBvZiBzdWJyb3V0aW5lc1xuLy8gICAgICAgICAgICAgICAgICAgICAgKHNlZSBjYWxjQ0ZGU3Vicm91dGluZUJpYXMoKSBhbmQgcGFyc2VDRkZDaGFyc3RyaW5nKCkpXG4vLyAgICBfZGVmYXVsdFdpZHRoWCAgIGRlZmF1bHQgd2lkdGhzIGZvciBDRkYgY2hhcmFjdGVyc1xuLy8gICAgX25vbWluYWxXaWR0aFggICBiaWFzIGFkZGVkIHRvIHdpZHRoIGVtYmVkZGVkIHdpdGhpbiBnbHlwaCBkZXNjcmlwdGlvblxuLy9cbi8vICAgIF9wcml2YXRlRGljdCAgICAgc2F2ZWQgY29weSBvZiBwYXJzZWQgUHJpdmF0ZSBESUNUIGZyb20gVG9wIERJQ1RcbmZ1bmN0aW9uIGdhdGhlckNGRlRvcERpY3RzKGRhdGEsIHN0YXJ0LCBjZmZJbmRleCwgc3RyaW5ncykge1xuICAgIGNvbnN0IHRvcERpY3RBcnJheSA9IFtdO1xuICAgIGZvciAobGV0IGlUb3BEaWN0ID0gMDsgaVRvcERpY3QgPCBjZmZJbmRleC5sZW5ndGg7IGlUb3BEaWN0ICs9IDEpIHtcbiAgICAgICAgY29uc3QgdG9wRGljdERhdGEgPSBuZXcgRGF0YVZpZXcobmV3IFVpbnQ4QXJyYXkoY2ZmSW5kZXhbaVRvcERpY3RdKS5idWZmZXIpO1xuICAgICAgICBjb25zdCB0b3BEaWN0ID0gcGFyc2VDRkZUb3BEaWN0KHRvcERpY3REYXRhLCBzdHJpbmdzKTtcbiAgICAgICAgdG9wRGljdC5fc3VicnMgPSBbXTtcbiAgICAgICAgdG9wRGljdC5fc3VicnNCaWFzID0gMDtcbiAgICAgICAgY29uc3QgcHJpdmF0ZVNpemUgPSB0b3BEaWN0LnByaXZhdGVbMF07XG4gICAgICAgIGNvbnN0IHByaXZhdGVPZmZzZXQgPSB0b3BEaWN0LnByaXZhdGVbMV07XG4gICAgICAgIGlmIChwcml2YXRlU2l6ZSAhPT0gMCAmJiBwcml2YXRlT2Zmc2V0ICE9PSAwKSB7XG4gICAgICAgICAgICBjb25zdCBwcml2YXRlRGljdCA9IHBhcnNlQ0ZGUHJpdmF0ZURpY3QoZGF0YSwgcHJpdmF0ZU9mZnNldCArIHN0YXJ0LCBwcml2YXRlU2l6ZSwgc3RyaW5ncyk7XG4gICAgICAgICAgICB0b3BEaWN0Ll9kZWZhdWx0V2lkdGhYID0gcHJpdmF0ZURpY3QuZGVmYXVsdFdpZHRoWDtcbiAgICAgICAgICAgIHRvcERpY3QuX25vbWluYWxXaWR0aFggPSBwcml2YXRlRGljdC5ub21pbmFsV2lkdGhYO1xuICAgICAgICAgICAgaWYgKHByaXZhdGVEaWN0LnN1YnJzICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3Vick9mZnNldCA9IHByaXZhdGVPZmZzZXQgKyBwcml2YXRlRGljdC5zdWJycztcbiAgICAgICAgICAgICAgICBjb25zdCBzdWJySW5kZXggPSBwYXJzZUNGRkluZGV4KGRhdGEsIHN1YnJPZmZzZXQgKyBzdGFydCk7XG4gICAgICAgICAgICAgICAgdG9wRGljdC5fc3VicnMgPSBzdWJySW5kZXgub2JqZWN0cztcbiAgICAgICAgICAgICAgICB0b3BEaWN0Ll9zdWJyc0JpYXMgPSBjYWxjQ0ZGU3Vicm91dGluZUJpYXModG9wRGljdC5fc3VicnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdG9wRGljdC5fcHJpdmF0ZURpY3QgPSBwcml2YXRlRGljdDtcbiAgICAgICAgfVxuICAgICAgICB0b3BEaWN0QXJyYXkucHVzaCh0b3BEaWN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvcERpY3RBcnJheTtcbn1cblxuLy8gUGFyc2UgdGhlIENGRiBjaGFyc2V0IHRhYmxlLCB3aGljaCBjb250YWlucyBpbnRlcm5hbCBuYW1lcyBmb3IgYWxsIHRoZSBnbHlwaHMuXG4vLyBUaGlzIGZ1bmN0aW9uIHdpbGwgcmV0dXJuIGEgbGlzdCBvZiBnbHlwaCBuYW1lcy5cbi8vIFNlZSBBZG9iZSBUTiAjNTE3NiBjaGFwdGVyIDEzLCBcIkNoYXJzZXRzXCIuXG5mdW5jdGlvbiBwYXJzZUNGRkNoYXJzZXQoZGF0YSwgc3RhcnQsIG5HbHlwaHMsIHN0cmluZ3MpIHtcbiAgICBsZXQgc2lkO1xuICAgIGxldCBjb3VudDtcbiAgICBjb25zdCBwYXJzZXIgPSBuZXcgcGFyc2UuUGFyc2VyKGRhdGEsIHN0YXJ0KTtcblxuICAgIC8vIFRoZSAubm90ZGVmIGdseXBoIGlzIG5vdCBpbmNsdWRlZCwgc28gc3VidHJhY3QgMS5cbiAgICBuR2x5cGhzIC09IDE7XG4gICAgY29uc3QgY2hhcnNldCA9IFsnLm5vdGRlZiddO1xuXG4gICAgY29uc3QgZm9ybWF0ID0gcGFyc2VyLnBhcnNlQ2FyZDgoKTtcbiAgICBpZiAoZm9ybWF0ID09PSAwKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbkdseXBoczsgaSArPSAxKSB7XG4gICAgICAgICAgICBzaWQgPSBwYXJzZXIucGFyc2VTSUQoKTtcbiAgICAgICAgICAgIGNoYXJzZXQucHVzaChnZXRDRkZTdHJpbmcoc3RyaW5ncywgc2lkKSk7XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGZvcm1hdCA9PT0gMSkge1xuICAgICAgICB3aGlsZSAoY2hhcnNldC5sZW5ndGggPD0gbkdseXBocykge1xuICAgICAgICAgICAgc2lkID0gcGFyc2VyLnBhcnNlU0lEKCk7XG4gICAgICAgICAgICBjb3VudCA9IHBhcnNlci5wYXJzZUNhcmQ4KCk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8PSBjb3VudDsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgY2hhcnNldC5wdXNoKGdldENGRlN0cmluZyhzdHJpbmdzLCBzaWQpKTtcbiAgICAgICAgICAgICAgICBzaWQgKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZm9ybWF0ID09PSAyKSB7XG4gICAgICAgIHdoaWxlIChjaGFyc2V0Lmxlbmd0aCA8PSBuR2x5cGhzKSB7XG4gICAgICAgICAgICBzaWQgPSBwYXJzZXIucGFyc2VTSUQoKTtcbiAgICAgICAgICAgIGNvdW50ID0gcGFyc2VyLnBhcnNlQ2FyZDE2KCk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8PSBjb3VudDsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgY2hhcnNldC5wdXNoKGdldENGRlN0cmluZyhzdHJpbmdzLCBzaWQpKTtcbiAgICAgICAgICAgICAgICBzaWQgKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBjaGFyc2V0IGZvcm1hdCAnICsgZm9ybWF0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gY2hhcnNldDtcbn1cblxuLy8gUGFyc2UgdGhlIENGRiBlbmNvZGluZyBkYXRhLiBPbmx5IG9uZSBlbmNvZGluZyBjYW4gYmUgc3BlY2lmaWVkIHBlciBmb250LlxuLy8gU2VlIEFkb2JlIFROICM1MTc2IGNoYXB0ZXIgMTIsIFwiRW5jb2RpbmdzXCIuXG5mdW5jdGlvbiBwYXJzZUNGRkVuY29kaW5nKGRhdGEsIHN0YXJ0LCBjaGFyc2V0KSB7XG4gICAgbGV0IGNvZGU7XG4gICAgY29uc3QgZW5jID0ge307XG4gICAgY29uc3QgcGFyc2VyID0gbmV3IHBhcnNlLlBhcnNlcihkYXRhLCBzdGFydCk7XG4gICAgY29uc3QgZm9ybWF0ID0gcGFyc2VyLnBhcnNlQ2FyZDgoKTtcbiAgICBpZiAoZm9ybWF0ID09PSAwKSB7XG4gICAgICAgIGNvbnN0IG5Db2RlcyA9IHBhcnNlci5wYXJzZUNhcmQ4KCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbkNvZGVzOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGNvZGUgPSBwYXJzZXIucGFyc2VDYXJkOCgpO1xuICAgICAgICAgICAgZW5jW2NvZGVdID0gaTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZm9ybWF0ID09PSAxKSB7XG4gICAgICAgIGNvbnN0IG5SYW5nZXMgPSBwYXJzZXIucGFyc2VDYXJkOCgpO1xuICAgICAgICBjb2RlID0gMTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuUmFuZ2VzOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGNvbnN0IGZpcnN0ID0gcGFyc2VyLnBhcnNlQ2FyZDgoKTtcbiAgICAgICAgICAgIGNvbnN0IG5MZWZ0ID0gcGFyc2VyLnBhcnNlQ2FyZDgoKTtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSBmaXJzdDsgaiA8PSBmaXJzdCArIG5MZWZ0OyBqICs9IDEpIHtcbiAgICAgICAgICAgICAgICBlbmNbal0gPSBjb2RlO1xuICAgICAgICAgICAgICAgIGNvZGUgKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBlbmNvZGluZyBmb3JtYXQgJyArIGZvcm1hdCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBDZmZFbmNvZGluZyhlbmMsIGNoYXJzZXQpO1xufVxuXG4vLyBUYWtlIGluIGNoYXJzdHJpbmcgY29kZSBhbmQgcmV0dXJuIGEgR2x5cGggb2JqZWN0LlxuLy8gVGhlIGVuY29kaW5nIGlzIGRlc2NyaWJlZCBpbiB0aGUgVHlwZSAyIENoYXJzdHJpbmcgRm9ybWF0XG4vLyBodHRwczovL3d3dy5taWNyb3NvZnQuY29tL3R5cG9ncmFwaHkvT1RTUEVDL2NoYXJzdHIyLmh0bVxuZnVuY3Rpb24gcGFyc2VDRkZDaGFyc3RyaW5nKGZvbnQsIGdseXBoLCBjb2RlKSB7XG4gICAgbGV0IGMxeDtcbiAgICBsZXQgYzF5O1xuICAgIGxldCBjMng7XG4gICAgbGV0IGMyeTtcbiAgICBjb25zdCBwID0gbmV3IFBhdGgoKTtcbiAgICBjb25zdCBzdGFjayA9IFtdO1xuICAgIGxldCBuU3RlbXMgPSAwO1xuICAgIGxldCBoYXZlV2lkdGggPSBmYWxzZTtcbiAgICBsZXQgb3BlbiA9IGZhbHNlO1xuICAgIGxldCB4ID0gMDtcbiAgICBsZXQgeSA9IDA7XG4gICAgbGV0IHN1YnJzO1xuICAgIGxldCBzdWJyc0JpYXM7XG4gICAgbGV0IGRlZmF1bHRXaWR0aFg7XG4gICAgbGV0IG5vbWluYWxXaWR0aFg7XG4gICAgaWYgKGZvbnQuaXNDSURGb250KSB7XG4gICAgICAgIGNvbnN0IGZkSW5kZXggPSBmb250LnRhYmxlcy5jZmYudG9wRGljdC5fZmRTZWxlY3RbZ2x5cGguaW5kZXhdO1xuICAgICAgICBjb25zdCBmZERpY3QgPSBmb250LnRhYmxlcy5jZmYudG9wRGljdC5fZmRBcnJheVtmZEluZGV4XTtcbiAgICAgICAgc3VicnMgPSBmZERpY3QuX3N1YnJzO1xuICAgICAgICBzdWJyc0JpYXMgPSBmZERpY3QuX3N1YnJzQmlhcztcbiAgICAgICAgZGVmYXVsdFdpZHRoWCA9IGZkRGljdC5fZGVmYXVsdFdpZHRoWDtcbiAgICAgICAgbm9taW5hbFdpZHRoWCA9IGZkRGljdC5fbm9taW5hbFdpZHRoWDtcbiAgICB9IGVsc2Uge1xuICAgICAgICBzdWJycyA9IGZvbnQudGFibGVzLmNmZi50b3BEaWN0Ll9zdWJycztcbiAgICAgICAgc3VicnNCaWFzID0gZm9udC50YWJsZXMuY2ZmLnRvcERpY3QuX3N1YnJzQmlhcztcbiAgICAgICAgZGVmYXVsdFdpZHRoWCA9IGZvbnQudGFibGVzLmNmZi50b3BEaWN0Ll9kZWZhdWx0V2lkdGhYO1xuICAgICAgICBub21pbmFsV2lkdGhYID0gZm9udC50YWJsZXMuY2ZmLnRvcERpY3QuX25vbWluYWxXaWR0aFg7XG4gICAgfVxuICAgIGxldCB3aWR0aCA9IGRlZmF1bHRXaWR0aFg7XG5cbiAgICBmdW5jdGlvbiBuZXdDb250b3VyKHgsIHkpIHtcbiAgICAgICAgaWYgKG9wZW4pIHtcbiAgICAgICAgICAgIHAuY2xvc2VQYXRoKCk7XG4gICAgICAgIH1cblxuICAgICAgICBwLm1vdmVUbyh4LCB5KTtcbiAgICAgICAgb3BlbiA9IHRydWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VTdGVtcygpIHtcbiAgICAgICAgbGV0IGhhc1dpZHRoQXJnO1xuXG4gICAgICAgIC8vIFRoZSBudW1iZXIgb2Ygc3RlbSBvcGVyYXRvcnMgb24gdGhlIHN0YWNrIGlzIGFsd2F5cyBldmVuLlxuICAgICAgICAvLyBJZiB0aGUgdmFsdWUgaXMgdW5ldmVuLCB0aGF0IG1lYW5zIGEgd2lkdGggaXMgc3BlY2lmaWVkLlxuICAgICAgICBoYXNXaWR0aEFyZyA9IHN0YWNrLmxlbmd0aCAlIDIgIT09IDA7XG4gICAgICAgIGlmIChoYXNXaWR0aEFyZyAmJiAhaGF2ZVdpZHRoKSB7XG4gICAgICAgICAgICB3aWR0aCA9IHN0YWNrLnNoaWZ0KCkgKyBub21pbmFsV2lkdGhYO1xuICAgICAgICB9XG5cbiAgICAgICAgblN0ZW1zICs9IHN0YWNrLmxlbmd0aCA+PiAxO1xuICAgICAgICBzdGFjay5sZW5ndGggPSAwO1xuICAgICAgICBoYXZlV2lkdGggPSB0cnVlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlKGNvZGUpIHtcbiAgICAgICAgbGV0IGIxO1xuICAgICAgICBsZXQgYjI7XG4gICAgICAgIGxldCBiMztcbiAgICAgICAgbGV0IGI0O1xuICAgICAgICBsZXQgY29kZUluZGV4O1xuICAgICAgICBsZXQgc3VickNvZGU7XG4gICAgICAgIGxldCBqcHg7XG4gICAgICAgIGxldCBqcHk7XG4gICAgICAgIGxldCBjM3g7XG4gICAgICAgIGxldCBjM3k7XG4gICAgICAgIGxldCBjNHg7XG4gICAgICAgIGxldCBjNHk7XG5cbiAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICB3aGlsZSAoaSA8IGNvZGUubGVuZ3RoKSB7XG4gICAgICAgICAgICBsZXQgdiA9IGNvZGVbaV07XG4gICAgICAgICAgICBpICs9IDE7XG4gICAgICAgICAgICBzd2l0Y2ggKHYpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6IC8vIGhzdGVtXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlU3RlbXMoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAzOiAvLyB2c3RlbVxuICAgICAgICAgICAgICAgICAgICBwYXJzZVN0ZW1zKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDogLy8gdm1vdmV0b1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhY2subGVuZ3RoID4gMSAmJiAhaGF2ZVdpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aCA9IHN0YWNrLnNoaWZ0KCkgKyBub21pbmFsV2lkdGhYO1xuICAgICAgICAgICAgICAgICAgICAgICAgaGF2ZVdpZHRoID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHkgKz0gc3RhY2sucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIG5ld0NvbnRvdXIoeCwgeSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNTogLy8gcmxpbmV0b1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoc3RhY2subGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgeCArPSBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgeSArPSBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcC5saW5lVG8oeCwgeSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDY6IC8vIGhsaW5ldG9cbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHggKz0gc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHAubGluZVRvKHgsIHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0YWNrLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICB5ICs9IHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwLmxpbmVUbyh4LCB5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNzogLy8gdmxpbmV0b1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoc3RhY2subGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgeSArPSBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcC5saW5lVG8oeCwgeSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RhY2subGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHggKz0gc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHAubGluZVRvKHgsIHkpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA4OiAvLyBycmN1cnZldG9cbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGMxeCA9IHggKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYzF5ID0geSArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjMnggPSBjMXggKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYzJ5ID0gYzF5ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHggPSBjMnggKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgeSA9IGMyeSArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwLmN1cnZlVG8oYzF4LCBjMXksIGMyeCwgYzJ5LCB4LCB5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMTA6IC8vIGNhbGxzdWJyXG4gICAgICAgICAgICAgICAgICAgIGNvZGVJbmRleCA9IHN0YWNrLnBvcCgpICsgc3VicnNCaWFzO1xuICAgICAgICAgICAgICAgICAgICBzdWJyQ29kZSA9IHN1YnJzW2NvZGVJbmRleF07XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdWJyQ29kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2Uoc3VickNvZGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAxMTogLy8gcmV0dXJuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBjYXNlIDEyOiAvLyBmbGV4IG9wZXJhdG9yc1xuICAgICAgICAgICAgICAgICAgICB2ID0gY29kZVtpXTtcbiAgICAgICAgICAgICAgICAgICAgaSArPSAxO1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMzU6IC8vIGZsZXhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB8LSBkeDEgZHkxIGR4MiBkeTIgZHgzIGR5MyBkeDQgZHk0IGR4NSBkeTUgZHg2IGR5NiBmZCBmbGV4ICgxMiAzNSkgfC1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjMXggPSB4ICAgKyBzdGFjay5zaGlmdCgpOyAgICAvLyBkeDFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjMXkgPSB5ICAgKyBzdGFjay5zaGlmdCgpOyAgICAvLyBkeTFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjMnggPSBjMXggKyBzdGFjay5zaGlmdCgpOyAgICAvLyBkeDJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjMnkgPSBjMXkgKyBzdGFjay5zaGlmdCgpOyAgICAvLyBkeTJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBqcHggPSBjMnggKyBzdGFjay5zaGlmdCgpOyAgICAvLyBkeDNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBqcHkgPSBjMnkgKyBzdGFjay5zaGlmdCgpOyAgICAvLyBkeTNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjM3ggPSBqcHggKyBzdGFjay5zaGlmdCgpOyAgICAvLyBkeDRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjM3kgPSBqcHkgKyBzdGFjay5zaGlmdCgpOyAgICAvLyBkeTRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjNHggPSBjM3ggKyBzdGFjay5zaGlmdCgpOyAgICAvLyBkeDVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjNHkgPSBjM3kgKyBzdGFjay5zaGlmdCgpOyAgICAvLyBkeTVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4ID0gYzR4ICAgKyBzdGFjay5zaGlmdCgpOyAgICAvLyBkeDZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5ID0gYzR5ICAgKyBzdGFjay5zaGlmdCgpOyAgICAvLyBkeTZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFjay5zaGlmdCgpOyAgICAgICAgICAgICAgICAvLyBmbGV4IGRlcHRoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcC5jdXJ2ZVRvKGMxeCwgYzF5LCBjMngsIGMyeSwganB4LCBqcHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAuY3VydmVUbyhjM3gsIGMzeSwgYzR4LCBjNHksIHgsIHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAzNDogLy8gaGZsZXhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB8LSBkeDEgZHgyIGR5MiBkeDMgZHg0IGR4NSBkeDYgaGZsZXggKDEyIDM0KSB8LVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMxeCA9IHggICArIHN0YWNrLnNoaWZ0KCk7ICAgIC8vIGR4MVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMxeSA9IHk7ICAgICAgICAgICAgICAgICAgICAgIC8vIGR5MVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMyeCA9IGMxeCArIHN0YWNrLnNoaWZ0KCk7ICAgIC8vIGR4MlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMyeSA9IGMxeSArIHN0YWNrLnNoaWZ0KCk7ICAgIC8vIGR5MlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpweCA9IGMyeCArIHN0YWNrLnNoaWZ0KCk7ICAgIC8vIGR4M1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpweSA9IGMyeTsgICAgICAgICAgICAgICAgICAgIC8vIGR5M1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMzeCA9IGpweCArIHN0YWNrLnNoaWZ0KCk7ICAgIC8vIGR4NFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMzeSA9IGMyeTsgICAgICAgICAgICAgICAgICAgIC8vIGR5NFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGM0eCA9IGMzeCArIHN0YWNrLnNoaWZ0KCk7ICAgIC8vIGR4NVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGM0eSA9IHk7ICAgICAgICAgICAgICAgICAgICAgIC8vIGR5NVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHggPSBjNHggKyBzdGFjay5zaGlmdCgpOyAgICAgIC8vIGR4NlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAuY3VydmVUbyhjMXgsIGMxeSwgYzJ4LCBjMnksIGpweCwganB5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwLmN1cnZlVG8oYzN4LCBjM3ksIGM0eCwgYzR5LCB4LCB5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMzY6IC8vIGhmbGV4MVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHwtIGR4MSBkeTEgZHgyIGR5MiBkeDMgZHg0IGR4NSBkeTUgZHg2IGhmbGV4MSAoMTIgMzYpIHwtXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYzF4ID0geCAgICsgc3RhY2suc2hpZnQoKTsgICAgLy8gZHgxXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYzF5ID0geSAgICsgc3RhY2suc2hpZnQoKTsgICAgLy8gZHkxXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYzJ4ID0gYzF4ICsgc3RhY2suc2hpZnQoKTsgICAgLy8gZHgyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYzJ5ID0gYzF5ICsgc3RhY2suc2hpZnQoKTsgICAgLy8gZHkyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAganB4ID0gYzJ4ICsgc3RhY2suc2hpZnQoKTsgICAgLy8gZHgzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAganB5ID0gYzJ5OyAgICAgICAgICAgICAgICAgICAgLy8gZHkzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYzN4ID0ganB4ICsgc3RhY2suc2hpZnQoKTsgICAgLy8gZHg0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYzN5ID0gYzJ5OyAgICAgICAgICAgICAgICAgICAgLy8gZHk0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYzR4ID0gYzN4ICsgc3RhY2suc2hpZnQoKTsgICAgLy8gZHg1XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYzR5ID0gYzN5ICsgc3RhY2suc2hpZnQoKTsgICAgLy8gZHk1XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeCA9IGM0eCArIHN0YWNrLnNoaWZ0KCk7ICAgICAgLy8gZHg2XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcC5jdXJ2ZVRvKGMxeCwgYzF5LCBjMngsIGMyeSwganB4LCBqcHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAuY3VydmVUbyhjM3gsIGMzeSwgYzR4LCBjNHksIHgsIHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAzNzogLy8gZmxleDFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB8LSBkeDEgZHkxIGR4MiBkeTIgZHgzIGR5MyBkeDQgZHk0IGR4NSBkeTUgZDYgZmxleDEgKDEyIDM3KSB8LVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMxeCA9IHggICArIHN0YWNrLnNoaWZ0KCk7ICAgIC8vIGR4MVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMxeSA9IHkgICArIHN0YWNrLnNoaWZ0KCk7ICAgIC8vIGR5MVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMyeCA9IGMxeCArIHN0YWNrLnNoaWZ0KCk7ICAgIC8vIGR4MlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMyeSA9IGMxeSArIHN0YWNrLnNoaWZ0KCk7ICAgIC8vIGR5MlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpweCA9IGMyeCArIHN0YWNrLnNoaWZ0KCk7ICAgIC8vIGR4M1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpweSA9IGMyeSArIHN0YWNrLnNoaWZ0KCk7ICAgIC8vIGR5M1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMzeCA9IGpweCArIHN0YWNrLnNoaWZ0KCk7ICAgIC8vIGR4NFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMzeSA9IGpweSArIHN0YWNrLnNoaWZ0KCk7ICAgIC8vIGR5NFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGM0eCA9IGMzeCArIHN0YWNrLnNoaWZ0KCk7ICAgIC8vIGR4NVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGM0eSA9IGMzeSArIHN0YWNrLnNoaWZ0KCk7ICAgIC8vIGR5NVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChNYXRoLmFicyhjNHggLSB4KSA+IE1hdGguYWJzKGM0eSAtIHkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHggPSBjNHggKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHkgPSBjNHkgKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAuY3VydmVUbyhjMXgsIGMxeSwgYzJ4LCBjMnksIGpweCwganB5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwLmN1cnZlVG8oYzN4LCBjM3ksIGM0eCwgYzR5LCB4LCB5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ0dseXBoICcgKyBnbHlwaC5pbmRleCArICc6IHVua25vd24gb3BlcmF0b3IgJyArIDEyMDAgKyB2KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFjay5sZW5ndGggPSAwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMTQ6IC8vIGVuZGNoYXJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YWNrLmxlbmd0aCA+IDAgJiYgIWhhdmVXaWR0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGggPSBzdGFjay5zaGlmdCgpICsgbm9taW5hbFdpZHRoWDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhdmVXaWR0aCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAob3Blbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wZW4gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMTg6IC8vIGhzdGVtaG1cbiAgICAgICAgICAgICAgICAgICAgcGFyc2VTdGVtcygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDE5OiAvLyBoaW50bWFza1xuICAgICAgICAgICAgICAgIGNhc2UgMjA6IC8vIGNudHJtYXNrXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlU3RlbXMoKTtcbiAgICAgICAgICAgICAgICAgICAgaSArPSAoblN0ZW1zICsgNykgPj4gMztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyMTogLy8gcm1vdmV0b1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhY2subGVuZ3RoID4gMiAmJiAhaGF2ZVdpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aCA9IHN0YWNrLnNoaWZ0KCkgKyBub21pbmFsV2lkdGhYO1xuICAgICAgICAgICAgICAgICAgICAgICAgaGF2ZVdpZHRoID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHkgKz0gc3RhY2sucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIHggKz0gc3RhY2sucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIG5ld0NvbnRvdXIoeCwgeSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjI6IC8vIGhtb3ZldG9cbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YWNrLmxlbmd0aCA+IDEgJiYgIWhhdmVXaWR0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGggPSBzdGFjay5zaGlmdCgpICsgbm9taW5hbFdpZHRoWDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhdmVXaWR0aCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB4ICs9IHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBuZXdDb250b3VyKHgsIHkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDIzOiAvLyB2c3RlbWhtXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlU3RlbXMoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyNDogLy8gcmN1cnZlbGluZVxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoc3RhY2subGVuZ3RoID4gMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgYzF4ID0geCArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjMXkgPSB5ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGMyeCA9IGMxeCArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjMnkgPSBjMXkgKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgeCA9IGMyeCArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB5ID0gYzJ5ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHAuY3VydmVUbyhjMXgsIGMxeSwgYzJ4LCBjMnksIHgsIHkpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgeCArPSBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICB5ICs9IHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIHAubGluZVRvKHgsIHkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI1OiAvLyBybGluZWN1cnZlXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChzdGFjay5sZW5ndGggPiA2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4ICs9IHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB5ICs9IHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwLmxpbmVUbyh4LCB5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGMxeCA9IHggKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICBjMXkgPSB5ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgYzJ4ID0gYzF4ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgYzJ5ID0gYzF5ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgeCA9IGMyeCArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIHkgPSBjMnkgKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICBwLmN1cnZlVG8oYzF4LCBjMXksIGMyeCwgYzJ5LCB4LCB5KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyNjogLy8gdnZjdXJ2ZXRvXG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGFjay5sZW5ndGggJSAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4ICs9IHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoc3RhY2subGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYzF4ID0geDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGMxeSA9IHkgKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYzJ4ID0gYzF4ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGMyeSA9IGMxeSArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB4ID0gYzJ4O1xuICAgICAgICAgICAgICAgICAgICAgICAgeSA9IGMyeSArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwLmN1cnZlVG8oYzF4LCBjMXksIGMyeCwgYzJ5LCB4LCB5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjc6IC8vIGhoY3VydmV0b1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhY2subGVuZ3RoICUgMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgeSArPSBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGMxeCA9IHggKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYzF5ID0geTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGMyeCA9IGMxeCArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjMnkgPSBjMXkgKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgeCA9IGMyeCArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB5ID0gYzJ5O1xuICAgICAgICAgICAgICAgICAgICAgICAgcC5jdXJ2ZVRvKGMxeCwgYzF5LCBjMngsIGMyeSwgeCwgeSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI4OiAvLyBzaG9ydGludFxuICAgICAgICAgICAgICAgICAgICBiMSA9IGNvZGVbaV07XG4gICAgICAgICAgICAgICAgICAgIGIyID0gY29kZVtpICsgMV07XG4gICAgICAgICAgICAgICAgICAgIHN0YWNrLnB1c2goKChiMSA8PCAyNCkgfCAoYjIgPDwgMTYpKSA+PiAxNik7XG4gICAgICAgICAgICAgICAgICAgIGkgKz0gMjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOTogLy8gY2FsbGdzdWJyXG4gICAgICAgICAgICAgICAgICAgIGNvZGVJbmRleCA9IHN0YWNrLnBvcCgpICsgZm9udC5nc3VicnNCaWFzO1xuICAgICAgICAgICAgICAgICAgICBzdWJyQ29kZSA9IGZvbnQuZ3N1YnJzW2NvZGVJbmRleF07XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdWJyQ29kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2Uoc3VickNvZGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAzMDogLy8gdmhjdXJ2ZXRvXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChzdGFjay5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjMXggPSB4O1xuICAgICAgICAgICAgICAgICAgICAgICAgYzF5ID0geSArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjMnggPSBjMXggKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYzJ5ID0gYzF5ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHggPSBjMnggKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgeSA9IGMyeSArIChzdGFjay5sZW5ndGggPT09IDEgPyBzdGFjay5zaGlmdCgpIDogMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwLmN1cnZlVG8oYzF4LCBjMXksIGMyeCwgYzJ5LCB4LCB5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdGFjay5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgYzF4ID0geCArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjMXkgPSB5O1xuICAgICAgICAgICAgICAgICAgICAgICAgYzJ4ID0gYzF4ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGMyeSA9IGMxeSArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB5ID0gYzJ5ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHggPSBjMnggKyAoc3RhY2subGVuZ3RoID09PSAxID8gc3RhY2suc2hpZnQoKSA6IDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgcC5jdXJ2ZVRvKGMxeCwgYzF5LCBjMngsIGMyeSwgeCwgeSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDMxOiAvLyBodmN1cnZldG9cbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGMxeCA9IHggKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYzF5ID0geTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGMyeCA9IGMxeCArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjMnkgPSBjMXkgKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgeSA9IGMyeSArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB4ID0gYzJ4ICsgKHN0YWNrLmxlbmd0aCA9PT0gMSA/IHN0YWNrLnNoaWZ0KCkgOiAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHAuY3VydmVUbyhjMXgsIGMxeSwgYzJ4LCBjMnksIHgsIHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0YWNrLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBjMXggPSB4O1xuICAgICAgICAgICAgICAgICAgICAgICAgYzF5ID0geSArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjMnggPSBjMXggKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYzJ5ID0gYzF5ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHggPSBjMnggKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgeSA9IGMyeSArIChzdGFjay5sZW5ndGggPT09IDEgPyBzdGFjay5zaGlmdCgpIDogMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwLmN1cnZlVG8oYzF4LCBjMXksIGMyeCwgYzJ5LCB4LCB5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGlmICh2IDwgMzIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdHbHlwaCAnICsgZ2x5cGguaW5kZXggKyAnOiB1bmtub3duIG9wZXJhdG9yICcgKyB2KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh2IDwgMjQ3KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFjay5wdXNoKHYgLSAxMzkpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHYgPCAyNTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGIxID0gY29kZVtpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGkgKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YWNrLnB1c2goKHYgLSAyNDcpICogMjU2ICsgYjEgKyAxMDgpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHYgPCAyNTUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGIxID0gY29kZVtpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGkgKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YWNrLnB1c2goLSh2IC0gMjUxKSAqIDI1NiAtIGIxIC0gMTA4KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGIxID0gY29kZVtpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGIyID0gY29kZVtpICsgMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBiMyA9IGNvZGVbaSArIDJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgYjQgPSBjb2RlW2kgKyAzXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGkgKz0gNDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YWNrLnB1c2goKChiMSA8PCAyNCkgfCAoYjIgPDwgMTYpIHwgKGIzIDw8IDgpIHwgYjQpIC8gNjU1MzYpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwYXJzZShjb2RlKTtcblxuICAgIGdseXBoLmFkdmFuY2VXaWR0aCA9IHdpZHRoO1xuICAgIHJldHVybiBwO1xufVxuXG5mdW5jdGlvbiBwYXJzZUNGRkZEU2VsZWN0KGRhdGEsIHN0YXJ0LCBuR2x5cGhzLCBmZEFycmF5Q291bnQpIHtcbiAgICBjb25zdCBmZFNlbGVjdCA9IFtdO1xuICAgIGxldCBmZEluZGV4O1xuICAgIGNvbnN0IHBhcnNlciA9IG5ldyBwYXJzZS5QYXJzZXIoZGF0YSwgc3RhcnQpO1xuICAgIGNvbnN0IGZvcm1hdCA9IHBhcnNlci5wYXJzZUNhcmQ4KCk7XG4gICAgaWYgKGZvcm1hdCA9PT0gMCkge1xuICAgICAgICAvLyBTaW1wbGUgbGlzdCBvZiBuR2x5cGhzIGVsZW1lbnRzXG4gICAgICAgIGZvciAobGV0IGlHaWQgPSAwOyBpR2lkIDwgbkdseXBoczsgaUdpZCsrKSB7XG4gICAgICAgICAgICBmZEluZGV4ID0gcGFyc2VyLnBhcnNlQ2FyZDgoKTtcbiAgICAgICAgICAgIGlmIChmZEluZGV4ID49IGZkQXJyYXlDb3VudCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ0ZGIHRhYmxlIENJRCBGb250IEZEU2VsZWN0IGhhcyBiYWQgRkQgaW5kZXggdmFsdWUgJyArIGZkSW5kZXggKyAnIChGRCBjb3VudCAnICsgZmRBcnJheUNvdW50ICsgJyknKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZkU2VsZWN0LnB1c2goZmRJbmRleCk7XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGZvcm1hdCA9PT0gMykge1xuICAgICAgICAvLyBSYW5nZXNcbiAgICAgICAgY29uc3QgblJhbmdlcyA9IHBhcnNlci5wYXJzZUNhcmQxNigpO1xuICAgICAgICBsZXQgZmlyc3QgPSBwYXJzZXIucGFyc2VDYXJkMTYoKTtcbiAgICAgICAgaWYgKGZpcnN0ICE9PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NGRiBUYWJsZSBDSUQgRm9udCBGRFNlbGVjdCBmb3JtYXQgMyByYW5nZSBoYXMgYmFkIGluaXRpYWwgR0lEICcgKyBmaXJzdCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG5leHQ7XG4gICAgICAgIGZvciAobGV0IGlSYW5nZSA9IDA7IGlSYW5nZSA8IG5SYW5nZXM7IGlSYW5nZSsrKSB7XG4gICAgICAgICAgICBmZEluZGV4ID0gcGFyc2VyLnBhcnNlQ2FyZDgoKTtcbiAgICAgICAgICAgIG5leHQgPSBwYXJzZXIucGFyc2VDYXJkMTYoKTtcbiAgICAgICAgICAgIGlmIChmZEluZGV4ID49IGZkQXJyYXlDb3VudCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ0ZGIHRhYmxlIENJRCBGb250IEZEU2VsZWN0IGhhcyBiYWQgRkQgaW5kZXggdmFsdWUgJyArIGZkSW5kZXggKyAnIChGRCBjb3VudCAnICsgZmRBcnJheUNvdW50ICsgJyknKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuZXh0ID4gbkdseXBocykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ0ZGIFRhYmxlIENJRCBGb250IEZEU2VsZWN0IGZvcm1hdCAzIHJhbmdlIGhhcyBiYWQgR0lEICcgKyBuZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoOyBmaXJzdCA8IG5leHQ7IGZpcnN0KyspIHtcbiAgICAgICAgICAgICAgICBmZFNlbGVjdC5wdXNoKGZkSW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmlyc3QgPSBuZXh0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChuZXh0ICE9PSBuR2x5cGhzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NGRiBUYWJsZSBDSUQgRm9udCBGRFNlbGVjdCBmb3JtYXQgMyByYW5nZSBoYXMgYmFkIGZpbmFsIEdJRCAnICsgbmV4dCk7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NGRiBUYWJsZSBDSUQgRm9udCBGRFNlbGVjdCB0YWJsZSBoYXMgdW5zdXBwb3J0ZWQgZm9ybWF0ICcgKyBmb3JtYXQpO1xuICAgIH1cbiAgICByZXR1cm4gZmRTZWxlY3Q7XG59XG5cbi8vIFBhcnNlIHRoZSBgQ0ZGYCB0YWJsZSwgd2hpY2ggY29udGFpbnMgdGhlIGdseXBoIG91dGxpbmVzIGluIFBvc3RTY3JpcHQgZm9ybWF0LlxuZnVuY3Rpb24gcGFyc2VDRkZUYWJsZShkYXRhLCBzdGFydCwgZm9udCkge1xuICAgIGZvbnQudGFibGVzLmNmZiA9IHt9O1xuICAgIGNvbnN0IGhlYWRlciA9IHBhcnNlQ0ZGSGVhZGVyKGRhdGEsIHN0YXJ0KTtcbiAgICBjb25zdCBuYW1lSW5kZXggPSBwYXJzZUNGRkluZGV4KGRhdGEsIGhlYWRlci5lbmRPZmZzZXQsIHBhcnNlLmJ5dGVzVG9TdHJpbmcpO1xuICAgIGNvbnN0IHRvcERpY3RJbmRleCA9IHBhcnNlQ0ZGSW5kZXgoZGF0YSwgbmFtZUluZGV4LmVuZE9mZnNldCk7XG4gICAgY29uc3Qgc3RyaW5nSW5kZXggPSBwYXJzZUNGRkluZGV4KGRhdGEsIHRvcERpY3RJbmRleC5lbmRPZmZzZXQsIHBhcnNlLmJ5dGVzVG9TdHJpbmcpO1xuICAgIGNvbnN0IGdsb2JhbFN1YnJJbmRleCA9IHBhcnNlQ0ZGSW5kZXgoZGF0YSwgc3RyaW5nSW5kZXguZW5kT2Zmc2V0KTtcbiAgICBmb250LmdzdWJycyA9IGdsb2JhbFN1YnJJbmRleC5vYmplY3RzO1xuICAgIGZvbnQuZ3N1YnJzQmlhcyA9IGNhbGNDRkZTdWJyb3V0aW5lQmlhcyhmb250LmdzdWJycyk7XG5cbiAgICBjb25zdCB0b3BEaWN0QXJyYXkgPSBnYXRoZXJDRkZUb3BEaWN0cyhkYXRhLCBzdGFydCwgdG9wRGljdEluZGV4Lm9iamVjdHMsIHN0cmluZ0luZGV4Lm9iamVjdHMpO1xuICAgIGlmICh0b3BEaWN0QXJyYXkubGVuZ3RoICE9PSAxKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ0ZGIHRhYmxlIGhhcyB0b28gbWFueSBmb250cyBpbiBcXCdGb250U2V0XFwnIC0gY291bnQgb2YgZm9udHMgTmFtZUluZGV4Lmxlbmd0aCA9ICcgKyB0b3BEaWN0QXJyYXkubGVuZ3RoKTtcbiAgICB9XG5cbiAgICBjb25zdCB0b3BEaWN0ID0gdG9wRGljdEFycmF5WzBdO1xuICAgIGZvbnQudGFibGVzLmNmZi50b3BEaWN0ID0gdG9wRGljdDtcblxuICAgIGlmICh0b3BEaWN0Ll9wcml2YXRlRGljdCkge1xuICAgICAgICBmb250LmRlZmF1bHRXaWR0aFggPSB0b3BEaWN0Ll9wcml2YXRlRGljdC5kZWZhdWx0V2lkdGhYO1xuICAgICAgICBmb250Lm5vbWluYWxXaWR0aFggPSB0b3BEaWN0Ll9wcml2YXRlRGljdC5ub21pbmFsV2lkdGhYO1xuICAgIH1cblxuICAgIGlmICh0b3BEaWN0LnJvc1swXSAhPT0gdW5kZWZpbmVkICYmIHRvcERpY3Qucm9zWzFdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZm9udC5pc0NJREZvbnQgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmIChmb250LmlzQ0lERm9udCkge1xuICAgICAgICBsZXQgZmRBcnJheU9mZnNldCA9IHRvcERpY3QuZmRBcnJheTtcbiAgICAgICAgbGV0IGZkU2VsZWN0T2Zmc2V0ID0gdG9wRGljdC5mZFNlbGVjdDtcbiAgICAgICAgaWYgKGZkQXJyYXlPZmZzZXQgPT09IDAgfHwgZmRTZWxlY3RPZmZzZXQgPT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRm9udCBpcyBtYXJrZWQgYXMgYSBDSUQgZm9udCwgYnV0IEZEQXJyYXkgYW5kL29yIEZEU2VsZWN0IGluZm9ybWF0aW9uIGlzIG1pc3NpbmcnKTtcbiAgICAgICAgfVxuICAgICAgICBmZEFycmF5T2Zmc2V0ICs9IHN0YXJ0O1xuICAgICAgICBjb25zdCBmZEFycmF5SW5kZXggPSBwYXJzZUNGRkluZGV4KGRhdGEsIGZkQXJyYXlPZmZzZXQpO1xuICAgICAgICBjb25zdCBmZEFycmF5ID0gZ2F0aGVyQ0ZGVG9wRGljdHMoZGF0YSwgc3RhcnQsIGZkQXJyYXlJbmRleC5vYmplY3RzLCBzdHJpbmdJbmRleC5vYmplY3RzKTtcbiAgICAgICAgdG9wRGljdC5fZmRBcnJheSA9IGZkQXJyYXk7XG4gICAgICAgIGZkU2VsZWN0T2Zmc2V0ICs9IHN0YXJ0O1xuICAgICAgICB0b3BEaWN0Ll9mZFNlbGVjdCA9IHBhcnNlQ0ZGRkRTZWxlY3QoZGF0YSwgZmRTZWxlY3RPZmZzZXQsIGZvbnQubnVtR2x5cGhzLCBmZEFycmF5Lmxlbmd0aCk7XG4gICAgfVxuXG4gICAgY29uc3QgcHJpdmF0ZURpY3RPZmZzZXQgPSBzdGFydCArIHRvcERpY3QucHJpdmF0ZVsxXTtcbiAgICBjb25zdCBwcml2YXRlRGljdCA9IHBhcnNlQ0ZGUHJpdmF0ZURpY3QoZGF0YSwgcHJpdmF0ZURpY3RPZmZzZXQsIHRvcERpY3QucHJpdmF0ZVswXSwgc3RyaW5nSW5kZXgub2JqZWN0cyk7XG4gICAgZm9udC5kZWZhdWx0V2lkdGhYID0gcHJpdmF0ZURpY3QuZGVmYXVsdFdpZHRoWDtcbiAgICBmb250Lm5vbWluYWxXaWR0aFggPSBwcml2YXRlRGljdC5ub21pbmFsV2lkdGhYO1xuXG4gICAgaWYgKHByaXZhdGVEaWN0LnN1YnJzICE9PSAwKSB7XG4gICAgICAgIGNvbnN0IHN1YnJPZmZzZXQgPSBwcml2YXRlRGljdE9mZnNldCArIHByaXZhdGVEaWN0LnN1YnJzO1xuICAgICAgICBjb25zdCBzdWJySW5kZXggPSBwYXJzZUNGRkluZGV4KGRhdGEsIHN1YnJPZmZzZXQpO1xuICAgICAgICBmb250LnN1YnJzID0gc3VickluZGV4Lm9iamVjdHM7XG4gICAgICAgIGZvbnQuc3VicnNCaWFzID0gY2FsY0NGRlN1YnJvdXRpbmVCaWFzKGZvbnQuc3VicnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGZvbnQuc3VicnMgPSBbXTtcbiAgICAgICAgZm9udC5zdWJyc0JpYXMgPSAwO1xuICAgIH1cblxuICAgIC8vIE9mZnNldHMgaW4gdGhlIHRvcCBkaWN0IGFyZSByZWxhdGl2ZSB0byB0aGUgYmVnaW5uaW5nIG9mIHRoZSBDRkYgZGF0YSwgc28gYWRkIHRoZSBDRkYgc3RhcnQgb2Zmc2V0LlxuICAgIGNvbnN0IGNoYXJTdHJpbmdzSW5kZXggPSBwYXJzZUNGRkluZGV4KGRhdGEsIHN0YXJ0ICsgdG9wRGljdC5jaGFyU3RyaW5ncyk7XG4gICAgZm9udC5uR2x5cGhzID0gY2hhclN0cmluZ3NJbmRleC5vYmplY3RzLmxlbmd0aDtcblxuICAgIGNvbnN0IGNoYXJzZXQgPSBwYXJzZUNGRkNoYXJzZXQoZGF0YSwgc3RhcnQgKyB0b3BEaWN0LmNoYXJzZXQsIGZvbnQubkdseXBocywgc3RyaW5nSW5kZXgub2JqZWN0cyk7XG4gICAgaWYgKHRvcERpY3QuZW5jb2RpbmcgPT09IDApIHsgLy8gU3RhbmRhcmQgZW5jb2RpbmdcbiAgICAgICAgZm9udC5jZmZFbmNvZGluZyA9IG5ldyBDZmZFbmNvZGluZyhjZmZTdGFuZGFyZEVuY29kaW5nLCBjaGFyc2V0KTtcbiAgICB9IGVsc2UgaWYgKHRvcERpY3QuZW5jb2RpbmcgPT09IDEpIHsgLy8gRXhwZXJ0IGVuY29kaW5nXG4gICAgICAgIGZvbnQuY2ZmRW5jb2RpbmcgPSBuZXcgQ2ZmRW5jb2RpbmcoY2ZmRXhwZXJ0RW5jb2RpbmcsIGNoYXJzZXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGZvbnQuY2ZmRW5jb2RpbmcgPSBwYXJzZUNGRkVuY29kaW5nKGRhdGEsIHN0YXJ0ICsgdG9wRGljdC5lbmNvZGluZywgY2hhcnNldCk7XG4gICAgfVxuXG4gICAgLy8gUHJlZmVyIHRoZSBDTUFQIGVuY29kaW5nIHRvIHRoZSBDRkYgZW5jb2RpbmcuXG4gICAgZm9udC5lbmNvZGluZyA9IGZvbnQuZW5jb2RpbmcgfHwgZm9udC5jZmZFbmNvZGluZztcblxuICAgIGZvbnQuZ2x5cGhzID0gbmV3IGdseXBoc2V0LkdseXBoU2V0KGZvbnQpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZm9udC5uR2x5cGhzOyBpICs9IDEpIHtcbiAgICAgICAgY29uc3QgY2hhclN0cmluZyA9IGNoYXJTdHJpbmdzSW5kZXgub2JqZWN0c1tpXTtcbiAgICAgICAgZm9udC5nbHlwaHMucHVzaChpLCBnbHlwaHNldC5jZmZHbHlwaExvYWRlcihmb250LCBpLCBwYXJzZUNGRkNoYXJzdHJpbmcsIGNoYXJTdHJpbmcpKTtcbiAgICB9XG59XG5cbi8vIENvbnZlcnQgYSBzdHJpbmcgdG8gYSBTdHJpbmcgSUQgKFNJRCkuXG4vLyBUaGUgbGlzdCBvZiBzdHJpbmdzIGlzIG1vZGlmaWVkIGluIHBsYWNlLlxuZnVuY3Rpb24gZW5jb2RlU3RyaW5nKHMsIHN0cmluZ3MpIHtcbiAgICBsZXQgc2lkO1xuXG4gICAgLy8gSXMgdGhlIHN0cmluZyBpbiB0aGUgQ0ZGIHN0YW5kYXJkIHN0cmluZ3M/XG4gICAgbGV0IGkgPSBjZmZTdGFuZGFyZFN0cmluZ3MuaW5kZXhPZihzKTtcbiAgICBpZiAoaSA+PSAwKSB7XG4gICAgICAgIHNpZCA9IGk7XG4gICAgfVxuXG4gICAgLy8gSXMgdGhlIHN0cmluZyBhbHJlYWR5IGluIHRoZSBzdHJpbmcgaW5kZXg/XG4gICAgaSA9IHN0cmluZ3MuaW5kZXhPZihzKTtcbiAgICBpZiAoaSA+PSAwKSB7XG4gICAgICAgIHNpZCA9IGkgKyBjZmZTdGFuZGFyZFN0cmluZ3MubGVuZ3RoO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHNpZCA9IGNmZlN0YW5kYXJkU3RyaW5ncy5sZW5ndGggKyBzdHJpbmdzLmxlbmd0aDtcbiAgICAgICAgc3RyaW5ncy5wdXNoKHMpO1xuICAgIH1cblxuICAgIHJldHVybiBzaWQ7XG59XG5cbmZ1bmN0aW9uIG1ha2VIZWFkZXIoKSB7XG4gICAgcmV0dXJuIG5ldyB0YWJsZS5SZWNvcmQoJ0hlYWRlcicsIFtcbiAgICAgICAge25hbWU6ICdtYWpvcicsIHR5cGU6ICdDYXJkOCcsIHZhbHVlOiAxfSxcbiAgICAgICAge25hbWU6ICdtaW5vcicsIHR5cGU6ICdDYXJkOCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICdoZHJTaXplJywgdHlwZTogJ0NhcmQ4JywgdmFsdWU6IDR9LFxuICAgICAgICB7bmFtZTogJ21ham9yJywgdHlwZTogJ0NhcmQ4JywgdmFsdWU6IDF9XG4gICAgXSk7XG59XG5cbmZ1bmN0aW9uIG1ha2VOYW1lSW5kZXgoZm9udE5hbWVzKSB7XG4gICAgY29uc3QgdCA9IG5ldyB0YWJsZS5SZWNvcmQoJ05hbWUgSU5ERVgnLCBbXG4gICAgICAgIHtuYW1lOiAnbmFtZXMnLCB0eXBlOiAnSU5ERVgnLCB2YWx1ZTogW119XG4gICAgXSk7XG4gICAgdC5uYW1lcyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZm9udE5hbWVzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHQubmFtZXMucHVzaCh7bmFtZTogJ25hbWVfJyArIGksIHR5cGU6ICdOQU1FJywgdmFsdWU6IGZvbnROYW1lc1tpXX0pO1xuICAgIH1cblxuICAgIHJldHVybiB0O1xufVxuXG4vLyBHaXZlbiBhIGRpY3Rpb25hcnkncyBtZXRhZGF0YSwgY3JlYXRlIGEgRElDVCBzdHJ1Y3R1cmUuXG5mdW5jdGlvbiBtYWtlRGljdChtZXRhLCBhdHRycywgc3RyaW5ncykge1xuICAgIGNvbnN0IG0gPSB7fTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1ldGEubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgY29uc3QgZW50cnkgPSBtZXRhW2ldO1xuICAgICAgICBsZXQgdmFsdWUgPSBhdHRyc1tlbnRyeS5uYW1lXTtcbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQgJiYgIWVxdWFscyh2YWx1ZSwgZW50cnkudmFsdWUpKSB7XG4gICAgICAgICAgICBpZiAoZW50cnkudHlwZSA9PT0gJ1NJRCcpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGVuY29kZVN0cmluZyh2YWx1ZSwgc3RyaW5ncyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG1bZW50cnkub3BdID0ge25hbWU6IGVudHJ5Lm5hbWUsIHR5cGU6IGVudHJ5LnR5cGUsIHZhbHVlOiB2YWx1ZX07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbTtcbn1cblxuLy8gVGhlIFRvcCBESUNUIGhvdXNlcyB0aGUgZ2xvYmFsIGZvbnQgYXR0cmlidXRlcy5cbmZ1bmN0aW9uIG1ha2VUb3BEaWN0KGF0dHJzLCBzdHJpbmdzKSB7XG4gICAgY29uc3QgdCA9IG5ldyB0YWJsZS5SZWNvcmQoJ1RvcCBESUNUJywgW1xuICAgICAgICB7bmFtZTogJ2RpY3QnLCB0eXBlOiAnRElDVCcsIHZhbHVlOiB7fX1cbiAgICBdKTtcbiAgICB0LmRpY3QgPSBtYWtlRGljdChUT1BfRElDVF9NRVRBLCBhdHRycywgc3RyaW5ncyk7XG4gICAgcmV0dXJuIHQ7XG59XG5cbmZ1bmN0aW9uIG1ha2VUb3BEaWN0SW5kZXgodG9wRGljdCkge1xuICAgIGNvbnN0IHQgPSBuZXcgdGFibGUuUmVjb3JkKCdUb3AgRElDVCBJTkRFWCcsIFtcbiAgICAgICAge25hbWU6ICd0b3BEaWN0cycsIHR5cGU6ICdJTkRFWCcsIHZhbHVlOiBbXX1cbiAgICBdKTtcbiAgICB0LnRvcERpY3RzID0gW3tuYW1lOiAndG9wRGljdF8wJywgdHlwZTogJ1RBQkxFJywgdmFsdWU6IHRvcERpY3R9XTtcbiAgICByZXR1cm4gdDtcbn1cblxuZnVuY3Rpb24gbWFrZVN0cmluZ0luZGV4KHN0cmluZ3MpIHtcbiAgICBjb25zdCB0ID0gbmV3IHRhYmxlLlJlY29yZCgnU3RyaW5nIElOREVYJywgW1xuICAgICAgICB7bmFtZTogJ3N0cmluZ3MnLCB0eXBlOiAnSU5ERVgnLCB2YWx1ZTogW119XG4gICAgXSk7XG4gICAgdC5zdHJpbmdzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHJpbmdzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHQuc3RyaW5ncy5wdXNoKHtuYW1lOiAnc3RyaW5nXycgKyBpLCB0eXBlOiAnU1RSSU5HJywgdmFsdWU6IHN0cmluZ3NbaV19KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdDtcbn1cblxuZnVuY3Rpb24gbWFrZUdsb2JhbFN1YnJJbmRleCgpIHtcbiAgICAvLyBDdXJyZW50bHkgd2UgZG9uJ3QgdXNlIHN1YnJvdXRpbmVzLlxuICAgIHJldHVybiBuZXcgdGFibGUuUmVjb3JkKCdHbG9iYWwgU3ViciBJTkRFWCcsIFtcbiAgICAgICAge25hbWU6ICdzdWJycycsIHR5cGU6ICdJTkRFWCcsIHZhbHVlOiBbXX1cbiAgICBdKTtcbn1cblxuZnVuY3Rpb24gbWFrZUNoYXJzZXRzKGdseXBoTmFtZXMsIHN0cmluZ3MpIHtcbiAgICBjb25zdCB0ID0gbmV3IHRhYmxlLlJlY29yZCgnQ2hhcnNldHMnLCBbXG4gICAgICAgIHtuYW1lOiAnZm9ybWF0JywgdHlwZTogJ0NhcmQ4JywgdmFsdWU6IDB9XG4gICAgXSk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBnbHlwaE5hbWVzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGNvbnN0IGdseXBoTmFtZSA9IGdseXBoTmFtZXNbaV07XG4gICAgICAgIGNvbnN0IGdseXBoU0lEID0gZW5jb2RlU3RyaW5nKGdseXBoTmFtZSwgc3RyaW5ncyk7XG4gICAgICAgIHQuZmllbGRzLnB1c2goe25hbWU6ICdnbHlwaF8nICsgaSwgdHlwZTogJ1NJRCcsIHZhbHVlOiBnbHlwaFNJRH0pO1xuICAgIH1cblxuICAgIHJldHVybiB0O1xufVxuXG5mdW5jdGlvbiBnbHlwaFRvT3BzKGdseXBoKSB7XG4gICAgY29uc3Qgb3BzID0gW107XG4gICAgY29uc3QgcGF0aCA9IGdseXBoLnBhdGg7XG4gICAgb3BzLnB1c2goe25hbWU6ICd3aWR0aCcsIHR5cGU6ICdOVU1CRVInLCB2YWx1ZTogZ2x5cGguYWR2YW5jZVdpZHRofSk7XG4gICAgbGV0IHggPSAwO1xuICAgIGxldCB5ID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhdGguY29tbWFuZHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgbGV0IGR4O1xuICAgICAgICBsZXQgZHk7XG4gICAgICAgIGxldCBjbWQgPSBwYXRoLmNvbW1hbmRzW2ldO1xuICAgICAgICBpZiAoY21kLnR5cGUgPT09ICdRJykge1xuICAgICAgICAgICAgLy8gQ0ZGIG9ubHkgc3VwcG9ydHMgYsOpemllciBjdXJ2ZXMsIHNvIGNvbnZlcnQgdGhlIHF1YWQgdG8gYSBiw6l6aWVyLlxuICAgICAgICAgICAgY29uc3QgXzEzID0gMSAvIDM7XG4gICAgICAgICAgICBjb25zdCBfMjMgPSAyIC8gMztcblxuICAgICAgICAgICAgLy8gV2UncmUgZ29pbmcgdG8gY3JlYXRlIGEgbmV3IGNvbW1hbmQgc28gd2UgZG9uJ3QgY2hhbmdlIHRoZSBvcmlnaW5hbCBwYXRoLlxuICAgICAgICAgICAgY21kID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdDJyxcbiAgICAgICAgICAgICAgICB4OiBjbWQueCxcbiAgICAgICAgICAgICAgICB5OiBjbWQueSxcbiAgICAgICAgICAgICAgICB4MTogXzEzICogeCArIF8yMyAqIGNtZC54MSxcbiAgICAgICAgICAgICAgICB5MTogXzEzICogeSArIF8yMyAqIGNtZC55MSxcbiAgICAgICAgICAgICAgICB4MjogXzEzICogY21kLnggKyBfMjMgKiBjbWQueDEsXG4gICAgICAgICAgICAgICAgeTI6IF8xMyAqIGNtZC55ICsgXzIzICogY21kLnkxXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNtZC50eXBlID09PSAnTScpIHtcbiAgICAgICAgICAgIGR4ID0gTWF0aC5yb3VuZChjbWQueCAtIHgpO1xuICAgICAgICAgICAgZHkgPSBNYXRoLnJvdW5kKGNtZC55IC0geSk7XG4gICAgICAgICAgICBvcHMucHVzaCh7bmFtZTogJ2R4JywgdHlwZTogJ05VTUJFUicsIHZhbHVlOiBkeH0pO1xuICAgICAgICAgICAgb3BzLnB1c2goe25hbWU6ICdkeScsIHR5cGU6ICdOVU1CRVInLCB2YWx1ZTogZHl9KTtcbiAgICAgICAgICAgIG9wcy5wdXNoKHtuYW1lOiAncm1vdmV0bycsIHR5cGU6ICdPUCcsIHZhbHVlOiAyMX0pO1xuICAgICAgICAgICAgeCA9IE1hdGgucm91bmQoY21kLngpO1xuICAgICAgICAgICAgeSA9IE1hdGgucm91bmQoY21kLnkpO1xuICAgICAgICB9IGVsc2UgaWYgKGNtZC50eXBlID09PSAnTCcpIHtcbiAgICAgICAgICAgIGR4ID0gTWF0aC5yb3VuZChjbWQueCAtIHgpO1xuICAgICAgICAgICAgZHkgPSBNYXRoLnJvdW5kKGNtZC55IC0geSk7XG4gICAgICAgICAgICBvcHMucHVzaCh7bmFtZTogJ2R4JywgdHlwZTogJ05VTUJFUicsIHZhbHVlOiBkeH0pO1xuICAgICAgICAgICAgb3BzLnB1c2goe25hbWU6ICdkeScsIHR5cGU6ICdOVU1CRVInLCB2YWx1ZTogZHl9KTtcbiAgICAgICAgICAgIG9wcy5wdXNoKHtuYW1lOiAncmxpbmV0bycsIHR5cGU6ICdPUCcsIHZhbHVlOiA1fSk7XG4gICAgICAgICAgICB4ID0gTWF0aC5yb3VuZChjbWQueCk7XG4gICAgICAgICAgICB5ID0gTWF0aC5yb3VuZChjbWQueSk7XG4gICAgICAgIH0gZWxzZSBpZiAoY21kLnR5cGUgPT09ICdDJykge1xuICAgICAgICAgICAgY29uc3QgZHgxID0gTWF0aC5yb3VuZChjbWQueDEgLSB4KTtcbiAgICAgICAgICAgIGNvbnN0IGR5MSA9IE1hdGgucm91bmQoY21kLnkxIC0geSk7XG4gICAgICAgICAgICBjb25zdCBkeDIgPSBNYXRoLnJvdW5kKGNtZC54MiAtIGNtZC54MSk7XG4gICAgICAgICAgICBjb25zdCBkeTIgPSBNYXRoLnJvdW5kKGNtZC55MiAtIGNtZC55MSk7XG4gICAgICAgICAgICBkeCA9IE1hdGgucm91bmQoY21kLnggLSBjbWQueDIpO1xuICAgICAgICAgICAgZHkgPSBNYXRoLnJvdW5kKGNtZC55IC0gY21kLnkyKTtcbiAgICAgICAgICAgIG9wcy5wdXNoKHtuYW1lOiAnZHgxJywgdHlwZTogJ05VTUJFUicsIHZhbHVlOiBkeDF9KTtcbiAgICAgICAgICAgIG9wcy5wdXNoKHtuYW1lOiAnZHkxJywgdHlwZTogJ05VTUJFUicsIHZhbHVlOiBkeTF9KTtcbiAgICAgICAgICAgIG9wcy5wdXNoKHtuYW1lOiAnZHgyJywgdHlwZTogJ05VTUJFUicsIHZhbHVlOiBkeDJ9KTtcbiAgICAgICAgICAgIG9wcy5wdXNoKHtuYW1lOiAnZHkyJywgdHlwZTogJ05VTUJFUicsIHZhbHVlOiBkeTJ9KTtcbiAgICAgICAgICAgIG9wcy5wdXNoKHtuYW1lOiAnZHgnLCB0eXBlOiAnTlVNQkVSJywgdmFsdWU6IGR4fSk7XG4gICAgICAgICAgICBvcHMucHVzaCh7bmFtZTogJ2R5JywgdHlwZTogJ05VTUJFUicsIHZhbHVlOiBkeX0pO1xuICAgICAgICAgICAgb3BzLnB1c2goe25hbWU6ICdycmN1cnZldG8nLCB0eXBlOiAnT1AnLCB2YWx1ZTogOH0pO1xuICAgICAgICAgICAgeCA9IE1hdGgucm91bmQoY21kLngpO1xuICAgICAgICAgICAgeSA9IE1hdGgucm91bmQoY21kLnkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ29udG91cnMgYXJlIGNsb3NlZCBhdXRvbWF0aWNhbGx5LlxuICAgIH1cblxuICAgIG9wcy5wdXNoKHtuYW1lOiAnZW5kY2hhcicsIHR5cGU6ICdPUCcsIHZhbHVlOiAxNH0pO1xuICAgIHJldHVybiBvcHM7XG59XG5cbmZ1bmN0aW9uIG1ha2VDaGFyU3RyaW5nc0luZGV4KGdseXBocykge1xuICAgIGNvbnN0IHQgPSBuZXcgdGFibGUuUmVjb3JkKCdDaGFyU3RyaW5ncyBJTkRFWCcsIFtcbiAgICAgICAge25hbWU6ICdjaGFyU3RyaW5ncycsIHR5cGU6ICdJTkRFWCcsIHZhbHVlOiBbXX1cbiAgICBdKTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZ2x5cGhzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGNvbnN0IGdseXBoID0gZ2x5cGhzLmdldChpKTtcbiAgICAgICAgY29uc3Qgb3BzID0gZ2x5cGhUb09wcyhnbHlwaCk7XG4gICAgICAgIHQuY2hhclN0cmluZ3MucHVzaCh7bmFtZTogZ2x5cGgubmFtZSwgdHlwZTogJ0NIQVJTVFJJTkcnLCB2YWx1ZTogb3BzfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHQ7XG59XG5cbmZ1bmN0aW9uIG1ha2VQcml2YXRlRGljdChhdHRycywgc3RyaW5ncykge1xuICAgIGNvbnN0IHQgPSBuZXcgdGFibGUuUmVjb3JkKCdQcml2YXRlIERJQ1QnLCBbXG4gICAgICAgIHtuYW1lOiAnZGljdCcsIHR5cGU6ICdESUNUJywgdmFsdWU6IHt9fVxuICAgIF0pO1xuICAgIHQuZGljdCA9IG1ha2VEaWN0KFBSSVZBVEVfRElDVF9NRVRBLCBhdHRycywgc3RyaW5ncyk7XG4gICAgcmV0dXJuIHQ7XG59XG5cbmZ1bmN0aW9uIG1ha2VDRkZUYWJsZShnbHlwaHMsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB0ID0gbmV3IHRhYmxlLlRhYmxlKCdDRkYgJywgW1xuICAgICAgICB7bmFtZTogJ2hlYWRlcicsIHR5cGU6ICdSRUNPUkQnfSxcbiAgICAgICAge25hbWU6ICduYW1lSW5kZXgnLCB0eXBlOiAnUkVDT1JEJ30sXG4gICAgICAgIHtuYW1lOiAndG9wRGljdEluZGV4JywgdHlwZTogJ1JFQ09SRCd9LFxuICAgICAgICB7bmFtZTogJ3N0cmluZ0luZGV4JywgdHlwZTogJ1JFQ09SRCd9LFxuICAgICAgICB7bmFtZTogJ2dsb2JhbFN1YnJJbmRleCcsIHR5cGU6ICdSRUNPUkQnfSxcbiAgICAgICAge25hbWU6ICdjaGFyc2V0cycsIHR5cGU6ICdSRUNPUkQnfSxcbiAgICAgICAge25hbWU6ICdjaGFyU3RyaW5nc0luZGV4JywgdHlwZTogJ1JFQ09SRCd9LFxuICAgICAgICB7bmFtZTogJ3ByaXZhdGVEaWN0JywgdHlwZTogJ1JFQ09SRCd9XG4gICAgXSk7XG5cbiAgICBjb25zdCBmb250U2NhbGUgPSAxIC8gb3B0aW9ucy51bml0c1BlckVtO1xuICAgIC8vIFdlIHVzZSBub24temVybyB2YWx1ZXMgZm9yIHRoZSBvZmZzZXRzIHNvIHRoYXQgdGhlIERJQ1QgZW5jb2RlcyB0aGVtLlxuICAgIC8vIFRoaXMgaXMgaW1wb3J0YW50IGJlY2F1c2UgdGhlIHNpemUgb2YgdGhlIFRvcCBESUNUIHBsYXlzIGEgcm9sZSBpbiBvZmZzZXQgY2FsY3VsYXRpb24sXG4gICAgLy8gYW5kIHRoZSBzaXplIHNob3VsZG4ndCBjaGFuZ2UgYWZ0ZXIgd2UndmUgd3JpdHRlbiBjb3JyZWN0IG9mZnNldHMuXG4gICAgY29uc3QgYXR0cnMgPSB7XG4gICAgICAgIHZlcnNpb246IG9wdGlvbnMudmVyc2lvbixcbiAgICAgICAgZnVsbE5hbWU6IG9wdGlvbnMuZnVsbE5hbWUsXG4gICAgICAgIGZhbWlseU5hbWU6IG9wdGlvbnMuZmFtaWx5TmFtZSxcbiAgICAgICAgd2VpZ2h0OiBvcHRpb25zLndlaWdodE5hbWUsXG4gICAgICAgIGZvbnRCQm94OiBvcHRpb25zLmZvbnRCQm94IHx8IFswLCAwLCAwLCAwXSxcbiAgICAgICAgZm9udE1hdHJpeDogW2ZvbnRTY2FsZSwgMCwgMCwgZm9udFNjYWxlLCAwLCAwXSxcbiAgICAgICAgY2hhcnNldDogOTk5LFxuICAgICAgICBlbmNvZGluZzogMCxcbiAgICAgICAgY2hhclN0cmluZ3M6IDk5OSxcbiAgICAgICAgcHJpdmF0ZTogWzAsIDk5OV1cbiAgICB9O1xuXG4gICAgY29uc3QgcHJpdmF0ZUF0dHJzID0ge307XG5cbiAgICBjb25zdCBnbHlwaE5hbWVzID0gW107XG4gICAgbGV0IGdseXBoO1xuXG4gICAgLy8gU2tpcCBmaXJzdCBnbHlwaCAoLm5vdGRlZilcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IGdseXBocy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBnbHlwaCA9IGdseXBocy5nZXQoaSk7XG4gICAgICAgIGdseXBoTmFtZXMucHVzaChnbHlwaC5uYW1lKTtcbiAgICB9XG5cbiAgICBjb25zdCBzdHJpbmdzID0gW107XG5cbiAgICB0LmhlYWRlciA9IG1ha2VIZWFkZXIoKTtcbiAgICB0Lm5hbWVJbmRleCA9IG1ha2VOYW1lSW5kZXgoW29wdGlvbnMucG9zdFNjcmlwdE5hbWVdKTtcbiAgICBsZXQgdG9wRGljdCA9IG1ha2VUb3BEaWN0KGF0dHJzLCBzdHJpbmdzKTtcbiAgICB0LnRvcERpY3RJbmRleCA9IG1ha2VUb3BEaWN0SW5kZXgodG9wRGljdCk7XG4gICAgdC5nbG9iYWxTdWJySW5kZXggPSBtYWtlR2xvYmFsU3VickluZGV4KCk7XG4gICAgdC5jaGFyc2V0cyA9IG1ha2VDaGFyc2V0cyhnbHlwaE5hbWVzLCBzdHJpbmdzKTtcbiAgICB0LmNoYXJTdHJpbmdzSW5kZXggPSBtYWtlQ2hhclN0cmluZ3NJbmRleChnbHlwaHMpO1xuICAgIHQucHJpdmF0ZURpY3QgPSBtYWtlUHJpdmF0ZURpY3QocHJpdmF0ZUF0dHJzLCBzdHJpbmdzKTtcblxuICAgIC8vIE5lZWRzIHRvIGNvbWUgYXQgdGhlIGVuZCwgdG8gZW5jb2RlIGFsbCBjdXN0b20gc3RyaW5ncyB1c2VkIGluIHRoZSBmb250LlxuICAgIHQuc3RyaW5nSW5kZXggPSBtYWtlU3RyaW5nSW5kZXgoc3RyaW5ncyk7XG5cbiAgICBjb25zdCBzdGFydE9mZnNldCA9IHQuaGVhZGVyLnNpemVPZigpICtcbiAgICAgICAgdC5uYW1lSW5kZXguc2l6ZU9mKCkgK1xuICAgICAgICB0LnRvcERpY3RJbmRleC5zaXplT2YoKSArXG4gICAgICAgIHQuc3RyaW5nSW5kZXguc2l6ZU9mKCkgK1xuICAgICAgICB0Lmdsb2JhbFN1YnJJbmRleC5zaXplT2YoKTtcbiAgICBhdHRycy5jaGFyc2V0ID0gc3RhcnRPZmZzZXQ7XG5cbiAgICAvLyBXZSB1c2UgdGhlIENGRiBzdGFuZGFyZCBlbmNvZGluZzsgcHJvcGVyIGVuY29kaW5nIHdpbGwgYmUgaGFuZGxlZCBpbiBjbWFwLlxuICAgIGF0dHJzLmVuY29kaW5nID0gMDtcbiAgICBhdHRycy5jaGFyU3RyaW5ncyA9IGF0dHJzLmNoYXJzZXQgKyB0LmNoYXJzZXRzLnNpemVPZigpO1xuICAgIGF0dHJzLnByaXZhdGVbMV0gPSBhdHRycy5jaGFyU3RyaW5ncyArIHQuY2hhclN0cmluZ3NJbmRleC5zaXplT2YoKTtcblxuICAgIC8vIFJlY3JlYXRlIHRoZSBUb3AgRElDVCBJTkRFWCB3aXRoIHRoZSBjb3JyZWN0IG9mZnNldHMuXG4gICAgdG9wRGljdCA9IG1ha2VUb3BEaWN0KGF0dHJzLCBzdHJpbmdzKTtcbiAgICB0LnRvcERpY3RJbmRleCA9IG1ha2VUb3BEaWN0SW5kZXgodG9wRGljdCk7XG5cbiAgICByZXR1cm4gdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgeyBwYXJzZTogcGFyc2VDRkZUYWJsZSwgbWFrZTogbWFrZUNGRlRhYmxlIH07XG4iLCIvLyBUaGUgYGhlYWRgIHRhYmxlIGNvbnRhaW5zIGdsb2JhbCBpbmZvcm1hdGlvbiBhYm91dCB0aGUgZm9udC5cbi8vIGh0dHBzOi8vd3d3Lm1pY3Jvc29mdC5jb20vdHlwb2dyYXBoeS9PVFNQRUMvaGVhZC5odG1cblxuaW1wb3J0IGNoZWNrIGZyb20gJy4uL2NoZWNrJztcbmltcG9ydCBwYXJzZSBmcm9tICcuLi9wYXJzZSc7XG5pbXBvcnQgdGFibGUgZnJvbSAnLi4vdGFibGUnO1xuXG4vLyBQYXJzZSB0aGUgaGVhZGVyIGBoZWFkYCB0YWJsZVxuZnVuY3Rpb24gcGFyc2VIZWFkVGFibGUoZGF0YSwgc3RhcnQpIHtcbiAgICBjb25zdCBoZWFkID0ge307XG4gICAgY29uc3QgcCA9IG5ldyBwYXJzZS5QYXJzZXIoZGF0YSwgc3RhcnQpO1xuICAgIGhlYWQudmVyc2lvbiA9IHAucGFyc2VWZXJzaW9uKCk7XG4gICAgaGVhZC5mb250UmV2aXNpb24gPSBNYXRoLnJvdW5kKHAucGFyc2VGaXhlZCgpICogMTAwMCkgLyAxMDAwO1xuICAgIGhlYWQuY2hlY2tTdW1BZGp1c3RtZW50ID0gcC5wYXJzZVVMb25nKCk7XG4gICAgaGVhZC5tYWdpY051bWJlciA9IHAucGFyc2VVTG9uZygpO1xuICAgIGNoZWNrLmFyZ3VtZW50KGhlYWQubWFnaWNOdW1iZXIgPT09IDB4NUYwRjNDRjUsICdGb250IGhlYWRlciBoYXMgd3JvbmcgbWFnaWMgbnVtYmVyLicpO1xuICAgIGhlYWQuZmxhZ3MgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgaGVhZC51bml0c1BlckVtID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgIGhlYWQuY3JlYXRlZCA9IHAucGFyc2VMb25nRGF0ZVRpbWUoKTtcbiAgICBoZWFkLm1vZGlmaWVkID0gcC5wYXJzZUxvbmdEYXRlVGltZSgpO1xuICAgIGhlYWQueE1pbiA9IHAucGFyc2VTaG9ydCgpO1xuICAgIGhlYWQueU1pbiA9IHAucGFyc2VTaG9ydCgpO1xuICAgIGhlYWQueE1heCA9IHAucGFyc2VTaG9ydCgpO1xuICAgIGhlYWQueU1heCA9IHAucGFyc2VTaG9ydCgpO1xuICAgIGhlYWQubWFjU3R5bGUgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgaGVhZC5sb3dlc3RSZWNQUEVNID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgIGhlYWQuZm9udERpcmVjdGlvbkhpbnQgPSBwLnBhcnNlU2hvcnQoKTtcbiAgICBoZWFkLmluZGV4VG9Mb2NGb3JtYXQgPSBwLnBhcnNlU2hvcnQoKTtcbiAgICBoZWFkLmdseXBoRGF0YUZvcm1hdCA9IHAucGFyc2VTaG9ydCgpO1xuICAgIHJldHVybiBoZWFkO1xufVxuXG5mdW5jdGlvbiBtYWtlSGVhZFRhYmxlKG9wdGlvbnMpIHtcbiAgICAvLyBBcHBsZSBNYWMgdGltZXN0YW1wIGVwb2NoIGlzIDAxLzAxLzE5MDQgbm90IDAxLzAxLzE5NzBcbiAgICBjb25zdCB0aW1lc3RhbXAgPSBNYXRoLnJvdW5kKG5ldyBEYXRlKCkuZ2V0VGltZSgpIC8gMTAwMCkgKyAyMDgyODQ0ODAwO1xuICAgIGxldCBjcmVhdGVkVGltZXN0YW1wID0gdGltZXN0YW1wO1xuXG4gICAgaWYgKG9wdGlvbnMuY3JlYXRlZFRpbWVzdGFtcCkge1xuICAgICAgICBjcmVhdGVkVGltZXN0YW1wID0gb3B0aW9ucy5jcmVhdGVkVGltZXN0YW1wICsgMjA4Mjg0NDgwMDtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IHRhYmxlLlRhYmxlKCdoZWFkJywgW1xuICAgICAgICB7bmFtZTogJ3ZlcnNpb24nLCB0eXBlOiAnRklYRUQnLCB2YWx1ZTogMHgwMDAxMDAwMH0sXG4gICAgICAgIHtuYW1lOiAnZm9udFJldmlzaW9uJywgdHlwZTogJ0ZJWEVEJywgdmFsdWU6IDB4MDAwMTAwMDB9LFxuICAgICAgICB7bmFtZTogJ2NoZWNrU3VtQWRqdXN0bWVudCcsIHR5cGU6ICdVTE9ORycsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICdtYWdpY051bWJlcicsIHR5cGU6ICdVTE9ORycsIHZhbHVlOiAweDVGMEYzQ0Y1fSxcbiAgICAgICAge25hbWU6ICdmbGFncycsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAndW5pdHNQZXJFbScsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogMTAwMH0sXG4gICAgICAgIHtuYW1lOiAnY3JlYXRlZCcsIHR5cGU6ICdMT05HREFURVRJTUUnLCB2YWx1ZTogY3JlYXRlZFRpbWVzdGFtcH0sXG4gICAgICAgIHtuYW1lOiAnbW9kaWZpZWQnLCB0eXBlOiAnTE9OR0RBVEVUSU1FJywgdmFsdWU6IHRpbWVzdGFtcH0sXG4gICAgICAgIHtuYW1lOiAneE1pbicsIHR5cGU6ICdTSE9SVCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICd5TWluJywgdHlwZTogJ1NIT1JUJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ3hNYXgnLCB0eXBlOiAnU0hPUlQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAneU1heCcsIHR5cGU6ICdTSE9SVCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICdtYWNTdHlsZScsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAnbG93ZXN0UmVjUFBFTScsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAnZm9udERpcmVjdGlvbkhpbnQnLCB0eXBlOiAnU0hPUlQnLCB2YWx1ZTogMn0sXG4gICAgICAgIHtuYW1lOiAnaW5kZXhUb0xvY0Zvcm1hdCcsIHR5cGU6ICdTSE9SVCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICdnbHlwaERhdGFGb3JtYXQnLCB0eXBlOiAnU0hPUlQnLCB2YWx1ZTogMH1cbiAgICBdLCBvcHRpb25zKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgeyBwYXJzZTogcGFyc2VIZWFkVGFibGUsIG1ha2U6IG1ha2VIZWFkVGFibGUgfTtcbiIsIi8vIFRoZSBgaGhlYWAgdGFibGUgY29udGFpbnMgaW5mb3JtYXRpb24gZm9yIGhvcml6b250YWwgbGF5b3V0LlxuLy8gaHR0cHM6Ly93d3cubWljcm9zb2Z0LmNvbS90eXBvZ3JhcGh5L09UU1BFQy9oaGVhLmh0bVxuXG5pbXBvcnQgcGFyc2UgZnJvbSAnLi4vcGFyc2UnO1xuaW1wb3J0IHRhYmxlIGZyb20gJy4uL3RhYmxlJztcblxuLy8gUGFyc2UgdGhlIGhvcml6b250YWwgaGVhZGVyIGBoaGVhYCB0YWJsZVxuZnVuY3Rpb24gcGFyc2VIaGVhVGFibGUoZGF0YSwgc3RhcnQpIHtcbiAgICBjb25zdCBoaGVhID0ge307XG4gICAgY29uc3QgcCA9IG5ldyBwYXJzZS5QYXJzZXIoZGF0YSwgc3RhcnQpO1xuICAgIGhoZWEudmVyc2lvbiA9IHAucGFyc2VWZXJzaW9uKCk7XG4gICAgaGhlYS5hc2NlbmRlciA9IHAucGFyc2VTaG9ydCgpO1xuICAgIGhoZWEuZGVzY2VuZGVyID0gcC5wYXJzZVNob3J0KCk7XG4gICAgaGhlYS5saW5lR2FwID0gcC5wYXJzZVNob3J0KCk7XG4gICAgaGhlYS5hZHZhbmNlV2lkdGhNYXggPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgaGhlYS5taW5MZWZ0U2lkZUJlYXJpbmcgPSBwLnBhcnNlU2hvcnQoKTtcbiAgICBoaGVhLm1pblJpZ2h0U2lkZUJlYXJpbmcgPSBwLnBhcnNlU2hvcnQoKTtcbiAgICBoaGVhLnhNYXhFeHRlbnQgPSBwLnBhcnNlU2hvcnQoKTtcbiAgICBoaGVhLmNhcmV0U2xvcGVSaXNlID0gcC5wYXJzZVNob3J0KCk7XG4gICAgaGhlYS5jYXJldFNsb3BlUnVuID0gcC5wYXJzZVNob3J0KCk7XG4gICAgaGhlYS5jYXJldE9mZnNldCA9IHAucGFyc2VTaG9ydCgpO1xuICAgIHAucmVsYXRpdmVPZmZzZXQgKz0gODtcbiAgICBoaGVhLm1ldHJpY0RhdGFGb3JtYXQgPSBwLnBhcnNlU2hvcnQoKTtcbiAgICBoaGVhLm51bWJlck9mSE1ldHJpY3MgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgcmV0dXJuIGhoZWE7XG59XG5cbmZ1bmN0aW9uIG1ha2VIaGVhVGFibGUob3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgdGFibGUuVGFibGUoJ2hoZWEnLCBbXG4gICAgICAgIHtuYW1lOiAndmVyc2lvbicsIHR5cGU6ICdGSVhFRCcsIHZhbHVlOiAweDAwMDEwMDAwfSxcbiAgICAgICAge25hbWU6ICdhc2NlbmRlcicsIHR5cGU6ICdGV09SRCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICdkZXNjZW5kZXInLCB0eXBlOiAnRldPUkQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAnbGluZUdhcCcsIHR5cGU6ICdGV09SRCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICdhZHZhbmNlV2lkdGhNYXgnLCB0eXBlOiAnVUZXT1JEJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ21pbkxlZnRTaWRlQmVhcmluZycsIHR5cGU6ICdGV09SRCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICdtaW5SaWdodFNpZGVCZWFyaW5nJywgdHlwZTogJ0ZXT1JEJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ3hNYXhFeHRlbnQnLCB0eXBlOiAnRldPUkQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAnY2FyZXRTbG9wZVJpc2UnLCB0eXBlOiAnU0hPUlQnLCB2YWx1ZTogMX0sXG4gICAgICAgIHtuYW1lOiAnY2FyZXRTbG9wZVJ1bicsIHR5cGU6ICdTSE9SVCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICdjYXJldE9mZnNldCcsIHR5cGU6ICdTSE9SVCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICdyZXNlcnZlZDEnLCB0eXBlOiAnU0hPUlQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAncmVzZXJ2ZWQyJywgdHlwZTogJ1NIT1JUJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ3Jlc2VydmVkMycsIHR5cGU6ICdTSE9SVCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICdyZXNlcnZlZDQnLCB0eXBlOiAnU0hPUlQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAnbWV0cmljRGF0YUZvcm1hdCcsIHR5cGU6ICdTSE9SVCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICdudW1iZXJPZkhNZXRyaWNzJywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiAwfVxuICAgIF0sIG9wdGlvbnMpO1xufVxuXG5leHBvcnQgZGVmYXVsdCB7IHBhcnNlOiBwYXJzZUhoZWFUYWJsZSwgbWFrZTogbWFrZUhoZWFUYWJsZSB9O1xuIiwiLy8gVGhlIGBobXR4YCB0YWJsZSBjb250YWlucyB0aGUgaG9yaXpvbnRhbCBtZXRyaWNzIGZvciBhbGwgZ2x5cGhzLlxuLy8gaHR0cHM6Ly93d3cubWljcm9zb2Z0LmNvbS90eXBvZ3JhcGh5L09UU1BFQy9obXR4Lmh0bVxuXG5pbXBvcnQgcGFyc2UgZnJvbSAnLi4vcGFyc2UnO1xuaW1wb3J0IHRhYmxlIGZyb20gJy4uL3RhYmxlJztcblxuLy8gUGFyc2UgdGhlIGBobXR4YCB0YWJsZSwgd2hpY2ggY29udGFpbnMgdGhlIGhvcml6b250YWwgbWV0cmljcyBmb3IgYWxsIGdseXBocy5cbi8vIFRoaXMgZnVuY3Rpb24gYXVnbWVudHMgdGhlIGdseXBoIGFycmF5LCBhZGRpbmcgdGhlIGFkdmFuY2VXaWR0aCBhbmQgbGVmdFNpZGVCZWFyaW5nIHRvIGVhY2ggZ2x5cGguXG5mdW5jdGlvbiBwYXJzZUhtdHhUYWJsZShkYXRhLCBzdGFydCwgbnVtTWV0cmljcywgbnVtR2x5cGhzLCBnbHlwaHMpIHtcbiAgICBsZXQgYWR2YW5jZVdpZHRoO1xuICAgIGxldCBsZWZ0U2lkZUJlYXJpbmc7XG4gICAgY29uc3QgcCA9IG5ldyBwYXJzZS5QYXJzZXIoZGF0YSwgc3RhcnQpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtR2x5cGhzOyBpICs9IDEpIHtcbiAgICAgICAgLy8gSWYgdGhlIGZvbnQgaXMgbW9ub3NwYWNlZCwgb25seSBvbmUgZW50cnkgaXMgbmVlZGVkLiBUaGlzIGxhc3QgZW50cnkgYXBwbGllcyB0byBhbGwgc3Vic2VxdWVudCBnbHlwaHMuXG4gICAgICAgIGlmIChpIDwgbnVtTWV0cmljcykge1xuICAgICAgICAgICAgYWR2YW5jZVdpZHRoID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICAgICAgbGVmdFNpZGVCZWFyaW5nID0gcC5wYXJzZVNob3J0KCk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBnbHlwaCA9IGdseXBocy5nZXQoaSk7XG4gICAgICAgIGdseXBoLmFkdmFuY2VXaWR0aCA9IGFkdmFuY2VXaWR0aDtcbiAgICAgICAgZ2x5cGgubGVmdFNpZGVCZWFyaW5nID0gbGVmdFNpZGVCZWFyaW5nO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gbWFrZUhtdHhUYWJsZShnbHlwaHMpIHtcbiAgICBjb25zdCB0ID0gbmV3IHRhYmxlLlRhYmxlKCdobXR4JywgW10pO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZ2x5cGhzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGNvbnN0IGdseXBoID0gZ2x5cGhzLmdldChpKTtcbiAgICAgICAgY29uc3QgYWR2YW5jZVdpZHRoID0gZ2x5cGguYWR2YW5jZVdpZHRoIHx8IDA7XG4gICAgICAgIGNvbnN0IGxlZnRTaWRlQmVhcmluZyA9IGdseXBoLmxlZnRTaWRlQmVhcmluZyB8fCAwO1xuICAgICAgICB0LmZpZWxkcy5wdXNoKHtuYW1lOiAnYWR2YW5jZVdpZHRoXycgKyBpLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IGFkdmFuY2VXaWR0aH0pO1xuICAgICAgICB0LmZpZWxkcy5wdXNoKHtuYW1lOiAnbGVmdFNpZGVCZWFyaW5nXycgKyBpLCB0eXBlOiAnU0hPUlQnLCB2YWx1ZTogbGVmdFNpZGVCZWFyaW5nfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHsgcGFyc2U6IHBhcnNlSG10eFRhYmxlLCBtYWtlOiBtYWtlSG10eFRhYmxlIH07XG4iLCIvLyBUaGUgYGx0YWdgIHRhYmxlIHN0b3JlcyBJRVRGIEJDUC00NyBsYW5ndWFnZSB0YWdzLiBJdCBhbGxvd3Mgc3VwcG9ydGluZ1xuLy8gbGFuZ3VhZ2VzIGZvciB3aGljaCBUcnVlVHlwZSBkb2VzIG5vdCBhc3NpZ24gYSBudW1lcmljIGNvZGUuXG4vLyBodHRwczovL2RldmVsb3Blci5hcHBsZS5jb20vZm9udHMvVHJ1ZVR5cGUtUmVmZXJlbmNlLU1hbnVhbC9STTA2L0NoYXA2bHRhZy5odG1sXG4vLyBodHRwOi8vd3d3LnczLm9yZy9JbnRlcm5hdGlvbmFsL2FydGljbGVzL2xhbmd1YWdlLXRhZ3MvXG4vLyBodHRwOi8vd3d3LmlhbmEub3JnL2Fzc2lnbm1lbnRzL2xhbmd1YWdlLXN1YnRhZy1yZWdpc3RyeS9sYW5ndWFnZS1zdWJ0YWctcmVnaXN0cnlcblxuaW1wb3J0IGNoZWNrIGZyb20gJy4uL2NoZWNrJztcbmltcG9ydCBwYXJzZSBmcm9tICcuLi9wYXJzZSc7XG5pbXBvcnQgdGFibGUgZnJvbSAnLi4vdGFibGUnO1xuXG5mdW5jdGlvbiBtYWtlTHRhZ1RhYmxlKHRhZ3MpIHtcbiAgICBjb25zdCByZXN1bHQgPSBuZXcgdGFibGUuVGFibGUoJ2x0YWcnLCBbXG4gICAgICAgIHtuYW1lOiAndmVyc2lvbicsIHR5cGU6ICdVTE9ORycsIHZhbHVlOiAxfSxcbiAgICAgICAge25hbWU6ICdmbGFncycsIHR5cGU6ICdVTE9ORycsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICdudW1UYWdzJywgdHlwZTogJ1VMT05HJywgdmFsdWU6IHRhZ3MubGVuZ3RofVxuICAgIF0pO1xuXG4gICAgbGV0IHN0cmluZ1Bvb2wgPSAnJztcbiAgICBjb25zdCBzdHJpbmdQb29sT2Zmc2V0ID0gMTIgKyB0YWdzLmxlbmd0aCAqIDQ7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0YWdzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGxldCBwb3MgPSBzdHJpbmdQb29sLmluZGV4T2YodGFnc1tpXSk7XG4gICAgICAgIGlmIChwb3MgPCAwKSB7XG4gICAgICAgICAgICBwb3MgPSBzdHJpbmdQb29sLmxlbmd0aDtcbiAgICAgICAgICAgIHN0cmluZ1Bvb2wgKz0gdGFnc1tpXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdC5maWVsZHMucHVzaCh7bmFtZTogJ29mZnNldCAnICsgaSwgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiBzdHJpbmdQb29sT2Zmc2V0ICsgcG9zfSk7XG4gICAgICAgIHJlc3VsdC5maWVsZHMucHVzaCh7bmFtZTogJ2xlbmd0aCAnICsgaSwgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiB0YWdzW2ldLmxlbmd0aH0pO1xuICAgIH1cblxuICAgIHJlc3VsdC5maWVsZHMucHVzaCh7bmFtZTogJ3N0cmluZ1Bvb2wnLCB0eXBlOiAnQ0hBUkFSUkFZJywgdmFsdWU6IHN0cmluZ1Bvb2x9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBwYXJzZUx0YWdUYWJsZShkYXRhLCBzdGFydCkge1xuICAgIGNvbnN0IHAgPSBuZXcgcGFyc2UuUGFyc2VyKGRhdGEsIHN0YXJ0KTtcbiAgICBjb25zdCB0YWJsZVZlcnNpb24gPSBwLnBhcnNlVUxvbmcoKTtcbiAgICBjaGVjay5hcmd1bWVudCh0YWJsZVZlcnNpb24gPT09IDEsICdVbnN1cHBvcnRlZCBsdGFnIHRhYmxlIHZlcnNpb24uJyk7XG4gICAgLy8gVGhlICdsdGFnJyBzcGVjaWZpY2F0aW9uIGRvZXMgbm90IGRlZmluZSBhbnkgZmxhZ3M7IHNraXAgdGhlIGZpZWxkLlxuICAgIHAuc2tpcCgndUxvbmcnLCAxKTtcbiAgICBjb25zdCBudW1UYWdzID0gcC5wYXJzZVVMb25nKCk7XG5cbiAgICBjb25zdCB0YWdzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1UYWdzOyBpKyspIHtcbiAgICAgICAgbGV0IHRhZyA9ICcnO1xuICAgICAgICBjb25zdCBvZmZzZXQgPSBzdGFydCArIHAucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICBmb3IgKGxldCBqID0gb2Zmc2V0OyBqIDwgb2Zmc2V0ICsgbGVuZ3RoOyArK2opIHtcbiAgICAgICAgICAgIHRhZyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGRhdGEuZ2V0SW50OChqKSk7XG4gICAgICAgIH1cblxuICAgICAgICB0YWdzLnB1c2godGFnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGFncztcbn1cblxuZXhwb3J0IGRlZmF1bHQgeyBtYWtlOiBtYWtlTHRhZ1RhYmxlLCBwYXJzZTogcGFyc2VMdGFnVGFibGUgfTtcbiIsIi8vIFRoZSBgbWF4cGAgdGFibGUgZXN0YWJsaXNoZXMgdGhlIG1lbW9yeSByZXF1aXJlbWVudHMgZm9yIHRoZSBmb250LlxuLy8gV2UgbmVlZCBpdCBqdXN0IHRvIGdldCB0aGUgbnVtYmVyIG9mIGdseXBocyBpbiB0aGUgZm9udC5cbi8vIGh0dHBzOi8vd3d3Lm1pY3Jvc29mdC5jb20vdHlwb2dyYXBoeS9PVFNQRUMvbWF4cC5odG1cblxuaW1wb3J0IHBhcnNlIGZyb20gJy4uL3BhcnNlJztcbmltcG9ydCB0YWJsZSBmcm9tICcuLi90YWJsZSc7XG5cbi8vIFBhcnNlIHRoZSBtYXhpbXVtIHByb2ZpbGUgYG1heHBgIHRhYmxlLlxuZnVuY3Rpb24gcGFyc2VNYXhwVGFibGUoZGF0YSwgc3RhcnQpIHtcbiAgICBjb25zdCBtYXhwID0ge307XG4gICAgY29uc3QgcCA9IG5ldyBwYXJzZS5QYXJzZXIoZGF0YSwgc3RhcnQpO1xuICAgIG1heHAudmVyc2lvbiA9IHAucGFyc2VWZXJzaW9uKCk7XG4gICAgbWF4cC5udW1HbHlwaHMgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgaWYgKG1heHAudmVyc2lvbiA9PT0gMS4wKSB7XG4gICAgICAgIG1heHAubWF4UG9pbnRzID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICBtYXhwLm1heENvbnRvdXJzID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICBtYXhwLm1heENvbXBvc2l0ZVBvaW50cyA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgbWF4cC5tYXhDb21wb3NpdGVDb250b3VycyA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgbWF4cC5tYXhab25lcyA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgbWF4cC5tYXhUd2lsaWdodFBvaW50cyA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgbWF4cC5tYXhTdG9yYWdlID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICBtYXhwLm1heEZ1bmN0aW9uRGVmcyA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgbWF4cC5tYXhJbnN0cnVjdGlvbkRlZnMgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgIG1heHAubWF4U3RhY2tFbGVtZW50cyA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgbWF4cC5tYXhTaXplT2ZJbnN0cnVjdGlvbnMgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgIG1heHAubWF4Q29tcG9uZW50RWxlbWVudHMgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgIG1heHAubWF4Q29tcG9uZW50RGVwdGggPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1heHA7XG59XG5cbmZ1bmN0aW9uIG1ha2VNYXhwVGFibGUobnVtR2x5cGhzKSB7XG4gICAgcmV0dXJuIG5ldyB0YWJsZS5UYWJsZSgnbWF4cCcsIFtcbiAgICAgICAge25hbWU6ICd2ZXJzaW9uJywgdHlwZTogJ0ZJWEVEJywgdmFsdWU6IDB4MDAwMDUwMDB9LFxuICAgICAgICB7bmFtZTogJ251bUdseXBocycsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogbnVtR2x5cGhzfVxuICAgIF0pO1xufVxuXG5leHBvcnQgZGVmYXVsdCB7IHBhcnNlOiBwYXJzZU1heHBUYWJsZSwgbWFrZTogbWFrZU1heHBUYWJsZSB9O1xuIiwiLy8gVGhlIGBuYW1lYCBuYW1pbmcgdGFibGUuXG4vLyBodHRwczovL3d3dy5taWNyb3NvZnQuY29tL3R5cG9ncmFwaHkvT1RTUEVDL25hbWUuaHRtXG5cbmltcG9ydCB7IGRlY29kZSwgZW5jb2RlIH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHBhcnNlIGZyb20gJy4uL3BhcnNlJztcbmltcG9ydCB0YWJsZSBmcm9tICcuLi90YWJsZSc7XG5cbi8vIE5hbWVJRHMgZm9yIHRoZSBuYW1lIHRhYmxlLlxuY29uc3QgbmFtZVRhYmxlTmFtZXMgPSBbXG4gICAgJ2NvcHlyaWdodCcsICAgICAgICAgICAgICAvLyAwXG4gICAgJ2ZvbnRGYW1pbHknLCAgICAgICAgICAgICAvLyAxXG4gICAgJ2ZvbnRTdWJmYW1pbHknLCAgICAgICAgICAvLyAyXG4gICAgJ3VuaXF1ZUlEJywgICAgICAgICAgICAgICAvLyAzXG4gICAgJ2Z1bGxOYW1lJywgICAgICAgICAgICAgICAvLyA0XG4gICAgJ3ZlcnNpb24nLCAgICAgICAgICAgICAgICAvLyA1XG4gICAgJ3Bvc3RTY3JpcHROYW1lJywgICAgICAgICAvLyA2XG4gICAgJ3RyYWRlbWFyaycsICAgICAgICAgICAgICAvLyA3XG4gICAgJ21hbnVmYWN0dXJlcicsICAgICAgICAgICAvLyA4XG4gICAgJ2Rlc2lnbmVyJywgICAgICAgICAgICAgICAvLyA5XG4gICAgJ2Rlc2NyaXB0aW9uJywgICAgICAgICAgICAvLyAxMFxuICAgICdtYW51ZmFjdHVyZXJVUkwnLCAgICAgICAgLy8gMTFcbiAgICAnZGVzaWduZXJVUkwnLCAgICAgICAgICAgIC8vIDEyXG4gICAgJ2xpY2Vuc2UnLCAgICAgICAgICAgICAgICAvLyAxM1xuICAgICdsaWNlbnNlVVJMJywgICAgICAgICAgICAgLy8gMTRcbiAgICAncmVzZXJ2ZWQnLCAgICAgICAgICAgICAgIC8vIDE1XG4gICAgJ3ByZWZlcnJlZEZhbWlseScsICAgICAgICAvLyAxNlxuICAgICdwcmVmZXJyZWRTdWJmYW1pbHknLCAgICAgLy8gMTdcbiAgICAnY29tcGF0aWJsZUZ1bGxOYW1lJywgICAgIC8vIDE4XG4gICAgJ3NhbXBsZVRleHQnLCAgICAgICAgICAgICAvLyAxOVxuICAgICdwb3N0U2NyaXB0RmluZEZvbnROYW1lJywgLy8gMjBcbiAgICAnd3dzRmFtaWx5JywgICAgICAgICAgICAgIC8vIDIxXG4gICAgJ3d3c1N1YmZhbWlseScgICAgICAgICAgICAvLyAyMlxuXTtcblxuY29uc3QgbWFjTGFuZ3VhZ2VzID0ge1xuICAgIDA6ICdlbicsXG4gICAgMTogJ2ZyJyxcbiAgICAyOiAnZGUnLFxuICAgIDM6ICdpdCcsXG4gICAgNDogJ25sJyxcbiAgICA1OiAnc3YnLFxuICAgIDY6ICdlcycsXG4gICAgNzogJ2RhJyxcbiAgICA4OiAncHQnLFxuICAgIDk6ICdubycsXG4gICAgMTA6ICdoZScsXG4gICAgMTE6ICdqYScsXG4gICAgMTI6ICdhcicsXG4gICAgMTM6ICdmaScsXG4gICAgMTQ6ICdlbCcsXG4gICAgMTU6ICdpcycsXG4gICAgMTY6ICdtdCcsXG4gICAgMTc6ICd0cicsXG4gICAgMTg6ICdocicsXG4gICAgMTk6ICd6aC1IYW50JyxcbiAgICAyMDogJ3VyJyxcbiAgICAyMTogJ2hpJyxcbiAgICAyMjogJ3RoJyxcbiAgICAyMzogJ2tvJyxcbiAgICAyNDogJ2x0JyxcbiAgICAyNTogJ3BsJyxcbiAgICAyNjogJ2h1JyxcbiAgICAyNzogJ2VzJyxcbiAgICAyODogJ2x2JyxcbiAgICAyOTogJ3NlJyxcbiAgICAzMDogJ2ZvJyxcbiAgICAzMTogJ2ZhJyxcbiAgICAzMjogJ3J1JyxcbiAgICAzMzogJ3poJyxcbiAgICAzNDogJ25sLUJFJyxcbiAgICAzNTogJ2dhJyxcbiAgICAzNjogJ3NxJyxcbiAgICAzNzogJ3JvJyxcbiAgICAzODogJ2N6JyxcbiAgICAzOTogJ3NrJyxcbiAgICA0MDogJ3NpJyxcbiAgICA0MTogJ3lpJyxcbiAgICA0MjogJ3NyJyxcbiAgICA0MzogJ21rJyxcbiAgICA0NDogJ2JnJyxcbiAgICA0NTogJ3VrJyxcbiAgICA0NjogJ2JlJyxcbiAgICA0NzogJ3V6JyxcbiAgICA0ODogJ2trJyxcbiAgICA0OTogJ2F6LUN5cmwnLFxuICAgIDUwOiAnYXotQXJhYicsXG4gICAgNTE6ICdoeScsXG4gICAgNTI6ICdrYScsXG4gICAgNTM6ICdtbycsXG4gICAgNTQ6ICdreScsXG4gICAgNTU6ICd0ZycsXG4gICAgNTY6ICd0aycsXG4gICAgNTc6ICdtbi1DTicsXG4gICAgNTg6ICdtbicsXG4gICAgNTk6ICdwcycsXG4gICAgNjA6ICdrcycsXG4gICAgNjE6ICdrdScsXG4gICAgNjI6ICdzZCcsXG4gICAgNjM6ICdibycsXG4gICAgNjQ6ICduZScsXG4gICAgNjU6ICdzYScsXG4gICAgNjY6ICdtcicsXG4gICAgNjc6ICdibicsXG4gICAgNjg6ICdhcycsXG4gICAgNjk6ICdndScsXG4gICAgNzA6ICdwYScsXG4gICAgNzE6ICdvcicsXG4gICAgNzI6ICdtbCcsXG4gICAgNzM6ICdrbicsXG4gICAgNzQ6ICd0YScsXG4gICAgNzU6ICd0ZScsXG4gICAgNzY6ICdzaScsXG4gICAgNzc6ICdteScsXG4gICAgNzg6ICdrbScsXG4gICAgNzk6ICdsbycsXG4gICAgODA6ICd2aScsXG4gICAgODE6ICdpZCcsXG4gICAgODI6ICd0bCcsXG4gICAgODM6ICdtcycsXG4gICAgODQ6ICdtcy1BcmFiJyxcbiAgICA4NTogJ2FtJyxcbiAgICA4NjogJ3RpJyxcbiAgICA4NzogJ29tJyxcbiAgICA4ODogJ3NvJyxcbiAgICA4OTogJ3N3JyxcbiAgICA5MDogJ3J3JyxcbiAgICA5MTogJ3JuJyxcbiAgICA5MjogJ255JyxcbiAgICA5MzogJ21nJyxcbiAgICA5NDogJ2VvJyxcbiAgICAxMjg6ICdjeScsXG4gICAgMTI5OiAnZXUnLFxuICAgIDEzMDogJ2NhJyxcbiAgICAxMzE6ICdsYScsXG4gICAgMTMyOiAncXUnLFxuICAgIDEzMzogJ2duJyxcbiAgICAxMzQ6ICdheScsXG4gICAgMTM1OiAndHQnLFxuICAgIDEzNjogJ3VnJyxcbiAgICAxMzc6ICdkeicsXG4gICAgMTM4OiAnanYnLFxuICAgIDEzOTogJ3N1JyxcbiAgICAxNDA6ICdnbCcsXG4gICAgMTQxOiAnYWYnLFxuICAgIDE0MjogJ2JyJyxcbiAgICAxNDM6ICdpdScsXG4gICAgMTQ0OiAnZ2QnLFxuICAgIDE0NTogJ2d2JyxcbiAgICAxNDY6ICdnYScsXG4gICAgMTQ3OiAndG8nLFxuICAgIDE0ODogJ2VsLXBvbHl0b24nLFxuICAgIDE0OTogJ2tsJyxcbiAgICAxNTA6ICdheicsXG4gICAgMTUxOiAnbm4nXG59O1xuXG4vLyBNYWNPUyBsYW5ndWFnZSBJRCDihpIgTWFjT1Mgc2NyaXB0IElEXG4vL1xuLy8gTm90ZSB0aGF0IHRoZSBzY3JpcHQgSUQgaXMgbm90IHN1ZmZpY2llbnQgdG8gZGV0ZXJtaW5lIHdoYXQgZW5jb2Rpbmdcbi8vIHRvIHVzZSBpbiBUcnVlVHlwZSBmaWxlcy4gRm9yIHNvbWUgbGFuZ3VhZ2VzLCBNYWNPUyB1c2VkIGEgbW9kaWZpY2F0aW9uXG4vLyBvZiBhIG1haW5zdHJlYW0gc2NyaXB0LiBGb3IgZXhhbXBsZSwgYW4gSWNlbGFuZGljIG5hbWUgd291bGQgYmUgc3RvcmVkXG4vLyB3aXRoIHNtUm9tYW4gaW4gdGhlIFRydWVUeXBlIG5hbWluZyB0YWJsZSwgYnV0IHRoZSBhY3R1YWwgZW5jb2Rpbmdcbi8vIGlzIGEgc3BlY2lhbCBJY2VsYW5kaWMgdmVyc2lvbiBvZiB0aGUgbm9ybWFsIE1hY2ludG9zaCBSb21hbiBlbmNvZGluZy5cbi8vIEFzIGFub3RoZXIgZXhhbXBsZSwgSW51a3RpdHV0IHVzZXMgYW4gOC1iaXQgZW5jb2RpbmcgZm9yIENhbmFkaWFuIEFib3JpZ2luYWxcbi8vIFN5bGxhYmxlcyBidXQgTWFjT1MgaGFkIHJ1biBvdXQgb2YgYXZhaWxhYmxlIHNjcmlwdCBjb2Rlcywgc28gdGhpcyB3YXNcbi8vIGRvbmUgYXMgYSAocHJldHR5IHJhZGljYWwpIFwibW9kaWZpY2F0aW9uXCIgb2YgRXRoaW9waWMuXG4vL1xuLy8gaHR0cDovL3VuaWNvZGUub3JnL1B1YmxpYy9NQVBQSU5HUy9WRU5ET1JTL0FQUExFL1JlYWRtZS50eHRcbmNvbnN0IG1hY0xhbmd1YWdlVG9TY3JpcHQgPSB7XG4gICAgMDogMCwgIC8vIGxhbmdFbmdsaXNoIOKGkiBzbVJvbWFuXG4gICAgMTogMCwgIC8vIGxhbmdGcmVuY2gg4oaSIHNtUm9tYW5cbiAgICAyOiAwLCAgLy8gbGFuZ0dlcm1hbiDihpIgc21Sb21hblxuICAgIDM6IDAsICAvLyBsYW5nSXRhbGlhbiDihpIgc21Sb21hblxuICAgIDQ6IDAsICAvLyBsYW5nRHV0Y2gg4oaSIHNtUm9tYW5cbiAgICA1OiAwLCAgLy8gbGFuZ1N3ZWRpc2gg4oaSIHNtUm9tYW5cbiAgICA2OiAwLCAgLy8gbGFuZ1NwYW5pc2gg4oaSIHNtUm9tYW5cbiAgICA3OiAwLCAgLy8gbGFuZ0RhbmlzaCDihpIgc21Sb21hblxuICAgIDg6IDAsICAvLyBsYW5nUG9ydHVndWVzZSDihpIgc21Sb21hblxuICAgIDk6IDAsICAvLyBsYW5nTm9yd2VnaWFuIOKGkiBzbVJvbWFuXG4gICAgMTA6IDUsICAvLyBsYW5nSGVicmV3IOKGkiBzbUhlYnJld1xuICAgIDExOiAxLCAgLy8gbGFuZ0phcGFuZXNlIOKGkiBzbUphcGFuZXNlXG4gICAgMTI6IDQsICAvLyBsYW5nQXJhYmljIOKGkiBzbUFyYWJpY1xuICAgIDEzOiAwLCAgLy8gbGFuZ0Zpbm5pc2gg4oaSIHNtUm9tYW5cbiAgICAxNDogNiwgIC8vIGxhbmdHcmVlayDihpIgc21HcmVla1xuICAgIDE1OiAwLCAgLy8gbGFuZ0ljZWxhbmRpYyDihpIgc21Sb21hbiAobW9kaWZpZWQpXG4gICAgMTY6IDAsICAvLyBsYW5nTWFsdGVzZSDihpIgc21Sb21hblxuICAgIDE3OiAwLCAgLy8gbGFuZ1R1cmtpc2gg4oaSIHNtUm9tYW4gKG1vZGlmaWVkKVxuICAgIDE4OiAwLCAgLy8gbGFuZ0Nyb2F0aWFuIOKGkiBzbVJvbWFuIChtb2RpZmllZClcbiAgICAxOTogMiwgIC8vIGxhbmdUcmFkQ2hpbmVzZSDihpIgc21UcmFkQ2hpbmVzZVxuICAgIDIwOiA0LCAgLy8gbGFuZ1VyZHUg4oaSIHNtQXJhYmljXG4gICAgMjE6IDksICAvLyBsYW5nSGluZGkg4oaSIHNtRGV2YW5hZ2FyaVxuICAgIDIyOiAyMSwgIC8vIGxhbmdUaGFpIOKGkiBzbVRoYWlcbiAgICAyMzogMywgIC8vIGxhbmdLb3JlYW4g4oaSIHNtS29yZWFuXG4gICAgMjQ6IDI5LCAgLy8gbGFuZ0xpdGh1YW5pYW4g4oaSIHNtQ2VudHJhbEV1cm9Sb21hblxuICAgIDI1OiAyOSwgIC8vIGxhbmdQb2xpc2gg4oaSIHNtQ2VudHJhbEV1cm9Sb21hblxuICAgIDI2OiAyOSwgIC8vIGxhbmdIdW5nYXJpYW4g4oaSIHNtQ2VudHJhbEV1cm9Sb21hblxuICAgIDI3OiAyOSwgIC8vIGxhbmdFc3RvbmlhbiDihpIgc21DZW50cmFsRXVyb1JvbWFuXG4gICAgMjg6IDI5LCAgLy8gbGFuZ0xhdHZpYW4g4oaSIHNtQ2VudHJhbEV1cm9Sb21hblxuICAgIDI5OiAwLCAgLy8gbGFuZ1NhbWkg4oaSIHNtUm9tYW5cbiAgICAzMDogMCwgIC8vIGxhbmdGYXJvZXNlIOKGkiBzbVJvbWFuIChtb2RpZmllZClcbiAgICAzMTogNCwgIC8vIGxhbmdGYXJzaSDihpIgc21BcmFiaWMgKG1vZGlmaWVkKVxuICAgIDMyOiA3LCAgLy8gbGFuZ1J1c3NpYW4g4oaSIHNtQ3lyaWxsaWNcbiAgICAzMzogMjUsICAvLyBsYW5nU2ltcENoaW5lc2Ug4oaSIHNtU2ltcENoaW5lc2VcbiAgICAzNDogMCwgIC8vIGxhbmdGbGVtaXNoIOKGkiBzbVJvbWFuXG4gICAgMzU6IDAsICAvLyBsYW5nSXJpc2hHYWVsaWMg4oaSIHNtUm9tYW4gKG1vZGlmaWVkKVxuICAgIDM2OiAwLCAgLy8gbGFuZ0FsYmFuaWFuIOKGkiBzbVJvbWFuXG4gICAgMzc6IDAsICAvLyBsYW5nUm9tYW5pYW4g4oaSIHNtUm9tYW4gKG1vZGlmaWVkKVxuICAgIDM4OiAyOSwgIC8vIGxhbmdDemVjaCDihpIgc21DZW50cmFsRXVyb1JvbWFuXG4gICAgMzk6IDI5LCAgLy8gbGFuZ1Nsb3ZhayDihpIgc21DZW50cmFsRXVyb1JvbWFuXG4gICAgNDA6IDAsICAvLyBsYW5nU2xvdmVuaWFuIOKGkiBzbVJvbWFuIChtb2RpZmllZClcbiAgICA0MTogNSwgIC8vIGxhbmdZaWRkaXNoIOKGkiBzbUhlYnJld1xuICAgIDQyOiA3LCAgLy8gbGFuZ1NlcmJpYW4g4oaSIHNtQ3lyaWxsaWNcbiAgICA0MzogNywgIC8vIGxhbmdNYWNlZG9uaWFuIOKGkiBzbUN5cmlsbGljXG4gICAgNDQ6IDcsICAvLyBsYW5nQnVsZ2FyaWFuIOKGkiBzbUN5cmlsbGljXG4gICAgNDU6IDcsICAvLyBsYW5nVWtyYWluaWFuIOKGkiBzbUN5cmlsbGljIChtb2RpZmllZClcbiAgICA0NjogNywgIC8vIGxhbmdCeWVsb3J1c3NpYW4g4oaSIHNtQ3lyaWxsaWNcbiAgICA0NzogNywgIC8vIGxhbmdVemJlayDihpIgc21DeXJpbGxpY1xuICAgIDQ4OiA3LCAgLy8gbGFuZ0themFraCDihpIgc21DeXJpbGxpY1xuICAgIDQ5OiA3LCAgLy8gbGFuZ0F6ZXJiYWlqYW5pIOKGkiBzbUN5cmlsbGljXG4gICAgNTA6IDQsICAvLyBsYW5nQXplcmJhaWphbkFyIOKGkiBzbUFyYWJpY1xuICAgIDUxOiAyNCwgIC8vIGxhbmdBcm1lbmlhbiDihpIgc21Bcm1lbmlhblxuICAgIDUyOiAyMywgIC8vIGxhbmdHZW9yZ2lhbiDihpIgc21HZW9yZ2lhblxuICAgIDUzOiA3LCAgLy8gbGFuZ01vbGRhdmlhbiDihpIgc21DeXJpbGxpY1xuICAgIDU0OiA3LCAgLy8gbGFuZ0tpcmdoaXog4oaSIHNtQ3lyaWxsaWNcbiAgICA1NTogNywgIC8vIGxhbmdUYWppa2kg4oaSIHNtQ3lyaWxsaWNcbiAgICA1NjogNywgIC8vIGxhbmdUdXJrbWVuIOKGkiBzbUN5cmlsbGljXG4gICAgNTc6IDI3LCAgLy8gbGFuZ01vbmdvbGlhbiDihpIgc21Nb25nb2xpYW5cbiAgICA1ODogNywgIC8vIGxhbmdNb25nb2xpYW5DeXIg4oaSIHNtQ3lyaWxsaWNcbiAgICA1OTogNCwgIC8vIGxhbmdQYXNodG8g4oaSIHNtQXJhYmljXG4gICAgNjA6IDQsICAvLyBsYW5nS3VyZGlzaCDihpIgc21BcmFiaWNcbiAgICA2MTogNCwgIC8vIGxhbmdLYXNobWlyaSDihpIgc21BcmFiaWNcbiAgICA2MjogNCwgIC8vIGxhbmdTaW5kaGkg4oaSIHNtQXJhYmljXG4gICAgNjM6IDI2LCAgLy8gbGFuZ1RpYmV0YW4g4oaSIHNtVGliZXRhblxuICAgIDY0OiA5LCAgLy8gbGFuZ05lcGFsaSDihpIgc21EZXZhbmFnYXJpXG4gICAgNjU6IDksICAvLyBsYW5nU2Fuc2tyaXQg4oaSIHNtRGV2YW5hZ2FyaVxuICAgIDY2OiA5LCAgLy8gbGFuZ01hcmF0aGkg4oaSIHNtRGV2YW5hZ2FyaVxuICAgIDY3OiAxMywgIC8vIGxhbmdCZW5nYWxpIOKGkiBzbUJlbmdhbGlcbiAgICA2ODogMTMsICAvLyBsYW5nQXNzYW1lc2Ug4oaSIHNtQmVuZ2FsaVxuICAgIDY5OiAxMSwgIC8vIGxhbmdHdWphcmF0aSDihpIgc21HdWphcmF0aVxuICAgIDcwOiAxMCwgIC8vIGxhbmdQdW5qYWJpIOKGkiBzbUd1cm11a2hpXG4gICAgNzE6IDEyLCAgLy8gbGFuZ09yaXlhIOKGkiBzbU9yaXlhXG4gICAgNzI6IDE3LCAgLy8gbGFuZ01hbGF5YWxhbSDihpIgc21NYWxheWFsYW1cbiAgICA3MzogMTYsICAvLyBsYW5nS2FubmFkYSDihpIgc21LYW5uYWRhXG4gICAgNzQ6IDE0LCAgLy8gbGFuZ1RhbWlsIOKGkiBzbVRhbWlsXG4gICAgNzU6IDE1LCAgLy8gbGFuZ1RlbHVndSDihpIgc21UZWx1Z3VcbiAgICA3NjogMTgsICAvLyBsYW5nU2luaGFsZXNlIOKGkiBzbVNpbmhhbGVzZVxuICAgIDc3OiAxOSwgIC8vIGxhbmdCdXJtZXNlIOKGkiBzbUJ1cm1lc2VcbiAgICA3ODogMjAsICAvLyBsYW5nS2htZXIg4oaSIHNtS2htZXJcbiAgICA3OTogMjIsICAvLyBsYW5nTGFvIOKGkiBzbUxhb1xuICAgIDgwOiAzMCwgIC8vIGxhbmdWaWV0bmFtZXNlIOKGkiBzbVZpZXRuYW1lc2VcbiAgICA4MTogMCwgIC8vIGxhbmdJbmRvbmVzaWFuIOKGkiBzbVJvbWFuXG4gICAgODI6IDAsICAvLyBsYW5nVGFnYWxvZyDihpIgc21Sb21hblxuICAgIDgzOiAwLCAgLy8gbGFuZ01hbGF5Um9tYW4g4oaSIHNtUm9tYW5cbiAgICA4NDogNCwgIC8vIGxhbmdNYWxheUFyYWJpYyDihpIgc21BcmFiaWNcbiAgICA4NTogMjgsICAvLyBsYW5nQW1oYXJpYyDihpIgc21FdGhpb3BpY1xuICAgIDg2OiAyOCwgIC8vIGxhbmdUaWdyaW55YSDihpIgc21FdGhpb3BpY1xuICAgIDg3OiAyOCwgIC8vIGxhbmdPcm9tbyDihpIgc21FdGhpb3BpY1xuICAgIDg4OiAwLCAgLy8gbGFuZ1NvbWFsaSDihpIgc21Sb21hblxuICAgIDg5OiAwLCAgLy8gbGFuZ1N3YWhpbGkg4oaSIHNtUm9tYW5cbiAgICA5MDogMCwgIC8vIGxhbmdLaW55YXJ3YW5kYSDihpIgc21Sb21hblxuICAgIDkxOiAwLCAgLy8gbGFuZ1J1bmRpIOKGkiBzbVJvbWFuXG4gICAgOTI6IDAsICAvLyBsYW5nTnlhbmphIOKGkiBzbVJvbWFuXG4gICAgOTM6IDAsICAvLyBsYW5nTWFsYWdhc3kg4oaSIHNtUm9tYW5cbiAgICA5NDogMCwgIC8vIGxhbmdFc3BlcmFudG8g4oaSIHNtUm9tYW5cbiAgICAxMjg6IDAsICAvLyBsYW5nV2Vsc2gg4oaSIHNtUm9tYW4gKG1vZGlmaWVkKVxuICAgIDEyOTogMCwgIC8vIGxhbmdCYXNxdWUg4oaSIHNtUm9tYW5cbiAgICAxMzA6IDAsICAvLyBsYW5nQ2F0YWxhbiDihpIgc21Sb21hblxuICAgIDEzMTogMCwgIC8vIGxhbmdMYXRpbiDihpIgc21Sb21hblxuICAgIDEzMjogMCwgIC8vIGxhbmdRdWVjaHVhIOKGkiBzbVJvbWFuXG4gICAgMTMzOiAwLCAgLy8gbGFuZ0d1YXJhbmkg4oaSIHNtUm9tYW5cbiAgICAxMzQ6IDAsICAvLyBsYW5nQXltYXJhIOKGkiBzbVJvbWFuXG4gICAgMTM1OiA3LCAgLy8gbGFuZ1RhdGFyIOKGkiBzbUN5cmlsbGljXG4gICAgMTM2OiA0LCAgLy8gbGFuZ1VpZ2h1ciDihpIgc21BcmFiaWNcbiAgICAxMzc6IDI2LCAgLy8gbGFuZ0R6b25na2hhIOKGkiBzbVRpYmV0YW5cbiAgICAxMzg6IDAsICAvLyBsYW5nSmF2YW5lc2VSb20g4oaSIHNtUm9tYW5cbiAgICAxMzk6IDAsICAvLyBsYW5nU3VuZGFuZXNlUm9tIOKGkiBzbVJvbWFuXG4gICAgMTQwOiAwLCAgLy8gbGFuZ0dhbGljaWFuIOKGkiBzbVJvbWFuXG4gICAgMTQxOiAwLCAgLy8gbGFuZ0FmcmlrYWFucyDihpIgc21Sb21hblxuICAgIDE0MjogMCwgIC8vIGxhbmdCcmV0b24g4oaSIHNtUm9tYW4gKG1vZGlmaWVkKVxuICAgIDE0MzogMjgsICAvLyBsYW5nSW51a3RpdHV0IOKGkiBzbUV0aGlvcGljIChtb2RpZmllZClcbiAgICAxNDQ6IDAsICAvLyBsYW5nU2NvdHRpc2hHYWVsaWMg4oaSIHNtUm9tYW4gKG1vZGlmaWVkKVxuICAgIDE0NTogMCwgIC8vIGxhbmdNYW54R2FlbGljIOKGkiBzbVJvbWFuIChtb2RpZmllZClcbiAgICAxNDY6IDAsICAvLyBsYW5nSXJpc2hHYWVsaWNTY3JpcHQg4oaSIHNtUm9tYW4gKG1vZGlmaWVkKVxuICAgIDE0NzogMCwgIC8vIGxhbmdUb25nYW4g4oaSIHNtUm9tYW5cbiAgICAxNDg6IDYsICAvLyBsYW5nR3JlZWtBbmNpZW50IOKGkiBzbVJvbWFuXG4gICAgMTQ5OiAwLCAgLy8gbGFuZ0dyZWVubGFuZGljIOKGkiBzbVJvbWFuXG4gICAgMTUwOiAwLCAgLy8gbGFuZ0F6ZXJiYWlqYW5Sb21hbiDihpIgc21Sb21hblxuICAgIDE1MTogMCAgIC8vIGxhbmdOeW5vcnNrIOKGkiBzbVJvbWFuXG59O1xuXG4vLyBXaGlsZSBNaWNyb3NvZnQgaW5kaWNhdGVzIGEgcmVnaW9uL2NvdW50cnkgZm9yIGFsbCBpdHMgbGFuZ3VhZ2Vcbi8vIElEcywgd2Ugb21pdCB0aGUgcmVnaW9uIGNvZGUgaWYgaXQncyBlcXVhbCB0byB0aGUgXCJtb3N0IGxpa2VseVxuLy8gcmVnaW9uIHN1YnRhZ1wiIGFjY29yZGluZyB0byBVbmljb2RlIENMRFIuIEZvciBzY3JpcHRzLCB3ZSBvbWl0XG4vLyB0aGUgc3VidGFnIGlmIGl0IGlzIGVxdWFsIHRvIHRoZSBTdXBwcmVzcy1TY3JpcHQgZW50cnkgaW4gdGhlXG4vLyBJQU5BIGxhbmd1YWdlIHN1YnRhZyByZWdpc3RyeSBmb3IgSUVURiBCQ1AgNDcuXG4vL1xuLy8gRm9yIGV4YW1wbGUsIE1pY3Jvc29mdCBzdGF0ZXMgdGhhdCBpdHMgbGFuZ3VhZ2UgY29kZSAweDA0MUEgaXNcbi8vIENyb2F0aWFuIGluIENyb2F0aWEuIFdlIHRyYW5zZm9ybSB0aGlzIHRvIHRoZSBCQ1AgNDcgbGFuZ3VhZ2UgY29kZSAnaHInXG4vLyBhbmQgbm90ICdoci1IUicgYmVjYXVzZSBDcm9hdGlhIGlzIHRoZSBkZWZhdWx0IGNvdW50cnkgZm9yIENyb2F0aWFuLFxuLy8gYWNjb3JkaW5nIHRvIFVuaWNvZGUgQ0xEUi4gQXMgYW5vdGhlciBleGFtcGxlLCBNaWNyb3NvZnQgc3RhdGVzXG4vLyB0aGF0IDB4MTAxQSBpcyBDcm9hdGlhbiAoTGF0aW4pIGluIEJvc25pYS1IZXJ6ZWdvdmluYS4gV2UgdHJhbnNmb3JtXG4vLyB0aGlzIHRvICdoci1CQScgYW5kIG5vdCAnaHItTGF0bi1CQScgYmVjYXVzZSBMYXRpbiBpcyB0aGUgZGVmYXVsdCBzY3JpcHRcbi8vIGZvciB0aGUgQ3JvYXRpYW4gbGFuZ3VhZ2UsIGFjY29yZGluZyB0byBJQU5BLlxuLy9cbi8vIGh0dHA6Ly93d3cudW5pY29kZS5vcmcvY2xkci9jaGFydHMvbGF0ZXN0L3N1cHBsZW1lbnRhbC9saWtlbHlfc3VidGFncy5odG1sXG4vLyBodHRwOi8vd3d3LmlhbmEub3JnL2Fzc2lnbm1lbnRzL2xhbmd1YWdlLXN1YnRhZy1yZWdpc3RyeS9sYW5ndWFnZS1zdWJ0YWctcmVnaXN0cnlcbmNvbnN0IHdpbmRvd3NMYW5ndWFnZXMgPSB7XG4gICAgMHgwNDM2OiAnYWYnLFxuICAgIDB4MDQxQzogJ3NxJyxcbiAgICAweDA0ODQ6ICdnc3cnLFxuICAgIDB4MDQ1RTogJ2FtJyxcbiAgICAweDE0MDE6ICdhci1EWicsXG4gICAgMHgzQzAxOiAnYXItQkgnLFxuICAgIDB4MEMwMTogJ2FyJyxcbiAgICAweDA4MDE6ICdhci1JUScsXG4gICAgMHgyQzAxOiAnYXItSk8nLFxuICAgIDB4MzQwMTogJ2FyLUtXJyxcbiAgICAweDMwMDE6ICdhci1MQicsXG4gICAgMHgxMDAxOiAnYXItTFknLFxuICAgIDB4MTgwMTogJ2FyeScsXG4gICAgMHgyMDAxOiAnYXItT00nLFxuICAgIDB4NDAwMTogJ2FyLVFBJyxcbiAgICAweDA0MDE6ICdhci1TQScsXG4gICAgMHgyODAxOiAnYXItU1knLFxuICAgIDB4MUMwMTogJ2FlYicsXG4gICAgMHgzODAxOiAnYXItQUUnLFxuICAgIDB4MjQwMTogJ2FyLVlFJyxcbiAgICAweDA0MkI6ICdoeScsXG4gICAgMHgwNDREOiAnYXMnLFxuICAgIDB4MDgyQzogJ2F6LUN5cmwnLFxuICAgIDB4MDQyQzogJ2F6JyxcbiAgICAweDA0NkQ6ICdiYScsXG4gICAgMHgwNDJEOiAnZXUnLFxuICAgIDB4MDQyMzogJ2JlJyxcbiAgICAweDA4NDU6ICdibicsXG4gICAgMHgwNDQ1OiAnYm4tSU4nLFxuICAgIDB4MjAxQTogJ2JzLUN5cmwnLFxuICAgIDB4MTQxQTogJ2JzJyxcbiAgICAweDA0N0U6ICdicicsXG4gICAgMHgwNDAyOiAnYmcnLFxuICAgIDB4MDQwMzogJ2NhJyxcbiAgICAweDBDMDQ6ICd6aC1ISycsXG4gICAgMHgxNDA0OiAnemgtTU8nLFxuICAgIDB4MDgwNDogJ3poJyxcbiAgICAweDEwMDQ6ICd6aC1TRycsXG4gICAgMHgwNDA0OiAnemgtVFcnLFxuICAgIDB4MDQ4MzogJ2NvJyxcbiAgICAweDA0MUE6ICdocicsXG4gICAgMHgxMDFBOiAnaHItQkEnLFxuICAgIDB4MDQwNTogJ2NzJyxcbiAgICAweDA0MDY6ICdkYScsXG4gICAgMHgwNDhDOiAncHJzJyxcbiAgICAweDA0NjU6ICdkdicsXG4gICAgMHgwODEzOiAnbmwtQkUnLFxuICAgIDB4MDQxMzogJ25sJyxcbiAgICAweDBDMDk6ICdlbi1BVScsXG4gICAgMHgyODA5OiAnZW4tQlonLFxuICAgIDB4MTAwOTogJ2VuLUNBJyxcbiAgICAweDI0MDk6ICdlbi0wMjknLFxuICAgIDB4NDAwOTogJ2VuLUlOJyxcbiAgICAweDE4MDk6ICdlbi1JRScsXG4gICAgMHgyMDA5OiAnZW4tSk0nLFxuICAgIDB4NDQwOTogJ2VuLU1ZJyxcbiAgICAweDE0MDk6ICdlbi1OWicsXG4gICAgMHgzNDA5OiAnZW4tUEgnLFxuICAgIDB4NDgwOTogJ2VuLVNHJyxcbiAgICAweDFDMDk6ICdlbi1aQScsXG4gICAgMHgyQzA5OiAnZW4tVFQnLFxuICAgIDB4MDgwOTogJ2VuLUdCJyxcbiAgICAweDA0MDk6ICdlbicsXG4gICAgMHgzMDA5OiAnZW4tWlcnLFxuICAgIDB4MDQyNTogJ2V0JyxcbiAgICAweDA0Mzg6ICdmbycsXG4gICAgMHgwNDY0OiAnZmlsJyxcbiAgICAweDA0MEI6ICdmaScsXG4gICAgMHgwODBDOiAnZnItQkUnLFxuICAgIDB4MEMwQzogJ2ZyLUNBJyxcbiAgICAweDA0MEM6ICdmcicsXG4gICAgMHgxNDBDOiAnZnItTFUnLFxuICAgIDB4MTgwQzogJ2ZyLU1DJyxcbiAgICAweDEwMEM6ICdmci1DSCcsXG4gICAgMHgwNDYyOiAnZnknLFxuICAgIDB4MDQ1NjogJ2dsJyxcbiAgICAweDA0Mzc6ICdrYScsXG4gICAgMHgwQzA3OiAnZGUtQVQnLFxuICAgIDB4MDQwNzogJ2RlJyxcbiAgICAweDE0MDc6ICdkZS1MSScsXG4gICAgMHgxMDA3OiAnZGUtTFUnLFxuICAgIDB4MDgwNzogJ2RlLUNIJyxcbiAgICAweDA0MDg6ICdlbCcsXG4gICAgMHgwNDZGOiAna2wnLFxuICAgIDB4MDQ0NzogJ2d1JyxcbiAgICAweDA0Njg6ICdoYScsXG4gICAgMHgwNDBEOiAnaGUnLFxuICAgIDB4MDQzOTogJ2hpJyxcbiAgICAweDA0MEU6ICdodScsXG4gICAgMHgwNDBGOiAnaXMnLFxuICAgIDB4MDQ3MDogJ2lnJyxcbiAgICAweDA0MjE6ICdpZCcsXG4gICAgMHgwNDVEOiAnaXUnLFxuICAgIDB4MDg1RDogJ2l1LUxhdG4nLFxuICAgIDB4MDgzQzogJ2dhJyxcbiAgICAweDA0MzQ6ICd4aCcsXG4gICAgMHgwNDM1OiAnenUnLFxuICAgIDB4MDQxMDogJ2l0JyxcbiAgICAweDA4MTA6ICdpdC1DSCcsXG4gICAgMHgwNDExOiAnamEnLFxuICAgIDB4MDQ0QjogJ2tuJyxcbiAgICAweDA0M0Y6ICdraycsXG4gICAgMHgwNDUzOiAna20nLFxuICAgIDB4MDQ4NjogJ3F1YycsXG4gICAgMHgwNDg3OiAncncnLFxuICAgIDB4MDQ0MTogJ3N3JyxcbiAgICAweDA0NTc6ICdrb2snLFxuICAgIDB4MDQxMjogJ2tvJyxcbiAgICAweDA0NDA6ICdreScsXG4gICAgMHgwNDU0OiAnbG8nLFxuICAgIDB4MDQyNjogJ2x2JyxcbiAgICAweDA0Mjc6ICdsdCcsXG4gICAgMHgwODJFOiAnZHNiJyxcbiAgICAweDA0NkU6ICdsYicsXG4gICAgMHgwNDJGOiAnbWsnLFxuICAgIDB4MDgzRTogJ21zLUJOJyxcbiAgICAweDA0M0U6ICdtcycsXG4gICAgMHgwNDRDOiAnbWwnLFxuICAgIDB4MDQzQTogJ210JyxcbiAgICAweDA0ODE6ICdtaScsXG4gICAgMHgwNDdBOiAnYXJuJyxcbiAgICAweDA0NEU6ICdtcicsXG4gICAgMHgwNDdDOiAnbW9oJyxcbiAgICAweDA0NTA6ICdtbicsXG4gICAgMHgwODUwOiAnbW4tQ04nLFxuICAgIDB4MDQ2MTogJ25lJyxcbiAgICAweDA0MTQ6ICduYicsXG4gICAgMHgwODE0OiAnbm4nLFxuICAgIDB4MDQ4MjogJ29jJyxcbiAgICAweDA0NDg6ICdvcicsXG4gICAgMHgwNDYzOiAncHMnLFxuICAgIDB4MDQxNTogJ3BsJyxcbiAgICAweDA0MTY6ICdwdCcsXG4gICAgMHgwODE2OiAncHQtUFQnLFxuICAgIDB4MDQ0NjogJ3BhJyxcbiAgICAweDA0NkI6ICdxdS1CTycsXG4gICAgMHgwODZCOiAncXUtRUMnLFxuICAgIDB4MEM2QjogJ3F1JyxcbiAgICAweDA0MTg6ICdybycsXG4gICAgMHgwNDE3OiAncm0nLFxuICAgIDB4MDQxOTogJ3J1JyxcbiAgICAweDI0M0I6ICdzbW4nLFxuICAgIDB4MTAzQjogJ3Ntai1OTycsXG4gICAgMHgxNDNCOiAnc21qJyxcbiAgICAweDBDM0I6ICdzZS1GSScsXG4gICAgMHgwNDNCOiAnc2UnLFxuICAgIDB4MDgzQjogJ3NlLVNFJyxcbiAgICAweDIwM0I6ICdzbXMnLFxuICAgIDB4MTgzQjogJ3NtYS1OTycsXG4gICAgMHgxQzNCOiAnc21zJyxcbiAgICAweDA0NEY6ICdzYScsXG4gICAgMHgxQzFBOiAnc3ItQ3lybC1CQScsXG4gICAgMHgwQzFBOiAnc3InLFxuICAgIDB4MTgxQTogJ3NyLUxhdG4tQkEnLFxuICAgIDB4MDgxQTogJ3NyLUxhdG4nLFxuICAgIDB4MDQ2QzogJ25zbycsXG4gICAgMHgwNDMyOiAndG4nLFxuICAgIDB4MDQ1QjogJ3NpJyxcbiAgICAweDA0MUI6ICdzaycsXG4gICAgMHgwNDI0OiAnc2wnLFxuICAgIDB4MkMwQTogJ2VzLUFSJyxcbiAgICAweDQwMEE6ICdlcy1CTycsXG4gICAgMHgzNDBBOiAnZXMtQ0wnLFxuICAgIDB4MjQwQTogJ2VzLUNPJyxcbiAgICAweDE0MEE6ICdlcy1DUicsXG4gICAgMHgxQzBBOiAnZXMtRE8nLFxuICAgIDB4MzAwQTogJ2VzLUVDJyxcbiAgICAweDQ0MEE6ICdlcy1TVicsXG4gICAgMHgxMDBBOiAnZXMtR1QnLFxuICAgIDB4NDgwQTogJ2VzLUhOJyxcbiAgICAweDA4MEE6ICdlcy1NWCcsXG4gICAgMHg0QzBBOiAnZXMtTkknLFxuICAgIDB4MTgwQTogJ2VzLVBBJyxcbiAgICAweDNDMEE6ICdlcy1QWScsXG4gICAgMHgyODBBOiAnZXMtUEUnLFxuICAgIDB4NTAwQTogJ2VzLVBSJyxcblxuICAgIC8vIE1pY3Jvc29mdCBoYXMgZGVmaW5lZCB0d28gZGlmZmVyZW50IGxhbmd1YWdlIGNvZGVzIGZvclxuICAgIC8vIOKAnFNwYW5pc2ggd2l0aCBtb2Rlcm4gc29ydGluZ+KAnSBhbmQg4oCcU3BhbmlzaCB3aXRoIHRyYWRpdGlvbmFsXG4gICAgLy8gc29ydGluZ+KAnS4gVGhpcyBtYWtlcyBzZW5zZSBmb3IgY29sbGF0aW9uIEFQSXMsIGFuZCBpdCB3b3VsZCBiZVxuICAgIC8vIHBvc3NpYmxlIHRvIGV4cHJlc3MgdGhpcyBpbiBCQ1AgNDcgbGFuZ3VhZ2UgdGFncyB2aWEgVW5pY29kZVxuICAgIC8vIGV4dGVuc2lvbnMgKGVnLiwgZXMtdS1jby10cmFkIGlzIFNwYW5pc2ggd2l0aCB0cmFkaXRpb25hbFxuICAgIC8vIHNvcnRpbmcpLiBIb3dldmVyLCBmb3Igc3RvcmluZyBuYW1lcyBpbiBmb250cywgdGhlIGRpc3RpbmN0aW9uXG4gICAgLy8gZG9lcyBub3QgbWFrZSBzZW5zZSwgc28gd2UgZ2l2ZSDigJxlc+KAnSBpbiBib3RoIGNhc2VzLlxuICAgIDB4MEMwQTogJ2VzJyxcbiAgICAweDA0MEE6ICdlcycsXG5cbiAgICAweDU0MEE6ICdlcy1VUycsXG4gICAgMHgzODBBOiAnZXMtVVknLFxuICAgIDB4MjAwQTogJ2VzLVZFJyxcbiAgICAweDA4MUQ6ICdzdi1GSScsXG4gICAgMHgwNDFEOiAnc3YnLFxuICAgIDB4MDQ1QTogJ3N5cicsXG4gICAgMHgwNDI4OiAndGcnLFxuICAgIDB4MDg1RjogJ3R6bScsXG4gICAgMHgwNDQ5OiAndGEnLFxuICAgIDB4MDQ0NDogJ3R0JyxcbiAgICAweDA0NEE6ICd0ZScsXG4gICAgMHgwNDFFOiAndGgnLFxuICAgIDB4MDQ1MTogJ2JvJyxcbiAgICAweDA0MUY6ICd0cicsXG4gICAgMHgwNDQyOiAndGsnLFxuICAgIDB4MDQ4MDogJ3VnJyxcbiAgICAweDA0MjI6ICd1aycsXG4gICAgMHgwNDJFOiAnaHNiJyxcbiAgICAweDA0MjA6ICd1cicsXG4gICAgMHgwODQzOiAndXotQ3lybCcsXG4gICAgMHgwNDQzOiAndXonLFxuICAgIDB4MDQyQTogJ3ZpJyxcbiAgICAweDA0NTI6ICdjeScsXG4gICAgMHgwNDg4OiAnd28nLFxuICAgIDB4MDQ4NTogJ3NhaCcsXG4gICAgMHgwNDc4OiAnaWknLFxuICAgIDB4MDQ2QTogJ3lvJ1xufTtcblxuLy8gUmV0dXJucyBhIElFVEYgQkNQIDQ3IGxhbmd1YWdlIGNvZGUsIGZvciBleGFtcGxlICd6aC1IYW50J1xuLy8gZm9yICdDaGluZXNlIGluIHRoZSB0cmFkaXRpb25hbCBzY3JpcHQnLlxuZnVuY3Rpb24gZ2V0TGFuZ3VhZ2VDb2RlKHBsYXRmb3JtSUQsIGxhbmd1YWdlSUQsIGx0YWcpIHtcbiAgICBzd2l0Y2ggKHBsYXRmb3JtSUQpIHtcbiAgICAgICAgY2FzZSAwOiAgLy8gVW5pY29kZVxuICAgICAgICAgICAgaWYgKGxhbmd1YWdlSUQgPT09IDB4RkZGRikge1xuICAgICAgICAgICAgICAgIHJldHVybiAndW5kJztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobHRhZykge1xuICAgICAgICAgICAgICAgIHJldHVybiBsdGFnW2xhbmd1YWdlSURdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIDE6ICAvLyBNYWNpbnRvc2hcbiAgICAgICAgICAgIHJldHVybiBtYWNMYW5ndWFnZXNbbGFuZ3VhZ2VJRF07XG5cbiAgICAgICAgY2FzZSAzOiAgLy8gV2luZG93c1xuICAgICAgICAgICAgcmV0dXJuIHdpbmRvd3NMYW5ndWFnZXNbbGFuZ3VhZ2VJRF07XG4gICAgfVxuXG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cblxuY29uc3QgdXRmMTYgPSAndXRmLTE2JztcblxuLy8gTWFjT1Mgc2NyaXB0IElEIOKGkiBlbmNvZGluZy4gVGhpcyB0YWJsZSBzdG9yZXMgdGhlIGRlZmF1bHQgY2FzZSxcbi8vIHdoaWNoIGNhbiBiZSBvdmVycmlkZGVuIGJ5IG1hY0xhbmd1YWdlRW5jb2RpbmdzLlxuY29uc3QgbWFjU2NyaXB0RW5jb2RpbmdzID0ge1xuICAgIDA6ICdtYWNpbnRvc2gnLCAgICAgICAgICAgLy8gc21Sb21hblxuICAgIDE6ICd4LW1hYy1qYXBhbmVzZScsICAgICAgLy8gc21KYXBhbmVzZVxuICAgIDI6ICd4LW1hYy1jaGluZXNldHJhZCcsICAgLy8gc21UcmFkQ2hpbmVzZVxuICAgIDM6ICd4LW1hYy1rb3JlYW4nLCAgICAgICAgLy8gc21Lb3JlYW5cbiAgICA2OiAneC1tYWMtZ3JlZWsnLCAgICAgICAgIC8vIHNtR3JlZWtcbiAgICA3OiAneC1tYWMtY3lyaWxsaWMnLCAgICAgIC8vIHNtQ3lyaWxsaWNcbiAgICA5OiAneC1tYWMtZGV2YW5hZ2FpJywgICAgIC8vIHNtRGV2YW5hZ2FyaVxuICAgIDEwOiAneC1tYWMtZ3VybXVraGknLCAgICAgLy8gc21HdXJtdWtoaVxuICAgIDExOiAneC1tYWMtZ3VqYXJhdGknLCAgICAgLy8gc21HdWphcmF0aVxuICAgIDEyOiAneC1tYWMtb3JpeWEnLCAgICAgICAgLy8gc21Pcml5YVxuICAgIDEzOiAneC1tYWMtYmVuZ2FsaScsICAgICAgLy8gc21CZW5nYWxpXG4gICAgMTQ6ICd4LW1hYy10YW1pbCcsICAgICAgICAvLyBzbVRhbWlsXG4gICAgMTU6ICd4LW1hYy10ZWx1Z3UnLCAgICAgICAvLyBzbVRlbHVndVxuICAgIDE2OiAneC1tYWMta2FubmFkYScsICAgICAgLy8gc21LYW5uYWRhXG4gICAgMTc6ICd4LW1hYy1tYWxheWFsYW0nLCAgICAvLyBzbU1hbGF5YWxhbVxuICAgIDE4OiAneC1tYWMtc2luaGFsZXNlJywgICAgLy8gc21TaW5oYWxlc2VcbiAgICAxOTogJ3gtbWFjLWJ1cm1lc2UnLCAgICAgIC8vIHNtQnVybWVzZVxuICAgIDIwOiAneC1tYWMta2htZXInLCAgICAgICAgLy8gc21LaG1lclxuICAgIDIxOiAneC1tYWMtdGhhaScsICAgICAgICAgLy8gc21UaGFpXG4gICAgMjI6ICd4LW1hYy1sYW8nLCAgICAgICAgICAvLyBzbUxhb1xuICAgIDIzOiAneC1tYWMtZ2VvcmdpYW4nLCAgICAgLy8gc21HZW9yZ2lhblxuICAgIDI0OiAneC1tYWMtYXJtZW5pYW4nLCAgICAgLy8gc21Bcm1lbmlhblxuICAgIDI1OiAneC1tYWMtY2hpbmVzZXNpbXAnLCAgLy8gc21TaW1wQ2hpbmVzZVxuICAgIDI2OiAneC1tYWMtdGliZXRhbicsICAgICAgLy8gc21UaWJldGFuXG4gICAgMjc6ICd4LW1hYy1tb25nb2xpYW4nLCAgICAvLyBzbU1vbmdvbGlhblxuICAgIDI4OiAneC1tYWMtZXRoaW9waWMnLCAgICAgLy8gc21FdGhpb3BpY1xuICAgIDI5OiAneC1tYWMtY2UnLCAgICAgICAgICAgLy8gc21DZW50cmFsRXVyb1JvbWFuXG4gICAgMzA6ICd4LW1hYy12aWV0bmFtZXNlJywgICAvLyBzbVZpZXRuYW1lc2VcbiAgICAzMTogJ3gtbWFjLWV4dGFyYWJpYycgICAgIC8vIHNtRXh0QXJhYmljXG59O1xuXG4vLyBNYWNPUyBsYW5ndWFnZSBJRCDihpIgZW5jb2RpbmcuIFRoaXMgdGFibGUgc3RvcmVzIHRoZSBleGNlcHRpb25hbFxuLy8gY2FzZXMsIHdoaWNoIG92ZXJyaWRlIG1hY1NjcmlwdEVuY29kaW5ncy4gRm9yIHdyaXRpbmcgTWFjT1MgbmFtaW5nXG4vLyB0YWJsZXMsIHdlIG5lZWQgdG8gZW1pdCBhIE1hY09TIHNjcmlwdCBJRC4gVGhlcmVmb3JlLCB3ZSBjYW5ub3Rcbi8vIG1lcmdlIG1hY1NjcmlwdEVuY29kaW5ncyBpbnRvIG1hY0xhbmd1YWdlRW5jb2RpbmdzLlxuLy9cbi8vIGh0dHA6Ly91bmljb2RlLm9yZy9QdWJsaWMvTUFQUElOR1MvVkVORE9SUy9BUFBMRS9SZWFkbWUudHh0XG5jb25zdCBtYWNMYW5ndWFnZUVuY29kaW5ncyA9IHtcbiAgICAxNTogJ3gtbWFjLWljZWxhbmRpYycsICAgIC8vIGxhbmdJY2VsYW5kaWNcbiAgICAxNzogJ3gtbWFjLXR1cmtpc2gnLCAgICAgIC8vIGxhbmdUdXJraXNoXG4gICAgMTg6ICd4LW1hYy1jcm9hdGlhbicsICAgICAvLyBsYW5nQ3JvYXRpYW5cbiAgICAyNDogJ3gtbWFjLWNlJywgICAgICAgICAgIC8vIGxhbmdMaXRodWFuaWFuXG4gICAgMjU6ICd4LW1hYy1jZScsICAgICAgICAgICAvLyBsYW5nUG9saXNoXG4gICAgMjY6ICd4LW1hYy1jZScsICAgICAgICAgICAvLyBsYW5nSHVuZ2FyaWFuXG4gICAgMjc6ICd4LW1hYy1jZScsICAgICAgICAgICAvLyBsYW5nRXN0b25pYW5cbiAgICAyODogJ3gtbWFjLWNlJywgICAgICAgICAgIC8vIGxhbmdMYXR2aWFuXG4gICAgMzA6ICd4LW1hYy1pY2VsYW5kaWMnLCAgICAvLyBsYW5nRmFyb2VzZVxuICAgIDM3OiAneC1tYWMtcm9tYW5pYW4nLCAgICAgLy8gbGFuZ1JvbWFuaWFuXG4gICAgMzg6ICd4LW1hYy1jZScsICAgICAgICAgICAvLyBsYW5nQ3plY2hcbiAgICAzOTogJ3gtbWFjLWNlJywgICAgICAgICAgIC8vIGxhbmdTbG92YWtcbiAgICA0MDogJ3gtbWFjLWNlJywgICAgICAgICAgIC8vIGxhbmdTbG92ZW5pYW5cbiAgICAxNDM6ICd4LW1hYy1pbnVpdCcsICAgICAgIC8vIGxhbmdJbnVrdGl0dXRcbiAgICAxNDY6ICd4LW1hYy1nYWVsaWMnICAgICAgIC8vIGxhbmdJcmlzaEdhZWxpY1NjcmlwdFxufTtcblxuZnVuY3Rpb24gZ2V0RW5jb2RpbmcocGxhdGZvcm1JRCwgZW5jb2RpbmdJRCwgbGFuZ3VhZ2VJRCkge1xuICAgIHN3aXRjaCAocGxhdGZvcm1JRCkge1xuICAgICAgICBjYXNlIDA6ICAvLyBVbmljb2RlXG4gICAgICAgICAgICByZXR1cm4gdXRmMTY7XG5cbiAgICAgICAgY2FzZSAxOiAgLy8gQXBwbGUgTWFjaW50b3NoXG4gICAgICAgICAgICByZXR1cm4gbWFjTGFuZ3VhZ2VFbmNvZGluZ3NbbGFuZ3VhZ2VJRF0gfHwgbWFjU2NyaXB0RW5jb2RpbmdzW2VuY29kaW5nSURdO1xuXG4gICAgICAgIGNhc2UgMzogIC8vIE1pY3Jvc29mdCBXaW5kb3dzXG4gICAgICAgICAgICBpZiAoZW5jb2RpbmdJRCA9PT0gMSB8fCBlbmNvZGluZ0lEID09PSAxMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB1dGYxNjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cblxuLy8gUGFyc2UgdGhlIG5hbWluZyBgbmFtZWAgdGFibGUuXG4vLyBGSVhNRTogRm9ybWF0IDEgYWRkaXRpb25hbCBmaWVsZHMgYXJlIG5vdCBzdXBwb3J0ZWQgeWV0LlxuLy8gbHRhZyBpcyB0aGUgY29udGVudCBvZiB0aGUgYGx0YWcnIHRhYmxlLCBzdWNoIGFzIFsnZW4nLCAnemgtSGFucycsICdkZS1DSC0xOTA0J10uXG5mdW5jdGlvbiBwYXJzZU5hbWVUYWJsZShkYXRhLCBzdGFydCwgbHRhZykge1xuICAgIGNvbnN0IG5hbWUgPSB7fTtcbiAgICBjb25zdCBwID0gbmV3IHBhcnNlLlBhcnNlcihkYXRhLCBzdGFydCk7XG4gICAgY29uc3QgZm9ybWF0ID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgIGNvbnN0IGNvdW50ID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgIGNvbnN0IHN0cmluZ09mZnNldCA9IHAub2Zmc2V0ICsgcC5wYXJzZVVTaG9ydCgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICBjb25zdCBwbGF0Zm9ybUlEID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICBjb25zdCBlbmNvZGluZ0lEID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICBjb25zdCBsYW5ndWFnZUlEID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICBjb25zdCBuYW1lSUQgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgIGNvbnN0IHByb3BlcnR5ID0gbmFtZVRhYmxlTmFtZXNbbmFtZUlEXSB8fCBuYW1lSUQ7XG4gICAgICAgIGNvbnN0IGJ5dGVMZW5ndGggPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgY29uc3QgbGFuZ3VhZ2UgPSBnZXRMYW5ndWFnZUNvZGUocGxhdGZvcm1JRCwgbGFuZ3VhZ2VJRCwgbHRhZyk7XG4gICAgICAgIGNvbnN0IGVuY29kaW5nID0gZ2V0RW5jb2RpbmcocGxhdGZvcm1JRCwgZW5jb2RpbmdJRCwgbGFuZ3VhZ2VJRCk7XG4gICAgICAgIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkICYmIGxhbmd1YWdlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGxldCB0ZXh0O1xuICAgICAgICAgICAgaWYgKGVuY29kaW5nID09PSB1dGYxNikge1xuICAgICAgICAgICAgICAgIHRleHQgPSBkZWNvZGUuVVRGMTYoZGF0YSwgc3RyaW5nT2Zmc2V0ICsgb2Zmc2V0LCBieXRlTGVuZ3RoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGV4dCA9IGRlY29kZS5NQUNTVFJJTkcoZGF0YSwgc3RyaW5nT2Zmc2V0ICsgb2Zmc2V0LCBieXRlTGVuZ3RoLCBlbmNvZGluZyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0ZXh0KSB7XG4gICAgICAgICAgICAgICAgbGV0IHRyYW5zbGF0aW9ucyA9IG5hbWVbcHJvcGVydHldO1xuICAgICAgICAgICAgICAgIGlmICh0cmFuc2xhdGlvbnMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICB0cmFuc2xhdGlvbnMgPSBuYW1lW3Byb3BlcnR5XSA9IHt9O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRyYW5zbGF0aW9uc1tsYW5ndWFnZV0gPSB0ZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgbGV0IGxhbmdUYWdDb3VudCA9IDA7XG4gICAgaWYgKGZvcm1hdCA9PT0gMSkge1xuICAgICAgICAvLyBGSVhNRTogQWxzbyBoYW5kbGUgTWljcm9zb2Z0J3MgJ25hbWUnIHRhYmxlIDEuXG4gICAgICAgIGxhbmdUYWdDb3VudCA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmFtZTtcbn1cblxuLy8gezIzOiAnZm9vJ30g4oaSIHsnZm9vJzogMjN9XG4vLyBbJ2JhcicsICdiYXonXSDihpIgeydiYXInOiAwLCAnYmF6JzogMX1cbmZ1bmN0aW9uIHJldmVyc2VEaWN0KGRpY3QpIHtcbiAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICBmb3IgKGxldCBrZXkgaW4gZGljdCkge1xuICAgICAgICByZXN1bHRbZGljdFtrZXldXSA9IHBhcnNlSW50KGtleSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gbWFrZU5hbWVSZWNvcmQocGxhdGZvcm1JRCwgZW5jb2RpbmdJRCwgbGFuZ3VhZ2VJRCwgbmFtZUlELCBsZW5ndGgsIG9mZnNldCkge1xuICAgIHJldHVybiBuZXcgdGFibGUuUmVjb3JkKCdOYW1lUmVjb3JkJywgW1xuICAgICAgICB7bmFtZTogJ3BsYXRmb3JtSUQnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IHBsYXRmb3JtSUR9LFxuICAgICAgICB7bmFtZTogJ2VuY29kaW5nSUQnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IGVuY29kaW5nSUR9LFxuICAgICAgICB7bmFtZTogJ2xhbmd1YWdlSUQnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IGxhbmd1YWdlSUR9LFxuICAgICAgICB7bmFtZTogJ25hbWVJRCcsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogbmFtZUlEfSxcbiAgICAgICAge25hbWU6ICdsZW5ndGgnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IGxlbmd0aH0sXG4gICAgICAgIHtuYW1lOiAnb2Zmc2V0JywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiBvZmZzZXR9XG4gICAgXSk7XG59XG5cbi8vIEZpbmRzIHRoZSBwb3NpdGlvbiBvZiBuZWVkbGUgaW4gaGF5c3RhY2ssIG9yIC0xIGlmIG5vdCB0aGVyZS5cbi8vIExpa2UgU3RyaW5nLmluZGV4T2YoKSwgYnV0IGZvciBhcnJheXMuXG5mdW5jdGlvbiBmaW5kU3ViQXJyYXkobmVlZGxlLCBoYXlzdGFjaykge1xuICAgIGNvbnN0IG5lZWRsZUxlbmd0aCA9IG5lZWRsZS5sZW5ndGg7XG4gICAgY29uc3QgbGltaXQgPSBoYXlzdGFjay5sZW5ndGggLSBuZWVkbGVMZW5ndGggKyAxO1xuXG4gICAgbG9vcDpcbiAgICBmb3IgKGxldCBwb3MgPSAwOyBwb3MgPCBsaW1pdDsgcG9zKyspIHtcbiAgICAgICAgZm9yICg7IHBvcyA8IGxpbWl0OyBwb3MrKykge1xuICAgICAgICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCBuZWVkbGVMZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgICAgIGlmIChoYXlzdGFja1twb3MgKyBrXSAhPT0gbmVlZGxlW2tdKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlIGxvb3A7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gcG9zO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIC0xO1xufVxuXG5mdW5jdGlvbiBhZGRTdHJpbmdUb1Bvb2wocywgcG9vbCkge1xuICAgIGxldCBvZmZzZXQgPSBmaW5kU3ViQXJyYXkocywgcG9vbCk7XG4gICAgaWYgKG9mZnNldCA8IDApIHtcbiAgICAgICAgb2Zmc2V0ID0gcG9vbC5sZW5ndGg7XG4gICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgY29uc3QgbGVuID0gcy5sZW5ndGg7XG4gICAgICAgIGZvciAoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgICAgIHBvb2wucHVzaChzW2ldKTtcbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgcmV0dXJuIG9mZnNldDtcbn1cblxuZnVuY3Rpb24gbWFrZU5hbWVUYWJsZShuYW1lcywgbHRhZykge1xuICAgIGxldCBuYW1lSUQ7XG4gICAgY29uc3QgbmFtZUlEcyA9IFtdO1xuXG4gICAgY29uc3QgbmFtZXNXaXRoTnVtZXJpY0tleXMgPSB7fTtcbiAgICBjb25zdCBuYW1lVGFibGVJZHMgPSByZXZlcnNlRGljdChuYW1lVGFibGVOYW1lcyk7XG4gICAgZm9yIChsZXQga2V5IGluIG5hbWVzKSB7XG4gICAgICAgIGxldCBpZCA9IG5hbWVUYWJsZUlkc1trZXldO1xuICAgICAgICBpZiAoaWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWQgPSBrZXk7XG4gICAgICAgIH1cblxuICAgICAgICBuYW1lSUQgPSBwYXJzZUludChpZCk7XG5cbiAgICAgICAgaWYgKGlzTmFOKG5hbWVJRCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTmFtZSB0YWJsZSBlbnRyeSBcIicgKyBrZXkgKyAnXCIgZG9lcyBub3QgZXhpc3QsIHNlZSBuYW1lVGFibGVOYW1lcyBmb3IgY29tcGxldGUgbGlzdC4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG5hbWVzV2l0aE51bWVyaWNLZXlzW25hbWVJRF0gPSBuYW1lc1trZXldO1xuICAgICAgICBuYW1lSURzLnB1c2gobmFtZUlEKTtcbiAgICB9XG5cbiAgICBjb25zdCBtYWNMYW5ndWFnZUlkcyA9IHJldmVyc2VEaWN0KG1hY0xhbmd1YWdlcyk7XG4gICAgY29uc3Qgd2luZG93c0xhbmd1YWdlSWRzID0gcmV2ZXJzZURpY3Qod2luZG93c0xhbmd1YWdlcyk7XG5cbiAgICBjb25zdCBuYW1lUmVjb3JkcyA9IFtdO1xuICAgIGNvbnN0IHN0cmluZ1Bvb2wgPSBbXTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmFtZUlEcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBuYW1lSUQgPSBuYW1lSURzW2ldO1xuICAgICAgICBjb25zdCB0cmFuc2xhdGlvbnMgPSBuYW1lc1dpdGhOdW1lcmljS2V5c1tuYW1lSURdO1xuICAgICAgICBmb3IgKGxldCBsYW5nIGluIHRyYW5zbGF0aW9ucykge1xuICAgICAgICAgICAgY29uc3QgdGV4dCA9IHRyYW5zbGF0aW9uc1tsYW5nXTtcblxuICAgICAgICAgICAgLy8gRm9yIE1hY09TLCB3ZSB0cnkgdG8gZW1pdCB0aGUgbmFtZSBpbiB0aGUgZm9ybSB0aGF0IHdhcyBpbnRyb2R1Y2VkXG4gICAgICAgICAgICAvLyBpbiB0aGUgaW5pdGlhbCB2ZXJzaW9uIG9mIHRoZSBUcnVlVHlwZSBzcGVjIChpbiB0aGUgbGF0ZSAxOTgwcykuXG4gICAgICAgICAgICAvLyBIb3dldmVyLCB0aGlzIGNhbiBmYWlsIGZvciB2YXJpb3VzIHJlYXNvbnM6IHRoZSByZXF1ZXN0ZWQgQkNQIDQ3XG4gICAgICAgICAgICAvLyBsYW5ndWFnZSBjb2RlIG1pZ2h0IG5vdCBoYXZlIGFuIG9sZC1zdHlsZSBNYWMgZXF1aXZhbGVudDtcbiAgICAgICAgICAgIC8vIHdlIG1pZ2h0IG5vdCBoYXZlIGEgY29kZWMgZm9yIHRoZSBuZWVkZWQgY2hhcmFjdGVyIGVuY29kaW5nO1xuICAgICAgICAgICAgLy8gb3IgdGhlIG5hbWUgbWlnaHQgY29udGFpbiBjaGFyYWN0ZXJzIHRoYXQgY2Fubm90IGJlIGV4cHJlc3NlZFxuICAgICAgICAgICAgLy8gaW4gdGhlIG9sZC1zdHlsZSBNYWNpbnRvc2ggZW5jb2RpbmcuIEluIGNhc2Ugb2YgZmFpbHVyZSwgd2UgZW1pdFxuICAgICAgICAgICAgLy8gdGhlIG5hbWUgaW4gYSBtb3JlIG1vZGVybiBmYXNoaW9uIChVbmljb2RlIGVuY29kaW5nIHdpdGggQkNQIDQ3XG4gICAgICAgICAgICAvLyBsYW5ndWFnZSB0YWdzKSB0aGF0IGlzIHJlY29nbml6ZWQgYnkgTWFjT1MgMTAuNSwgcmVsZWFzZWQgaW4gMjAwOS5cbiAgICAgICAgICAgIC8vIElmIGZvbnRzIHdlcmUgb25seSByZWFkIGJ5IG9wZXJhdGluZyBzeXN0ZW1zLCB3ZSBjb3VsZCBzaW1wbHlcbiAgICAgICAgICAgIC8vIGVtaXQgYWxsIG5hbWVzIGluIHRoZSBtb2Rlcm4gZm9ybTsgdGhpcyB3b3VsZCBiZSBtdWNoIGVhc2llci5cbiAgICAgICAgICAgIC8vIEhvd2V2ZXIsIHRoZXJlIGFyZSBtYW55IGFwcGxpY2F0aW9ucyBhbmQgbGlicmFyaWVzIHRoYXQgcmVhZFxuICAgICAgICAgICAgLy8gJ25hbWUnIHRhYmxlcyBkaXJlY3RseSwgYW5kIHRoZXNlIHdpbGwgdXN1YWxseSBvbmx5IHJlY29nbml6ZVxuICAgICAgICAgICAgLy8gdGhlIGFuY2llbnQgZm9ybSAoc2lsZW50bHkgc2tpcHBpbmcgdGhlIHVucmVjb2duaXplZCBuYW1lcykuXG4gICAgICAgICAgICBsZXQgbWFjUGxhdGZvcm0gPSAxOyAgLy8gTWFjaW50b3NoXG4gICAgICAgICAgICBsZXQgbWFjTGFuZ3VhZ2UgPSBtYWNMYW5ndWFnZUlkc1tsYW5nXTtcbiAgICAgICAgICAgIGxldCBtYWNTY3JpcHQgPSBtYWNMYW5ndWFnZVRvU2NyaXB0W21hY0xhbmd1YWdlXTtcbiAgICAgICAgICAgIGNvbnN0IG1hY0VuY29kaW5nID0gZ2V0RW5jb2RpbmcobWFjUGxhdGZvcm0sIG1hY1NjcmlwdCwgbWFjTGFuZ3VhZ2UpO1xuICAgICAgICAgICAgbGV0IG1hY05hbWUgPSBlbmNvZGUuTUFDU1RSSU5HKHRleHQsIG1hY0VuY29kaW5nKTtcbiAgICAgICAgICAgIGlmIChtYWNOYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBtYWNQbGF0Zm9ybSA9IDA7ICAvLyBVbmljb2RlXG4gICAgICAgICAgICAgICAgbWFjTGFuZ3VhZ2UgPSBsdGFnLmluZGV4T2YobGFuZyk7XG4gICAgICAgICAgICAgICAgaWYgKG1hY0xhbmd1YWdlIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICBtYWNMYW5ndWFnZSA9IGx0YWcubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBsdGFnLnB1c2gobGFuZyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbWFjU2NyaXB0ID0gNDsgIC8vIFVuaWNvZGUgMi4wIGFuZCBsYXRlclxuICAgICAgICAgICAgICAgIG1hY05hbWUgPSBlbmNvZGUuVVRGMTYodGV4dCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IG1hY05hbWVPZmZzZXQgPSBhZGRTdHJpbmdUb1Bvb2wobWFjTmFtZSwgc3RyaW5nUG9vbCk7XG4gICAgICAgICAgICBuYW1lUmVjb3Jkcy5wdXNoKG1ha2VOYW1lUmVjb3JkKG1hY1BsYXRmb3JtLCBtYWNTY3JpcHQsIG1hY0xhbmd1YWdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lSUQsIG1hY05hbWUubGVuZ3RoLCBtYWNOYW1lT2Zmc2V0KSk7XG5cbiAgICAgICAgICAgIGNvbnN0IHdpbkxhbmd1YWdlID0gd2luZG93c0xhbmd1YWdlSWRzW2xhbmddO1xuICAgICAgICAgICAgaWYgKHdpbkxhbmd1YWdlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB3aW5OYW1lID0gZW5jb2RlLlVURjE2KHRleHQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHdpbk5hbWVPZmZzZXQgPSBhZGRTdHJpbmdUb1Bvb2wod2luTmFtZSwgc3RyaW5nUG9vbCk7XG4gICAgICAgICAgICAgICAgbmFtZVJlY29yZHMucHVzaChtYWtlTmFtZVJlY29yZCgzLCAxLCB3aW5MYW5ndWFnZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWVJRCwgd2luTmFtZS5sZW5ndGgsIHdpbk5hbWVPZmZzZXQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIG5hbWVSZWNvcmRzLnNvcnQoZnVuY3Rpb24oYSwgYikge1xuICAgICAgICByZXR1cm4gKChhLnBsYXRmb3JtSUQgLSBiLnBsYXRmb3JtSUQpIHx8XG4gICAgICAgICAgICAgICAgKGEuZW5jb2RpbmdJRCAtIGIuZW5jb2RpbmdJRCkgfHxcbiAgICAgICAgICAgICAgICAoYS5sYW5ndWFnZUlEIC0gYi5sYW5ndWFnZUlEKSB8fFxuICAgICAgICAgICAgICAgIChhLm5hbWVJRCAtIGIubmFtZUlEKSk7XG4gICAgfSk7XG5cbiAgICBjb25zdCB0ID0gbmV3IHRhYmxlLlRhYmxlKCduYW1lJywgW1xuICAgICAgICB7bmFtZTogJ2Zvcm1hdCcsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAnY291bnQnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IG5hbWVSZWNvcmRzLmxlbmd0aH0sXG4gICAgICAgIHtuYW1lOiAnc3RyaW5nT2Zmc2V0JywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiA2ICsgbmFtZVJlY29yZHMubGVuZ3RoICogMTJ9XG4gICAgXSk7XG5cbiAgICBmb3IgKGxldCByID0gMDsgciA8IG5hbWVSZWNvcmRzLmxlbmd0aDsgcisrKSB7XG4gICAgICAgIHQuZmllbGRzLnB1c2goe25hbWU6ICdyZWNvcmRfJyArIHIsIHR5cGU6ICdSRUNPUkQnLCB2YWx1ZTogbmFtZVJlY29yZHNbcl19KTtcbiAgICB9XG5cbiAgICB0LmZpZWxkcy5wdXNoKHtuYW1lOiAnc3RyaW5ncycsIHR5cGU6ICdMSVRFUkFMJywgdmFsdWU6IHN0cmluZ1Bvb2x9KTtcbiAgICByZXR1cm4gdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgeyBwYXJzZTogcGFyc2VOYW1lVGFibGUsIG1ha2U6IG1ha2VOYW1lVGFibGUgfTtcbiIsIi8vIFRoZSBgT1MvMmAgdGFibGUgY29udGFpbnMgbWV0cmljcyByZXF1aXJlZCBpbiBPcGVuVHlwZSBmb250cy5cbi8vIGh0dHBzOi8vd3d3Lm1pY3Jvc29mdC5jb20vdHlwb2dyYXBoeS9PVFNQRUMvb3MyLmh0bVxuXG5pbXBvcnQgcGFyc2UgZnJvbSAnLi4vcGFyc2UnO1xuaW1wb3J0IHRhYmxlIGZyb20gJy4uL3RhYmxlJztcblxuY29uc3QgdW5pY29kZVJhbmdlcyA9IFtcbiAgICB7YmVnaW46IDB4MDAwMCwgZW5kOiAweDAwN0Z9LCAvLyBCYXNpYyBMYXRpblxuICAgIHtiZWdpbjogMHgwMDgwLCBlbmQ6IDB4MDBGRn0sIC8vIExhdGluLTEgU3VwcGxlbWVudFxuICAgIHtiZWdpbjogMHgwMTAwLCBlbmQ6IDB4MDE3Rn0sIC8vIExhdGluIEV4dGVuZGVkLUFcbiAgICB7YmVnaW46IDB4MDE4MCwgZW5kOiAweDAyNEZ9LCAvLyBMYXRpbiBFeHRlbmRlZC1CXG4gICAge2JlZ2luOiAweDAyNTAsIGVuZDogMHgwMkFGfSwgLy8gSVBBIEV4dGVuc2lvbnNcbiAgICB7YmVnaW46IDB4MDJCMCwgZW5kOiAweDAyRkZ9LCAvLyBTcGFjaW5nIE1vZGlmaWVyIExldHRlcnNcbiAgICB7YmVnaW46IDB4MDMwMCwgZW5kOiAweDAzNkZ9LCAvLyBDb21iaW5pbmcgRGlhY3JpdGljYWwgTWFya3NcbiAgICB7YmVnaW46IDB4MDM3MCwgZW5kOiAweDAzRkZ9LCAvLyBHcmVlayBhbmQgQ29wdGljXG4gICAge2JlZ2luOiAweDJDODAsIGVuZDogMHgyQ0ZGfSwgLy8gQ29wdGljXG4gICAge2JlZ2luOiAweDA0MDAsIGVuZDogMHgwNEZGfSwgLy8gQ3lyaWxsaWNcbiAgICB7YmVnaW46IDB4MDUzMCwgZW5kOiAweDA1OEZ9LCAvLyBBcm1lbmlhblxuICAgIHtiZWdpbjogMHgwNTkwLCBlbmQ6IDB4MDVGRn0sIC8vIEhlYnJld1xuICAgIHtiZWdpbjogMHhBNTAwLCBlbmQ6IDB4QTYzRn0sIC8vIFZhaVxuICAgIHtiZWdpbjogMHgwNjAwLCBlbmQ6IDB4MDZGRn0sIC8vIEFyYWJpY1xuICAgIHtiZWdpbjogMHgwN0MwLCBlbmQ6IDB4MDdGRn0sIC8vIE5Lb1xuICAgIHtiZWdpbjogMHgwOTAwLCBlbmQ6IDB4MDk3Rn0sIC8vIERldmFuYWdhcmlcbiAgICB7YmVnaW46IDB4MDk4MCwgZW5kOiAweDA5RkZ9LCAvLyBCZW5nYWxpXG4gICAge2JlZ2luOiAweDBBMDAsIGVuZDogMHgwQTdGfSwgLy8gR3VybXVraGlcbiAgICB7YmVnaW46IDB4MEE4MCwgZW5kOiAweDBBRkZ9LCAvLyBHdWphcmF0aVxuICAgIHtiZWdpbjogMHgwQjAwLCBlbmQ6IDB4MEI3Rn0sIC8vIE9yaXlhXG4gICAge2JlZ2luOiAweDBCODAsIGVuZDogMHgwQkZGfSwgLy8gVGFtaWxcbiAgICB7YmVnaW46IDB4MEMwMCwgZW5kOiAweDBDN0Z9LCAvLyBUZWx1Z3VcbiAgICB7YmVnaW46IDB4MEM4MCwgZW5kOiAweDBDRkZ9LCAvLyBLYW5uYWRhXG4gICAge2JlZ2luOiAweDBEMDAsIGVuZDogMHgwRDdGfSwgLy8gTWFsYXlhbGFtXG4gICAge2JlZ2luOiAweDBFMDAsIGVuZDogMHgwRTdGfSwgLy8gVGhhaVxuICAgIHtiZWdpbjogMHgwRTgwLCBlbmQ6IDB4MEVGRn0sIC8vIExhb1xuICAgIHtiZWdpbjogMHgxMEEwLCBlbmQ6IDB4MTBGRn0sIC8vIEdlb3JnaWFuXG4gICAge2JlZ2luOiAweDFCMDAsIGVuZDogMHgxQjdGfSwgLy8gQmFsaW5lc2VcbiAgICB7YmVnaW46IDB4MTEwMCwgZW5kOiAweDExRkZ9LCAvLyBIYW5ndWwgSmFtb1xuICAgIHtiZWdpbjogMHgxRTAwLCBlbmQ6IDB4MUVGRn0sIC8vIExhdGluIEV4dGVuZGVkIEFkZGl0aW9uYWxcbiAgICB7YmVnaW46IDB4MUYwMCwgZW5kOiAweDFGRkZ9LCAvLyBHcmVlayBFeHRlbmRlZFxuICAgIHtiZWdpbjogMHgyMDAwLCBlbmQ6IDB4MjA2Rn0sIC8vIEdlbmVyYWwgUHVuY3R1YXRpb25cbiAgICB7YmVnaW46IDB4MjA3MCwgZW5kOiAweDIwOUZ9LCAvLyBTdXBlcnNjcmlwdHMgQW5kIFN1YnNjcmlwdHNcbiAgICB7YmVnaW46IDB4MjBBMCwgZW5kOiAweDIwQ0Z9LCAvLyBDdXJyZW5jeSBTeW1ib2xcbiAgICB7YmVnaW46IDB4MjBEMCwgZW5kOiAweDIwRkZ9LCAvLyBDb21iaW5pbmcgRGlhY3JpdGljYWwgTWFya3MgRm9yIFN5bWJvbHNcbiAgICB7YmVnaW46IDB4MjEwMCwgZW5kOiAweDIxNEZ9LCAvLyBMZXR0ZXJsaWtlIFN5bWJvbHNcbiAgICB7YmVnaW46IDB4MjE1MCwgZW5kOiAweDIxOEZ9LCAvLyBOdW1iZXIgRm9ybXNcbiAgICB7YmVnaW46IDB4MjE5MCwgZW5kOiAweDIxRkZ9LCAvLyBBcnJvd3NcbiAgICB7YmVnaW46IDB4MjIwMCwgZW5kOiAweDIyRkZ9LCAvLyBNYXRoZW1hdGljYWwgT3BlcmF0b3JzXG4gICAge2JlZ2luOiAweDIzMDAsIGVuZDogMHgyM0ZGfSwgLy8gTWlzY2VsbGFuZW91cyBUZWNobmljYWxcbiAgICB7YmVnaW46IDB4MjQwMCwgZW5kOiAweDI0M0Z9LCAvLyBDb250cm9sIFBpY3R1cmVzXG4gICAge2JlZ2luOiAweDI0NDAsIGVuZDogMHgyNDVGfSwgLy8gT3B0aWNhbCBDaGFyYWN0ZXIgUmVjb2duaXRpb25cbiAgICB7YmVnaW46IDB4MjQ2MCwgZW5kOiAweDI0RkZ9LCAvLyBFbmNsb3NlZCBBbHBoYW51bWVyaWNzXG4gICAge2JlZ2luOiAweDI1MDAsIGVuZDogMHgyNTdGfSwgLy8gQm94IERyYXdpbmdcbiAgICB7YmVnaW46IDB4MjU4MCwgZW5kOiAweDI1OUZ9LCAvLyBCbG9jayBFbGVtZW50c1xuICAgIHtiZWdpbjogMHgyNUEwLCBlbmQ6IDB4MjVGRn0sIC8vIEdlb21ldHJpYyBTaGFwZXNcbiAgICB7YmVnaW46IDB4MjYwMCwgZW5kOiAweDI2RkZ9LCAvLyBNaXNjZWxsYW5lb3VzIFN5bWJvbHNcbiAgICB7YmVnaW46IDB4MjcwMCwgZW5kOiAweDI3QkZ9LCAvLyBEaW5nYmF0c1xuICAgIHtiZWdpbjogMHgzMDAwLCBlbmQ6IDB4MzAzRn0sIC8vIENKSyBTeW1ib2xzIEFuZCBQdW5jdHVhdGlvblxuICAgIHtiZWdpbjogMHgzMDQwLCBlbmQ6IDB4MzA5Rn0sIC8vIEhpcmFnYW5hXG4gICAge2JlZ2luOiAweDMwQTAsIGVuZDogMHgzMEZGfSwgLy8gS2F0YWthbmFcbiAgICB7YmVnaW46IDB4MzEwMCwgZW5kOiAweDMxMkZ9LCAvLyBCb3BvbW9mb1xuICAgIHtiZWdpbjogMHgzMTMwLCBlbmQ6IDB4MzE4Rn0sIC8vIEhhbmd1bCBDb21wYXRpYmlsaXR5IEphbW9cbiAgICB7YmVnaW46IDB4QTg0MCwgZW5kOiAweEE4N0Z9LCAvLyBQaGFncy1wYVxuICAgIHtiZWdpbjogMHgzMjAwLCBlbmQ6IDB4MzJGRn0sIC8vIEVuY2xvc2VkIENKSyBMZXR0ZXJzIEFuZCBNb250aHNcbiAgICB7YmVnaW46IDB4MzMwMCwgZW5kOiAweDMzRkZ9LCAvLyBDSksgQ29tcGF0aWJpbGl0eVxuICAgIHtiZWdpbjogMHhBQzAwLCBlbmQ6IDB4RDdBRn0sIC8vIEhhbmd1bCBTeWxsYWJsZXNcbiAgICB7YmVnaW46IDB4RDgwMCwgZW5kOiAweERGRkZ9LCAvLyBOb24tUGxhbmUgMCAqXG4gICAge2JlZ2luOiAweDEwOTAwLCBlbmQ6IDB4MTA5MUZ9LCAvLyBQaG9lbmljaWFcbiAgICB7YmVnaW46IDB4NEUwMCwgZW5kOiAweDlGRkZ9LCAvLyBDSksgVW5pZmllZCBJZGVvZ3JhcGhzXG4gICAge2JlZ2luOiAweEUwMDAsIGVuZDogMHhGOEZGfSwgLy8gUHJpdmF0ZSBVc2UgQXJlYSAocGxhbmUgMClcbiAgICB7YmVnaW46IDB4MzFDMCwgZW5kOiAweDMxRUZ9LCAvLyBDSksgU3Ryb2tlc1xuICAgIHtiZWdpbjogMHhGQjAwLCBlbmQ6IDB4RkI0Rn0sIC8vIEFscGhhYmV0aWMgUHJlc2VudGF0aW9uIEZvcm1zXG4gICAge2JlZ2luOiAweEZCNTAsIGVuZDogMHhGREZGfSwgLy8gQXJhYmljIFByZXNlbnRhdGlvbiBGb3Jtcy1BXG4gICAge2JlZ2luOiAweEZFMjAsIGVuZDogMHhGRTJGfSwgLy8gQ29tYmluaW5nIEhhbGYgTWFya3NcbiAgICB7YmVnaW46IDB4RkUxMCwgZW5kOiAweEZFMUZ9LCAvLyBWZXJ0aWNhbCBGb3Jtc1xuICAgIHtiZWdpbjogMHhGRTUwLCBlbmQ6IDB4RkU2Rn0sIC8vIFNtYWxsIEZvcm0gVmFyaWFudHNcbiAgICB7YmVnaW46IDB4RkU3MCwgZW5kOiAweEZFRkZ9LCAvLyBBcmFiaWMgUHJlc2VudGF0aW9uIEZvcm1zLUJcbiAgICB7YmVnaW46IDB4RkYwMCwgZW5kOiAweEZGRUZ9LCAvLyBIYWxmd2lkdGggQW5kIEZ1bGx3aWR0aCBGb3Jtc1xuICAgIHtiZWdpbjogMHhGRkYwLCBlbmQ6IDB4RkZGRn0sIC8vIFNwZWNpYWxzXG4gICAge2JlZ2luOiAweDBGMDAsIGVuZDogMHgwRkZGfSwgLy8gVGliZXRhblxuICAgIHtiZWdpbjogMHgwNzAwLCBlbmQ6IDB4MDc0Rn0sIC8vIFN5cmlhY1xuICAgIHtiZWdpbjogMHgwNzgwLCBlbmQ6IDB4MDdCRn0sIC8vIFRoYWFuYVxuICAgIHtiZWdpbjogMHgwRDgwLCBlbmQ6IDB4MERGRn0sIC8vIFNpbmhhbGFcbiAgICB7YmVnaW46IDB4MTAwMCwgZW5kOiAweDEwOUZ9LCAvLyBNeWFubWFyXG4gICAge2JlZ2luOiAweDEyMDAsIGVuZDogMHgxMzdGfSwgLy8gRXRoaW9waWNcbiAgICB7YmVnaW46IDB4MTNBMCwgZW5kOiAweDEzRkZ9LCAvLyBDaGVyb2tlZVxuICAgIHtiZWdpbjogMHgxNDAwLCBlbmQ6IDB4MTY3Rn0sIC8vIFVuaWZpZWQgQ2FuYWRpYW4gQWJvcmlnaW5hbCBTeWxsYWJpY3NcbiAgICB7YmVnaW46IDB4MTY4MCwgZW5kOiAweDE2OUZ9LCAvLyBPZ2hhbVxuICAgIHtiZWdpbjogMHgxNkEwLCBlbmQ6IDB4MTZGRn0sIC8vIFJ1bmljXG4gICAge2JlZ2luOiAweDE3ODAsIGVuZDogMHgxN0ZGfSwgLy8gS2htZXJcbiAgICB7YmVnaW46IDB4MTgwMCwgZW5kOiAweDE4QUZ9LCAvLyBNb25nb2xpYW5cbiAgICB7YmVnaW46IDB4MjgwMCwgZW5kOiAweDI4RkZ9LCAvLyBCcmFpbGxlIFBhdHRlcm5zXG4gICAge2JlZ2luOiAweEEwMDAsIGVuZDogMHhBNDhGfSwgLy8gWWkgU3lsbGFibGVzXG4gICAge2JlZ2luOiAweDE3MDAsIGVuZDogMHgxNzFGfSwgLy8gVGFnYWxvZ1xuICAgIHtiZWdpbjogMHgxMDMwMCwgZW5kOiAweDEwMzJGfSwgLy8gT2xkIEl0YWxpY1xuICAgIHtiZWdpbjogMHgxMDMzMCwgZW5kOiAweDEwMzRGfSwgLy8gR290aGljXG4gICAge2JlZ2luOiAweDEwNDAwLCBlbmQ6IDB4MTA0NEZ9LCAvLyBEZXNlcmV0XG4gICAge2JlZ2luOiAweDFEMDAwLCBlbmQ6IDB4MUQwRkZ9LCAvLyBCeXphbnRpbmUgTXVzaWNhbCBTeW1ib2xzXG4gICAge2JlZ2luOiAweDFENDAwLCBlbmQ6IDB4MUQ3RkZ9LCAvLyBNYXRoZW1hdGljYWwgQWxwaGFudW1lcmljIFN5bWJvbHNcbiAgICB7YmVnaW46IDB4RkYwMDAsIGVuZDogMHhGRkZGRH0sIC8vIFByaXZhdGUgVXNlIChwbGFuZSAxNSlcbiAgICB7YmVnaW46IDB4RkUwMCwgZW5kOiAweEZFMEZ9LCAvLyBWYXJpYXRpb24gU2VsZWN0b3JzXG4gICAge2JlZ2luOiAweEUwMDAwLCBlbmQ6IDB4RTAwN0Z9LCAvLyBUYWdzXG4gICAge2JlZ2luOiAweDE5MDAsIGVuZDogMHgxOTRGfSwgLy8gTGltYnVcbiAgICB7YmVnaW46IDB4MTk1MCwgZW5kOiAweDE5N0Z9LCAvLyBUYWkgTGVcbiAgICB7YmVnaW46IDB4MTk4MCwgZW5kOiAweDE5REZ9LCAvLyBOZXcgVGFpIEx1ZVxuICAgIHtiZWdpbjogMHgxQTAwLCBlbmQ6IDB4MUExRn0sIC8vIEJ1Z2luZXNlXG4gICAge2JlZ2luOiAweDJDMDAsIGVuZDogMHgyQzVGfSwgLy8gR2xhZ29saXRpY1xuICAgIHtiZWdpbjogMHgyRDMwLCBlbmQ6IDB4MkQ3Rn0sIC8vIFRpZmluYWdoXG4gICAge2JlZ2luOiAweDREQzAsIGVuZDogMHg0REZGfSwgLy8gWWlqaW5nIEhleGFncmFtIFN5bWJvbHNcbiAgICB7YmVnaW46IDB4QTgwMCwgZW5kOiAweEE4MkZ9LCAvLyBTeWxvdGkgTmFncmlcbiAgICB7YmVnaW46IDB4MTAwMDAsIGVuZDogMHgxMDA3Rn0sIC8vIExpbmVhciBCIFN5bGxhYmFyeVxuICAgIHtiZWdpbjogMHgxMDE0MCwgZW5kOiAweDEwMThGfSwgLy8gQW5jaWVudCBHcmVlayBOdW1iZXJzXG4gICAge2JlZ2luOiAweDEwMzgwLCBlbmQ6IDB4MTAzOUZ9LCAvLyBVZ2FyaXRpY1xuICAgIHtiZWdpbjogMHgxMDNBMCwgZW5kOiAweDEwM0RGfSwgLy8gT2xkIFBlcnNpYW5cbiAgICB7YmVnaW46IDB4MTA0NTAsIGVuZDogMHgxMDQ3Rn0sIC8vIFNoYXZpYW5cbiAgICB7YmVnaW46IDB4MTA0ODAsIGVuZDogMHgxMDRBRn0sIC8vIE9zbWFueWFcbiAgICB7YmVnaW46IDB4MTA4MDAsIGVuZDogMHgxMDgzRn0sIC8vIEN5cHJpb3QgU3lsbGFiYXJ5XG4gICAge2JlZ2luOiAweDEwQTAwLCBlbmQ6IDB4MTBBNUZ9LCAvLyBLaGFyb3NodGhpXG4gICAge2JlZ2luOiAweDFEMzAwLCBlbmQ6IDB4MUQzNUZ9LCAvLyBUYWkgWHVhbiBKaW5nIFN5bWJvbHNcbiAgICB7YmVnaW46IDB4MTIwMDAsIGVuZDogMHgxMjNGRn0sIC8vIEN1bmVpZm9ybVxuICAgIHtiZWdpbjogMHgxRDM2MCwgZW5kOiAweDFEMzdGfSwgLy8gQ291bnRpbmcgUm9kIE51bWVyYWxzXG4gICAge2JlZ2luOiAweDFCODAsIGVuZDogMHgxQkJGfSwgLy8gU3VuZGFuZXNlXG4gICAge2JlZ2luOiAweDFDMDAsIGVuZDogMHgxQzRGfSwgLy8gTGVwY2hhXG4gICAge2JlZ2luOiAweDFDNTAsIGVuZDogMHgxQzdGfSwgLy8gT2wgQ2hpa2lcbiAgICB7YmVnaW46IDB4QTg4MCwgZW5kOiAweEE4REZ9LCAvLyBTYXVyYXNodHJhXG4gICAge2JlZ2luOiAweEE5MDAsIGVuZDogMHhBOTJGfSwgLy8gS2F5YWggTGlcbiAgICB7YmVnaW46IDB4QTkzMCwgZW5kOiAweEE5NUZ9LCAvLyBSZWphbmdcbiAgICB7YmVnaW46IDB4QUEwMCwgZW5kOiAweEFBNUZ9LCAvLyBDaGFtXG4gICAge2JlZ2luOiAweDEwMTkwLCBlbmQ6IDB4MTAxQ0Z9LCAvLyBBbmNpZW50IFN5bWJvbHNcbiAgICB7YmVnaW46IDB4MTAxRDAsIGVuZDogMHgxMDFGRn0sIC8vIFBoYWlzdG9zIERpc2NcbiAgICB7YmVnaW46IDB4MTAyQTAsIGVuZDogMHgxMDJERn0sIC8vIENhcmlhblxuICAgIHtiZWdpbjogMHgxRjAzMCwgZW5kOiAweDFGMDlGfSAgLy8gRG9taW5vIFRpbGVzXG5dO1xuXG5mdW5jdGlvbiBnZXRVbmljb2RlUmFuZ2UodW5pY29kZSkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdW5pY29kZVJhbmdlcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBjb25zdCByYW5nZSA9IHVuaWNvZGVSYW5nZXNbaV07XG4gICAgICAgIGlmICh1bmljb2RlID49IHJhbmdlLmJlZ2luICYmIHVuaWNvZGUgPCByYW5nZS5lbmQpIHtcbiAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIC0xO1xufVxuXG4vLyBQYXJzZSB0aGUgT1MvMiBhbmQgV2luZG93cyBtZXRyaWNzIGBPUy8yYCB0YWJsZVxuZnVuY3Rpb24gcGFyc2VPUzJUYWJsZShkYXRhLCBzdGFydCkge1xuICAgIGNvbnN0IG9zMiA9IHt9O1xuICAgIGNvbnN0IHAgPSBuZXcgcGFyc2UuUGFyc2VyKGRhdGEsIHN0YXJ0KTtcbiAgICBvczIudmVyc2lvbiA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICBvczIueEF2Z0NoYXJXaWR0aCA9IHAucGFyc2VTaG9ydCgpO1xuICAgIG9zMi51c1dlaWdodENsYXNzID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgIG9zMi51c1dpZHRoQ2xhc3MgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgb3MyLmZzVHlwZSA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICBvczIueVN1YnNjcmlwdFhTaXplID0gcC5wYXJzZVNob3J0KCk7XG4gICAgb3MyLnlTdWJzY3JpcHRZU2l6ZSA9IHAucGFyc2VTaG9ydCgpO1xuICAgIG9zMi55U3Vic2NyaXB0WE9mZnNldCA9IHAucGFyc2VTaG9ydCgpO1xuICAgIG9zMi55U3Vic2NyaXB0WU9mZnNldCA9IHAucGFyc2VTaG9ydCgpO1xuICAgIG9zMi55U3VwZXJzY3JpcHRYU2l6ZSA9IHAucGFyc2VTaG9ydCgpO1xuICAgIG9zMi55U3VwZXJzY3JpcHRZU2l6ZSA9IHAucGFyc2VTaG9ydCgpO1xuICAgIG9zMi55U3VwZXJzY3JpcHRYT2Zmc2V0ID0gcC5wYXJzZVNob3J0KCk7XG4gICAgb3MyLnlTdXBlcnNjcmlwdFlPZmZzZXQgPSBwLnBhcnNlU2hvcnQoKTtcbiAgICBvczIueVN0cmlrZW91dFNpemUgPSBwLnBhcnNlU2hvcnQoKTtcbiAgICBvczIueVN0cmlrZW91dFBvc2l0aW9uID0gcC5wYXJzZVNob3J0KCk7XG4gICAgb3MyLnNGYW1pbHlDbGFzcyA9IHAucGFyc2VTaG9ydCgpO1xuICAgIG9zMi5wYW5vc2UgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDEwOyBpKyspIHtcbiAgICAgICAgb3MyLnBhbm9zZVtpXSA9IHAucGFyc2VCeXRlKCk7XG4gICAgfVxuXG4gICAgb3MyLnVsVW5pY29kZVJhbmdlMSA9IHAucGFyc2VVTG9uZygpO1xuICAgIG9zMi51bFVuaWNvZGVSYW5nZTIgPSBwLnBhcnNlVUxvbmcoKTtcbiAgICBvczIudWxVbmljb2RlUmFuZ2UzID0gcC5wYXJzZVVMb25nKCk7XG4gICAgb3MyLnVsVW5pY29kZVJhbmdlNCA9IHAucGFyc2VVTG9uZygpO1xuICAgIG9zMi5hY2hWZW5kSUQgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHAucGFyc2VCeXRlKCksIHAucGFyc2VCeXRlKCksIHAucGFyc2VCeXRlKCksIHAucGFyc2VCeXRlKCkpO1xuICAgIG9zMi5mc1NlbGVjdGlvbiA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICBvczIudXNGaXJzdENoYXJJbmRleCA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICBvczIudXNMYXN0Q2hhckluZGV4ID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgIG9zMi5zVHlwb0FzY2VuZGVyID0gcC5wYXJzZVNob3J0KCk7XG4gICAgb3MyLnNUeXBvRGVzY2VuZGVyID0gcC5wYXJzZVNob3J0KCk7XG4gICAgb3MyLnNUeXBvTGluZUdhcCA9IHAucGFyc2VTaG9ydCgpO1xuICAgIG9zMi51c1dpbkFzY2VudCA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICBvczIudXNXaW5EZXNjZW50ID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgIGlmIChvczIudmVyc2lvbiA+PSAxKSB7XG4gICAgICAgIG9zMi51bENvZGVQYWdlUmFuZ2UxID0gcC5wYXJzZVVMb25nKCk7XG4gICAgICAgIG9zMi51bENvZGVQYWdlUmFuZ2UyID0gcC5wYXJzZVVMb25nKCk7XG4gICAgfVxuXG4gICAgaWYgKG9zMi52ZXJzaW9uID49IDIpIHtcbiAgICAgICAgb3MyLnN4SGVpZ2h0ID0gcC5wYXJzZVNob3J0KCk7XG4gICAgICAgIG9zMi5zQ2FwSGVpZ2h0ID0gcC5wYXJzZVNob3J0KCk7XG4gICAgICAgIG9zMi51c0RlZmF1bHRDaGFyID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICBvczIudXNCcmVha0NoYXIgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgIG9zMi51c01heENvbnRlbnQgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG9zMjtcbn1cblxuZnVuY3Rpb24gbWFrZU9TMlRhYmxlKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IHRhYmxlLlRhYmxlKCdPUy8yJywgW1xuICAgICAgICB7bmFtZTogJ3ZlcnNpb24nLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDB4MDAwM30sXG4gICAgICAgIHtuYW1lOiAneEF2Z0NoYXJXaWR0aCcsIHR5cGU6ICdTSE9SVCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICd1c1dlaWdodENsYXNzJywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICd1c1dpZHRoQ2xhc3MnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ2ZzVHlwZScsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAneVN1YnNjcmlwdFhTaXplJywgdHlwZTogJ1NIT1JUJywgdmFsdWU6IDY1MH0sXG4gICAgICAgIHtuYW1lOiAneVN1YnNjcmlwdFlTaXplJywgdHlwZTogJ1NIT1JUJywgdmFsdWU6IDY5OX0sXG4gICAgICAgIHtuYW1lOiAneVN1YnNjcmlwdFhPZmZzZXQnLCB0eXBlOiAnU0hPUlQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAneVN1YnNjcmlwdFlPZmZzZXQnLCB0eXBlOiAnU0hPUlQnLCB2YWx1ZTogMTQwfSxcbiAgICAgICAge25hbWU6ICd5U3VwZXJzY3JpcHRYU2l6ZScsIHR5cGU6ICdTSE9SVCcsIHZhbHVlOiA2NTB9LFxuICAgICAgICB7bmFtZTogJ3lTdXBlcnNjcmlwdFlTaXplJywgdHlwZTogJ1NIT1JUJywgdmFsdWU6IDY5OX0sXG4gICAgICAgIHtuYW1lOiAneVN1cGVyc2NyaXB0WE9mZnNldCcsIHR5cGU6ICdTSE9SVCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICd5U3VwZXJzY3JpcHRZT2Zmc2V0JywgdHlwZTogJ1NIT1JUJywgdmFsdWU6IDQ3OX0sXG4gICAgICAgIHtuYW1lOiAneVN0cmlrZW91dFNpemUnLCB0eXBlOiAnU0hPUlQnLCB2YWx1ZTogNDl9LFxuICAgICAgICB7bmFtZTogJ3lTdHJpa2VvdXRQb3NpdGlvbicsIHR5cGU6ICdTSE9SVCcsIHZhbHVlOiAyNTh9LFxuICAgICAgICB7bmFtZTogJ3NGYW1pbHlDbGFzcycsIHR5cGU6ICdTSE9SVCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICdiRmFtaWx5VHlwZScsIHR5cGU6ICdCWVRFJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ2JTZXJpZlN0eWxlJywgdHlwZTogJ0JZVEUnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAnYldlaWdodCcsIHR5cGU6ICdCWVRFJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ2JQcm9wb3J0aW9uJywgdHlwZTogJ0JZVEUnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAnYkNvbnRyYXN0JywgdHlwZTogJ0JZVEUnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAnYlN0cm9rZVZhcmlhdGlvbicsIHR5cGU6ICdCWVRFJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ2JBcm1TdHlsZScsIHR5cGU6ICdCWVRFJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ2JMZXR0ZXJmb3JtJywgdHlwZTogJ0JZVEUnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAnYk1pZGxpbmUnLCB0eXBlOiAnQllURScsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICdiWEhlaWdodCcsIHR5cGU6ICdCWVRFJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ3VsVW5pY29kZVJhbmdlMScsIHR5cGU6ICdVTE9ORycsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICd1bFVuaWNvZGVSYW5nZTInLCB0eXBlOiAnVUxPTkcnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAndWxVbmljb2RlUmFuZ2UzJywgdHlwZTogJ1VMT05HJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ3VsVW5pY29kZVJhbmdlNCcsIHR5cGU6ICdVTE9ORycsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICdhY2hWZW5kSUQnLCB0eXBlOiAnQ0hBUkFSUkFZJywgdmFsdWU6ICdYWFhYJ30sXG4gICAgICAgIHtuYW1lOiAnZnNTZWxlY3Rpb24nLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ3VzRmlyc3RDaGFySW5kZXgnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ3VzTGFzdENoYXJJbmRleCcsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAnc1R5cG9Bc2NlbmRlcicsIHR5cGU6ICdTSE9SVCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICdzVHlwb0Rlc2NlbmRlcicsIHR5cGU6ICdTSE9SVCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICdzVHlwb0xpbmVHYXAnLCB0eXBlOiAnU0hPUlQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAndXNXaW5Bc2NlbnQnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ3VzV2luRGVzY2VudCcsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAndWxDb2RlUGFnZVJhbmdlMScsIHR5cGU6ICdVTE9ORycsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICd1bENvZGVQYWdlUmFuZ2UyJywgdHlwZTogJ1VMT05HJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ3N4SGVpZ2h0JywgdHlwZTogJ1NIT1JUJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ3NDYXBIZWlnaHQnLCB0eXBlOiAnU0hPUlQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAndXNEZWZhdWx0Q2hhcicsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAndXNCcmVha0NoYXInLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ3VzTWF4Q29udGV4dCcsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogMH1cbiAgICBdLCBvcHRpb25zKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgeyBwYXJzZTogcGFyc2VPUzJUYWJsZSwgbWFrZTogbWFrZU9TMlRhYmxlLCB1bmljb2RlUmFuZ2VzLCBnZXRVbmljb2RlUmFuZ2UgfTtcbiIsIi8vIFRoZSBgcG9zdGAgdGFibGUgc3RvcmVzIGFkZGl0aW9uYWwgUG9zdFNjcmlwdCBpbmZvcm1hdGlvbiwgc3VjaCBhcyBnbHlwaCBuYW1lcy5cbi8vIGh0dHBzOi8vd3d3Lm1pY3Jvc29mdC5jb20vdHlwb2dyYXBoeS9PVFNQRUMvcG9zdC5odG1cblxuaW1wb3J0IHsgc3RhbmRhcmROYW1lcyB9IGZyb20gJy4uL2VuY29kaW5nJztcbmltcG9ydCBwYXJzZSBmcm9tICcuLi9wYXJzZSc7XG5pbXBvcnQgdGFibGUgZnJvbSAnLi4vdGFibGUnO1xuXG4vLyBQYXJzZSB0aGUgUG9zdFNjcmlwdCBgcG9zdGAgdGFibGVcbmZ1bmN0aW9uIHBhcnNlUG9zdFRhYmxlKGRhdGEsIHN0YXJ0KSB7XG4gICAgY29uc3QgcG9zdCA9IHt9O1xuICAgIGNvbnN0IHAgPSBuZXcgcGFyc2UuUGFyc2VyKGRhdGEsIHN0YXJ0KTtcbiAgICBwb3N0LnZlcnNpb24gPSBwLnBhcnNlVmVyc2lvbigpO1xuICAgIHBvc3QuaXRhbGljQW5nbGUgPSBwLnBhcnNlRml4ZWQoKTtcbiAgICBwb3N0LnVuZGVybGluZVBvc2l0aW9uID0gcC5wYXJzZVNob3J0KCk7XG4gICAgcG9zdC51bmRlcmxpbmVUaGlja25lc3MgPSBwLnBhcnNlU2hvcnQoKTtcbiAgICBwb3N0LmlzRml4ZWRQaXRjaCA9IHAucGFyc2VVTG9uZygpO1xuICAgIHBvc3QubWluTWVtVHlwZTQyID0gcC5wYXJzZVVMb25nKCk7XG4gICAgcG9zdC5tYXhNZW1UeXBlNDIgPSBwLnBhcnNlVUxvbmcoKTtcbiAgICBwb3N0Lm1pbk1lbVR5cGUxID0gcC5wYXJzZVVMb25nKCk7XG4gICAgcG9zdC5tYXhNZW1UeXBlMSA9IHAucGFyc2VVTG9uZygpO1xuICAgIHN3aXRjaCAocG9zdC52ZXJzaW9uKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIHBvc3QubmFtZXMgPSBzdGFuZGFyZE5hbWVzLnNsaWNlKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgcG9zdC5udW1iZXJPZkdseXBocyA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgICAgIHBvc3QuZ2x5cGhOYW1lSW5kZXggPSBuZXcgQXJyYXkocG9zdC5udW1iZXJPZkdseXBocyk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBvc3QubnVtYmVyT2ZHbHlwaHM7IGkrKykge1xuICAgICAgICAgICAgICAgIHBvc3QuZ2x5cGhOYW1lSW5kZXhbaV0gPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHBvc3QubmFtZXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcG9zdC5udW1iZXJPZkdseXBoczsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBvc3QuZ2x5cGhOYW1lSW5kZXhbaV0gPj0gc3RhbmRhcmROYW1lcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmFtZUxlbmd0aCA9IHAucGFyc2VDaGFyKCk7XG4gICAgICAgICAgICAgICAgICAgIHBvc3QubmFtZXMucHVzaChwLnBhcnNlU3RyaW5nKG5hbWVMZW5ndGgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDIuNTpcbiAgICAgICAgICAgIHBvc3QubnVtYmVyT2ZHbHlwaHMgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgICAgICBwb3N0Lm9mZnNldCA9IG5ldyBBcnJheShwb3N0Lm51bWJlck9mR2x5cGhzKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcG9zdC5udW1iZXJPZkdseXBoczsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcG9zdC5vZmZzZXRbaV0gPSBwLnBhcnNlQ2hhcigpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIHBvc3Q7XG59XG5cbmZ1bmN0aW9uIG1ha2VQb3N0VGFibGUoKSB7XG4gICAgcmV0dXJuIG5ldyB0YWJsZS5UYWJsZSgncG9zdCcsIFtcbiAgICAgICAge25hbWU6ICd2ZXJzaW9uJywgdHlwZTogJ0ZJWEVEJywgdmFsdWU6IDB4MDAwMzAwMDB9LFxuICAgICAgICB7bmFtZTogJ2l0YWxpY0FuZ2xlJywgdHlwZTogJ0ZJWEVEJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ3VuZGVybGluZVBvc2l0aW9uJywgdHlwZTogJ0ZXT1JEJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ3VuZGVybGluZVRoaWNrbmVzcycsIHR5cGU6ICdGV09SRCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICdpc0ZpeGVkUGl0Y2gnLCB0eXBlOiAnVUxPTkcnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAnbWluTWVtVHlwZTQyJywgdHlwZTogJ1VMT05HJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ21heE1lbVR5cGU0MicsIHR5cGU6ICdVTE9ORycsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICdtaW5NZW1UeXBlMScsIHR5cGU6ICdVTE9ORycsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICdtYXhNZW1UeXBlMScsIHR5cGU6ICdVTE9ORycsIHZhbHVlOiAwfVxuICAgIF0pO1xufVxuXG5leHBvcnQgZGVmYXVsdCB7IHBhcnNlOiBwYXJzZVBvc3RUYWJsZSwgbWFrZTogbWFrZVBvc3RUYWJsZSB9O1xuIiwiLy8gVGhlIGBHU1VCYCB0YWJsZSBjb250YWlucyBsaWdhdHVyZXMsIGFtb25nIG90aGVyIHRoaW5ncy5cbi8vIGh0dHBzOi8vd3d3Lm1pY3Jvc29mdC5jb20vdHlwb2dyYXBoeS9PVFNQRUMvZ3N1Yi5odG1cblxuaW1wb3J0IGNoZWNrIGZyb20gJy4uL2NoZWNrJztcbmltcG9ydCB7IFBhcnNlciB9IGZyb20gJy4uL3BhcnNlJztcbmltcG9ydCB0YWJsZSBmcm9tICcuLi90YWJsZSc7XG5cbmNvbnN0IHN1YnRhYmxlUGFyc2VycyA9IG5ldyBBcnJheSg5KTsgICAgICAgICAvLyBzdWJ0YWJsZVBhcnNlcnNbMF0gaXMgdW51c2VkXG5cbi8vIGh0dHBzOi8vd3d3Lm1pY3Jvc29mdC5jb20vdHlwb2dyYXBoeS9PVFNQRUMvR1NVQi5odG0jU1NcbnN1YnRhYmxlUGFyc2Vyc1sxXSA9IGZ1bmN0aW9uIHBhcnNlTG9va3VwMSgpIHtcbiAgICBjb25zdCBzdGFydCA9IHRoaXMub2Zmc2V0ICsgdGhpcy5yZWxhdGl2ZU9mZnNldDtcbiAgICBjb25zdCBzdWJzdEZvcm1hdCA9IHRoaXMucGFyc2VVU2hvcnQoKTtcbiAgICBpZiAoc3Vic3RGb3JtYXQgPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN1YnN0Rm9ybWF0OiAxLFxuICAgICAgICAgICAgY292ZXJhZ2U6IHRoaXMucGFyc2VQb2ludGVyKFBhcnNlci5jb3ZlcmFnZSksXG4gICAgICAgICAgICBkZWx0YUdseXBoSWQ6IHRoaXMucGFyc2VVU2hvcnQoKVxuICAgICAgICB9O1xuICAgIH0gZWxzZSBpZiAoc3Vic3RGb3JtYXQgPT09IDIpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN1YnN0Rm9ybWF0OiAyLFxuICAgICAgICAgICAgY292ZXJhZ2U6IHRoaXMucGFyc2VQb2ludGVyKFBhcnNlci5jb3ZlcmFnZSksXG4gICAgICAgICAgICBzdWJzdGl0dXRlOiB0aGlzLnBhcnNlT2Zmc2V0MTZMaXN0KClcbiAgICAgICAgfTtcbiAgICB9XG4gICAgY2hlY2suYXNzZXJ0KGZhbHNlLCAnMHgnICsgc3RhcnQudG9TdHJpbmcoMTYpICsgJzogbG9va3VwIHR5cGUgMSBmb3JtYXQgbXVzdCBiZSAxIG9yIDIuJyk7XG59O1xuXG4vLyBodHRwczovL3d3dy5taWNyb3NvZnQuY29tL3R5cG9ncmFwaHkvT1RTUEVDL0dTVUIuaHRtI01TXG5zdWJ0YWJsZVBhcnNlcnNbMl0gPSBmdW5jdGlvbiBwYXJzZUxvb2t1cDIoKSB7XG4gICAgY29uc3Qgc3Vic3RGb3JtYXQgPSB0aGlzLnBhcnNlVVNob3J0KCk7XG4gICAgY2hlY2suYXJndW1lbnQoc3Vic3RGb3JtYXQgPT09IDEsICdHU1VCIE11bHRpcGxlIFN1YnN0aXR1dGlvbiBTdWJ0YWJsZSBpZGVudGlmaWVyLWZvcm1hdCBtdXN0IGJlIDEnKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBzdWJzdEZvcm1hdDogc3Vic3RGb3JtYXQsXG4gICAgICAgIGNvdmVyYWdlOiB0aGlzLnBhcnNlUG9pbnRlcihQYXJzZXIuY292ZXJhZ2UpLFxuICAgICAgICBzZXF1ZW5jZXM6IHRoaXMucGFyc2VMaXN0T2ZMaXN0cygpXG4gICAgfTtcbn07XG5cbi8vIGh0dHBzOi8vd3d3Lm1pY3Jvc29mdC5jb20vdHlwb2dyYXBoeS9PVFNQRUMvR1NVQi5odG0jQVNcbnN1YnRhYmxlUGFyc2Vyc1szXSA9IGZ1bmN0aW9uIHBhcnNlTG9va3VwMygpIHtcbiAgICBjb25zdCBzdWJzdEZvcm1hdCA9IHRoaXMucGFyc2VVU2hvcnQoKTtcbiAgICBjaGVjay5hcmd1bWVudChzdWJzdEZvcm1hdCA9PT0gMSwgJ0dTVUIgQWx0ZXJuYXRlIFN1YnN0aXR1dGlvbiBTdWJ0YWJsZSBpZGVudGlmaWVyLWZvcm1hdCBtdXN0IGJlIDEnKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBzdWJzdEZvcm1hdDogc3Vic3RGb3JtYXQsXG4gICAgICAgIGNvdmVyYWdlOiB0aGlzLnBhcnNlUG9pbnRlcihQYXJzZXIuY292ZXJhZ2UpLFxuICAgICAgICBhbHRlcm5hdGVTZXRzOiB0aGlzLnBhcnNlTGlzdE9mTGlzdHMoKVxuICAgIH07XG59O1xuXG4vLyBodHRwczovL3d3dy5taWNyb3NvZnQuY29tL3R5cG9ncmFwaHkvT1RTUEVDL0dTVUIuaHRtI0xTXG5zdWJ0YWJsZVBhcnNlcnNbNF0gPSBmdW5jdGlvbiBwYXJzZUxvb2t1cDQoKSB7XG4gICAgY29uc3Qgc3Vic3RGb3JtYXQgPSB0aGlzLnBhcnNlVVNob3J0KCk7XG4gICAgY2hlY2suYXJndW1lbnQoc3Vic3RGb3JtYXQgPT09IDEsICdHU1VCIGxpZ2F0dXJlIHRhYmxlIGlkZW50aWZpZXItZm9ybWF0IG11c3QgYmUgMScpO1xuICAgIHJldHVybiB7XG4gICAgICAgIHN1YnN0Rm9ybWF0OiBzdWJzdEZvcm1hdCxcbiAgICAgICAgY292ZXJhZ2U6IHRoaXMucGFyc2VQb2ludGVyKFBhcnNlci5jb3ZlcmFnZSksXG4gICAgICAgIGxpZ2F0dXJlU2V0czogdGhpcy5wYXJzZUxpc3RPZkxpc3RzKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBsaWdHbHlwaDogdGhpcy5wYXJzZVVTaG9ydCgpLFxuICAgICAgICAgICAgICAgIGNvbXBvbmVudHM6IHRoaXMucGFyc2VVU2hvcnRMaXN0KHRoaXMucGFyc2VVU2hvcnQoKSAtIDEpXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KVxuICAgIH07XG59O1xuXG5jb25zdCBsb29rdXBSZWNvcmREZXNjID0ge1xuICAgIHNlcXVlbmNlSW5kZXg6IFBhcnNlci51U2hvcnQsXG4gICAgbG9va3VwTGlzdEluZGV4OiBQYXJzZXIudVNob3J0XG59O1xuXG4vLyBodHRwczovL3d3dy5taWNyb3NvZnQuY29tL3R5cG9ncmFwaHkvT1RTUEVDL0dTVUIuaHRtI0NTRlxuc3VidGFibGVQYXJzZXJzWzVdID0gZnVuY3Rpb24gcGFyc2VMb29rdXA1KCkge1xuICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5vZmZzZXQgKyB0aGlzLnJlbGF0aXZlT2Zmc2V0O1xuICAgIGNvbnN0IHN1YnN0Rm9ybWF0ID0gdGhpcy5wYXJzZVVTaG9ydCgpO1xuXG4gICAgaWYgKHN1YnN0Rm9ybWF0ID09PSAxKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdWJzdEZvcm1hdDogc3Vic3RGb3JtYXQsXG4gICAgICAgICAgICBjb3ZlcmFnZTogdGhpcy5wYXJzZVBvaW50ZXIoUGFyc2VyLmNvdmVyYWdlKSxcbiAgICAgICAgICAgIHJ1bGVTZXRzOiB0aGlzLnBhcnNlTGlzdE9mTGlzdHMoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZ2x5cGhDb3VudCA9IHRoaXMucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzdWJzdENvdW50ID0gdGhpcy5wYXJzZVVTaG9ydCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGlucHV0OiB0aGlzLnBhcnNlVVNob3J0TGlzdChnbHlwaENvdW50IC0gMSksXG4gICAgICAgICAgICAgICAgICAgIGxvb2t1cFJlY29yZHM6IHRoaXMucGFyc2VSZWNvcmRMaXN0KHN1YnN0Q291bnQsIGxvb2t1cFJlY29yZERlc2MpXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH07XG4gICAgfSBlbHNlIGlmIChzdWJzdEZvcm1hdCA9PT0gMikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3Vic3RGb3JtYXQ6IHN1YnN0Rm9ybWF0LFxuICAgICAgICAgICAgY292ZXJhZ2U6IHRoaXMucGFyc2VQb2ludGVyKFBhcnNlci5jb3ZlcmFnZSksXG4gICAgICAgICAgICBjbGFzc0RlZjogdGhpcy5wYXJzZVBvaW50ZXIoUGFyc2VyLmNsYXNzRGVmKSxcbiAgICAgICAgICAgIGNsYXNzU2V0czogdGhpcy5wYXJzZUxpc3RPZkxpc3RzKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGdseXBoQ291bnQgPSB0aGlzLnBhcnNlVVNob3J0KCk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3Vic3RDb3VudCA9IHRoaXMucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBjbGFzc2VzOiB0aGlzLnBhcnNlVVNob3J0TGlzdChnbHlwaENvdW50IC0gMSksXG4gICAgICAgICAgICAgICAgICAgIGxvb2t1cFJlY29yZHM6IHRoaXMucGFyc2VSZWNvcmRMaXN0KHN1YnN0Q291bnQsIGxvb2t1cFJlY29yZERlc2MpXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH07XG4gICAgfSBlbHNlIGlmIChzdWJzdEZvcm1hdCA9PT0gMykge1xuICAgICAgICBjb25zdCBnbHlwaENvdW50ID0gdGhpcy5wYXJzZVVTaG9ydCgpO1xuICAgICAgICBjb25zdCBzdWJzdENvdW50ID0gdGhpcy5wYXJzZVVTaG9ydCgpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3Vic3RGb3JtYXQ6IHN1YnN0Rm9ybWF0LFxuICAgICAgICAgICAgY292ZXJhZ2VzOiB0aGlzLnBhcnNlTGlzdChnbHlwaENvdW50LCBQYXJzZXIucG9pbnRlcihQYXJzZXIuY292ZXJhZ2UpKSxcbiAgICAgICAgICAgIGxvb2t1cFJlY29yZHM6IHRoaXMucGFyc2VSZWNvcmRMaXN0KHN1YnN0Q291bnQsIGxvb2t1cFJlY29yZERlc2MpXG4gICAgICAgIH07XG4gICAgfVxuICAgIGNoZWNrLmFzc2VydChmYWxzZSwgJzB4JyArIHN0YXJ0LnRvU3RyaW5nKDE2KSArICc6IGxvb2t1cCB0eXBlIDUgZm9ybWF0IG11c3QgYmUgMSwgMiBvciAzLicpO1xufTtcblxuLy8gaHR0cHM6Ly93d3cubWljcm9zb2Z0LmNvbS90eXBvZ3JhcGh5L09UU1BFQy9HU1VCLmh0bSNDQ1xuc3VidGFibGVQYXJzZXJzWzZdID0gZnVuY3Rpb24gcGFyc2VMb29rdXA2KCkge1xuICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5vZmZzZXQgKyB0aGlzLnJlbGF0aXZlT2Zmc2V0O1xuICAgIGNvbnN0IHN1YnN0Rm9ybWF0ID0gdGhpcy5wYXJzZVVTaG9ydCgpO1xuICAgIGlmIChzdWJzdEZvcm1hdCA9PT0gMSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3Vic3RGb3JtYXQ6IDEsXG4gICAgICAgICAgICBjb3ZlcmFnZTogdGhpcy5wYXJzZVBvaW50ZXIoUGFyc2VyLmNvdmVyYWdlKSxcbiAgICAgICAgICAgIGNoYWluUnVsZVNldHM6IHRoaXMucGFyc2VMaXN0T2ZMaXN0cyhmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBiYWNrdHJhY2s6IHRoaXMucGFyc2VVU2hvcnRMaXN0KCksXG4gICAgICAgICAgICAgICAgICAgIGlucHV0OiB0aGlzLnBhcnNlVVNob3J0TGlzdCh0aGlzLnBhcnNlU2hvcnQoKSAtIDEpLFxuICAgICAgICAgICAgICAgICAgICBsb29rYWhlYWQ6IHRoaXMucGFyc2VVU2hvcnRMaXN0KCksXG4gICAgICAgICAgICAgICAgICAgIGxvb2t1cFJlY29yZHM6IHRoaXMucGFyc2VSZWNvcmRMaXN0KGxvb2t1cFJlY29yZERlc2MpXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH07XG4gICAgfSBlbHNlIGlmIChzdWJzdEZvcm1hdCA9PT0gMikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3Vic3RGb3JtYXQ6IDIsXG4gICAgICAgICAgICBjb3ZlcmFnZTogdGhpcy5wYXJzZVBvaW50ZXIoUGFyc2VyLmNvdmVyYWdlKSxcbiAgICAgICAgICAgIGJhY2t0cmFja0NsYXNzRGVmOiB0aGlzLnBhcnNlUG9pbnRlcihQYXJzZXIuY2xhc3NEZWYpLFxuICAgICAgICAgICAgaW5wdXRDbGFzc0RlZjogdGhpcy5wYXJzZVBvaW50ZXIoUGFyc2VyLmNsYXNzRGVmKSxcbiAgICAgICAgICAgIGxvb2thaGVhZENsYXNzRGVmOiB0aGlzLnBhcnNlUG9pbnRlcihQYXJzZXIuY2xhc3NEZWYpLFxuICAgICAgICAgICAgY2hhaW5DbGFzc1NldDogdGhpcy5wYXJzZUxpc3RPZkxpc3RzKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGJhY2t0cmFjazogdGhpcy5wYXJzZVVTaG9ydExpc3QoKSxcbiAgICAgICAgICAgICAgICAgICAgaW5wdXQ6IHRoaXMucGFyc2VVU2hvcnRMaXN0KHRoaXMucGFyc2VTaG9ydCgpIC0gMSksXG4gICAgICAgICAgICAgICAgICAgIGxvb2thaGVhZDogdGhpcy5wYXJzZVVTaG9ydExpc3QoKSxcbiAgICAgICAgICAgICAgICAgICAgbG9va3VwUmVjb3JkczogdGhpcy5wYXJzZVJlY29yZExpc3QobG9va3VwUmVjb3JkRGVzYylcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSlcbiAgICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKHN1YnN0Rm9ybWF0ID09PSAzKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdWJzdEZvcm1hdDogMyxcbiAgICAgICAgICAgIGJhY2t0cmFja0NvdmVyYWdlOiB0aGlzLnBhcnNlTGlzdChQYXJzZXIucG9pbnRlcihQYXJzZXIuY292ZXJhZ2UpKSxcbiAgICAgICAgICAgIGlucHV0Q292ZXJhZ2U6IHRoaXMucGFyc2VMaXN0KFBhcnNlci5wb2ludGVyKFBhcnNlci5jb3ZlcmFnZSkpLFxuICAgICAgICAgICAgbG9va2FoZWFkQ292ZXJhZ2U6IHRoaXMucGFyc2VMaXN0KFBhcnNlci5wb2ludGVyKFBhcnNlci5jb3ZlcmFnZSkpLFxuICAgICAgICAgICAgbG9va3VwUmVjb3JkczogdGhpcy5wYXJzZVJlY29yZExpc3QobG9va3VwUmVjb3JkRGVzYylcbiAgICAgICAgfTtcbiAgICB9XG4gICAgY2hlY2suYXNzZXJ0KGZhbHNlLCAnMHgnICsgc3RhcnQudG9TdHJpbmcoMTYpICsgJzogbG9va3VwIHR5cGUgNiBmb3JtYXQgbXVzdCBiZSAxLCAyIG9yIDMuJyk7XG59O1xuXG4vLyBodHRwczovL3d3dy5taWNyb3NvZnQuY29tL3R5cG9ncmFwaHkvT1RTUEVDL0dTVUIuaHRtI0VTXG5zdWJ0YWJsZVBhcnNlcnNbN10gPSBmdW5jdGlvbiBwYXJzZUxvb2t1cDcoKSB7XG4gICAgLy8gRXh0ZW5zaW9uIFN1YnN0aXR1dGlvbiBzdWJ0YWJsZVxuICAgIGNvbnN0IHN1YnN0Rm9ybWF0ID0gdGhpcy5wYXJzZVVTaG9ydCgpO1xuICAgIGNoZWNrLmFyZ3VtZW50KHN1YnN0Rm9ybWF0ID09PSAxLCAnR1NVQiBFeHRlbnNpb24gU3Vic3RpdHV0aW9uIHN1YnRhYmxlIGlkZW50aWZpZXItZm9ybWF0IG11c3QgYmUgMScpO1xuICAgIGNvbnN0IGV4dGVuc2lvbkxvb2t1cFR5cGUgPSB0aGlzLnBhcnNlVVNob3J0KCk7XG4gICAgY29uc3QgZXh0ZW5zaW9uUGFyc2VyID0gbmV3IFBhcnNlcih0aGlzLmRhdGEsIHRoaXMub2Zmc2V0ICsgdGhpcy5wYXJzZVVMb25nKCkpO1xuICAgIHJldHVybiB7XG4gICAgICAgIHN1YnN0Rm9ybWF0OiAxLFxuICAgICAgICBsb29rdXBUeXBlOiBleHRlbnNpb25Mb29rdXBUeXBlLFxuICAgICAgICBleHRlbnNpb246IHN1YnRhYmxlUGFyc2Vyc1tleHRlbnNpb25Mb29rdXBUeXBlXS5jYWxsKGV4dGVuc2lvblBhcnNlcilcbiAgICB9O1xufTtcblxuLy8gaHR0cHM6Ly93d3cubWljcm9zb2Z0LmNvbS90eXBvZ3JhcGh5L09UU1BFQy9HU1VCLmh0bSNSQ0NTXG5zdWJ0YWJsZVBhcnNlcnNbOF0gPSBmdW5jdGlvbiBwYXJzZUxvb2t1cDgoKSB7XG4gICAgY29uc3Qgc3Vic3RGb3JtYXQgPSB0aGlzLnBhcnNlVVNob3J0KCk7XG4gICAgY2hlY2suYXJndW1lbnQoc3Vic3RGb3JtYXQgPT09IDEsICdHU1VCIFJldmVyc2UgQ2hhaW5pbmcgQ29udGV4dHVhbCBTaW5nbGUgU3Vic3RpdHV0aW9uIFN1YnRhYmxlIGlkZW50aWZpZXItZm9ybWF0IG11c3QgYmUgMScpO1xuICAgIHJldHVybiB7XG4gICAgICAgIHN1YnN0Rm9ybWF0OiBzdWJzdEZvcm1hdCxcbiAgICAgICAgY292ZXJhZ2U6IHRoaXMucGFyc2VQb2ludGVyKFBhcnNlci5jb3ZlcmFnZSksXG4gICAgICAgIGJhY2t0cmFja0NvdmVyYWdlOiB0aGlzLnBhcnNlTGlzdChQYXJzZXIucG9pbnRlcihQYXJzZXIuY292ZXJhZ2UpKSxcbiAgICAgICAgbG9va2FoZWFkQ292ZXJhZ2U6IHRoaXMucGFyc2VMaXN0KFBhcnNlci5wb2ludGVyKFBhcnNlci5jb3ZlcmFnZSkpLFxuICAgICAgICBzdWJzdGl0dXRlczogdGhpcy5wYXJzZVVTaG9ydExpc3QoKVxuICAgIH07XG59O1xuXG4vLyBodHRwczovL3d3dy5taWNyb3NvZnQuY29tL3R5cG9ncmFwaHkvT1RTUEVDL2dzdWIuaHRtXG5mdW5jdGlvbiBwYXJzZUdzdWJUYWJsZShkYXRhLCBzdGFydCkge1xuICAgIHN0YXJ0ID0gc3RhcnQgfHwgMDtcbiAgICBjb25zdCBwID0gbmV3IFBhcnNlcihkYXRhLCBzdGFydCk7XG4gICAgY29uc3QgdGFibGVWZXJzaW9uID0gcC5wYXJzZVZlcnNpb24oKTtcbiAgICBjaGVjay5hcmd1bWVudCh0YWJsZVZlcnNpb24gPT09IDEsICdVbnN1cHBvcnRlZCBHU1VCIHRhYmxlIHZlcnNpb24uJyk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdmVyc2lvbjogdGFibGVWZXJzaW9uLFxuICAgICAgICBzY3JpcHRzOiBwLnBhcnNlU2NyaXB0TGlzdCgpLFxuICAgICAgICBmZWF0dXJlczogcC5wYXJzZUZlYXR1cmVMaXN0KCksXG4gICAgICAgIGxvb2t1cHM6IHAucGFyc2VMb29rdXBMaXN0KHN1YnRhYmxlUGFyc2VycylcbiAgICB9O1xufVxuXG4vLyBHU1VCIFdyaXRpbmcgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuY29uc3Qgc3VidGFibGVNYWtlcnMgPSBuZXcgQXJyYXkoOSk7XG5cbnN1YnRhYmxlTWFrZXJzWzFdID0gZnVuY3Rpb24gbWFrZUxvb2t1cDEoc3VidGFibGUpIHtcbiAgICBpZiAoc3VidGFibGUuc3Vic3RGb3JtYXQgPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIG5ldyB0YWJsZS5UYWJsZSgnc3Vic3RpdHV0aW9uVGFibGUnLCBbXG4gICAgICAgICAgICB7bmFtZTogJ3N1YnN0Rm9ybWF0JywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiAxfSxcbiAgICAgICAgICAgIHtuYW1lOiAnY292ZXJhZ2UnLCB0eXBlOiAnVEFCTEUnLCB2YWx1ZTogbmV3IHRhYmxlLkNvdmVyYWdlKHN1YnRhYmxlLmNvdmVyYWdlKX0sXG4gICAgICAgICAgICB7bmFtZTogJ2RlbHRhR2x5cGhJRCcsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogc3VidGFibGUuZGVsdGFHbHlwaElkfVxuICAgICAgICBdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbmV3IHRhYmxlLlRhYmxlKCdzdWJzdGl0dXRpb25UYWJsZScsIFtcbiAgICAgICAgICAgIHtuYW1lOiAnc3Vic3RGb3JtYXQnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDJ9LFxuICAgICAgICAgICAge25hbWU6ICdjb3ZlcmFnZScsIHR5cGU6ICdUQUJMRScsIHZhbHVlOiBuZXcgdGFibGUuQ292ZXJhZ2Uoc3VidGFibGUuY292ZXJhZ2UpfVxuICAgICAgICBdLmNvbmNhdCh0YWJsZS51c2hvcnRMaXN0KCdzdWJzdGl0dXRlJywgc3VidGFibGUuc3Vic3RpdHV0ZSkpKTtcbiAgICB9XG4gICAgY2hlY2suZmFpbCgnTG9va3VwIHR5cGUgMSBzdWJzdEZvcm1hdCBtdXN0IGJlIDEgb3IgMi4nKTtcbn07XG5cbnN1YnRhYmxlTWFrZXJzWzNdID0gZnVuY3Rpb24gbWFrZUxvb2t1cDMoc3VidGFibGUpIHtcbiAgICBjaGVjay5hc3NlcnQoc3VidGFibGUuc3Vic3RGb3JtYXQgPT09IDEsICdMb29rdXAgdHlwZSAzIHN1YnN0Rm9ybWF0IG11c3QgYmUgMS4nKTtcbiAgICByZXR1cm4gbmV3IHRhYmxlLlRhYmxlKCdzdWJzdGl0dXRpb25UYWJsZScsIFtcbiAgICAgICAge25hbWU6ICdzdWJzdEZvcm1hdCcsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogMX0sXG4gICAgICAgIHtuYW1lOiAnY292ZXJhZ2UnLCB0eXBlOiAnVEFCTEUnLCB2YWx1ZTogbmV3IHRhYmxlLkNvdmVyYWdlKHN1YnRhYmxlLmNvdmVyYWdlKX1cbiAgICBdLmNvbmNhdCh0YWJsZS50YWJsZUxpc3QoJ2FsdFNldCcsIHN1YnRhYmxlLmFsdGVybmF0ZVNldHMsIGZ1bmN0aW9uKGFsdGVybmF0ZVNldCkge1xuICAgICAgICByZXR1cm4gbmV3IHRhYmxlLlRhYmxlKCdhbHRlcm5hdGVTZXRUYWJsZScsIHRhYmxlLnVzaG9ydExpc3QoJ2FsdGVybmF0ZScsIGFsdGVybmF0ZVNldCkpO1xuICAgIH0pKSk7XG59O1xuXG5zdWJ0YWJsZU1ha2Vyc1s0XSA9IGZ1bmN0aW9uIG1ha2VMb29rdXA0KHN1YnRhYmxlKSB7XG4gICAgY2hlY2suYXNzZXJ0KHN1YnRhYmxlLnN1YnN0Rm9ybWF0ID09PSAxLCAnTG9va3VwIHR5cGUgNCBzdWJzdEZvcm1hdCBtdXN0IGJlIDEuJyk7XG4gICAgcmV0dXJuIG5ldyB0YWJsZS5UYWJsZSgnc3Vic3RpdHV0aW9uVGFibGUnLCBbXG4gICAgICAgIHtuYW1lOiAnc3Vic3RGb3JtYXQnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDF9LFxuICAgICAgICB7bmFtZTogJ2NvdmVyYWdlJywgdHlwZTogJ1RBQkxFJywgdmFsdWU6IG5ldyB0YWJsZS5Db3ZlcmFnZShzdWJ0YWJsZS5jb3ZlcmFnZSl9XG4gICAgXS5jb25jYXQodGFibGUudGFibGVMaXN0KCdsaWdTZXQnLCBzdWJ0YWJsZS5saWdhdHVyZVNldHMsIGZ1bmN0aW9uKGxpZ2F0dXJlU2V0KSB7XG4gICAgICAgIHJldHVybiBuZXcgdGFibGUuVGFibGUoJ2xpZ2F0dXJlU2V0VGFibGUnLCB0YWJsZS50YWJsZUxpc3QoJ2xpZ2F0dXJlJywgbGlnYXR1cmVTZXQsIGZ1bmN0aW9uKGxpZ2F0dXJlKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IHRhYmxlLlRhYmxlKCdsaWdhdHVyZVRhYmxlJyxcbiAgICAgICAgICAgICAgICBbe25hbWU6ICdsaWdHbHlwaCcsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogbGlnYXR1cmUubGlnR2x5cGh9XVxuICAgICAgICAgICAgICAgIC5jb25jYXQodGFibGUudXNob3J0TGlzdCgnY29tcG9uZW50JywgbGlnYXR1cmUuY29tcG9uZW50cywgbGlnYXR1cmUuY29tcG9uZW50cy5sZW5ndGggKyAxKSlcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0pKTtcbiAgICB9KSkpO1xufTtcblxuZnVuY3Rpb24gbWFrZUdzdWJUYWJsZShnc3ViKSB7XG4gICAgcmV0dXJuIG5ldyB0YWJsZS5UYWJsZSgnR1NVQicsIFtcbiAgICAgICAge25hbWU6ICd2ZXJzaW9uJywgdHlwZTogJ1VMT05HJywgdmFsdWU6IDB4MTAwMDB9LFxuICAgICAgICB7bmFtZTogJ3NjcmlwdHMnLCB0eXBlOiAnVEFCTEUnLCB2YWx1ZTogbmV3IHRhYmxlLlNjcmlwdExpc3QoZ3N1Yi5zY3JpcHRzKX0sXG4gICAgICAgIHtuYW1lOiAnZmVhdHVyZXMnLCB0eXBlOiAnVEFCTEUnLCB2YWx1ZTogbmV3IHRhYmxlLkZlYXR1cmVMaXN0KGdzdWIuZmVhdHVyZXMpfSxcbiAgICAgICAge25hbWU6ICdsb29rdXBzJywgdHlwZTogJ1RBQkxFJywgdmFsdWU6IG5ldyB0YWJsZS5Mb29rdXBMaXN0KGdzdWIubG9va3Vwcywgc3VidGFibGVNYWtlcnMpfVxuICAgIF0pO1xufVxuXG5leHBvcnQgZGVmYXVsdCB7IHBhcnNlOiBwYXJzZUdzdWJUYWJsZSwgbWFrZTogbWFrZUdzdWJUYWJsZSB9O1xuIiwiLy8gVGhlIGBHUE9TYCB0YWJsZSBjb250YWlucyBrZXJuaW5nIHBhaXJzLCBhbW9uZyBvdGhlciB0aGluZ3MuXG4vLyBodHRwczovL3d3dy5taWNyb3NvZnQuY29tL3R5cG9ncmFwaHkvT1RTUEVDL2dwb3MuaHRtXG5cbmltcG9ydCBjaGVjayBmcm9tICcuLi9jaGVjayc7XG5pbXBvcnQgeyBkZWNvZGUgfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgcGFyc2UgZnJvbSAnLi4vcGFyc2UnO1xuaW1wb3J0IHRhYmxlIGZyb20gJy4uL3RhYmxlJztcblxuLy8gUGFyc2UgdGhlIG1ldGFkYXRhIGBtZXRhYCB0YWJsZS5cbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLmFwcGxlLmNvbS9mb250cy9UcnVlVHlwZS1SZWZlcmVuY2UtTWFudWFsL1JNMDYvQ2hhcDZtZXRhLmh0bWxcbmZ1bmN0aW9uIHBhcnNlTWV0YVRhYmxlKGRhdGEsIHN0YXJ0KSB7XG4gICAgY29uc3QgcCA9IG5ldyBwYXJzZS5QYXJzZXIoZGF0YSwgc3RhcnQpO1xuICAgIGNvbnN0IHRhYmxlVmVyc2lvbiA9IHAucGFyc2VVTG9uZygpO1xuICAgIGNoZWNrLmFyZ3VtZW50KHRhYmxlVmVyc2lvbiA9PT0gMSwgJ1Vuc3VwcG9ydGVkIE1FVEEgdGFibGUgdmVyc2lvbi4nKTtcbiAgICBwLnBhcnNlVUxvbmcoKTsgLy8gZmxhZ3MgLSBjdXJyZW50bHkgdW51c2VkIGFuZCBzZXQgdG8gMFxuICAgIHAucGFyc2VVTG9uZygpOyAvLyB0YWJsZU9mZnNldFxuICAgIGNvbnN0IG51bURhdGFNYXBzID0gcC5wYXJzZVVMb25nKCk7XG5cbiAgICBjb25zdCB0YWdzID0ge307XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1EYXRhTWFwczsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHRhZyA9IHAucGFyc2VUYWcoKTtcbiAgICAgICAgY29uc3QgZGF0YU9mZnNldCA9IHAucGFyc2VVTG9uZygpO1xuICAgICAgICBjb25zdCBkYXRhTGVuZ3RoID0gcC5wYXJzZVVMb25nKCk7XG4gICAgICAgIGNvbnN0IHRleHQgPSBkZWNvZGUuVVRGOChkYXRhLCBzdGFydCArIGRhdGFPZmZzZXQsIGRhdGFMZW5ndGgpO1xuXG4gICAgICAgIHRhZ3NbdGFnXSA9IHRleHQ7XG4gICAgfVxuICAgIHJldHVybiB0YWdzO1xufVxuXG5mdW5jdGlvbiBtYWtlTWV0YVRhYmxlKHRhZ3MpIHtcbiAgICBjb25zdCBudW1UYWdzID0gT2JqZWN0LmtleXModGFncykubGVuZ3RoO1xuICAgIGxldCBzdHJpbmdQb29sID0gJyc7XG4gICAgY29uc3Qgc3RyaW5nUG9vbE9mZnNldCA9IDE2ICsgbnVtVGFncyAqIDEyO1xuXG4gICAgY29uc3QgcmVzdWx0ID0gbmV3IHRhYmxlLlRhYmxlKCdtZXRhJywgW1xuICAgICAgICB7bmFtZTogJ3ZlcnNpb24nLCB0eXBlOiAnVUxPTkcnLCB2YWx1ZTogMX0sXG4gICAgICAgIHtuYW1lOiAnZmxhZ3MnLCB0eXBlOiAnVUxPTkcnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAnb2Zmc2V0JywgdHlwZTogJ1VMT05HJywgdmFsdWU6IHN0cmluZ1Bvb2xPZmZzZXR9LFxuICAgICAgICB7bmFtZTogJ251bVRhZ3MnLCB0eXBlOiAnVUxPTkcnLCB2YWx1ZTogbnVtVGFnc31cbiAgICBdKTtcblxuICAgIGZvciAobGV0IHRhZyBpbiB0YWdzKSB7XG4gICAgICAgIGNvbnN0IHBvcyA9IHN0cmluZ1Bvb2wubGVuZ3RoO1xuICAgICAgICBzdHJpbmdQb29sICs9IHRhZ3NbdGFnXTtcblxuICAgICAgICByZXN1bHQuZmllbGRzLnB1c2goe25hbWU6ICd0YWcgJyArIHRhZywgdHlwZTogJ1RBRycsIHZhbHVlOiB0YWd9KTtcbiAgICAgICAgcmVzdWx0LmZpZWxkcy5wdXNoKHtuYW1lOiAnb2Zmc2V0ICcgKyB0YWcsIHR5cGU6ICdVTE9ORycsIHZhbHVlOiBzdHJpbmdQb29sT2Zmc2V0ICsgcG9zfSk7XG4gICAgICAgIHJlc3VsdC5maWVsZHMucHVzaCh7bmFtZTogJ2xlbmd0aCAnICsgdGFnLCB0eXBlOiAnVUxPTkcnLCB2YWx1ZTogdGFnc1t0YWddLmxlbmd0aH0pO1xuICAgIH1cblxuICAgIHJlc3VsdC5maWVsZHMucHVzaCh7bmFtZTogJ3N0cmluZ1Bvb2wnLCB0eXBlOiAnQ0hBUkFSUkFZJywgdmFsdWU6IHN0cmluZ1Bvb2x9KTtcblxuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHsgcGFyc2U6IHBhcnNlTWV0YVRhYmxlLCBtYWtlOiBtYWtlTWV0YVRhYmxlIH07XG4iLCIvLyBUaGUgYHNmbnRgIHdyYXBwZXIgcHJvdmlkZXMgb3JnYW5pemF0aW9uIGZvciB0aGUgdGFibGVzIGluIHRoZSBmb250LlxuLy8gSXQgaXMgdGhlIHRvcC1sZXZlbCBkYXRhIHN0cnVjdHVyZSBpbiBhIGZvbnQuXG4vLyBodHRwczovL3d3dy5taWNyb3NvZnQuY29tL3R5cG9ncmFwaHkvT1RTUEVDL290ZmYuaHRtXG4vLyBSZWNvbW1lbmRhdGlvbnMgZm9yIGNyZWF0aW5nIE9wZW5UeXBlIEZvbnRzOlxuLy8gaHR0cDovL3d3dy5taWNyb3NvZnQuY29tL3R5cG9ncmFwaHkvb3RzcGVjMTQwL3JlY29tLmh0bVxuXG5pbXBvcnQgY2hlY2sgZnJvbSAnLi4vY2hlY2snO1xuaW1wb3J0IHRhYmxlIGZyb20gJy4uL3RhYmxlJztcblxuaW1wb3J0IGNtYXAgZnJvbSAnLi9jbWFwJztcbmltcG9ydCBjZmYgZnJvbSAnLi9jZmYnO1xuaW1wb3J0IGhlYWQgZnJvbSAnLi9oZWFkJztcbmltcG9ydCBoaGVhIGZyb20gJy4vaGhlYSc7XG5pbXBvcnQgaG10eCBmcm9tICcuL2htdHgnO1xuaW1wb3J0IGx0YWcgZnJvbSAnLi9sdGFnJztcbmltcG9ydCBtYXhwIGZyb20gJy4vbWF4cCc7XG5pbXBvcnQgX25hbWUgZnJvbSAnLi9uYW1lJztcbmltcG9ydCBvczIgZnJvbSAnLi9vczInO1xuaW1wb3J0IHBvc3QgZnJvbSAnLi9wb3N0JztcbmltcG9ydCBnc3ViIGZyb20gJy4vZ3N1Yic7XG5pbXBvcnQgbWV0YSBmcm9tICcuL21ldGEnO1xuXG5mdW5jdGlvbiBsb2cyKHYpIHtcbiAgICByZXR1cm4gTWF0aC5sb2codikgLyBNYXRoLmxvZygyKSB8IDA7XG59XG5cbmZ1bmN0aW9uIGNvbXB1dGVDaGVja1N1bShieXRlcykge1xuICAgIHdoaWxlIChieXRlcy5sZW5ndGggJSA0ICE9PSAwKSB7XG4gICAgICAgIGJ5dGVzLnB1c2goMCk7XG4gICAgfVxuXG4gICAgbGV0IHN1bSA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkgKz0gNCkge1xuICAgICAgICBzdW0gKz0gKGJ5dGVzW2ldIDw8IDI0KSArXG4gICAgICAgICAgICAoYnl0ZXNbaSArIDFdIDw8IDE2KSArXG4gICAgICAgICAgICAoYnl0ZXNbaSArIDJdIDw8IDgpICtcbiAgICAgICAgICAgIChieXRlc1tpICsgM10pO1xuICAgIH1cblxuICAgIHN1bSAlPSBNYXRoLnBvdygyLCAzMik7XG4gICAgcmV0dXJuIHN1bTtcbn1cblxuZnVuY3Rpb24gbWFrZVRhYmxlUmVjb3JkKHRhZywgY2hlY2tTdW0sIG9mZnNldCwgbGVuZ3RoKSB7XG4gICAgcmV0dXJuIG5ldyB0YWJsZS5SZWNvcmQoJ1RhYmxlIFJlY29yZCcsIFtcbiAgICAgICAge25hbWU6ICd0YWcnLCB0eXBlOiAnVEFHJywgdmFsdWU6IHRhZyAhPT0gdW5kZWZpbmVkID8gdGFnIDogJyd9LFxuICAgICAgICB7bmFtZTogJ2NoZWNrU3VtJywgdHlwZTogJ1VMT05HJywgdmFsdWU6IGNoZWNrU3VtICE9PSB1bmRlZmluZWQgPyBjaGVja1N1bSA6IDB9LFxuICAgICAgICB7bmFtZTogJ29mZnNldCcsIHR5cGU6ICdVTE9ORycsIHZhbHVlOiBvZmZzZXQgIT09IHVuZGVmaW5lZCA/IG9mZnNldCA6IDB9LFxuICAgICAgICB7bmFtZTogJ2xlbmd0aCcsIHR5cGU6ICdVTE9ORycsIHZhbHVlOiBsZW5ndGggIT09IHVuZGVmaW5lZCA/IGxlbmd0aCA6IDB9XG4gICAgXSk7XG59XG5cbmZ1bmN0aW9uIG1ha2VTZm50VGFibGUodGFibGVzKSB7XG4gICAgY29uc3Qgc2ZudCA9IG5ldyB0YWJsZS5UYWJsZSgnc2ZudCcsIFtcbiAgICAgICAge25hbWU6ICd2ZXJzaW9uJywgdHlwZTogJ1RBRycsIHZhbHVlOiAnT1RUTyd9LFxuICAgICAgICB7bmFtZTogJ251bVRhYmxlcycsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAnc2VhcmNoUmFuZ2UnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ2VudHJ5U2VsZWN0b3InLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ3JhbmdlU2hpZnQnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDB9XG4gICAgXSk7XG4gICAgc2ZudC50YWJsZXMgPSB0YWJsZXM7XG4gICAgc2ZudC5udW1UYWJsZXMgPSB0YWJsZXMubGVuZ3RoO1xuICAgIGNvbnN0IGhpZ2hlc3RQb3dlck9mMiA9IE1hdGgucG93KDIsIGxvZzIoc2ZudC5udW1UYWJsZXMpKTtcbiAgICBzZm50LnNlYXJjaFJhbmdlID0gMTYgKiBoaWdoZXN0UG93ZXJPZjI7XG4gICAgc2ZudC5lbnRyeVNlbGVjdG9yID0gbG9nMihoaWdoZXN0UG93ZXJPZjIpO1xuICAgIHNmbnQucmFuZ2VTaGlmdCA9IHNmbnQubnVtVGFibGVzICogMTYgLSBzZm50LnNlYXJjaFJhbmdlO1xuXG4gICAgY29uc3QgcmVjb3JkRmllbGRzID0gW107XG4gICAgY29uc3QgdGFibGVGaWVsZHMgPSBbXTtcblxuICAgIGxldCBvZmZzZXQgPSBzZm50LnNpemVPZigpICsgKG1ha2VUYWJsZVJlY29yZCgpLnNpemVPZigpICogc2ZudC5udW1UYWJsZXMpO1xuICAgIHdoaWxlIChvZmZzZXQgJSA0ICE9PSAwKSB7XG4gICAgICAgIG9mZnNldCArPSAxO1xuICAgICAgICB0YWJsZUZpZWxkcy5wdXNoKHtuYW1lOiAncGFkZGluZycsIHR5cGU6ICdCWVRFJywgdmFsdWU6IDB9KTtcbiAgICB9XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRhYmxlcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBjb25zdCB0ID0gdGFibGVzW2ldO1xuICAgICAgICBjaGVjay5hcmd1bWVudCh0LnRhYmxlTmFtZS5sZW5ndGggPT09IDQsICdUYWJsZSBuYW1lJyArIHQudGFibGVOYW1lICsgJyBpcyBpbnZhbGlkLicpO1xuICAgICAgICBjb25zdCB0YWJsZUxlbmd0aCA9IHQuc2l6ZU9mKCk7XG4gICAgICAgIGNvbnN0IHRhYmxlUmVjb3JkID0gbWFrZVRhYmxlUmVjb3JkKHQudGFibGVOYW1lLCBjb21wdXRlQ2hlY2tTdW0odC5lbmNvZGUoKSksIG9mZnNldCwgdGFibGVMZW5ndGgpO1xuICAgICAgICByZWNvcmRGaWVsZHMucHVzaCh7bmFtZTogdGFibGVSZWNvcmQudGFnICsgJyBUYWJsZSBSZWNvcmQnLCB0eXBlOiAnUkVDT1JEJywgdmFsdWU6IHRhYmxlUmVjb3JkfSk7XG4gICAgICAgIHRhYmxlRmllbGRzLnB1c2goe25hbWU6IHQudGFibGVOYW1lICsgJyB0YWJsZScsIHR5cGU6ICdSRUNPUkQnLCB2YWx1ZTogdH0pO1xuICAgICAgICBvZmZzZXQgKz0gdGFibGVMZW5ndGg7XG4gICAgICAgIGNoZWNrLmFyZ3VtZW50KCFpc05hTihvZmZzZXQpLCAnU29tZXRoaW5nIHdlbnQgd3JvbmcgY2FsY3VsYXRpbmcgdGhlIG9mZnNldC4nKTtcbiAgICAgICAgd2hpbGUgKG9mZnNldCAlIDQgIT09IDApIHtcbiAgICAgICAgICAgIG9mZnNldCArPSAxO1xuICAgICAgICAgICAgdGFibGVGaWVsZHMucHVzaCh7bmFtZTogJ3BhZGRpbmcnLCB0eXBlOiAnQllURScsIHZhbHVlOiAwfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUYWJsZSByZWNvcmRzIG5lZWQgdG8gYmUgc29ydGVkIGFscGhhYmV0aWNhbGx5LlxuICAgIHJlY29yZEZpZWxkcy5zb3J0KGZ1bmN0aW9uKHIxLCByMikge1xuICAgICAgICBpZiAocjEudmFsdWUudGFnID4gcjIudmFsdWUudGFnKSB7XG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgc2ZudC5maWVsZHMgPSBzZm50LmZpZWxkcy5jb25jYXQocmVjb3JkRmllbGRzKTtcbiAgICBzZm50LmZpZWxkcyA9IHNmbnQuZmllbGRzLmNvbmNhdCh0YWJsZUZpZWxkcyk7XG4gICAgcmV0dXJuIHNmbnQ7XG59XG5cbi8vIEdldCB0aGUgbWV0cmljcyBmb3IgYSBjaGFyYWN0ZXIuIElmIHRoZSBzdHJpbmcgaGFzIG1vcmUgdGhhbiBvbmUgY2hhcmFjdGVyXG4vLyB0aGlzIGZ1bmN0aW9uIHJldHVybnMgbWV0cmljcyBmb3IgdGhlIGZpcnN0IGF2YWlsYWJsZSBjaGFyYWN0ZXIuXG4vLyBZb3UgY2FuIHByb3ZpZGUgb3B0aW9uYWwgZmFsbGJhY2sgbWV0cmljcyBpZiBubyBjaGFyYWN0ZXJzIGFyZSBhdmFpbGFibGUuXG5mdW5jdGlvbiBtZXRyaWNzRm9yQ2hhcihmb250LCBjaGFycywgbm90Rm91bmRNZXRyaWNzKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGFycy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBjb25zdCBnbHlwaEluZGV4ID0gZm9udC5jaGFyVG9HbHlwaEluZGV4KGNoYXJzW2ldKTtcbiAgICAgICAgaWYgKGdseXBoSW5kZXggPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBnbHlwaCA9IGZvbnQuZ2x5cGhzLmdldChnbHlwaEluZGV4KTtcbiAgICAgICAgICAgIHJldHVybiBnbHlwaC5nZXRNZXRyaWNzKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbm90Rm91bmRNZXRyaWNzO1xufVxuXG5mdW5jdGlvbiBhdmVyYWdlKHZzKSB7XG4gICAgbGV0IHN1bSA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2cy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBzdW0gKz0gdnNbaV07XG4gICAgfVxuXG4gICAgcmV0dXJuIHN1bSAvIHZzLmxlbmd0aDtcbn1cblxuLy8gQ29udmVydCB0aGUgZm9udCBvYmplY3QgdG8gYSBTRk5UIGRhdGEgc3RydWN0dXJlLlxuLy8gVGhpcyBzdHJ1Y3R1cmUgY29udGFpbnMgYWxsIHRoZSBuZWNlc3NhcnkgdGFibGVzIGFuZCBtZXRhZGF0YSB0byBjcmVhdGUgYSBiaW5hcnkgT1RGIGZpbGUuXG5mdW5jdGlvbiBmb250VG9TZm50VGFibGUoZm9udCkge1xuICAgIGNvbnN0IHhNaW5zID0gW107XG4gICAgY29uc3QgeU1pbnMgPSBbXTtcbiAgICBjb25zdCB4TWF4cyA9IFtdO1xuICAgIGNvbnN0IHlNYXhzID0gW107XG4gICAgY29uc3QgYWR2YW5jZVdpZHRocyA9IFtdO1xuICAgIGNvbnN0IGxlZnRTaWRlQmVhcmluZ3MgPSBbXTtcbiAgICBjb25zdCByaWdodFNpZGVCZWFyaW5ncyA9IFtdO1xuICAgIGxldCBmaXJzdENoYXJJbmRleDtcbiAgICBsZXQgbGFzdENoYXJJbmRleCA9IDA7XG4gICAgbGV0IHVsVW5pY29kZVJhbmdlMSA9IDA7XG4gICAgbGV0IHVsVW5pY29kZVJhbmdlMiA9IDA7XG4gICAgbGV0IHVsVW5pY29kZVJhbmdlMyA9IDA7XG4gICAgbGV0IHVsVW5pY29kZVJhbmdlNCA9IDA7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZvbnQuZ2x5cGhzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGNvbnN0IGdseXBoID0gZm9udC5nbHlwaHMuZ2V0KGkpO1xuICAgICAgICBjb25zdCB1bmljb2RlID0gZ2x5cGgudW5pY29kZSB8IDA7XG5cbiAgICAgICAgaWYgKGlzTmFOKGdseXBoLmFkdmFuY2VXaWR0aCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignR2x5cGggJyArIGdseXBoLm5hbWUgKyAnICgnICsgaSArICcpOiBhZHZhbmNlV2lkdGggaXMgbm90IGEgbnVtYmVyLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGZpcnN0Q2hhckluZGV4ID4gdW5pY29kZSB8fCBmaXJzdENoYXJJbmRleCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyBpZ25vcmUgLm5vdGRlZiBjaGFyXG4gICAgICAgICAgICBpZiAodW5pY29kZSA+IDApIHtcbiAgICAgICAgICAgICAgICBmaXJzdENoYXJJbmRleCA9IHVuaWNvZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobGFzdENoYXJJbmRleCA8IHVuaWNvZGUpIHtcbiAgICAgICAgICAgIGxhc3RDaGFySW5kZXggPSB1bmljb2RlO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcG9zaXRpb24gPSBvczIuZ2V0VW5pY29kZVJhbmdlKHVuaWNvZGUpO1xuICAgICAgICBpZiAocG9zaXRpb24gPCAzMikge1xuICAgICAgICAgICAgdWxVbmljb2RlUmFuZ2UxIHw9IDEgPDwgcG9zaXRpb247XG4gICAgICAgIH0gZWxzZSBpZiAocG9zaXRpb24gPCA2NCkge1xuICAgICAgICAgICAgdWxVbmljb2RlUmFuZ2UyIHw9IDEgPDwgcG9zaXRpb24gLSAzMjtcbiAgICAgICAgfSBlbHNlIGlmIChwb3NpdGlvbiA8IDk2KSB7XG4gICAgICAgICAgICB1bFVuaWNvZGVSYW5nZTMgfD0gMSA8PCBwb3NpdGlvbiAtIDY0O1xuICAgICAgICB9IGVsc2UgaWYgKHBvc2l0aW9uIDwgMTIzKSB7XG4gICAgICAgICAgICB1bFVuaWNvZGVSYW5nZTQgfD0gMSA8PCBwb3NpdGlvbiAtIDk2O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmljb2RlIHJhbmdlcyBiaXRzID4gMTIzIGFyZSByZXNlcnZlZCBmb3IgaW50ZXJuYWwgdXNhZ2UnKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTa2lwIG5vbi1pbXBvcnRhbnQgY2hhcmFjdGVycy5cbiAgICAgICAgaWYgKGdseXBoLm5hbWUgPT09ICcubm90ZGVmJykgY29udGludWU7XG4gICAgICAgIGNvbnN0IG1ldHJpY3MgPSBnbHlwaC5nZXRNZXRyaWNzKCk7XG4gICAgICAgIHhNaW5zLnB1c2gobWV0cmljcy54TWluKTtcbiAgICAgICAgeU1pbnMucHVzaChtZXRyaWNzLnlNaW4pO1xuICAgICAgICB4TWF4cy5wdXNoKG1ldHJpY3MueE1heCk7XG4gICAgICAgIHlNYXhzLnB1c2gobWV0cmljcy55TWF4KTtcbiAgICAgICAgbGVmdFNpZGVCZWFyaW5ncy5wdXNoKG1ldHJpY3MubGVmdFNpZGVCZWFyaW5nKTtcbiAgICAgICAgcmlnaHRTaWRlQmVhcmluZ3MucHVzaChtZXRyaWNzLnJpZ2h0U2lkZUJlYXJpbmcpO1xuICAgICAgICBhZHZhbmNlV2lkdGhzLnB1c2goZ2x5cGguYWR2YW5jZVdpZHRoKTtcbiAgICB9XG5cbiAgICBjb25zdCBnbG9iYWxzID0ge1xuICAgICAgICB4TWluOiBNYXRoLm1pbi5hcHBseShudWxsLCB4TWlucyksXG4gICAgICAgIHlNaW46IE1hdGgubWluLmFwcGx5KG51bGwsIHlNaW5zKSxcbiAgICAgICAgeE1heDogTWF0aC5tYXguYXBwbHkobnVsbCwgeE1heHMpLFxuICAgICAgICB5TWF4OiBNYXRoLm1heC5hcHBseShudWxsLCB5TWF4cyksXG4gICAgICAgIGFkdmFuY2VXaWR0aE1heDogTWF0aC5tYXguYXBwbHkobnVsbCwgYWR2YW5jZVdpZHRocyksXG4gICAgICAgIGFkdmFuY2VXaWR0aEF2ZzogYXZlcmFnZShhZHZhbmNlV2lkdGhzKSxcbiAgICAgICAgbWluTGVmdFNpZGVCZWFyaW5nOiBNYXRoLm1pbi5hcHBseShudWxsLCBsZWZ0U2lkZUJlYXJpbmdzKSxcbiAgICAgICAgbWF4TGVmdFNpZGVCZWFyaW5nOiBNYXRoLm1heC5hcHBseShudWxsLCBsZWZ0U2lkZUJlYXJpbmdzKSxcbiAgICAgICAgbWluUmlnaHRTaWRlQmVhcmluZzogTWF0aC5taW4uYXBwbHkobnVsbCwgcmlnaHRTaWRlQmVhcmluZ3MpXG4gICAgfTtcbiAgICBnbG9iYWxzLmFzY2VuZGVyID0gZm9udC5hc2NlbmRlcjtcbiAgICBnbG9iYWxzLmRlc2NlbmRlciA9IGZvbnQuZGVzY2VuZGVyO1xuXG4gICAgY29uc3QgaGVhZFRhYmxlID0gaGVhZC5tYWtlKHtcbiAgICAgICAgZmxhZ3M6IDMsIC8vIDAwMDAwMDExIChiYXNlbGluZSBmb3IgZm9udCBhdCB5PTA7IGxlZnQgc2lkZWJlYXJpbmcgcG9pbnQgYXQgeD0wKVxuICAgICAgICB1bml0c1BlckVtOiBmb250LnVuaXRzUGVyRW0sXG4gICAgICAgIHhNaW46IGdsb2JhbHMueE1pbixcbiAgICAgICAgeU1pbjogZ2xvYmFscy55TWluLFxuICAgICAgICB4TWF4OiBnbG9iYWxzLnhNYXgsXG4gICAgICAgIHlNYXg6IGdsb2JhbHMueU1heCxcbiAgICAgICAgbG93ZXN0UmVjUFBFTTogMyxcbiAgICAgICAgY3JlYXRlZFRpbWVzdGFtcDogZm9udC5jcmVhdGVkVGltZXN0YW1wXG4gICAgfSk7XG5cbiAgICBjb25zdCBoaGVhVGFibGUgPSBoaGVhLm1ha2Uoe1xuICAgICAgICBhc2NlbmRlcjogZ2xvYmFscy5hc2NlbmRlcixcbiAgICAgICAgZGVzY2VuZGVyOiBnbG9iYWxzLmRlc2NlbmRlcixcbiAgICAgICAgYWR2YW5jZVdpZHRoTWF4OiBnbG9iYWxzLmFkdmFuY2VXaWR0aE1heCxcbiAgICAgICAgbWluTGVmdFNpZGVCZWFyaW5nOiBnbG9iYWxzLm1pbkxlZnRTaWRlQmVhcmluZyxcbiAgICAgICAgbWluUmlnaHRTaWRlQmVhcmluZzogZ2xvYmFscy5taW5SaWdodFNpZGVCZWFyaW5nLFxuICAgICAgICB4TWF4RXh0ZW50OiBnbG9iYWxzLm1heExlZnRTaWRlQmVhcmluZyArIChnbG9iYWxzLnhNYXggLSBnbG9iYWxzLnhNaW4pLFxuICAgICAgICBudW1iZXJPZkhNZXRyaWNzOiBmb250LmdseXBocy5sZW5ndGhcbiAgICB9KTtcblxuICAgIGNvbnN0IG1heHBUYWJsZSA9IG1heHAubWFrZShmb250LmdseXBocy5sZW5ndGgpO1xuXG4gICAgY29uc3Qgb3MyVGFibGUgPSBvczIubWFrZSh7XG4gICAgICAgIHhBdmdDaGFyV2lkdGg6IE1hdGgucm91bmQoZ2xvYmFscy5hZHZhbmNlV2lkdGhBdmcpLFxuICAgICAgICB1c1dlaWdodENsYXNzOiBmb250LnRhYmxlcy5vczIudXNXZWlnaHRDbGFzcyxcbiAgICAgICAgdXNXaWR0aENsYXNzOiBmb250LnRhYmxlcy5vczIudXNXaWR0aENsYXNzLFxuICAgICAgICB1c0ZpcnN0Q2hhckluZGV4OiBmaXJzdENoYXJJbmRleCxcbiAgICAgICAgdXNMYXN0Q2hhckluZGV4OiBsYXN0Q2hhckluZGV4LFxuICAgICAgICB1bFVuaWNvZGVSYW5nZTE6IHVsVW5pY29kZVJhbmdlMSxcbiAgICAgICAgdWxVbmljb2RlUmFuZ2UyOiB1bFVuaWNvZGVSYW5nZTIsXG4gICAgICAgIHVsVW5pY29kZVJhbmdlMzogdWxVbmljb2RlUmFuZ2UzLFxuICAgICAgICB1bFVuaWNvZGVSYW5nZTQ6IHVsVW5pY29kZVJhbmdlNCxcbiAgICAgICAgZnNTZWxlY3Rpb246IGZvbnQudGFibGVzLm9zMi5mc1NlbGVjdGlvbiwgLy8gUkVHVUxBUlxuICAgICAgICAvLyBTZWUgaHR0cDovL3R5cG9waGlsZS5jb20vbm9kZS8xMzA4MSBmb3IgbW9yZSBpbmZvIG9uIHZlcnRpY2FsIG1ldHJpY3MuXG4gICAgICAgIC8vIFdlIGdldCBtZXRyaWNzIGZvciB0eXBpY2FsIGNoYXJhY3RlcnMgKHN1Y2ggYXMgXCJ4XCIgZm9yIHhIZWlnaHQpLlxuICAgICAgICAvLyBXZSBwcm92aWRlIHNvbWUgZmFsbGJhY2sgY2hhcmFjdGVycyBpZiBjaGFyYWN0ZXJzIGFyZSB1bmF2YWlsYWJsZTogdGhlaXJcbiAgICAgICAgLy8gb3JkZXJpbmcgd2FzIGNob3NlbiBleHBlcmltZW50YWxseS5cbiAgICAgICAgc1R5cG9Bc2NlbmRlcjogZ2xvYmFscy5hc2NlbmRlcixcbiAgICAgICAgc1R5cG9EZXNjZW5kZXI6IGdsb2JhbHMuZGVzY2VuZGVyLFxuICAgICAgICBzVHlwb0xpbmVHYXA6IDAsXG4gICAgICAgIHVzV2luQXNjZW50OiBnbG9iYWxzLnlNYXgsXG4gICAgICAgIHVzV2luRGVzY2VudDogTWF0aC5hYnMoZ2xvYmFscy55TWluKSxcbiAgICAgICAgdWxDb2RlUGFnZVJhbmdlMTogMSwgLy8gRklYTUU6IGhhcmQtY29kZSBMYXRpbiAxIHN1cHBvcnQgZm9yIG5vd1xuICAgICAgICBzeEhlaWdodDogbWV0cmljc0ZvckNoYXIoZm9udCwgJ3h5dncnLCB7eU1heDogTWF0aC5yb3VuZChnbG9iYWxzLmFzY2VuZGVyIC8gMil9KS55TWF4LFxuICAgICAgICBzQ2FwSGVpZ2h0OiBtZXRyaWNzRm9yQ2hhcihmb250LCAnSElLTEVGSk1OVFpCRFBSQUdPUVNVVldYWScsIGdsb2JhbHMpLnlNYXgsXG4gICAgICAgIHVzRGVmYXVsdENoYXI6IGZvbnQuaGFzQ2hhcignICcpID8gMzIgOiAwLCAvLyBVc2Ugc3BhY2UgYXMgdGhlIGRlZmF1bHQgY2hhcmFjdGVyLCBpZiBhdmFpbGFibGUuXG4gICAgICAgIHVzQnJlYWtDaGFyOiBmb250Lmhhc0NoYXIoJyAnKSA/IDMyIDogMCAvLyBVc2Ugc3BhY2UgYXMgdGhlIGJyZWFrIGNoYXJhY3RlciwgaWYgYXZhaWxhYmxlLlxuICAgIH0pO1xuXG4gICAgY29uc3QgaG10eFRhYmxlID0gaG10eC5tYWtlKGZvbnQuZ2x5cGhzKTtcbiAgICBjb25zdCBjbWFwVGFibGUgPSBjbWFwLm1ha2UoZm9udC5nbHlwaHMpO1xuXG4gICAgY29uc3QgZW5nbGlzaEZhbWlseU5hbWUgPSBmb250LmdldEVuZ2xpc2hOYW1lKCdmb250RmFtaWx5Jyk7XG4gICAgY29uc3QgZW5nbGlzaFN0eWxlTmFtZSA9IGZvbnQuZ2V0RW5nbGlzaE5hbWUoJ2ZvbnRTdWJmYW1pbHknKTtcbiAgICBjb25zdCBlbmdsaXNoRnVsbE5hbWUgPSBlbmdsaXNoRmFtaWx5TmFtZSArICcgJyArIGVuZ2xpc2hTdHlsZU5hbWU7XG4gICAgbGV0IHBvc3RTY3JpcHROYW1lID0gZm9udC5nZXRFbmdsaXNoTmFtZSgncG9zdFNjcmlwdE5hbWUnKTtcbiAgICBpZiAoIXBvc3RTY3JpcHROYW1lKSB7XG4gICAgICAgIHBvc3RTY3JpcHROYW1lID0gZW5nbGlzaEZhbWlseU5hbWUucmVwbGFjZSgvXFxzL2csICcnKSArICctJyArIGVuZ2xpc2hTdHlsZU5hbWU7XG4gICAgfVxuXG4gICAgY29uc3QgbmFtZXMgPSB7fTtcbiAgICBmb3IgKGxldCBuIGluIGZvbnQubmFtZXMpIHtcbiAgICAgICAgbmFtZXNbbl0gPSBmb250Lm5hbWVzW25dO1xuICAgIH1cblxuICAgIGlmICghbmFtZXMudW5pcXVlSUQpIHtcbiAgICAgICAgbmFtZXMudW5pcXVlSUQgPSB7ZW46IGZvbnQuZ2V0RW5nbGlzaE5hbWUoJ21hbnVmYWN0dXJlcicpICsgJzonICsgZW5nbGlzaEZ1bGxOYW1lfTtcbiAgICB9XG5cbiAgICBpZiAoIW5hbWVzLnBvc3RTY3JpcHROYW1lKSB7XG4gICAgICAgIG5hbWVzLnBvc3RTY3JpcHROYW1lID0ge2VuOiBwb3N0U2NyaXB0TmFtZX07XG4gICAgfVxuXG4gICAgaWYgKCFuYW1lcy5wcmVmZXJyZWRGYW1pbHkpIHtcbiAgICAgICAgbmFtZXMucHJlZmVycmVkRmFtaWx5ID0gZm9udC5uYW1lcy5mb250RmFtaWx5O1xuICAgIH1cblxuICAgIGlmICghbmFtZXMucHJlZmVycmVkU3ViZmFtaWx5KSB7XG4gICAgICAgIG5hbWVzLnByZWZlcnJlZFN1YmZhbWlseSA9IGZvbnQubmFtZXMuZm9udFN1YmZhbWlseTtcbiAgICB9XG5cbiAgICBjb25zdCBsYW5ndWFnZVRhZ3MgPSBbXTtcbiAgICBjb25zdCBuYW1lVGFibGUgPSBfbmFtZS5tYWtlKG5hbWVzLCBsYW5ndWFnZVRhZ3MpO1xuICAgIGNvbnN0IGx0YWdUYWJsZSA9IChsYW5ndWFnZVRhZ3MubGVuZ3RoID4gMCA/IGx0YWcubWFrZShsYW5ndWFnZVRhZ3MpIDogdW5kZWZpbmVkKTtcblxuICAgIGNvbnN0IHBvc3RUYWJsZSA9IHBvc3QubWFrZSgpO1xuICAgIGNvbnN0IGNmZlRhYmxlID0gY2ZmLm1ha2UoZm9udC5nbHlwaHMsIHtcbiAgICAgICAgdmVyc2lvbjogZm9udC5nZXRFbmdsaXNoTmFtZSgndmVyc2lvbicpLFxuICAgICAgICBmdWxsTmFtZTogZW5nbGlzaEZ1bGxOYW1lLFxuICAgICAgICBmYW1pbHlOYW1lOiBlbmdsaXNoRmFtaWx5TmFtZSxcbiAgICAgICAgd2VpZ2h0TmFtZTogZW5nbGlzaFN0eWxlTmFtZSxcbiAgICAgICAgcG9zdFNjcmlwdE5hbWU6IHBvc3RTY3JpcHROYW1lLFxuICAgICAgICB1bml0c1BlckVtOiBmb250LnVuaXRzUGVyRW0sXG4gICAgICAgIGZvbnRCQm94OiBbMCwgZ2xvYmFscy55TWluLCBnbG9iYWxzLmFzY2VuZGVyLCBnbG9iYWxzLmFkdmFuY2VXaWR0aE1heF1cbiAgICB9KTtcblxuICAgIGNvbnN0IG1ldGFUYWJsZSA9IChmb250Lm1ldGFzICYmIE9iamVjdC5rZXlzKGZvbnQubWV0YXMpLmxlbmd0aCA+IDApID8gbWV0YS5tYWtlKGZvbnQubWV0YXMpIDogdW5kZWZpbmVkO1xuXG4gICAgLy8gVGhlIG9yZGVyIGRvZXMgbm90IG1hdHRlciBiZWNhdXNlIG1ha2VTZm50VGFibGUoKSB3aWxsIHNvcnQgdGhlbS5cbiAgICBjb25zdCB0YWJsZXMgPSBbaGVhZFRhYmxlLCBoaGVhVGFibGUsIG1heHBUYWJsZSwgb3MyVGFibGUsIG5hbWVUYWJsZSwgY21hcFRhYmxlLCBwb3N0VGFibGUsIGNmZlRhYmxlLCBobXR4VGFibGVdO1xuICAgIGlmIChsdGFnVGFibGUpIHtcbiAgICAgICAgdGFibGVzLnB1c2gobHRhZ1RhYmxlKTtcbiAgICB9XG4gICAgLy8gT3B0aW9uYWwgdGFibGVzXG4gICAgaWYgKGZvbnQudGFibGVzLmdzdWIpIHtcbiAgICAgICAgdGFibGVzLnB1c2goZ3N1Yi5tYWtlKGZvbnQudGFibGVzLmdzdWIpKTtcbiAgICB9XG4gICAgaWYgKG1ldGFUYWJsZSkge1xuICAgICAgICB0YWJsZXMucHVzaChtZXRhVGFibGUpO1xuICAgIH1cblxuICAgIGNvbnN0IHNmbnRUYWJsZSA9IG1ha2VTZm50VGFibGUodGFibGVzKTtcblxuICAgIC8vIENvbXB1dGUgdGhlIGZvbnQncyBjaGVja1N1bSBhbmQgc3RvcmUgaXQgaW4gaGVhZC5jaGVja1N1bUFkanVzdG1lbnQuXG4gICAgY29uc3QgYnl0ZXMgPSBzZm50VGFibGUuZW5jb2RlKCk7XG4gICAgY29uc3QgY2hlY2tTdW0gPSBjb21wdXRlQ2hlY2tTdW0oYnl0ZXMpO1xuICAgIGNvbnN0IHRhYmxlRmllbGRzID0gc2ZudFRhYmxlLmZpZWxkcztcbiAgICBsZXQgY2hlY2tTdW1BZGp1c3RlZCA9IGZhbHNlO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGFibGVGaWVsZHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgaWYgKHRhYmxlRmllbGRzW2ldLm5hbWUgPT09ICdoZWFkIHRhYmxlJykge1xuICAgICAgICAgICAgdGFibGVGaWVsZHNbaV0udmFsdWUuY2hlY2tTdW1BZGp1c3RtZW50ID0gMHhCMUIwQUZCQSAtIGNoZWNrU3VtO1xuICAgICAgICAgICAgY2hlY2tTdW1BZGp1c3RlZCA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmICghY2hlY2tTdW1BZGp1c3RlZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBmaW5kIGhlYWQgdGFibGUgd2l0aCBjaGVja1N1bSB0byBhZGp1c3QuJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNmbnRUYWJsZTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgeyBtYWtlOiBtYWtlU2ZudFRhYmxlLCBmb250VG9UYWJsZTogZm9udFRvU2ZudFRhYmxlLCBjb21wdXRlQ2hlY2tTdW0gfTtcbiIsIi8vIFRoZSBMYXlvdXQgb2JqZWN0IGlzIHRoZSBwcm90b3R5cGUgb2YgU3Vic3RpdHV0aW9uIG9iamVjdHMsIGFuZCBwcm92aWRlc1xuLy8gdXRpbGl0eSBtZXRob2RzIHRvIG1hbmlwdWxhdGUgY29tbW9uIGxheW91dCB0YWJsZXMgKEdQT1MsIEdTVUIsIEdERUYuLi4pXG5cbmltcG9ydCBjaGVjayBmcm9tICcuL2NoZWNrJztcblxuZnVuY3Rpb24gc2VhcmNoVGFnKGFyciwgdGFnKSB7XG4gICAgLyoganNoaW50IGJpdHdpc2U6IGZhbHNlICovXG4gICAgbGV0IGltaW4gPSAwO1xuICAgIGxldCBpbWF4ID0gYXJyLmxlbmd0aCAtIDE7XG4gICAgd2hpbGUgKGltaW4gPD0gaW1heCkge1xuICAgICAgICBjb25zdCBpbWlkID0gKGltaW4gKyBpbWF4KSA+Pj4gMTtcbiAgICAgICAgY29uc3QgdmFsID0gYXJyW2ltaWRdLnRhZztcbiAgICAgICAgaWYgKHZhbCA9PT0gdGFnKSB7XG4gICAgICAgICAgICByZXR1cm4gaW1pZDtcbiAgICAgICAgfSBlbHNlIGlmICh2YWwgPCB0YWcpIHtcbiAgICAgICAgICAgIGltaW4gPSBpbWlkICsgMTtcbiAgICAgICAgfSBlbHNlIHsgaW1heCA9IGltaWQgLSAxOyB9XG4gICAgfVxuICAgIC8vIE5vdCBmb3VuZDogcmV0dXJuIC0xLWluc2VydGlvbiBwb2ludFxuICAgIHJldHVybiAtaW1pbiAtIDE7XG59XG5cbmZ1bmN0aW9uIGJpblNlYXJjaChhcnIsIHZhbHVlKSB7XG4gICAgLyoganNoaW50IGJpdHdpc2U6IGZhbHNlICovXG4gICAgbGV0IGltaW4gPSAwO1xuICAgIGxldCBpbWF4ID0gYXJyLmxlbmd0aCAtIDE7XG4gICAgd2hpbGUgKGltaW4gPD0gaW1heCkge1xuICAgICAgICBjb25zdCBpbWlkID0gKGltaW4gKyBpbWF4KSA+Pj4gMTtcbiAgICAgICAgY29uc3QgdmFsID0gYXJyW2ltaWRdO1xuICAgICAgICBpZiAodmFsID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGltaWQ7XG4gICAgICAgIH0gZWxzZSBpZiAodmFsIDwgdmFsdWUpIHtcbiAgICAgICAgICAgIGltaW4gPSBpbWlkICsgMTtcbiAgICAgICAgfSBlbHNlIHsgaW1heCA9IGltaWQgLSAxOyB9XG4gICAgfVxuICAgIC8vIE5vdCBmb3VuZDogcmV0dXJuIC0xLWluc2VydGlvbiBwb2ludFxuICAgIHJldHVybiAtaW1pbiAtIDE7XG59XG5cbi8qKlxuICogQGV4cG9ydHMgb3BlbnR5cGUuTGF5b3V0XG4gKiBAY2xhc3NcbiAqL1xuZnVuY3Rpb24gTGF5b3V0KGZvbnQsIHRhYmxlTmFtZSkge1xuICAgIHRoaXMuZm9udCA9IGZvbnQ7XG4gICAgdGhpcy50YWJsZU5hbWUgPSB0YWJsZU5hbWU7XG59XG5cbkxheW91dC5wcm90b3R5cGUgPSB7XG5cbiAgICAvKipcbiAgICAgKiBCaW5hcnkgc2VhcmNoIGFuIG9iamVjdCBieSBcInRhZ1wiIHByb3BlcnR5XG4gICAgICogQGluc3RhbmNlXG4gICAgICogQGZ1bmN0aW9uIHNlYXJjaFRhZ1xuICAgICAqIEBtZW1iZXJvZiBvcGVudHlwZS5MYXlvdXRcbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gYXJyXG4gICAgICogQHBhcmFtICB7c3RyaW5nfSB0YWdcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICovXG4gICAgc2VhcmNoVGFnOiBzZWFyY2hUYWcsXG5cbiAgICAvKipcbiAgICAgKiBCaW5hcnkgc2VhcmNoIGluIGEgbGlzdCBvZiBudW1iZXJzXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQGZ1bmN0aW9uIGJpblNlYXJjaFxuICAgICAqIEBtZW1iZXJvZiBvcGVudHlwZS5MYXlvdXRcbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gYXJyXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSB2YWx1ZVxuICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgKi9cbiAgICBiaW5TZWFyY2g6IGJpblNlYXJjaCxcblxuICAgIC8qKlxuICAgICAqIEdldCBvciBjcmVhdGUgdGhlIExheW91dCB0YWJsZSAoR1NVQiwgR1BPUyBldGMpLlxuICAgICAqIEBwYXJhbSAge2Jvb2xlYW59IGNyZWF0ZSAtIFdoZXRoZXIgdG8gY3JlYXRlIGEgbmV3IG9uZS5cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBHU1VCIG9yIEdQT1MgdGFibGUuXG4gICAgICovXG4gICAgZ2V0VGFibGU6IGZ1bmN0aW9uKGNyZWF0ZSkge1xuICAgICAgICBsZXQgbGF5b3V0ID0gdGhpcy5mb250LnRhYmxlc1t0aGlzLnRhYmxlTmFtZV07XG4gICAgICAgIGlmICghbGF5b3V0ICYmIGNyZWF0ZSkge1xuICAgICAgICAgICAgbGF5b3V0ID0gdGhpcy5mb250LnRhYmxlc1t0aGlzLnRhYmxlTmFtZV0gPSB0aGlzLmNyZWF0ZURlZmF1bHRUYWJsZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsYXlvdXQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYWxsIHNjcmlwdHMgaW4gdGhlIHN1YnN0aXR1dGlvbiB0YWJsZS5cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICAgKi9cbiAgICBnZXRTY3JpcHROYW1lczogZnVuY3Rpb24oKSB7XG4gICAgICAgIGxldCBsYXlvdXQgPSB0aGlzLmdldFRhYmxlKCk7XG4gICAgICAgIGlmICghbGF5b3V0KSB7IHJldHVybiBbXTsgfVxuICAgICAgICByZXR1cm4gbGF5b3V0LnNjcmlwdHMubWFwKGZ1bmN0aW9uKHNjcmlwdCkge1xuICAgICAgICAgICAgcmV0dXJuIHNjcmlwdC50YWc7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBiZXN0IGJldCBmb3IgYSBzY3JpcHQgbmFtZS5cbiAgICAgKiBSZXR1cm5zICdERkxUJyBpZiBpdCBleGlzdHMuXG4gICAgICogSWYgbm90LCByZXR1cm5zICdsYXRuJyBpZiBpdCBleGlzdHMuXG4gICAgICogSWYgbmVpdGhlciBleGlzdCwgcmV0dXJucyB1bmRlZmluZWQuXG4gICAgICovXG4gICAgZ2V0RGVmYXVsdFNjcmlwdE5hbWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICBsZXQgbGF5b3V0ID0gdGhpcy5nZXRUYWJsZSgpO1xuICAgICAgICBpZiAoIWxheW91dCkgeyByZXR1cm47IH1cbiAgICAgICAgbGV0IGhhc0xhdG4gPSBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsYXlvdXQuc2NyaXB0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgbmFtZSA9IGxheW91dC5zY3JpcHRzW2ldLnRhZztcbiAgICAgICAgICAgIGlmIChuYW1lID09PSAnREZMVCcpIHJldHVybiBuYW1lO1xuICAgICAgICAgICAgaWYgKG5hbWUgPT09ICdsYXRuJykgaGFzTGF0biA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhhc0xhdG4pIHJldHVybiAnbGF0bic7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYWxsIExhbmdTeXNSZWNvcmRzIGluIHRoZSBnaXZlbiBzY3JpcHQuXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzY3JpcHQ9J0RGTFQnXVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gY3JlYXRlIC0gZm9yY2VzIHRoZSBjcmVhdGlvbiBvZiB0aGlzIHNjcmlwdCB0YWJsZSBpZiBpdCBkb2Vzbid0IGV4aXN0LlxuICAgICAqIEByZXR1cm4ge09iamVjdH0gQW4gb2JqZWN0IHdpdGggdGFnIGFuZCBzY3JpcHQgcHJvcGVydGllcy5cbiAgICAgKi9cbiAgICBnZXRTY3JpcHRUYWJsZTogZnVuY3Rpb24oc2NyaXB0LCBjcmVhdGUpIHtcbiAgICAgICAgY29uc3QgbGF5b3V0ID0gdGhpcy5nZXRUYWJsZShjcmVhdGUpO1xuICAgICAgICBpZiAobGF5b3V0KSB7XG4gICAgICAgICAgICBzY3JpcHQgPSBzY3JpcHQgfHwgJ0RGTFQnO1xuICAgICAgICAgICAgY29uc3Qgc2NyaXB0cyA9IGxheW91dC5zY3JpcHRzO1xuICAgICAgICAgICAgY29uc3QgcG9zID0gc2VhcmNoVGFnKGxheW91dC5zY3JpcHRzLCBzY3JpcHQpO1xuICAgICAgICAgICAgaWYgKHBvcyA+PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNjcmlwdHNbcG9zXS5zY3JpcHQ7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNyZWF0ZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNjciA9IHtcbiAgICAgICAgICAgICAgICAgICAgdGFnOiBzY3JpcHQsXG4gICAgICAgICAgICAgICAgICAgIHNjcmlwdDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdExhbmdTeXM6IHtyZXNlcnZlZDogMCwgcmVxRmVhdHVyZUluZGV4OiAweGZmZmYsIGZlYXR1cmVJbmRleGVzOiBbXX0sXG4gICAgICAgICAgICAgICAgICAgICAgICBsYW5nU3lzUmVjb3JkczogW11cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgc2NyaXB0cy5zcGxpY2UoLTEgLSBwb3MsIDAsIHNjcik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNjci5zY3JpcHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGxhbmd1YWdlIHN5c3RlbSB0YWJsZVxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc2NyaXB0PSdERkxUJ11cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2xhbmd1YWdlPSdkbGZ0J11cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGNyZWF0ZSAtIGZvcmNlcyB0aGUgY3JlYXRpb24gb2YgdGhpcyBsYW5nU3lzVGFibGUgaWYgaXQgZG9lc24ndCBleGlzdC5cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAgICovXG4gICAgZ2V0TGFuZ1N5c1RhYmxlOiBmdW5jdGlvbihzY3JpcHQsIGxhbmd1YWdlLCBjcmVhdGUpIHtcbiAgICAgICAgY29uc3Qgc2NyaXB0VGFibGUgPSB0aGlzLmdldFNjcmlwdFRhYmxlKHNjcmlwdCwgY3JlYXRlKTtcbiAgICAgICAgaWYgKHNjcmlwdFRhYmxlKSB7XG4gICAgICAgICAgICBpZiAoIWxhbmd1YWdlIHx8IGxhbmd1YWdlID09PSAnZGZsdCcgfHwgbGFuZ3VhZ2UgPT09ICdERkxUJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBzY3JpcHRUYWJsZS5kZWZhdWx0TGFuZ1N5cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHBvcyA9IHNlYXJjaFRhZyhzY3JpcHRUYWJsZS5sYW5nU3lzUmVjb3JkcywgbGFuZ3VhZ2UpO1xuICAgICAgICAgICAgaWYgKHBvcyA+PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNjcmlwdFRhYmxlLmxhbmdTeXNSZWNvcmRzW3Bvc10ubGFuZ1N5cztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY3JlYXRlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbGFuZ1N5c1JlY29yZCA9IHtcbiAgICAgICAgICAgICAgICAgICAgdGFnOiBsYW5ndWFnZSxcbiAgICAgICAgICAgICAgICAgICAgbGFuZ1N5czoge3Jlc2VydmVkOiAwLCByZXFGZWF0dXJlSW5kZXg6IDB4ZmZmZiwgZmVhdHVyZUluZGV4ZXM6IFtdfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgc2NyaXB0VGFibGUubGFuZ1N5c1JlY29yZHMuc3BsaWNlKC0xIC0gcG9zLCAwLCBsYW5nU3lzUmVjb3JkKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbGFuZ1N5c1JlY29yZC5sYW5nU3lzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCBhIHNwZWNpZmljIGZlYXR1cmUgdGFibGUuXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzY3JpcHQ9J0RGTFQnXVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbbGFuZ3VhZ2U9J2RsZnQnXVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmZWF0dXJlIC0gT25lIG9mIHRoZSBjb2RlcyBsaXN0ZWQgYXQgaHR0cHM6Ly93d3cubWljcm9zb2Z0LmNvbS90eXBvZ3JhcGh5L09UU1BFQy9mZWF0dXJlbGlzdC5odG1cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGNyZWF0ZSAtIGZvcmNlcyB0aGUgY3JlYXRpb24gb2YgdGhlIGZlYXR1cmUgdGFibGUgaWYgaXQgZG9lc24ndCBleGlzdC5cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAgICovXG4gICAgZ2V0RmVhdHVyZVRhYmxlOiBmdW5jdGlvbihzY3JpcHQsIGxhbmd1YWdlLCBmZWF0dXJlLCBjcmVhdGUpIHtcbiAgICAgICAgY29uc3QgbGFuZ1N5c1RhYmxlID0gdGhpcy5nZXRMYW5nU3lzVGFibGUoc2NyaXB0LCBsYW5ndWFnZSwgY3JlYXRlKTtcbiAgICAgICAgaWYgKGxhbmdTeXNUYWJsZSkge1xuICAgICAgICAgICAgbGV0IGZlYXR1cmVSZWNvcmQ7XG4gICAgICAgICAgICBjb25zdCBmZWF0SW5kZXhlcyA9IGxhbmdTeXNUYWJsZS5mZWF0dXJlSW5kZXhlcztcbiAgICAgICAgICAgIGNvbnN0IGFsbEZlYXR1cmVzID0gdGhpcy5mb250LnRhYmxlc1t0aGlzLnRhYmxlTmFtZV0uZmVhdHVyZXM7XG4gICAgICAgICAgICAvLyBUaGUgRmVhdHVyZUluZGV4IGFycmF5IG9mIGluZGljZXMgaXMgaW4gYXJiaXRyYXJ5IG9yZGVyLFxuICAgICAgICAgICAgLy8gZXZlbiBpZiBhbGxGZWF0dXJlcyBpcyBzb3J0ZWQgYWxwaGFiZXRpY2FsbHkgYnkgZmVhdHVyZSB0YWcuXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZlYXRJbmRleGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgZmVhdHVyZVJlY29yZCA9IGFsbEZlYXR1cmVzW2ZlYXRJbmRleGVzW2ldXTtcbiAgICAgICAgICAgICAgICBpZiAoZmVhdHVyZVJlY29yZC50YWcgPT09IGZlYXR1cmUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZlYXR1cmVSZWNvcmQuZmVhdHVyZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY3JlYXRlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5kZXggPSBhbGxGZWF0dXJlcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgLy8gQXV0b21hdGljIG9yZGVyaW5nIG9mIGZlYXR1cmVzIHdvdWxkIHJlcXVpcmUgdG8gc2hpZnQgZmVhdHVyZSBpbmRleGVzIGluIHRoZSBzY3JpcHQgbGlzdC5cbiAgICAgICAgICAgICAgICBjaGVjay5hc3NlcnQoaW5kZXggPT09IDAgfHwgZmVhdHVyZSA+PSBhbGxGZWF0dXJlc1tpbmRleCAtIDFdLnRhZywgJ0ZlYXR1cmVzIG11c3QgYmUgYWRkZWQgaW4gYWxwaGFiZXRpY2FsIG9yZGVyLicpO1xuICAgICAgICAgICAgICAgIGZlYXR1cmVSZWNvcmQgPSB7XG4gICAgICAgICAgICAgICAgICAgIHRhZzogZmVhdHVyZSxcbiAgICAgICAgICAgICAgICAgICAgZmVhdHVyZTogeyBwYXJhbXM6IDAsIGxvb2t1cExpc3RJbmRleGVzOiBbXSB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBhbGxGZWF0dXJlcy5wdXNoKGZlYXR1cmVSZWNvcmQpO1xuICAgICAgICAgICAgICAgIGZlYXRJbmRleGVzLnB1c2goaW5kZXgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmZWF0dXJlUmVjb3JkLmZlYXR1cmU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBsb29rdXAgdGFibGVzIG9mIGEgZ2l2ZW4gdHlwZSBmb3IgYSBzY3JpcHQvbGFuZ3VhZ2UvZmVhdHVyZS5cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3NjcmlwdD0nREZMVCddXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtsYW5ndWFnZT0nZGxmdCddXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGZlYXR1cmUgLSA0LWxldHRlciBmZWF0dXJlIGNvZGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbG9va3VwVHlwZSAtIDEgdG8gOFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gY3JlYXRlIC0gZm9yY2VzIHRoZSBjcmVhdGlvbiBvZiB0aGUgbG9va3VwIHRhYmxlIGlmIGl0IGRvZXNuJ3QgZXhpc3QsIHdpdGggbm8gc3VidGFibGVzLlxuICAgICAqIEByZXR1cm4ge09iamVjdFtdfVxuICAgICAqL1xuICAgIGdldExvb2t1cFRhYmxlczogZnVuY3Rpb24oc2NyaXB0LCBsYW5ndWFnZSwgZmVhdHVyZSwgbG9va3VwVHlwZSwgY3JlYXRlKSB7XG4gICAgICAgIGNvbnN0IGZlYXR1cmVUYWJsZSA9IHRoaXMuZ2V0RmVhdHVyZVRhYmxlKHNjcmlwdCwgbGFuZ3VhZ2UsIGZlYXR1cmUsIGNyZWF0ZSk7XG4gICAgICAgIGNvbnN0IHRhYmxlcyA9IFtdO1xuICAgICAgICBpZiAoZmVhdHVyZVRhYmxlKSB7XG4gICAgICAgICAgICBsZXQgbG9va3VwVGFibGU7XG4gICAgICAgICAgICBjb25zdCBsb29rdXBMaXN0SW5kZXhlcyA9IGZlYXR1cmVUYWJsZS5sb29rdXBMaXN0SW5kZXhlcztcbiAgICAgICAgICAgIGNvbnN0IGFsbExvb2t1cHMgPSB0aGlzLmZvbnQudGFibGVzW3RoaXMudGFibGVOYW1lXS5sb29rdXBzO1xuICAgICAgICAgICAgLy8gbG9va3VwTGlzdEluZGV4ZXMgYXJlIGluIG5vIHBhcnRpY3VsYXIgb3JkZXIsIHNvIHVzZSBuYWl2ZSBzZWFyY2guXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxvb2t1cExpc3RJbmRleGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbG9va3VwVGFibGUgPSBhbGxMb29rdXBzW2xvb2t1cExpc3RJbmRleGVzW2ldXTtcbiAgICAgICAgICAgICAgICBpZiAobG9va3VwVGFibGUubG9va3VwVHlwZSA9PT0gbG9va3VwVHlwZSkge1xuICAgICAgICAgICAgICAgICAgICB0YWJsZXMucHVzaChsb29rdXBUYWJsZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRhYmxlcy5sZW5ndGggPT09IDAgJiYgY3JlYXRlKSB7XG4gICAgICAgICAgICAgICAgbG9va3VwVGFibGUgPSB7XG4gICAgICAgICAgICAgICAgICAgIGxvb2t1cFR5cGU6IGxvb2t1cFR5cGUsXG4gICAgICAgICAgICAgICAgICAgIGxvb2t1cEZsYWc6IDAsXG4gICAgICAgICAgICAgICAgICAgIHN1YnRhYmxlczogW10sXG4gICAgICAgICAgICAgICAgICAgIG1hcmtGaWx0ZXJpbmdTZXQ6IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgY29uc3QgaW5kZXggPSBhbGxMb29rdXBzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBhbGxMb29rdXBzLnB1c2gobG9va3VwVGFibGUpO1xuICAgICAgICAgICAgICAgIGxvb2t1cExpc3RJbmRleGVzLnB1c2goaW5kZXgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbbG9va3VwVGFibGVdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0YWJsZXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGxpc3Qgb2YgZ2x5cGggaW5kZXhlcyBvZiBhIGNvdmVyYWdlIHRhYmxlLlxuICAgICAqIEZvcm1hdCAxOiB0aGUgbGlzdCBpcyBzdG9yZWQgcmF3XG4gICAgICogRm9ybWF0IDI6IGNvbXBhY3QgbGlzdCBhcyByYW5nZSByZWNvcmRzLlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSAge09iamVjdH0gY292ZXJhZ2VUYWJsZVxuICAgICAqIEByZXR1cm4ge0FycmF5fVxuICAgICAqL1xuICAgIGV4cGFuZENvdmVyYWdlOiBmdW5jdGlvbihjb3ZlcmFnZVRhYmxlKSB7XG4gICAgICAgIGlmIChjb3ZlcmFnZVRhYmxlLmZvcm1hdCA9PT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIGNvdmVyYWdlVGFibGUuZ2x5cGhzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgZ2x5cGhzID0gW107XG4gICAgICAgICAgICBjb25zdCByYW5nZXMgPSBjb3ZlcmFnZVRhYmxlLnJhbmdlcztcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmFuZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmFuZ2UgPSByYW5nZXNbaV07XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RhcnQgPSByYW5nZS5zdGFydDtcbiAgICAgICAgICAgICAgICBjb25zdCBlbmQgPSByYW5nZS5lbmQ7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IHN0YXJ0OyBqIDw9IGVuZDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGdseXBocy5wdXNoKGopO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBnbHlwaHM7XG4gICAgICAgIH1cbiAgICB9XG5cbn07XG5cbmV4cG9ydCBkZWZhdWx0IExheW91dDtcbiIsIi8vIFRoZSBTdWJzdGl0dXRpb24gb2JqZWN0IHByb3ZpZGVzIHV0aWxpdHkgbWV0aG9kcyB0byBtYW5pcHVsYXRlXG4vLyB0aGUgR1NVQiBzdWJzdGl0dXRpb24gdGFibGUuXG5cbmltcG9ydCBjaGVjayBmcm9tICcuL2NoZWNrJztcbmltcG9ydCBMYXlvdXQgZnJvbSAnLi9sYXlvdXQnO1xuXG4vKipcbiAqIEBleHBvcnRzIG9wZW50eXBlLlN1YnN0aXR1dGlvblxuICogQGNsYXNzXG4gKiBAZXh0ZW5kcyBvcGVudHlwZS5MYXlvdXRcbiAqIEBwYXJhbSB7b3BlbnR5cGUuRm9udH1cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBTdWJzdGl0dXRpb24oZm9udCkge1xuICAgIExheW91dC5jYWxsKHRoaXMsIGZvbnQsICdnc3ViJyk7XG59XG5cbi8vIENoZWNrIGlmIDIgYXJyYXlzIG9mIHByaW1pdGl2ZXMgYXJlIGVxdWFsLlxuZnVuY3Rpb24gYXJyYXlzRXF1YWwoYXIxLCBhcjIpIHtcbiAgICBjb25zdCBuID0gYXIxLmxlbmd0aDtcbiAgICBpZiAobiAhPT0gYXIyLmxlbmd0aCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgICBpZiAoYXIxW2ldICE9PSBhcjJbaV0pIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuXG4vLyBGaW5kIHRoZSBmaXJzdCBzdWJ0YWJsZSBvZiBhIGxvb2t1cCB0YWJsZSBpbiBhIHBhcnRpY3VsYXIgZm9ybWF0LlxuZnVuY3Rpb24gZ2V0U3Vic3RGb3JtYXQobG9va3VwVGFibGUsIGZvcm1hdCwgZGVmYXVsdFN1YnRhYmxlKSB7XG4gICAgY29uc3Qgc3VidGFibGVzID0gbG9va3VwVGFibGUuc3VidGFibGVzO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3VidGFibGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHN1YnRhYmxlID0gc3VidGFibGVzW2ldO1xuICAgICAgICBpZiAoc3VidGFibGUuc3Vic3RGb3JtYXQgPT09IGZvcm1hdCkge1xuICAgICAgICAgICAgcmV0dXJuIHN1YnRhYmxlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChkZWZhdWx0U3VidGFibGUpIHtcbiAgICAgICAgc3VidGFibGVzLnB1c2goZGVmYXVsdFN1YnRhYmxlKTtcbiAgICAgICAgcmV0dXJuIGRlZmF1bHRTdWJ0YWJsZTtcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cblxuU3Vic3RpdHV0aW9uLnByb3RvdHlwZSA9IExheW91dC5wcm90b3R5cGU7XG5cbi8qKlxuICogQ3JlYXRlIGEgZGVmYXVsdCBHU1VCIHRhYmxlLlxuICogQHJldHVybiB7T2JqZWN0fSBnc3ViIC0gVGhlIEdTVUIgdGFibGUuXG4gKi9cblN1YnN0aXR1dGlvbi5wcm90b3R5cGUuY3JlYXRlRGVmYXVsdFRhYmxlID0gZnVuY3Rpb24oKSB7XG4gICAgLy8gR2VuZXJhdGUgYSBkZWZhdWx0IGVtcHR5IEdTVUIgdGFibGUgd2l0aCBqdXN0IGEgREZMVCBzY3JpcHQgYW5kIGRmbHQgbGFuZyBzeXMuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgdmVyc2lvbjogMSxcbiAgICAgICAgc2NyaXB0czogW3tcbiAgICAgICAgICAgIHRhZzogJ0RGTFQnLFxuICAgICAgICAgICAgc2NyaXB0OiB7XG4gICAgICAgICAgICAgICAgZGVmYXVsdExhbmdTeXM6IHsgcmVzZXJ2ZWQ6IDAsIHJlcUZlYXR1cmVJbmRleDogMHhmZmZmLCBmZWF0dXJlSW5kZXhlczogW10gfSxcbiAgICAgICAgICAgICAgICBsYW5nU3lzUmVjb3JkczogW11cbiAgICAgICAgICAgIH1cbiAgICAgICAgfV0sXG4gICAgICAgIGZlYXR1cmVzOiBbXSxcbiAgICAgICAgbG9va3VwczogW11cbiAgICB9O1xufTtcblxuLyoqXG4gKiBMaXN0IGFsbCBzaW5nbGUgc3Vic3RpdHV0aW9ucyAobG9va3VwIHR5cGUgMSkgZm9yIGEgZ2l2ZW4gc2NyaXB0LCBsYW5ndWFnZSwgYW5kIGZlYXR1cmUuXG4gKiBAcGFyYW0ge3N0cmluZ30gW3NjcmlwdD0nREZMVCddXG4gKiBAcGFyYW0ge3N0cmluZ30gW2xhbmd1YWdlPSdkZmx0J11cbiAqIEBwYXJhbSB7c3RyaW5nfSBmZWF0dXJlIC0gNC1jaGFyYWN0ZXIgZmVhdHVyZSBuYW1lICgnYWFsdCcsICdzYWx0JywgJ3NzMDEnLi4uKVxuICogQHJldHVybiB7QXJyYXl9IHN1YnN0aXR1dGlvbnMgLSBUaGUgbGlzdCBvZiBzdWJzdGl0dXRpb25zLlxuICovXG5TdWJzdGl0dXRpb24ucHJvdG90eXBlLmdldFNpbmdsZSA9IGZ1bmN0aW9uKGZlYXR1cmUsIHNjcmlwdCwgbGFuZ3VhZ2UpIHtcbiAgICBjb25zdCBzdWJzdGl0dXRpb25zID0gW107XG4gICAgY29uc3QgbG9va3VwVGFibGVzID0gdGhpcy5nZXRMb29rdXBUYWJsZXMoc2NyaXB0LCBsYW5ndWFnZSwgZmVhdHVyZSwgMSk7XG4gICAgZm9yIChsZXQgaWR4ID0gMDsgaWR4IDwgbG9va3VwVGFibGVzLmxlbmd0aDsgaWR4KyspIHtcbiAgICAgICAgY29uc3Qgc3VidGFibGVzID0gbG9va3VwVGFibGVzW2lkeF0uc3VidGFibGVzO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN1YnRhYmxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3Qgc3VidGFibGUgPSBzdWJ0YWJsZXNbaV07XG4gICAgICAgICAgICBjb25zdCBnbHlwaHMgPSB0aGlzLmV4cGFuZENvdmVyYWdlKHN1YnRhYmxlLmNvdmVyYWdlKTtcbiAgICAgICAgICAgIGxldCBqO1xuICAgICAgICAgICAgaWYgKHN1YnRhYmxlLnN1YnN0Rm9ybWF0ID09PSAxKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGVsdGEgPSBzdWJ0YWJsZS5kZWx0YUdseXBoSWQ7XG4gICAgICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IGdseXBocy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBnbHlwaCA9IGdseXBoc1tqXTtcbiAgICAgICAgICAgICAgICAgICAgc3Vic3RpdHV0aW9ucy5wdXNoKHsgc3ViOiBnbHlwaCwgYnk6IGdseXBoICsgZGVsdGEgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzdWJzdGl0dXRlID0gc3VidGFibGUuc3Vic3RpdHV0ZTtcbiAgICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgZ2x5cGhzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1YnN0aXR1dGlvbnMucHVzaCh7IHN1YjogZ2x5cGhzW2pdLCBieTogc3Vic3RpdHV0ZVtqXSB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHN1YnN0aXR1dGlvbnM7XG59O1xuXG4vKipcbiAqIExpc3QgYWxsIGFsdGVybmF0ZXMgKGxvb2t1cCB0eXBlIDMpIGZvciBhIGdpdmVuIHNjcmlwdCwgbGFuZ3VhZ2UsIGFuZCBmZWF0dXJlLlxuICogQHBhcmFtIHtzdHJpbmd9IFtzY3JpcHQ9J0RGTFQnXVxuICogQHBhcmFtIHtzdHJpbmd9IFtsYW5ndWFnZT0nZGZsdCddXG4gKiBAcGFyYW0ge3N0cmluZ30gZmVhdHVyZSAtIDQtY2hhcmFjdGVyIGZlYXR1cmUgbmFtZSAoJ2FhbHQnLCAnc2FsdCcuLi4pXG4gKiBAcmV0dXJuIHtBcnJheX0gYWx0ZXJuYXRlcyAtIFRoZSBsaXN0IG9mIGFsdGVybmF0ZXNcbiAqL1xuU3Vic3RpdHV0aW9uLnByb3RvdHlwZS5nZXRBbHRlcm5hdGVzID0gZnVuY3Rpb24oZmVhdHVyZSwgc2NyaXB0LCBsYW5ndWFnZSkge1xuICAgIGNvbnN0IGFsdGVybmF0ZXMgPSBbXTtcbiAgICBjb25zdCBsb29rdXBUYWJsZXMgPSB0aGlzLmdldExvb2t1cFRhYmxlcyhzY3JpcHQsIGxhbmd1YWdlLCBmZWF0dXJlLCAzKTtcbiAgICBmb3IgKGxldCBpZHggPSAwOyBpZHggPCBsb29rdXBUYWJsZXMubGVuZ3RoOyBpZHgrKykge1xuICAgICAgICBjb25zdCBzdWJ0YWJsZXMgPSBsb29rdXBUYWJsZXNbaWR4XS5zdWJ0YWJsZXM7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3VidGFibGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBzdWJ0YWJsZSA9IHN1YnRhYmxlc1tpXTtcbiAgICAgICAgICAgIGNvbnN0IGdseXBocyA9IHRoaXMuZXhwYW5kQ292ZXJhZ2Uoc3VidGFibGUuY292ZXJhZ2UpO1xuICAgICAgICAgICAgY29uc3QgYWx0ZXJuYXRlU2V0cyA9IHN1YnRhYmxlLmFsdGVybmF0ZVNldHM7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGdseXBocy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIGFsdGVybmF0ZXMucHVzaCh7IHN1YjogZ2x5cGhzW2pdLCBieTogYWx0ZXJuYXRlU2V0c1tqXSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYWx0ZXJuYXRlcztcbn07XG5cbi8qKlxuICogTGlzdCBhbGwgbGlnYXR1cmVzIChsb29rdXAgdHlwZSA0KSBmb3IgYSBnaXZlbiBzY3JpcHQsIGxhbmd1YWdlLCBhbmQgZmVhdHVyZS5cbiAqIFRoZSByZXN1bHQgaXMgYW4gYXJyYXkgb2YgbGlnYXR1cmUgb2JqZWN0cyBsaWtlIHsgc3ViOiBbaWRzXSwgYnk6IGlkIH1cbiAqIEBwYXJhbSB7c3RyaW5nfSBmZWF0dXJlIC0gNC1sZXR0ZXIgZmVhdHVyZSBuYW1lICgnbGlnYScsICdybGlnJywgJ2RsaWcnLi4uKVxuICogQHBhcmFtIHtzdHJpbmd9IFtzY3JpcHQ9J0RGTFQnXVxuICogQHBhcmFtIHtzdHJpbmd9IFtsYW5ndWFnZT0nZGZsdCddXG4gKiBAcmV0dXJuIHtBcnJheX0gbGlnYXR1cmVzIC0gVGhlIGxpc3Qgb2YgbGlnYXR1cmVzLlxuICovXG5TdWJzdGl0dXRpb24ucHJvdG90eXBlLmdldExpZ2F0dXJlcyA9IGZ1bmN0aW9uKGZlYXR1cmUsIHNjcmlwdCwgbGFuZ3VhZ2UpIHtcbiAgICBjb25zdCBsaWdhdHVyZXMgPSBbXTtcbiAgICBjb25zdCBsb29rdXBUYWJsZXMgPSB0aGlzLmdldExvb2t1cFRhYmxlcyhzY3JpcHQsIGxhbmd1YWdlLCBmZWF0dXJlLCA0KTtcbiAgICBmb3IgKGxldCBpZHggPSAwOyBpZHggPCBsb29rdXBUYWJsZXMubGVuZ3RoOyBpZHgrKykge1xuICAgICAgICBjb25zdCBzdWJ0YWJsZXMgPSBsb29rdXBUYWJsZXNbaWR4XS5zdWJ0YWJsZXM7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3VidGFibGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBzdWJ0YWJsZSA9IHN1YnRhYmxlc1tpXTtcbiAgICAgICAgICAgIGNvbnN0IGdseXBocyA9IHRoaXMuZXhwYW5kQ292ZXJhZ2Uoc3VidGFibGUuY292ZXJhZ2UpO1xuICAgICAgICAgICAgY29uc3QgbGlnYXR1cmVTZXRzID0gc3VidGFibGUubGlnYXR1cmVTZXRzO1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBnbHlwaHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzdGFydEdseXBoID0gZ2x5cGhzW2pdO1xuICAgICAgICAgICAgICAgIGNvbnN0IGxpZ1NldCA9IGxpZ2F0dXJlU2V0c1tqXTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IGxpZ1NldC5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBsaWcgPSBsaWdTZXRba107XG4gICAgICAgICAgICAgICAgICAgIGxpZ2F0dXJlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1YjogW3N0YXJ0R2x5cGhdLmNvbmNhdChsaWcuY29tcG9uZW50cyksXG4gICAgICAgICAgICAgICAgICAgICAgICBieTogbGlnLmxpZ0dseXBoXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbGlnYXR1cmVzO1xufTtcblxuLyoqXG4gKiBBZGQgb3IgbW9kaWZ5IGEgc2luZ2xlIHN1YnN0aXR1dGlvbiAobG9va3VwIHR5cGUgMSlcbiAqIEZvcm1hdCAyLCBtb3JlIGZsZXhpYmxlLCBpcyBhbHdheXMgdXNlZC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBmZWF0dXJlIC0gNC1sZXR0ZXIgZmVhdHVyZSBuYW1lICgnbGlnYScsICdybGlnJywgJ2RsaWcnLi4uKVxuICogQHBhcmFtIHtPYmplY3R9IHN1YnN0aXR1dGlvbiAtIHsgc3ViOiBpZCwgZGVsdGE6IG51bWJlciB9IGZvciBmb3JtYXQgMSBvciB7IHN1YjogaWQsIGJ5OiBpZCB9IGZvciBmb3JtYXQgMi5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbc2NyaXB0PSdERkxUJ11cbiAqIEBwYXJhbSB7c3RyaW5nfSBbbGFuZ3VhZ2U9J2RmbHQnXVxuICovXG5TdWJzdGl0dXRpb24ucHJvdG90eXBlLmFkZFNpbmdsZSA9IGZ1bmN0aW9uKGZlYXR1cmUsIHN1YnN0aXR1dGlvbiwgc2NyaXB0LCBsYW5ndWFnZSkge1xuICAgIGNvbnN0IGxvb2t1cFRhYmxlID0gdGhpcy5nZXRMb29rdXBUYWJsZXMoc2NyaXB0LCBsYW5ndWFnZSwgZmVhdHVyZSwgMSwgdHJ1ZSlbMF07XG4gICAgY29uc3Qgc3VidGFibGUgPSBnZXRTdWJzdEZvcm1hdChsb29rdXBUYWJsZSwgMiwgeyAgICAgICAgICAgICAgICAvLyBsb29rdXAgdHlwZSAxIHN1YnRhYmxlLCBmb3JtYXQgMiwgY292ZXJhZ2UgZm9ybWF0IDFcbiAgICAgICAgc3Vic3RGb3JtYXQ6IDIsXG4gICAgICAgIGNvdmVyYWdlOiB7Zm9ybWF0OiAxLCBnbHlwaHM6IFtdfSxcbiAgICAgICAgc3Vic3RpdHV0ZTogW11cbiAgICB9KTtcbiAgICBjaGVjay5hc3NlcnQoc3VidGFibGUuY292ZXJhZ2UuZm9ybWF0ID09PSAxLCAnTGlnYXR1cmU6IHVuYWJsZSB0byBtb2RpZnkgY292ZXJhZ2UgdGFibGUgZm9ybWF0ICcgKyBzdWJ0YWJsZS5jb3ZlcmFnZS5mb3JtYXQpO1xuICAgIGNvbnN0IGNvdmVyYWdlR2x5cGggPSBzdWJzdGl0dXRpb24uc3ViO1xuICAgIGxldCBwb3MgPSB0aGlzLmJpblNlYXJjaChzdWJ0YWJsZS5jb3ZlcmFnZS5nbHlwaHMsIGNvdmVyYWdlR2x5cGgpO1xuICAgIGlmIChwb3MgPCAwKSB7XG4gICAgICAgIHBvcyA9IC0xIC0gcG9zO1xuICAgICAgICBzdWJ0YWJsZS5jb3ZlcmFnZS5nbHlwaHMuc3BsaWNlKHBvcywgMCwgY292ZXJhZ2VHbHlwaCk7XG4gICAgICAgIHN1YnRhYmxlLnN1YnN0aXR1dGUuc3BsaWNlKHBvcywgMCwgMCk7XG4gICAgfVxuICAgIHN1YnRhYmxlLnN1YnN0aXR1dGVbcG9zXSA9IHN1YnN0aXR1dGlvbi5ieTtcbn07XG5cbi8qKlxuICogQWRkIG9yIG1vZGlmeSBhbiBhbHRlcm5hdGUgc3Vic3RpdHV0aW9uIChsb29rdXAgdHlwZSAxKVxuICogQHBhcmFtIHtzdHJpbmd9IGZlYXR1cmUgLSA0LWxldHRlciBmZWF0dXJlIG5hbWUgKCdsaWdhJywgJ3JsaWcnLCAnZGxpZycuLi4pXG4gKiBAcGFyYW0ge09iamVjdH0gc3Vic3RpdHV0aW9uIC0geyBzdWI6IGlkLCBieTogW2lkc10gfVxuICogQHBhcmFtIHtzdHJpbmd9IFtzY3JpcHQ9J0RGTFQnXVxuICogQHBhcmFtIHtzdHJpbmd9IFtsYW5ndWFnZT0nZGZsdCddXG4gKi9cblN1YnN0aXR1dGlvbi5wcm90b3R5cGUuYWRkQWx0ZXJuYXRlID0gZnVuY3Rpb24oZmVhdHVyZSwgc3Vic3RpdHV0aW9uLCBzY3JpcHQsIGxhbmd1YWdlKSB7XG4gICAgY29uc3QgbG9va3VwVGFibGUgPSB0aGlzLmdldExvb2t1cFRhYmxlcyhzY3JpcHQsIGxhbmd1YWdlLCBmZWF0dXJlLCAzLCB0cnVlKVswXTtcbiAgICBjb25zdCBzdWJ0YWJsZSA9IGdldFN1YnN0Rm9ybWF0KGxvb2t1cFRhYmxlLCAxLCB7ICAgICAgICAgICAgICAgIC8vIGxvb2t1cCB0eXBlIDMgc3VidGFibGUsIGZvcm1hdCAxLCBjb3ZlcmFnZSBmb3JtYXQgMVxuICAgICAgICBzdWJzdEZvcm1hdDogMSxcbiAgICAgICAgY292ZXJhZ2U6IHtmb3JtYXQ6IDEsIGdseXBoczogW119LFxuICAgICAgICBhbHRlcm5hdGVTZXRzOiBbXVxuICAgIH0pO1xuICAgIGNoZWNrLmFzc2VydChzdWJ0YWJsZS5jb3ZlcmFnZS5mb3JtYXQgPT09IDEsICdMaWdhdHVyZTogdW5hYmxlIHRvIG1vZGlmeSBjb3ZlcmFnZSB0YWJsZSBmb3JtYXQgJyArIHN1YnRhYmxlLmNvdmVyYWdlLmZvcm1hdCk7XG4gICAgY29uc3QgY292ZXJhZ2VHbHlwaCA9IHN1YnN0aXR1dGlvbi5zdWI7XG4gICAgbGV0IHBvcyA9IHRoaXMuYmluU2VhcmNoKHN1YnRhYmxlLmNvdmVyYWdlLmdseXBocywgY292ZXJhZ2VHbHlwaCk7XG4gICAgaWYgKHBvcyA8IDApIHtcbiAgICAgICAgcG9zID0gLTEgLSBwb3M7XG4gICAgICAgIHN1YnRhYmxlLmNvdmVyYWdlLmdseXBocy5zcGxpY2UocG9zLCAwLCBjb3ZlcmFnZUdseXBoKTtcbiAgICAgICAgc3VidGFibGUuYWx0ZXJuYXRlU2V0cy5zcGxpY2UocG9zLCAwLCAwKTtcbiAgICB9XG4gICAgc3VidGFibGUuYWx0ZXJuYXRlU2V0c1twb3NdID0gc3Vic3RpdHV0aW9uLmJ5O1xufTtcblxuLyoqXG4gKiBBZGQgYSBsaWdhdHVyZSAobG9va3VwIHR5cGUgNClcbiAqIExpZ2F0dXJlcyB3aXRoIG1vcmUgY29tcG9uZW50cyBtdXN0IGJlIHN0b3JlZCBhaGVhZCBvZiB0aG9zZSB3aXRoIGZld2VyIGNvbXBvbmVudHMgaW4gb3JkZXIgdG8gYmUgZm91bmRcbiAqIEBwYXJhbSB7c3RyaW5nfSBmZWF0dXJlIC0gNC1sZXR0ZXIgZmVhdHVyZSBuYW1lICgnbGlnYScsICdybGlnJywgJ2RsaWcnLi4uKVxuICogQHBhcmFtIHtPYmplY3R9IGxpZ2F0dXJlIC0geyBzdWI6IFtpZHNdLCBieTogaWQgfVxuICogQHBhcmFtIHtzdHJpbmd9IFtzY3JpcHQ9J0RGTFQnXVxuICogQHBhcmFtIHtzdHJpbmd9IFtsYW5ndWFnZT0nZGZsdCddXG4gKi9cblN1YnN0aXR1dGlvbi5wcm90b3R5cGUuYWRkTGlnYXR1cmUgPSBmdW5jdGlvbihmZWF0dXJlLCBsaWdhdHVyZSwgc2NyaXB0LCBsYW5ndWFnZSkge1xuICAgIGNvbnN0IGxvb2t1cFRhYmxlID0gdGhpcy5nZXRMb29rdXBUYWJsZXMoc2NyaXB0LCBsYW5ndWFnZSwgZmVhdHVyZSwgNCwgdHJ1ZSlbMF07XG4gICAgbGV0IHN1YnRhYmxlID0gbG9va3VwVGFibGUuc3VidGFibGVzWzBdO1xuICAgIGlmICghc3VidGFibGUpIHtcbiAgICAgICAgc3VidGFibGUgPSB7ICAgICAgICAgICAgICAgIC8vIGxvb2t1cCB0eXBlIDQgc3VidGFibGUsIGZvcm1hdCAxLCBjb3ZlcmFnZSBmb3JtYXQgMVxuICAgICAgICAgICAgc3Vic3RGb3JtYXQ6IDEsXG4gICAgICAgICAgICBjb3ZlcmFnZTogeyBmb3JtYXQ6IDEsIGdseXBoczogW10gfSxcbiAgICAgICAgICAgIGxpZ2F0dXJlU2V0czogW11cbiAgICAgICAgfTtcbiAgICAgICAgbG9va3VwVGFibGUuc3VidGFibGVzWzBdID0gc3VidGFibGU7XG4gICAgfVxuICAgIGNoZWNrLmFzc2VydChzdWJ0YWJsZS5jb3ZlcmFnZS5mb3JtYXQgPT09IDEsICdMaWdhdHVyZTogdW5hYmxlIHRvIG1vZGlmeSBjb3ZlcmFnZSB0YWJsZSBmb3JtYXQgJyArIHN1YnRhYmxlLmNvdmVyYWdlLmZvcm1hdCk7XG4gICAgY29uc3QgY292ZXJhZ2VHbHlwaCA9IGxpZ2F0dXJlLnN1YlswXTtcbiAgICBjb25zdCBsaWdDb21wb25lbnRzID0gbGlnYXR1cmUuc3ViLnNsaWNlKDEpO1xuICAgIGNvbnN0IGxpZ2F0dXJlVGFibGUgPSB7XG4gICAgICAgIGxpZ0dseXBoOiBsaWdhdHVyZS5ieSxcbiAgICAgICAgY29tcG9uZW50czogbGlnQ29tcG9uZW50c1xuICAgIH07XG4gICAgbGV0IHBvcyA9IHRoaXMuYmluU2VhcmNoKHN1YnRhYmxlLmNvdmVyYWdlLmdseXBocywgY292ZXJhZ2VHbHlwaCk7XG4gICAgaWYgKHBvcyA+PSAwKSB7XG4gICAgICAgIC8vIGxpZ2F0dXJlU2V0IGFscmVhZHkgZXhpc3RzXG4gICAgICAgIGNvbnN0IGxpZ2F0dXJlU2V0ID0gc3VidGFibGUubGlnYXR1cmVTZXRzW3Bvc107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGlnYXR1cmVTZXQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIC8vIElmIGxpZ2F0dXJlIGFscmVhZHkgZXhpc3RzLCByZXR1cm4uXG4gICAgICAgICAgICBpZiAoYXJyYXlzRXF1YWwobGlnYXR1cmVTZXRbaV0uY29tcG9uZW50cywgbGlnQ29tcG9uZW50cykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gbGlnYXR1cmUgZG9lcyBub3QgZXhpc3Q6IGFkZCBpdC5cbiAgICAgICAgbGlnYXR1cmVTZXQucHVzaChsaWdhdHVyZVRhYmxlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBDcmVhdGUgYSBuZXcgbGlnYXR1cmVTZXQgYW5kIGFkZCBjb3ZlcmFnZSBmb3IgdGhlIGZpcnN0IGdseXBoLlxuICAgICAgICBwb3MgPSAtMSAtIHBvcztcbiAgICAgICAgc3VidGFibGUuY292ZXJhZ2UuZ2x5cGhzLnNwbGljZShwb3MsIDAsIGNvdmVyYWdlR2x5cGgpO1xuICAgICAgICBzdWJ0YWJsZS5saWdhdHVyZVNldHMuc3BsaWNlKHBvcywgMCwgW2xpZ2F0dXJlVGFibGVdKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIExpc3QgYWxsIGZlYXR1cmUgZGF0YSBmb3IgYSBnaXZlbiBzY3JpcHQgYW5kIGxhbmd1YWdlLlxuICogQHBhcmFtIHtzdHJpbmd9IGZlYXR1cmUgLSA0LWxldHRlciBmZWF0dXJlIG5hbWVcbiAqIEBwYXJhbSB7c3RyaW5nfSBbc2NyaXB0PSdERkxUJ11cbiAqIEBwYXJhbSB7c3RyaW5nfSBbbGFuZ3VhZ2U9J2RmbHQnXVxuICogQHJldHVybiB7QXJyYXl9IHN1YnN0aXR1dGlvbnMgLSBUaGUgbGlzdCBvZiBzdWJzdGl0dXRpb25zLlxuICovXG5TdWJzdGl0dXRpb24ucHJvdG90eXBlLmdldEZlYXR1cmUgPSBmdW5jdGlvbihmZWF0dXJlLCBzY3JpcHQsIGxhbmd1YWdlKSB7XG4gICAgaWYgKC9zc1xcZFxcZC8udGVzdChmZWF0dXJlKSkgeyAgICAgICAgICAgICAgIC8vIHNzMDEgLSBzczIwXG4gICAgICAgIHJldHVybiB0aGlzLmdldFNpbmdsZShmZWF0dXJlLCBzY3JpcHQsIGxhbmd1YWdlKTtcbiAgICB9XG4gICAgc3dpdGNoIChmZWF0dXJlKSB7XG4gICAgICAgIGNhc2UgJ2FhbHQnOlxuICAgICAgICBjYXNlICdzYWx0JzpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFNpbmdsZShmZWF0dXJlLCBzY3JpcHQsIGxhbmd1YWdlKVxuICAgICAgICAgICAgICAgICAgICAuY29uY2F0KHRoaXMuZ2V0QWx0ZXJuYXRlcyhmZWF0dXJlLCBzY3JpcHQsIGxhbmd1YWdlKSk7XG4gICAgICAgIGNhc2UgJ2RsaWcnOlxuICAgICAgICBjYXNlICdsaWdhJzpcbiAgICAgICAgY2FzZSAncmxpZyc6IHJldHVybiB0aGlzLmdldExpZ2F0dXJlcyhmZWF0dXJlLCBzY3JpcHQsIGxhbmd1YWdlKTtcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn07XG5cbi8qKlxuICogQWRkIGEgc3Vic3RpdHV0aW9uIHRvIGEgZmVhdHVyZSBmb3IgYSBnaXZlbiBzY3JpcHQgYW5kIGxhbmd1YWdlLlxuICogQHBhcmFtIHtzdHJpbmd9IGZlYXR1cmUgLSA0LWxldHRlciBmZWF0dXJlIG5hbWVcbiAqIEBwYXJhbSB7T2JqZWN0fSBzdWIgLSB0aGUgc3Vic3RpdHV0aW9uIHRvIGFkZCAoYW4gb2JqZWN0IGxpa2UgeyBzdWI6IGlkIG9yIFtpZHNdLCBieTogaWQgb3IgW2lkc10gfSlcbiAqIEBwYXJhbSB7c3RyaW5nfSBbc2NyaXB0PSdERkxUJ11cbiAqIEBwYXJhbSB7c3RyaW5nfSBbbGFuZ3VhZ2U9J2RmbHQnXVxuICovXG5TdWJzdGl0dXRpb24ucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uKGZlYXR1cmUsIHN1Yiwgc2NyaXB0LCBsYW5ndWFnZSkge1xuICAgIGlmICgvc3NcXGRcXGQvLnRlc3QoZmVhdHVyZSkpIHsgICAgICAgICAgICAgICAvLyBzczAxIC0gc3MyMFxuICAgICAgICByZXR1cm4gdGhpcy5hZGRTaW5nbGUoZmVhdHVyZSwgc3ViLCBzY3JpcHQsIGxhbmd1YWdlKTtcbiAgICB9XG4gICAgc3dpdGNoIChmZWF0dXJlKSB7XG4gICAgICAgIGNhc2UgJ2FhbHQnOlxuICAgICAgICBjYXNlICdzYWx0JzpcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc3ViLmJ5ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmFkZFNpbmdsZShmZWF0dXJlLCBzdWIsIHNjcmlwdCwgbGFuZ3VhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWRkQWx0ZXJuYXRlKGZlYXR1cmUsIHN1Yiwgc2NyaXB0LCBsYW5ndWFnZSk7XG4gICAgICAgIGNhc2UgJ2RsaWcnOlxuICAgICAgICBjYXNlICdsaWdhJzpcbiAgICAgICAgY2FzZSAncmxpZyc6XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hZGRMaWdhdHVyZShmZWF0dXJlLCBzdWIsIHNjcmlwdCwgbGFuZ3VhZ2UpO1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgU3Vic3RpdHV0aW9uO1xuIiwiLyogQSBUcnVlVHlwZSBmb250IGhpbnRpbmcgaW50ZXJwcmV0ZXIuXG4qXG4qIChjKSAyMDE3IEF4ZWwgS2l0dGVuYmVyZ2VyXG4qXG4qIFRoaXMgaW50ZXJwcmV0ZXIgaGFzIGJlZW4gaW1wbGVtZW50ZWQgYWNjb3JkaW5nIHRvIHRoaXMgZG9jdW1lbnRhdGlvbjpcbiogaHR0cHM6Ly9kZXZlbG9wZXIuYXBwbGUuY29tL2ZvbnRzL1RydWVUeXBlLVJlZmVyZW5jZS1NYW51YWwvUk0wNS9DaGFwNS5odG1sXG4qXG4qIEFjY29yZGluZyB0byB0aGUgZG9jdW1lbnRhdGlvbiBGMjRET1Q2IHZhbHVlcyBhcmUgdXNlZCBmb3IgcGl4ZWxzLlxuKiBUaGF0IG1lYW5zIGNhbGN1bGF0aW9uIGlzIDEvNjQgcGl4ZWwgYWNjdXJhdGUgYW5kIHVzZXMgaW50ZWdlciBvcGVyYXRpb25zLlxuKiBIb3dldmVyLCBKYXZhc2NyaXB0IGhhcyBmbG9hdGluZyBwb2ludCBvcGVyYXRpb25zIGJ5IGRlZmF1bHQgYW5kIG9ubHlcbiogdGhvc2UgYXJlIGF2YWlsYWJsZS4gT25lIGNvdWxkIG1ha2UgYSBjYXNlIHRvIHNpbXVsYXRlIHRoZSAxLzY0IGFjY3VyYWN5XG4qIGV4YWN0bHkgYnkgdHJ1bmNhdGluZyBhZnRlciBldmVyeSBkaXZpc2lvbiBvcGVyYXRpb25cbiogKGZvciBleGFtcGxlIHdpdGggPDwgMCkgdG8gZ2V0IHBpeGVsIGV4YWN0bHkgcmVzdWx0cyBhcyBvdGhlciBUcnVlVHlwZVxuKiBpbXBsZW1lbnRhdGlvbnMuIEl0IG1heSBtYWtlIHNlbnNlIHNpbmNlIHNvbWUgZm9udHMgYXJlIHBpeGVsIG9wdGltaXplZFxuKiBieSBoYW5kIHVzaW5nIERFTFRBUCBpbnN0cnVjdGlvbnMuIFRoZSBjdXJyZW50IGltcGxlbWVudGF0aW9uIGRvZXNuJ3RcbiogYW5kIHJhdGhlciB1c2VzIGZ1bGwgZmxvYXRpbmcgcG9pbnQgcHJlY2lzaW9uLlxuKlxuKiB4U2NhbGUsIHlTY2FsZSBhbmQgcm90YXRpb24gaXMgY3VycmVudGx5IGlnbm9yZWQuXG4qXG4qIEEgZmV3IG5vbi10cml2aWFsIGluc3RydWN0aW9ucyBhcmUgbWlzc2luZyBhcyBJIGRpZG4ndCBlbmNvdW50ZXIgeWV0XG4qIGEgZm9udCB0aGF0IHVzZWQgdGhlbSB0byB0ZXN0IGEgcG9zc2libGUgaW1wbGVtZW50YXRpb24uXG4qXG4qIFNvbWUgZm9udHMgc2VlbSB0byB1c2UgdW5kb2N1bWVudGVkIGZlYXR1cmVzIHJlZ2FyZGluZyB0aGUgdHdpbGlnaHQgem9uZS5cbiogT25seSBzb21lIG9mIHRoZW0gYXJlIGltcGxlbWVudGVkIGFzIHRoZXkgd2VyZSBlbmNvdW50ZXJlZC5cbipcbiogVGhlIGV4cG9ydHMuREVCVUcgc3RhdGVtZW50cyBhcmUgcmVtb3ZlZCBvbiB0aGUgbWluaWZpZWQgZGlzdHJpYnV0aW9uIGZpbGUuXG4qL1xuJ3VzZSBzdHJpY3QnO1xuXG5sZXQgaW5zdHJ1Y3Rpb25UYWJsZTtcbmxldCBleGVjO1xubGV0IGV4ZWNHbHlwaDtcbmxldCBleGVjQ29tcG9uZW50O1xuXG4vKlxuKiBDcmVhdGVzIGEgaGludGluZyBvYmplY3QuXG4qXG4qIFRoZXJlIG91Z2h0IHRvIGJlIGV4YWN0bHkgb25lXG4qIGZvciBlYWNoIHRydWV0eXBlIGZvbnQgdGhhdCBpcyB1c2VkIGZvciBoaW50aW5nLlxuKi9cbmZ1bmN0aW9uIEhpbnRpbmcoZm9udCkge1xuICAgIC8vIHRoZSBmb250IHRoaXMgaGludGluZyBvYmplY3QgaXMgZm9yXG4gICAgdGhpcy5mb250ID0gZm9udDtcblxuICAgIC8vIGNhY2hlZCBzdGF0ZXNcbiAgICB0aGlzLl9mcGdtU3RhdGUgID1cbiAgICB0aGlzLl9wcmVwU3RhdGUgID1cbiAgICAgICAgdW5kZWZpbmVkO1xuXG4gICAgLy8gZXJyb3JTdGF0ZVxuICAgIC8vIDAgLi4uIGFsbCBva2F5XG4gICAgLy8gMSAuLi4gaGFkIGFuIGVycm9yIGluIGEgZ2x5ZixcbiAgICAvLyAgICAgICBjb250aW51ZSB3b3JraW5nIGJ1dCBzdG9wIHNwYW1taW5nXG4gICAgLy8gICAgICAgdGhlIGNvbnNvbGVcbiAgICAvLyAyIC4uLiBlcnJvciBhdCBwcmVwLCBzdG9wIGhpbnRpbmcgYXQgdGhpcyBwcGVtXG4gICAgLy8gMyAuLi4gZXJyb3IgYXQgZnBlZywgc3RvcCBoaW50aW5nIGZvciB0aGlzIGZvbnQgYXQgYWxsXG4gICAgdGhpcy5fZXJyb3JTdGF0ZSA9IDA7XG59XG5cbi8qXG4qIE5vdCByb3VuZGluZy5cbiovXG5mdW5jdGlvbiByb3VuZE9mZih2KSB7XG4gICAgcmV0dXJuIHY7XG59XG5cbi8qXG4qIFJvdW5kaW5nIHRvIGdyaWQuXG4qL1xuZnVuY3Rpb24gcm91bmRUb0dyaWQodikge1xuICAgIC8vUm91bmRpbmcgaW4gVFQgaXMgc3VwcG9zZWQgdG8gXCJzeW1tZXRyaWNhbCBhcm91bmQgemVyb1wiXG4gICAgcmV0dXJuIE1hdGguc2lnbih2KSAqIE1hdGgucm91bmQoTWF0aC5hYnModikpO1xufVxuXG4vKlxuKiBSb3VuZGluZyB0byBkb3VibGUgZ3JpZC5cbiovXG5mdW5jdGlvbiByb3VuZFRvRG91YmxlR3JpZCh2KSB7XG4gICAgcmV0dXJuIE1hdGguc2lnbih2KSAqIE1hdGgucm91bmQoTWF0aC5hYnModiAqIDIpKSAvIDI7XG59XG5cbi8qXG4qIFJvdW5kaW5nIHRvIGhhbGYgZ3JpZC5cbiovXG5mdW5jdGlvbiByb3VuZFRvSGFsZkdyaWQodikge1xuICAgIHJldHVybiBNYXRoLnNpZ24odikgKiAoTWF0aC5yb3VuZChNYXRoLmFicyh2KSArIDAuNSkgLSAwLjUpO1xufVxuXG4vKlxuKiBSb3VuZGluZyB0byB1cCB0byBncmlkLlxuKi9cbmZ1bmN0aW9uIHJvdW5kVXBUb0dyaWQodikge1xuICAgIHJldHVybiBNYXRoLnNpZ24odikgKiBNYXRoLmNlaWwoTWF0aC5hYnModikpO1xufVxuXG4vKlxuKiBSb3VuZGluZyB0byBkb3duIHRvIGdyaWQuXG4qL1xuZnVuY3Rpb24gcm91bmREb3duVG9HcmlkKHYpIHtcbiAgICByZXR1cm4gTWF0aC5zaWduKHYpICogTWF0aC5mbG9vcihNYXRoLmFicyh2KSk7XG59XG5cbi8qXG4qIFN1cGVyIHJvdW5kaW5nLlxuKi9cbmNvbnN0IHJvdW5kU3VwZXIgPSBmdW5jdGlvbiAodikge1xuICAgIGNvbnN0IHBlcmlvZCA9IHRoaXMuc3JQZXJpb2Q7XG4gICAgbGV0IHBoYXNlID0gdGhpcy5zclBoYXNlO1xuICAgIGNvbnN0IHRocmVzaG9sZCA9IHRoaXMuc3JUaHJlc2hvbGQ7XG4gICAgbGV0IHNpZ24gPSAxO1xuXG4gICAgaWYgKHYgPCAwKSB7XG4gICAgICAgIHYgPSAtdjtcbiAgICAgICAgc2lnbiA9IC0xO1xuICAgIH1cblxuICAgIHYgKz0gdGhyZXNob2xkIC0gcGhhc2U7XG5cbiAgICB2ID0gTWF0aC50cnVuYyh2IC8gcGVyaW9kKSAqIHBlcmlvZDtcblxuICAgIHYgKz0gcGhhc2U7XG5cbiAgICAvLyBhY2NvcmRpbmcgdG8gaHR0cDovL3hncmlkZml0LnNvdXJjZWZvcmdlLm5ldC9yb3VuZC5odG1sXG4gICAgaWYgKHNpZ24gPiAwICYmIHYgPCAwKSByZXR1cm4gcGhhc2U7XG4gICAgaWYgKHNpZ24gPCAwICYmIHYgPiAwKSByZXR1cm4gLXBoYXNlO1xuXG4gICAgcmV0dXJuIHYgKiBzaWduO1xufTtcblxuLypcbiogVW5pdCB2ZWN0b3Igb2YgeC1heGlzLlxuKi9cbmNvbnN0IHhVbml0VmVjdG9yID0ge1xuICAgIHg6IDEsXG5cbiAgICB5OiAwLFxuXG4gICAgYXhpczogJ3gnLFxuXG4gICAgLy8gR2V0cyB0aGUgcHJvamVjdGVkIGRpc3RhbmNlIGJldHdlZW4gdHdvIHBvaW50cy5cbiAgICAvLyBvMS9vMiAuLi4gaWYgdHJ1ZSwgcmVzcGVjdGl2ZSBvcmlnaW5hbCBwb3NpdGlvbiBpcyB1c2VkLlxuICAgIGRpc3RhbmNlOiBmdW5jdGlvbiAocDEsIHAyLCBvMSwgbzIpIHtcbiAgICAgICAgcmV0dXJuIChvMSA/IHAxLnhvIDogcDEueCkgLSAobzIgPyBwMi54byA6IHAyLngpO1xuICAgIH0sXG5cbiAgICAvLyBNb3ZlcyBwb2ludCBwIHNvIHRoZSBtb3ZlZCBwb3NpdGlvbiBoYXMgdGhlIHNhbWUgcmVsYXRpdmVcbiAgICAvLyBwb3NpdGlvbiB0byB0aGUgbW92ZWQgcG9zaXRpb25zIG9mIHJwMSBhbmQgcnAyIHRoYW4gdGhlXG4gICAgLy8gb3JpZ2luYWwgcG9zaXRpb25zIGhhZC5cbiAgICAvL1xuICAgIC8vIFNlZSBBUFBFTkRJWCBvbiBJTlRFUlBPTEFURSBhdCB0aGUgYm90dG9tIG9mIHRoaXMgZmlsZS5cbiAgICBpbnRlcnBvbGF0ZTogZnVuY3Rpb24gKHAsIHJwMSwgcnAyLCBwdikge1xuICAgICAgICBsZXQgZG8xO1xuICAgICAgICBsZXQgZG8yO1xuICAgICAgICBsZXQgZG9hMTtcbiAgICAgICAgbGV0IGRvYTI7XG4gICAgICAgIGxldCBkbTE7XG4gICAgICAgIGxldCBkbTI7XG4gICAgICAgIGxldCBkdDtcblxuICAgICAgICBpZiAoIXB2IHx8IHB2ID09PSB0aGlzKSB7XG4gICAgICAgICAgICBkbzEgPSBwLnhvIC0gcnAxLnhvO1xuICAgICAgICAgICAgZG8yID0gcC54byAtIHJwMi54bztcbiAgICAgICAgICAgIGRtMSA9IHJwMS54IC0gcnAxLnhvO1xuICAgICAgICAgICAgZG0yID0gcnAyLnggLSBycDIueG87XG4gICAgICAgICAgICBkb2ExID0gTWF0aC5hYnMoZG8xKTtcbiAgICAgICAgICAgIGRvYTIgPSBNYXRoLmFicyhkbzIpO1xuICAgICAgICAgICAgZHQgPSBkb2ExICsgZG9hMjtcblxuICAgICAgICAgICAgaWYgKGR0ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcC54ID0gcC54byArIChkbTEgKyBkbTIpIC8gMjtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHAueCA9IHAueG8gKyAoZG0xICogZG9hMiArIGRtMiAqIGRvYTEpIC8gZHQ7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBkbzEgPSBwdi5kaXN0YW5jZShwLCBycDEsIHRydWUsIHRydWUpO1xuICAgICAgICBkbzIgPSBwdi5kaXN0YW5jZShwLCBycDIsIHRydWUsIHRydWUpO1xuICAgICAgICBkbTEgPSBwdi5kaXN0YW5jZShycDEsIHJwMSwgZmFsc2UsIHRydWUpO1xuICAgICAgICBkbTIgPSBwdi5kaXN0YW5jZShycDIsIHJwMiwgZmFsc2UsIHRydWUpO1xuICAgICAgICBkb2ExID0gTWF0aC5hYnMoZG8xKTtcbiAgICAgICAgZG9hMiA9IE1hdGguYWJzKGRvMik7XG4gICAgICAgIGR0ID0gZG9hMSArIGRvYTI7XG5cbiAgICAgICAgaWYgKGR0ID09PSAwKSB7XG4gICAgICAgICAgICB4VW5pdFZlY3Rvci5zZXRSZWxhdGl2ZShwLCBwLCAoZG0xICsgZG0yKSAvIDIsIHB2LCB0cnVlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHhVbml0VmVjdG9yLnNldFJlbGF0aXZlKHAsIHAsIChkbTEgKiBkb2EyICsgZG0yICogZG9hMSkgLyBkdCwgcHYsIHRydWUpO1xuICAgIH0sXG5cbiAgICAvLyBTbG9wZSBvZiBsaW5lIG5vcm1hbCB0byB0aGlzXG4gICAgbm9ybWFsU2xvcGU6IE51bWJlci5ORUdBVElWRV9JTkZJTklUWSxcblxuICAgIC8vIFNldHMgdGhlIHBvaW50ICdwJyByZWxhdGl2ZSB0byBwb2ludCAncnAnXG4gICAgLy8gYnkgdGhlIGRpc3RhbmNlICdkJy5cbiAgICAvL1xuICAgIC8vIFNlZSBBUFBFTkRJWCBvbiBTRVRSRUxBVElWRSBhdCB0aGUgYm90dG9tIG9mIHRoaXMgZmlsZS5cbiAgICAvL1xuICAgIC8vIHAgICAuLi4gcG9pbnQgdG8gc2V0XG4gICAgLy8gcnAgIC4uLiByZWZlcmVuY2UgcG9pbnRcbiAgICAvLyBkICAgLi4uIGRpc3RhbmNlIG9uIHByb2plY3Rpb24gdmVjdG9yXG4gICAgLy8gcHYgIC4uLiBwcm9qZWN0aW9uIHZlY3RvciAodW5kZWZpbmVkID0gdGhpcylcbiAgICAvLyBvcmcgLi4uIGlmIHRydWUsIHVzZXMgdGhlIG9yaWdpbmFsIHBvc2l0aW9uIG9mIHJwIGFzIHJlZmVyZW5jZS5cbiAgICBzZXRSZWxhdGl2ZTogZnVuY3Rpb24gKHAsIHJwLCBkLCBwdiwgb3JnKSB7XG4gICAgICAgIGlmICghcHYgfHwgcHYgPT09IHRoaXMpIHtcbiAgICAgICAgICAgIHAueCA9IChvcmcgPyBycC54byA6IHJwLngpICsgZDtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHJweCA9IG9yZyA/IHJwLnhvIDogcnAueDtcbiAgICAgICAgY29uc3QgcnB5ID0gb3JnID8gcnAueW8gOiBycC55O1xuICAgICAgICBjb25zdCBycGR4ID0gcnB4ICsgZCAqIHB2Lng7XG4gICAgICAgIGNvbnN0IHJwZHkgPSBycHkgKyBkICogcHYueTtcblxuICAgICAgICBwLnggPSBycGR4ICsgKHAueSAtIHJwZHkpIC8gcHYubm9ybWFsU2xvcGU7XG4gICAgfSxcblxuICAgIC8vIFNsb3BlIG9mIHZlY3RvciBsaW5lLlxuICAgIHNsb3BlOiAwLFxuXG4gICAgLy8gVG91Y2hlcyB0aGUgcG9pbnQgcC5cbiAgICB0b3VjaDogZnVuY3Rpb24gKHApIHtcbiAgICAgICAgcC54VG91Y2hlZCA9IHRydWU7XG4gICAgfSxcblxuICAgIC8vIFRlc3RzIGlmIGEgcG9pbnQgcCBpcyB0b3VjaGVkLlxuICAgIHRvdWNoZWQ6IGZ1bmN0aW9uIChwKSB7XG4gICAgICAgIHJldHVybiBwLnhUb3VjaGVkO1xuICAgIH0sXG5cbiAgICAvLyBVbnRvdWNoZXMgdGhlIHBvaW50IHAuXG4gICAgdW50b3VjaDogZnVuY3Rpb24gKHApIHtcbiAgICAgICAgcC54VG91Y2hlZCA9IGZhbHNlO1xuICAgIH1cbn07XG5cbi8qXG4qIFVuaXQgdmVjdG9yIG9mIHktYXhpcy5cbiovXG5jb25zdCB5VW5pdFZlY3RvciA9IHtcbiAgICB4OiAwLFxuXG4gICAgeTogMSxcblxuICAgIGF4aXM6ICd5JyxcblxuICAgIC8vIEdldHMgdGhlIHByb2plY3RlZCBkaXN0YW5jZSBiZXR3ZWVuIHR3byBwb2ludHMuXG4gICAgLy8gbzEvbzIgLi4uIGlmIHRydWUsIHJlc3BlY3RpdmUgb3JpZ2luYWwgcG9zaXRpb24gaXMgdXNlZC5cbiAgICBkaXN0YW5jZTogZnVuY3Rpb24gKHAxLCBwMiwgbzEsIG8yKSB7XG4gICAgICAgIHJldHVybiAobzEgPyBwMS55byA6IHAxLnkpIC0gKG8yID8gcDIueW8gOiBwMi55KTtcbiAgICB9LFxuXG4gICAgLy8gTW92ZXMgcG9pbnQgcCBzbyB0aGUgbW92ZWQgcG9zaXRpb24gaGFzIHRoZSBzYW1lIHJlbGF0aXZlXG4gICAgLy8gcG9zaXRpb24gdG8gdGhlIG1vdmVkIHBvc2l0aW9ucyBvZiBycDEgYW5kIHJwMiB0aGFuIHRoZVxuICAgIC8vIG9yaWdpbmFsIHBvc2l0aW9ucyBoYWQuXG4gICAgLy9cbiAgICAvLyBTZWUgQVBQRU5ESVggb24gSU5URVJQT0xBVEUgYXQgdGhlIGJvdHRvbSBvZiB0aGlzIGZpbGUuXG4gICAgaW50ZXJwb2xhdGU6IGZ1bmN0aW9uIChwLCBycDEsIHJwMiwgcHYpIHtcbiAgICAgICAgbGV0IGRvMTtcbiAgICAgICAgbGV0IGRvMjtcbiAgICAgICAgbGV0IGRvYTE7XG4gICAgICAgIGxldCBkb2EyO1xuICAgICAgICBsZXQgZG0xO1xuICAgICAgICBsZXQgZG0yO1xuICAgICAgICBsZXQgZHQ7XG5cbiAgICAgICAgaWYgKCFwdiB8fCBwdiA9PT0gdGhpcykge1xuICAgICAgICAgICAgZG8xID0gcC55byAtIHJwMS55bztcbiAgICAgICAgICAgIGRvMiA9IHAueW8gLSBycDIueW87XG4gICAgICAgICAgICBkbTEgPSBycDEueSAtIHJwMS55bztcbiAgICAgICAgICAgIGRtMiA9IHJwMi55IC0gcnAyLnlvO1xuICAgICAgICAgICAgZG9hMSA9IE1hdGguYWJzKGRvMSk7XG4gICAgICAgICAgICBkb2EyID0gTWF0aC5hYnMoZG8yKTtcbiAgICAgICAgICAgIGR0ID0gZG9hMSArIGRvYTI7XG5cbiAgICAgICAgICAgIGlmIChkdCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHAueSA9IHAueW8gKyAoZG0xICsgZG0yKSAvIDI7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwLnkgPSBwLnlvICsgKGRtMSAqIGRvYTIgKyBkbTIgKiBkb2ExKSAvIGR0O1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgZG8xID0gcHYuZGlzdGFuY2UocCwgcnAxLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgZG8yID0gcHYuZGlzdGFuY2UocCwgcnAyLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgZG0xID0gcHYuZGlzdGFuY2UocnAxLCBycDEsIGZhbHNlLCB0cnVlKTtcbiAgICAgICAgZG0yID0gcHYuZGlzdGFuY2UocnAyLCBycDIsIGZhbHNlLCB0cnVlKTtcbiAgICAgICAgZG9hMSA9IE1hdGguYWJzKGRvMSk7XG4gICAgICAgIGRvYTIgPSBNYXRoLmFicyhkbzIpO1xuICAgICAgICBkdCA9IGRvYTEgKyBkb2EyO1xuXG4gICAgICAgIGlmIChkdCA9PT0gMCkge1xuICAgICAgICAgICAgeVVuaXRWZWN0b3Iuc2V0UmVsYXRpdmUocCwgcCwgKGRtMSArIGRtMikgLyAyLCBwdiwgdHJ1ZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB5VW5pdFZlY3Rvci5zZXRSZWxhdGl2ZShwLCBwLCAoZG0xICogZG9hMiArIGRtMiAqIGRvYTEpIC8gZHQsIHB2LCB0cnVlKTtcbiAgICB9LFxuXG4gICAgLy8gU2xvcGUgb2YgbGluZSBub3JtYWwgdG8gdGhpcy5cbiAgICBub3JtYWxTbG9wZTogMCxcblxuICAgIC8vIFNldHMgdGhlIHBvaW50ICdwJyByZWxhdGl2ZSB0byBwb2ludCAncnAnXG4gICAgLy8gYnkgdGhlIGRpc3RhbmNlICdkJ1xuICAgIC8vXG4gICAgLy8gU2VlIEFQUEVORElYIG9uIFNFVFJFTEFUSVZFIGF0IHRoZSBib3R0b20gb2YgdGhpcyBmaWxlLlxuICAgIC8vXG4gICAgLy8gcCAgIC4uLiBwb2ludCB0byBzZXRcbiAgICAvLyBycCAgLi4uIHJlZmVyZW5jZSBwb2ludFxuICAgIC8vIGQgICAuLi4gZGlzdGFuY2Ugb24gcHJvamVjdGlvbiB2ZWN0b3JcbiAgICAvLyBwdiAgLi4uIHByb2plY3Rpb24gdmVjdG9yICh1bmRlZmluZWQgPSB0aGlzKVxuICAgIC8vIG9yZyAuLi4gaWYgdHJ1ZSwgdXNlcyB0aGUgb3JpZ2luYWwgcG9zaXRpb24gb2YgcnAgYXMgcmVmZXJlbmNlLlxuICAgIHNldFJlbGF0aXZlOiBmdW5jdGlvbiAocCwgcnAsIGQsIHB2LCBvcmcpIHtcbiAgICAgICAgaWYgKCFwdiB8fCBwdiA9PT0gdGhpcykge1xuICAgICAgICAgICAgcC55ID0gKG9yZyA/IHJwLnlvIDogcnAueSkgKyBkO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcnB4ID0gb3JnID8gcnAueG8gOiBycC54O1xuICAgICAgICBjb25zdCBycHkgPSBvcmcgPyBycC55byA6IHJwLnk7XG4gICAgICAgIGNvbnN0IHJwZHggPSBycHggKyBkICogcHYueDtcbiAgICAgICAgY29uc3QgcnBkeSA9IHJweSArIGQgKiBwdi55O1xuXG4gICAgICAgIHAueSA9IHJwZHkgKyBwdi5ub3JtYWxTbG9wZSAqIChwLnggLSBycGR4KTtcbiAgICB9LFxuXG4gICAgLy8gU2xvcGUgb2YgdmVjdG9yIGxpbmUuXG4gICAgc2xvcGU6IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSxcblxuICAgIC8vIFRvdWNoZXMgdGhlIHBvaW50IHAuXG4gICAgdG91Y2g6IGZ1bmN0aW9uIChwKSB7XG4gICAgICAgIHAueVRvdWNoZWQgPSB0cnVlO1xuICAgIH0sXG5cbiAgICAvLyBUZXN0cyBpZiBhIHBvaW50IHAgaXMgdG91Y2hlZC5cbiAgICB0b3VjaGVkOiBmdW5jdGlvbiAocCkge1xuICAgICAgICByZXR1cm4gcC55VG91Y2hlZDtcbiAgICB9LFxuXG4gICAgLy8gVW50b3VjaGVzIHRoZSBwb2ludCBwLlxuICAgIHVudG91Y2g6IGZ1bmN0aW9uIChwKSB7XG4gICAgICAgIHAueVRvdWNoZWQgPSBmYWxzZTtcbiAgICB9XG59O1xuXG5PYmplY3QuZnJlZXplKHhVbml0VmVjdG9yKTtcbk9iamVjdC5mcmVlemUoeVVuaXRWZWN0b3IpO1xuXG4vKlxuKiBDcmVhdGVzIGEgdW5pdCB2ZWN0b3IgdGhhdCBpcyBub3QgeC0gb3IgeS1heGlzLlxuKi9cbmZ1bmN0aW9uIFVuaXRWZWN0b3IoeCwgeSkge1xuICAgIHRoaXMueCA9IHg7XG4gICAgdGhpcy55ID0geTtcbiAgICB0aGlzLmF4aXMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5zbG9wZSA9IHkgLyB4O1xuICAgIHRoaXMubm9ybWFsU2xvcGUgPSAteCAvIHk7XG4gICAgT2JqZWN0LmZyZWV6ZSh0aGlzKTtcbn1cblxuLypcbiogR2V0cyB0aGUgcHJvamVjdGVkIGRpc3RhbmNlIGJldHdlZW4gdHdvIHBvaW50cy5cbiogbzEvbzIgLi4uIGlmIHRydWUsIHJlc3BlY3RpdmUgb3JpZ2luYWwgcG9zaXRpb24gaXMgdXNlZC5cbiovXG5Vbml0VmVjdG9yLnByb3RvdHlwZS5kaXN0YW5jZSA9IGZ1bmN0aW9uKHAxLCBwMiwgbzEsIG8yKSB7XG4gICAgcmV0dXJuIChcbiAgICAgICAgdGhpcy54ICogeFVuaXRWZWN0b3IuZGlzdGFuY2UocDEsIHAyLCBvMSwgbzIpICtcbiAgICAgICAgdGhpcy55ICogeVVuaXRWZWN0b3IuZGlzdGFuY2UocDEsIHAyLCBvMSwgbzIpXG4gICAgKTtcbn07XG5cbi8qXG4qIE1vdmVzIHBvaW50IHAgc28gdGhlIG1vdmVkIHBvc2l0aW9uIGhhcyB0aGUgc2FtZSByZWxhdGl2ZVxuKiBwb3NpdGlvbiB0byB0aGUgbW92ZWQgcG9zaXRpb25zIG9mIHJwMSBhbmQgcnAyIHRoYW4gdGhlXG4qIG9yaWdpbmFsIHBvc2l0aW9ucyBoYWQuXG4qXG4qIFNlZSBBUFBFTkRJWCBvbiBJTlRFUlBPTEFURSBhdCB0aGUgYm90dG9tIG9mIHRoaXMgZmlsZS5cbiovXG5Vbml0VmVjdG9yLnByb3RvdHlwZS5pbnRlcnBvbGF0ZSA9IGZ1bmN0aW9uKHAsIHJwMSwgcnAyLCBwdikge1xuICAgIGxldCBkbTE7XG4gICAgbGV0IGRtMjtcbiAgICBsZXQgZG8xO1xuICAgIGxldCBkbzI7XG4gICAgbGV0IGRvYTE7XG4gICAgbGV0IGRvYTI7XG4gICAgbGV0IGR0O1xuXG4gICAgZG8xID0gcHYuZGlzdGFuY2UocCwgcnAxLCB0cnVlLCB0cnVlKTtcbiAgICBkbzIgPSBwdi5kaXN0YW5jZShwLCBycDIsIHRydWUsIHRydWUpO1xuICAgIGRtMSA9IHB2LmRpc3RhbmNlKHJwMSwgcnAxLCBmYWxzZSwgdHJ1ZSk7XG4gICAgZG0yID0gcHYuZGlzdGFuY2UocnAyLCBycDIsIGZhbHNlLCB0cnVlKTtcbiAgICBkb2ExID0gTWF0aC5hYnMoZG8xKTtcbiAgICBkb2EyID0gTWF0aC5hYnMoZG8yKTtcbiAgICBkdCA9IGRvYTEgKyBkb2EyO1xuXG4gICAgaWYgKGR0ID09PSAwKSB7XG4gICAgICAgIHRoaXMuc2V0UmVsYXRpdmUocCwgcCwgKGRtMSArIGRtMikgLyAyLCBwdiwgdHJ1ZSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLnNldFJlbGF0aXZlKHAsIHAsIChkbTEgKiBkb2EyICsgZG0yICogZG9hMSkgLyBkdCwgcHYsIHRydWUpO1xufTtcblxuLypcbiogU2V0cyB0aGUgcG9pbnQgJ3AnIHJlbGF0aXZlIHRvIHBvaW50ICdycCdcbiogYnkgdGhlIGRpc3RhbmNlICdkJ1xuKlxuKiBTZWUgQVBQRU5ESVggb24gU0VUUkVMQVRJVkUgYXQgdGhlIGJvdHRvbSBvZiB0aGlzIGZpbGUuXG4qXG4qIHAgICAuLi4gIHBvaW50IHRvIHNldFxuKiBycCAgLi4uIHJlZmVyZW5jZSBwb2ludFxuKiBkICAgLi4uIGRpc3RhbmNlIG9uIHByb2plY3Rpb24gdmVjdG9yXG4qIHB2ICAuLi4gcHJvamVjdGlvbiB2ZWN0b3IgKHVuZGVmaW5lZCA9IHRoaXMpXG4qIG9yZyAuLi4gaWYgdHJ1ZSwgdXNlcyB0aGUgb3JpZ2luYWwgcG9zaXRpb24gb2YgcnAgYXMgcmVmZXJlbmNlLlxuKi9cblVuaXRWZWN0b3IucHJvdG90eXBlLnNldFJlbGF0aXZlID0gZnVuY3Rpb24ocCwgcnAsIGQsIHB2LCBvcmcpIHtcbiAgICBwdiA9IHB2IHx8IHRoaXM7XG5cbiAgICBjb25zdCBycHggPSBvcmcgPyBycC54byA6IHJwLng7XG4gICAgY29uc3QgcnB5ID0gb3JnID8gcnAueW8gOiBycC55O1xuICAgIGNvbnN0IHJwZHggPSBycHggKyBkICogcHYueDtcbiAgICBjb25zdCBycGR5ID0gcnB5ICsgZCAqIHB2Lnk7XG5cbiAgICBjb25zdCBwdm5zID0gcHYubm9ybWFsU2xvcGU7XG4gICAgY29uc3QgZnZzID0gdGhpcy5zbG9wZTtcblxuICAgIGNvbnN0IHB4ID0gcC54O1xuICAgIGNvbnN0IHB5ID0gcC55O1xuXG4gICAgcC54ID0gKGZ2cyAqIHB4IC0gcHZucyAqIHJwZHggKyBycGR5IC0gcHkpIC8gKGZ2cyAtIHB2bnMpO1xuICAgIHAueSA9IGZ2cyAqIChwLnggLSBweCkgKyBweTtcbn07XG5cbi8qXG4qIFRvdWNoZXMgdGhlIHBvaW50IHAuXG4qL1xuVW5pdFZlY3Rvci5wcm90b3R5cGUudG91Y2ggPSBmdW5jdGlvbihwKSB7XG4gICAgcC54VG91Y2hlZCA9IHRydWU7XG4gICAgcC55VG91Y2hlZCA9IHRydWU7XG59O1xuXG4vKlxuKiBSZXR1cm5zIGEgdW5pdCB2ZWN0b3Igd2l0aCB4L3kgY29vcmRpbmF0ZXMuXG4qL1xuZnVuY3Rpb24gZ2V0VW5pdFZlY3Rvcih4LCB5KSB7XG4gICAgY29uc3QgZCA9IE1hdGguc3FydCh4ICogeCArIHkgKiB5KTtcblxuICAgIHggLz0gZDtcbiAgICB5IC89IGQ7XG5cbiAgICBpZiAoeCA9PT0gMSAmJiB5ID09PSAwKSByZXR1cm4geFVuaXRWZWN0b3I7XG4gICAgZWxzZSBpZiAoeCA9PT0gMCAmJiB5ID09PSAxKSByZXR1cm4geVVuaXRWZWN0b3I7XG4gICAgZWxzZSByZXR1cm4gbmV3IFVuaXRWZWN0b3IoeCwgeSk7XG59XG5cbi8qXG4qIENyZWF0ZXMgYSBwb2ludCBpbiB0aGUgaGludGluZyBlbmdpbmUuXG4qL1xuZnVuY3Rpb24gSFBvaW50KFxuICAgIHgsXG4gICAgeSxcbiAgICBsYXN0UG9pbnRPZkNvbnRvdXIsXG4gICAgb25DdXJ2ZVxuKSB7XG4gICAgdGhpcy54ID0gdGhpcy54byA9IE1hdGgucm91bmQoeCAqIDY0KSAvIDY0OyAvLyBoaW50ZWQgeCB2YWx1ZSBhbmQgb3JpZ2luYWwgeC12YWx1ZVxuICAgIHRoaXMueSA9IHRoaXMueW8gPSBNYXRoLnJvdW5kKHkgKiA2NCkgLyA2NDsgLy8gaGludGVkIHkgdmFsdWUgYW5kIG9yaWdpbmFsIHktdmFsdWVcblxuICAgIHRoaXMubGFzdFBvaW50T2ZDb250b3VyID0gbGFzdFBvaW50T2ZDb250b3VyO1xuICAgIHRoaXMub25DdXJ2ZSA9IG9uQ3VydmU7XG4gICAgdGhpcy5wcmV2UG9pbnRPbkNvbnRvdXIgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5uZXh0UG9pbnRPbkNvbnRvdXIgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy54VG91Y2hlZCA9IGZhbHNlO1xuICAgIHRoaXMueVRvdWNoZWQgPSBmYWxzZTtcblxuICAgIE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucyh0aGlzKTtcbn1cblxuLypcbiogUmV0dXJucyB0aGUgbmV4dCB0b3VjaGVkIHBvaW50IG9uIHRoZSBjb250b3VyLlxuKlxuKiB2ICAuLi4gdW5pdCB2ZWN0b3IgdG8gdGVzdCB0b3VjaCBheGlzLlxuKi9cbkhQb2ludC5wcm90b3R5cGUubmV4dFRvdWNoZWQgPSBmdW5jdGlvbih2KSB7XG4gICAgbGV0IHAgPSB0aGlzLm5leHRQb2ludE9uQ29udG91cjtcblxuICAgIHdoaWxlICghdi50b3VjaGVkKHApICYmIHAgIT09IHRoaXMpIHAgPSBwLm5leHRQb2ludE9uQ29udG91cjtcblxuICAgIHJldHVybiBwO1xufTtcblxuLypcbiogUmV0dXJucyB0aGUgcHJldmlvdXMgdG91Y2hlZCBwb2ludCBvbiB0aGUgY29udG91clxuKlxuKiB2ICAuLi4gdW5pdCB2ZWN0b3IgdG8gdGVzdCB0b3VjaCBheGlzLlxuKi9cbkhQb2ludC5wcm90b3R5cGUucHJldlRvdWNoZWQgPSBmdW5jdGlvbih2KSB7XG4gICAgbGV0IHAgPSB0aGlzLnByZXZQb2ludE9uQ29udG91cjtcblxuICAgIHdoaWxlICghdi50b3VjaGVkKHApICYmIHAgIT09IHRoaXMpIHAgPSBwLnByZXZQb2ludE9uQ29udG91cjtcblxuICAgIHJldHVybiBwO1xufTtcblxuLypcbiogVGhlIHplcm8gcG9pbnQuXG4qL1xuY29uc3QgSFBaZXJvID0gT2JqZWN0LmZyZWV6ZShuZXcgSFBvaW50KDAsIDApKTtcblxuLypcbiogVGhlIGRlZmF1bHQgc3RhdGUgb2YgdGhlIGludGVycHJldGVyLlxuKlxuKiBOb3RlOiBGcmVlemluZyB0aGUgZGVmYXVsdFN0YXRlIGFuZCB0aGVuIGRlcml2aW5nIGZyb20gaXRcbiogbWFrZXMgdGhlIFY4IEphdmFzY3JpcHQgZW5naW5lIGdvaW5nIGF3a3dhcmQsXG4qIHNvIHRoaXMgaXMgYXZvaWRlZCwgYWxiZWl0IHRoZSBkZWZhdWx0U3RhdGUgc2hvdWxkbid0XG4qIGV2ZXIgY2hhbmdlLlxuKi9cbmNvbnN0IGRlZmF1bHRTdGF0ZSA9IHtcbiAgICBjdkN1dEluOiAxNyAvIDE2LCAgICAvLyBjb250cm9sIHZhbHVlIGN1dCBpblxuICAgIGRlbHRhQmFzZTogOSxcbiAgICBkZWx0YVNoaWZ0OiAwLjEyNSxcbiAgICBsb29wOiAxLCAgICAgICAgICAgICAvLyBsb29wcyBzb21lIGluc3RydWN0aW9uc1xuICAgIG1pbkRpczogMSwgICAgICAgICAgIC8vIG1pbmltdW0gZGlzdGFuY2VcbiAgICBhdXRvRmxpcDogdHJ1ZVxufTtcblxuLypcbiogVGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlIGludGVycHJldGVyLlxuKlxuKiBlbnYgIC4uLiAnZnBnbScgb3IgJ3ByZXAnIG9yICdnbHlmJ1xuKiBwcm9nIC4uLiB0aGUgcHJvZ3JhbVxuKi9cbmZ1bmN0aW9uIFN0YXRlKGVudiwgcHJvZykge1xuICAgIHRoaXMuZW52ID0gZW52O1xuICAgIHRoaXMuc3RhY2sgPSBbXTtcbiAgICB0aGlzLnByb2cgPSBwcm9nO1xuXG4gICAgc3dpdGNoIChlbnYpIHtcbiAgICAgICAgY2FzZSAnZ2x5ZicgOlxuICAgICAgICAgICAgdGhpcy56cDAgPSB0aGlzLnpwMSA9IHRoaXMuenAyID0gMTtcbiAgICAgICAgICAgIHRoaXMucnAwID0gdGhpcy5ycDEgPSB0aGlzLnJwMiA9IDA7XG4gICAgICAgICAgICAvKiBmYWxsIHRocm91Z2ggKi9cbiAgICAgICAgY2FzZSAncHJlcCcgOlxuICAgICAgICAgICAgdGhpcy5mdiA9IHRoaXMucHYgPSB0aGlzLmRwdiA9IHhVbml0VmVjdG9yO1xuICAgICAgICAgICAgdGhpcy5yb3VuZCA9IHJvdW5kVG9HcmlkO1xuICAgIH1cbn1cblxuLypcbiogRXhlY3V0ZXMgYSBnbHlwaCBwcm9ncmFtLlxuKlxuKiBUaGlzIGRvZXMgdGhlIGhpbnRpbmcgZm9yIGVhY2ggZ2x5cGguXG4qXG4qIFJldHVybnMgYW4gYXJyYXkgb2YgbW92ZWQgcG9pbnRzLlxuKlxuKiBnbHlwaDogdGhlIGdseXBoIHRvIGhpbnRcbiogcHBlbTogdGhlIHNpemUgdGhlIGdseXBoIGlzIHJlbmRlcmVkIGZvclxuKi9cbkhpbnRpbmcucHJvdG90eXBlLmV4ZWMgPSBmdW5jdGlvbihnbHlwaCwgcHBlbSkge1xuICAgIGlmICh0eXBlb2YgcHBlbSAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQb2ludCBzaXplIGlzIG5vdCBhIG51bWJlciEnKTtcbiAgICB9XG5cbiAgICAvLyBSZWNlaXZlZCBhIGZhdGFsIGVycm9yLCBkb24ndCBkbyBhbnkgaGludGluZyBhbnltb3JlLlxuICAgIGlmICh0aGlzLl9lcnJvclN0YXRlID4gMikgcmV0dXJuO1xuXG4gICAgY29uc3QgZm9udCA9IHRoaXMuZm9udDtcbiAgICBsZXQgcHJlcFN0YXRlID0gdGhpcy5fcHJlcFN0YXRlO1xuXG4gICAgaWYgKCFwcmVwU3RhdGUgfHwgcHJlcFN0YXRlLnBwZW0gIT09IHBwZW0pIHtcbiAgICAgICAgbGV0IGZwZ21TdGF0ZSA9IHRoaXMuX2ZwZ21TdGF0ZTtcblxuICAgICAgICBpZiAoIWZwZ21TdGF0ZSkge1xuICAgICAgICAgICAgLy8gRXhlY3V0ZXMgdGhlIGZwZ20gc3RhdGUuXG4gICAgICAgICAgICAvLyBUaGlzIGlzIHVzZWQgYnkgZm9udHMgdG8gZGVmaW5lIGZ1bmN0aW9ucy5cbiAgICAgICAgICAgIFN0YXRlLnByb3RvdHlwZSA9IGRlZmF1bHRTdGF0ZTtcblxuICAgICAgICAgICAgZnBnbVN0YXRlID1cbiAgICAgICAgICAgIHRoaXMuX2ZwZ21TdGF0ZSA9XG4gICAgICAgICAgICAgICAgbmV3IFN0YXRlKCdmcGdtJywgZm9udC50YWJsZXMuZnBnbSk7XG5cbiAgICAgICAgICAgIGZwZ21TdGF0ZS5mdW5jcyA9IFsgXTtcbiAgICAgICAgICAgIGZwZ21TdGF0ZS5mb250ID0gZm9udDtcblxuICAgICAgICAgICAgaWYgKGV4cG9ydHMuREVCVUcpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnLS0tRVhFQyBGUEdNLS0tJyk7XG4gICAgICAgICAgICAgICAgZnBnbVN0YXRlLnN0ZXAgPSAtMTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBleGVjKGZwZ21TdGF0ZSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ0hpbnRpbmcgZXJyb3IgaW4gRlBHTTonICsgZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fZXJyb3JTdGF0ZSA9IDM7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gRXhlY3V0ZXMgdGhlIHByZXAgcHJvZ3JhbSBmb3IgdGhpcyBwcGVtIHNldHRpbmcuXG4gICAgICAgIC8vIFRoaXMgaXMgdXNlZCBieSBmb250cyB0byBzZXQgY3Z0IHZhbHVlc1xuICAgICAgICAvLyBkZXBlbmRpbmcgb24gdG8gYmUgcmVuZGVyZWQgZm9udCBzaXplLlxuXG4gICAgICAgIFN0YXRlLnByb3RvdHlwZSA9IGZwZ21TdGF0ZTtcbiAgICAgICAgcHJlcFN0YXRlID1cbiAgICAgICAgdGhpcy5fcHJlcFN0YXRlID1cbiAgICAgICAgICAgIG5ldyBTdGF0ZSgncHJlcCcsIGZvbnQudGFibGVzLnByZXApO1xuXG4gICAgICAgIHByZXBTdGF0ZS5wcGVtID0gcHBlbTtcblxuICAgICAgICAvLyBDcmVhdGVzIGEgY29weSBvZiB0aGUgY3Z0IHRhYmxlXG4gICAgICAgIC8vIGFuZCBzY2FsZXMgaXQgdG8gdGhlIGN1cnJlbnQgcHBlbSBzZXR0aW5nLlxuICAgICAgICBjb25zdCBvQ3Z0ID0gZm9udC50YWJsZXMuY3Z0O1xuICAgICAgICBpZiAob0N2dCkge1xuICAgICAgICAgICAgY29uc3QgY3Z0ID0gcHJlcFN0YXRlLmN2dCA9IG5ldyBBcnJheShvQ3Z0Lmxlbmd0aCk7XG4gICAgICAgICAgICBjb25zdCBzY2FsZSA9IHBwZW0gLyBmb250LnVuaXRzUGVyRW07XG4gICAgICAgICAgICBmb3IgKGxldCBjID0gMDsgYyA8IG9DdnQubGVuZ3RoOyBjKyspIHtcbiAgICAgICAgICAgICAgICBjdnRbY10gPSBvQ3Z0W2NdICogc2NhbGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwcmVwU3RhdGUuY3Z0ID0gW107XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXhwb3J0cy5ERUJVRykge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJy0tLUVYRUMgUFJFUC0tLScpO1xuICAgICAgICAgICAgcHJlcFN0YXRlLnN0ZXAgPSAtMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBleGVjKHByZXBTdGF0ZSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9lcnJvclN0YXRlIDwgMikge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdIaW50aW5nIGVycm9yIGluIFBSRVA6JyArIGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fZXJyb3JTdGF0ZSA9IDI7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5fZXJyb3JTdGF0ZSA+IDEpIHJldHVybjtcblxuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBleGVjR2x5cGgoZ2x5cGgsIHByZXBTdGF0ZSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpZiAodGhpcy5fZXJyb3JTdGF0ZSA8IDEpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdIaW50aW5nIGVycm9yOicgKyBlKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdOb3RlOiBmdXJ0aGVyIGhpbnRpbmcgZXJyb3JzIGFyZSBzaWxlbmNlZCcpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2Vycm9yU3RhdGUgPSAxO1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbn07XG5cbi8qXG4qIEV4ZWN1dGVzIHRoZSBoaW50aW5nIHByb2dyYW0gZm9yIGEgZ2x5cGguXG4qL1xuZXhlY0dseXBoID0gZnVuY3Rpb24oZ2x5cGgsIHByZXBTdGF0ZSkge1xuICAgIC8vIG9yaWdpbmFsIHBvaW50IHBvc2l0aW9uc1xuICAgIGNvbnN0IHhTY2FsZSA9IHByZXBTdGF0ZS5wcGVtIC8gcHJlcFN0YXRlLmZvbnQudW5pdHNQZXJFbTtcbiAgICBjb25zdCB5U2NhbGUgPSB4U2NhbGU7XG4gICAgbGV0IGNvbXBvbmVudHMgPSBnbHlwaC5jb21wb25lbnRzO1xuICAgIGxldCBjb250b3VycztcbiAgICBsZXQgZ1pvbmU7XG4gICAgbGV0IHN0YXRlO1xuXG4gICAgU3RhdGUucHJvdG90eXBlID0gcHJlcFN0YXRlO1xuICAgIGlmICghY29tcG9uZW50cykge1xuICAgICAgICBzdGF0ZSA9IG5ldyBTdGF0ZSgnZ2x5ZicsIGdseXBoLmluc3RydWN0aW9ucyk7XG4gICAgICAgIGlmIChleHBvcnRzLkRFQlVHKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnLS0tRVhFQyBHTFlQSC0tLScpO1xuICAgICAgICAgICAgc3RhdGUuc3RlcCA9IC0xO1xuICAgICAgICB9XG4gICAgICAgIGV4ZWNDb21wb25lbnQoZ2x5cGgsIHN0YXRlLCB4U2NhbGUsIHlTY2FsZSk7XG4gICAgICAgIGdab25lID0gc3RhdGUuZ1pvbmU7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgZm9udCA9IHByZXBTdGF0ZS5mb250O1xuICAgICAgICBnWm9uZSA9IFtdO1xuICAgICAgICBjb250b3VycyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbXBvbmVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGMgPSBjb21wb25lbnRzW2ldO1xuICAgICAgICAgICAgY29uc3QgY2cgPSBmb250LmdseXBocy5nZXQoYy5nbHlwaEluZGV4KTtcblxuICAgICAgICAgICAgc3RhdGUgPSBuZXcgU3RhdGUoJ2dseWYnLCBjZy5pbnN0cnVjdGlvbnMpO1xuXG4gICAgICAgICAgICBpZiAoZXhwb3J0cy5ERUJVRykge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCctLS1FWEVDIENPTVAgJyArIGkgKyAnLS0tJyk7XG4gICAgICAgICAgICAgICAgc3RhdGUuc3RlcCA9IC0xO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBleGVjQ29tcG9uZW50KGNnLCBzdGF0ZSwgeFNjYWxlLCB5U2NhbGUpO1xuICAgICAgICAgICAgLy8gYXBwZW5kcyB0aGUgY29tcHV0ZWQgcG9pbnRzIHRvIHRoZSByZXN1bHQgYXJyYXlcbiAgICAgICAgICAgIC8vIHBvc3QgcHJvY2Vzc2VzIHRoZSBjb21wb25lbnQgcG9pbnRzXG4gICAgICAgICAgICBjb25zdCBkeCA9IE1hdGgucm91bmQoYy5keCAqIHhTY2FsZSk7XG4gICAgICAgICAgICBjb25zdCBkeSA9IE1hdGgucm91bmQoYy5keSAqIHlTY2FsZSk7XG4gICAgICAgICAgICBjb25zdCBneiA9IHN0YXRlLmdab25lO1xuICAgICAgICAgICAgY29uc3QgY2MgPSBzdGF0ZS5jb250b3VycztcbiAgICAgICAgICAgIGZvciAobGV0IHBpID0gMDsgcGkgPCBnei5sZW5ndGg7IHBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwID0gZ3pbcGldO1xuICAgICAgICAgICAgICAgIHAueFRvdWNoZWQgPSBwLnlUb3VjaGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgcC54byA9IHAueCA9IHAueCArIGR4O1xuICAgICAgICAgICAgICAgIHAueW8gPSBwLnkgPSBwLnkgKyBkeTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgZ0xlbiA9IGdab25lLmxlbmd0aDtcbiAgICAgICAgICAgIGdab25lLnB1c2guYXBwbHkoZ1pvbmUsIGd6KTtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgY2MubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICBjb250b3Vycy5wdXNoKGNjW2pdICsgZ0xlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZ2x5cGguaW5zdHJ1Y3Rpb25zICYmICFzdGF0ZS5pbmhpYml0R3JpZEZpdCkge1xuICAgICAgICAgICAgLy8gdGhlIGNvbXBvc2l0ZSBoYXMgaW5zdHJ1Y3Rpb25zIG9uIGl0cyBvd25cbiAgICAgICAgICAgIHN0YXRlID0gbmV3IFN0YXRlKCdnbHlmJywgZ2x5cGguaW5zdHJ1Y3Rpb25zKTtcblxuICAgICAgICAgICAgc3RhdGUuZ1pvbmUgPSBzdGF0ZS56MCA9IHN0YXRlLnoxID0gc3RhdGUuejIgPSBnWm9uZTtcblxuICAgICAgICAgICAgc3RhdGUuY29udG91cnMgPSBjb250b3VycztcblxuICAgICAgICAgICAgLy8gbm90ZTogSFBaZXJvIGNhbm5vdCBiZSB1c2VkIGhlcmUsIHNpbmNlXG4gICAgICAgICAgICAvLyAgICAgICB0aGUgcG9pbnQgbWlnaHQgYmUgbW9kaWZpZWRcbiAgICAgICAgICAgIGdab25lLnB1c2goXG4gICAgICAgICAgICAgICAgbmV3IEhQb2ludCgwLCAwKSxcbiAgICAgICAgICAgICAgICBuZXcgSFBvaW50KE1hdGgucm91bmQoZ2x5cGguYWR2YW5jZVdpZHRoICogeFNjYWxlKSwgMClcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIGlmIChleHBvcnRzLkRFQlVHKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJy0tLUVYRUMgQ09NUE9TSVRFLS0tJyk7XG4gICAgICAgICAgICAgICAgc3RhdGUuc3RlcCA9IC0xO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBleGVjKHN0YXRlKTtcblxuICAgICAgICAgICAgZ1pvbmUubGVuZ3RoIC09IDI7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZ1pvbmU7XG59O1xuXG4vKlxuKiBFeGVjdXRlcyB0aGUgaGludGluZyBwcm9ncmFtIGZvciBhIGNvbXBvbmVudCBvZiBhIG11bHRpLWNvbXBvbmVudCBnbHlwaFxuKiBvciBvZiB0aGUgZ2x5cGggaXRzZWxmIGJ5IGEgbm9uLWNvbXBvbmVudCBnbHlwaC5cbiovXG5leGVjQ29tcG9uZW50ID0gZnVuY3Rpb24oZ2x5cGgsIHN0YXRlLCB4U2NhbGUsIHlTY2FsZSlcbntcbiAgICBjb25zdCBwb2ludHMgPSBnbHlwaC5wb2ludHMgfHwgW107XG4gICAgY29uc3QgcExlbiA9IHBvaW50cy5sZW5ndGg7XG4gICAgY29uc3QgZ1pvbmUgPSBzdGF0ZS5nWm9uZSA9IHN0YXRlLnowID0gc3RhdGUuejEgPSBzdGF0ZS56MiA9IFtdO1xuICAgIGNvbnN0IGNvbnRvdXJzID0gc3RhdGUuY29udG91cnMgPSBbXTtcblxuICAgIC8vIFNjYWxlcyB0aGUgb3JpZ2luYWwgcG9pbnRzIGFuZFxuICAgIC8vIG1ha2VzIGNvcGllcyBmb3IgdGhlIGhpbnRlZCBwb2ludHMuXG4gICAgbGV0IGNwOyAvLyBjdXJyZW50IHBvaW50XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwTGVuOyBpKyspIHtcbiAgICAgICAgY3AgPSBwb2ludHNbaV07XG5cbiAgICAgICAgZ1pvbmVbaV0gPSBuZXcgSFBvaW50KFxuICAgICAgICAgICAgY3AueCAqIHhTY2FsZSxcbiAgICAgICAgICAgIGNwLnkgKiB5U2NhbGUsXG4gICAgICAgICAgICBjcC5sYXN0UG9pbnRPZkNvbnRvdXIsXG4gICAgICAgICAgICBjcC5vbkN1cnZlXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gQ2hhaW4gbGlua3MgdGhlIGNvbnRvdXJzLlxuICAgIGxldCBzcDsgLy8gc3RhcnQgcG9pbnRcbiAgICBsZXQgbnA7IC8vIG5leHQgcG9pbnRcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcExlbjsgaSsrKSB7XG4gICAgICAgIGNwID0gZ1pvbmVbaV07XG5cbiAgICAgICAgaWYgKCFzcCkge1xuICAgICAgICAgICAgc3AgPSBjcDtcbiAgICAgICAgICAgIGNvbnRvdXJzLnB1c2goaSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY3AubGFzdFBvaW50T2ZDb250b3VyKSB7XG4gICAgICAgICAgICBjcC5uZXh0UG9pbnRPbkNvbnRvdXIgPSBzcDtcbiAgICAgICAgICAgIHNwLnByZXZQb2ludE9uQ29udG91ciA9IGNwO1xuICAgICAgICAgICAgc3AgPSB1bmRlZmluZWQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBucCA9IGdab25lW2kgKyAxXTtcbiAgICAgICAgICAgIGNwLm5leHRQb2ludE9uQ29udG91ciA9IG5wO1xuICAgICAgICAgICAgbnAucHJldlBvaW50T25Db250b3VyID0gY3A7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc3RhdGUuaW5oaWJpdEdyaWRGaXQpIHJldHVybjtcblxuICAgIGdab25lLnB1c2goXG4gICAgICAgIG5ldyBIUG9pbnQoMCwgMCksXG4gICAgICAgIG5ldyBIUG9pbnQoTWF0aC5yb3VuZChnbHlwaC5hZHZhbmNlV2lkdGggKiB4U2NhbGUpLCAwKVxuICAgICk7XG5cbiAgICBleGVjKHN0YXRlKTtcblxuICAgIC8vIFJlbW92ZXMgdGhlIGV4dHJhIHBvaW50cy5cbiAgICBnWm9uZS5sZW5ndGggLT0gMjtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdGSU5JU0hFRCBHTFlQSCcsIHN0YXRlLnN0YWNrKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwTGVuOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGksIGdab25lW2ldLngsIGdab25lW2ldLnkpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuLypcbiogRXhlY3V0ZXMgdGhlIHByb2dyYW0gbG9hZGVkIGluIHN0YXRlLlxuKi9cbmV4ZWMgPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIGxldCBwcm9nID0gc3RhdGUucHJvZztcblxuICAgIGlmICghcHJvZykgcmV0dXJuO1xuXG4gICAgY29uc3QgcExlbiA9IHByb2cubGVuZ3RoO1xuICAgIGxldCBpbnM7XG5cbiAgICBmb3IgKHN0YXRlLmlwID0gMDsgc3RhdGUuaXAgPCBwTGVuOyBzdGF0ZS5pcCsrKSB7XG4gICAgICAgIGlmIChleHBvcnRzLkRFQlVHKSBzdGF0ZS5zdGVwKys7XG4gICAgICAgIGlucyA9IGluc3RydWN0aW9uVGFibGVbcHJvZ1tzdGF0ZS5pcF1dO1xuXG4gICAgICAgIGlmICghaW5zKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgJ3Vua25vd24gaW5zdHJ1Y3Rpb246IDB4JyArXG4gICAgICAgICAgICAgICAgTnVtYmVyKHByb2dbc3RhdGUuaXBdKS50b1N0cmluZygxNilcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICBpbnMoc3RhdGUpO1xuXG4gICAgICAgIC8vIHZlcnkgZXh0ZW5zaXZlIGRlYnVnZ2luZyBmb3IgZWFjaCBzdGVwXG4gICAgICAgIC8qXG4gICAgICAgIGlmIChleHBvcnRzLkRFQlVHKSB7XG4gICAgICAgICAgICB2YXIgZGE7XG4gICAgICAgICAgICBpZiAoc3RhdGUuZ1pvbmUpIHtcbiAgICAgICAgICAgICAgICBkYSA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RhdGUuZ1pvbmUubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBkYS5wdXNoKGkgKyAnICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUuZ1pvbmVbaV0ueCAqIDY0ICsgJyAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLmdab25lW2ldLnkgKiA2NCArICcgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAoc3RhdGUuZ1pvbmVbaV0ueFRvdWNoZWQgPyAneCcgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgICAgICAgKHN0YXRlLmdab25lW2ldLnlUb3VjaGVkID8gJ3knIDogJycpXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdHWicsIGRhKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHN0YXRlLnRab25lKSB7XG4gICAgICAgICAgICAgICAgZGEgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0YXRlLnRab25lLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhLnB1c2goaSArICcgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS50Wm9uZVtpXS54ICogNjQgKyAnICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUudFpvbmVbaV0ueSAqIDY0ICsgJyAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgIChzdGF0ZS50Wm9uZVtpXS54VG91Y2hlZCA/ICd4JyA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAoc3RhdGUudFpvbmVbaV0ueVRvdWNoZWQgPyAneScgOiAnJylcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1RaJywgZGEpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoc3RhdGUuc3RhY2subGVuZ3RoID4gMTApIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUuc3RhY2subGVuZ3RoLFxuICAgICAgICAgICAgICAgICAgICAnLi4uJywgc3RhdGUuc3RhY2suc2xpY2Uoc3RhdGUuc3RhY2subGVuZ3RoIC0gMTApXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coc3RhdGUuc3RhY2subGVuZ3RoLCBzdGF0ZS5zdGFjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgKi9cbiAgICB9XG59O1xuXG4vKlxuKiBJbml0aWFsaXplcyB0aGUgdHdpbGlnaHQgem9uZS5cbipcbiogVGhpcyBpcyBvbmx5IGRvbmUgaWYgYSBTWlB4IGluc3RydWN0aW9uXG4qIHJlZmVycyB0byB0aGUgdHdpbGlnaHQgem9uZS5cbiovXG5mdW5jdGlvbiBpbml0VFpvbmUoc3RhdGUpXG57XG4gICAgY29uc3QgdFpvbmUgPSBzdGF0ZS50Wm9uZSA9IG5ldyBBcnJheShzdGF0ZS5nWm9uZS5sZW5ndGgpO1xuXG4gICAgLy8gbm8gaWRlYSBpZiB0aGlzIGlzIGFjdHVhbGx5IGNvcnJlY3QuLi5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRab25lLmxlbmd0aDsgaSsrKVxuICAgIHtcbiAgICAgICAgdFpvbmVbaV0gPSBuZXcgSFBvaW50KDAsIDApO1xuICAgIH1cbn1cblxuLypcbiogU2tpcHMgdGhlIGluc3RydWN0aW9uIHBvaW50ZXIgYWhlYWQgb3ZlciBhbiBJRi9FTFNFIGJsb2NrLlxuKiBoYW5kbGVFbHNlIC4uIGlmIHRydWUgYnJlYWtzIG9uIG1hdGNoaW5nIEVMU0VcbiovXG5mdW5jdGlvbiBza2lwKHN0YXRlLCBoYW5kbGVFbHNlKVxue1xuICAgIGNvbnN0IHByb2cgPSBzdGF0ZS5wcm9nO1xuICAgIGxldCBpcCA9IHN0YXRlLmlwO1xuICAgIGxldCBuZXN0aW5nID0gMTtcbiAgICBsZXQgaW5zO1xuXG4gICAgZG8ge1xuICAgICAgICBpbnMgPSBwcm9nWysraXBdO1xuICAgICAgICBpZiAoaW5zID09PSAweDU4KSAvLyBJRlxuICAgICAgICAgICAgbmVzdGluZysrO1xuICAgICAgICBlbHNlIGlmIChpbnMgPT09IDB4NTkpIC8vIEVJRlxuICAgICAgICAgICAgbmVzdGluZy0tO1xuICAgICAgICBlbHNlIGlmIChpbnMgPT09IDB4NDApIC8vIE5QVVNIQlxuICAgICAgICAgICAgaXAgKz0gcHJvZ1tpcCArIDFdICsgMTtcbiAgICAgICAgZWxzZSBpZiAoaW5zID09PSAweDQxKSAvLyBOUFVTSFdcbiAgICAgICAgICAgIGlwICs9IDIgKiBwcm9nW2lwICsgMV0gKyAxO1xuICAgICAgICBlbHNlIGlmIChpbnMgPj0gMHhCMCAmJiBpbnMgPD0gMHhCNykgLy8gUFVTSEJcbiAgICAgICAgICAgIGlwICs9IGlucyAtIDB4QjAgKyAxO1xuICAgICAgICBlbHNlIGlmIChpbnMgPj0gMHhCOCAmJiBpbnMgPD0gMHhCRikgLy8gUFVTSFdcbiAgICAgICAgICAgIGlwICs9IChpbnMgLSAweEI4ICsgMSkgKiAyO1xuICAgICAgICBlbHNlIGlmIChoYW5kbGVFbHNlICYmIG5lc3RpbmcgPT09IDEgJiYgaW5zID09PSAweDFCKSAvLyBFTFNFXG4gICAgICAgICAgICBicmVhaztcbiAgICB9IHdoaWxlIChuZXN0aW5nID4gMCk7XG5cbiAgICBzdGF0ZS5pcCA9IGlwO1xufVxuXG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qXG4qICAgICAgICAgIEFuZCB0aGVuIGEgbG90IG9mIGluc3RydWN0aW9ucy4uLiAgICAgICAgICAgICAgICAqXG4qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbi8vIFNWVENBW2FdIFNldCBmcmVlZG9tIGFuZCBwcm9qZWN0aW9uIFZlY3RvcnMgVG8gQ29vcmRpbmF0ZSBBeGlzXG4vLyAweDAwLTB4MDFcbmZ1bmN0aW9uIFNWVENBKHYsIHN0YXRlKSB7XG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdTVlRDQVsnICsgdi5heGlzICsgJ10nKTtcblxuICAgIHN0YXRlLmZ2ID0gc3RhdGUucHYgPSBzdGF0ZS5kcHYgPSB2O1xufVxuXG4vLyBTUFZUQ0FbYV0gU2V0IFByb2plY3Rpb24gVmVjdG9yIHRvIENvb3JkaW5hdGUgQXhpc1xuLy8gMHgwMi0weDAzXG5mdW5jdGlvbiBTUFZUQ0Eodiwgc3RhdGUpIHtcbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ1NQVlRDQVsnICsgdi5heGlzICsgJ10nKTtcblxuICAgIHN0YXRlLnB2ID0gc3RhdGUuZHB2ID0gdjtcbn1cblxuLy8gU0ZWVENBW2FdIFNldCBGcmVlZG9tIFZlY3RvciB0byBDb29yZGluYXRlIEF4aXNcbi8vIDB4MDQtMHgwNVxuZnVuY3Rpb24gU0ZWVENBKHYsIHN0YXRlKSB7XG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdTRlZUQ0FbJyArIHYuYXhpcyArICddJyk7XG5cbiAgICBzdGF0ZS5mdiA9IHY7XG59XG5cbi8vIFNQVlRMW2FdIFNldCBQcm9qZWN0aW9uIFZlY3RvciBUbyBMaW5lXG4vLyAweDA2LTB4MDdcbmZ1bmN0aW9uIFNQVlRMKGEsIHN0YXRlKSB7XG4gICAgY29uc3Qgc3RhY2sgPSBzdGF0ZS5zdGFjaztcbiAgICBjb25zdCBwMmkgPSBzdGFjay5wb3AoKTtcbiAgICBjb25zdCBwMWkgPSBzdGFjay5wb3AoKTtcbiAgICBjb25zdCBwMiA9IHN0YXRlLnoyW3AyaV07XG4gICAgY29uc3QgcDEgPSBzdGF0ZS56MVtwMWldO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIGNvbnNvbGUubG9nKCdTUFZUTFsnICsgYSArICddJywgcDJpLCBwMWkpO1xuXG4gICAgbGV0IGR4O1xuICAgIGxldCBkeTtcblxuICAgIGlmICghYSkge1xuICAgICAgICBkeCA9IHAxLnggLSBwMi54O1xuICAgICAgICBkeSA9IHAxLnkgLSBwMi55O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGR4ID0gcDIueSAtIHAxLnk7XG4gICAgICAgIGR5ID0gcDEueCAtIHAyLng7XG4gICAgfVxuXG4gICAgc3RhdGUucHYgPSBzdGF0ZS5kcHYgPSBnZXRVbml0VmVjdG9yKGR4LCBkeSk7XG59XG5cbi8vIFNGVlRMW2FdIFNldCBGcmVlZG9tIFZlY3RvciBUbyBMaW5lXG4vLyAweDA4LTB4MDlcbmZ1bmN0aW9uIFNGVlRMKGEsIHN0YXRlKSB7XG4gICAgY29uc3Qgc3RhY2sgPSBzdGF0ZS5zdGFjaztcbiAgICBjb25zdCBwMmkgPSBzdGFjay5wb3AoKTtcbiAgICBjb25zdCBwMWkgPSBzdGFjay5wb3AoKTtcbiAgICBjb25zdCBwMiA9IHN0YXRlLnoyW3AyaV07XG4gICAgY29uc3QgcDEgPSBzdGF0ZS56MVtwMWldO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIGNvbnNvbGUubG9nKCdTRlZUTFsnICsgYSArICddJywgcDJpLCBwMWkpO1xuXG4gICAgbGV0IGR4O1xuICAgIGxldCBkeTtcblxuICAgIGlmICghYSkge1xuICAgICAgICBkeCA9IHAxLnggLSBwMi54O1xuICAgICAgICBkeSA9IHAxLnkgLSBwMi55O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGR4ID0gcDIueSAtIHAxLnk7XG4gICAgICAgIGR5ID0gcDEueCAtIHAyLng7XG4gICAgfVxuXG4gICAgc3RhdGUuZnYgPSBnZXRVbml0VmVjdG9yKGR4LCBkeSk7XG59XG5cbi8vIFNQVkZTW10gU2V0IFByb2plY3Rpb24gVmVjdG9yIEZyb20gU3RhY2tcbi8vIDB4MEFcbmZ1bmN0aW9uIFNQVkZTKHN0YXRlKSB7XG4gICAgY29uc3Qgc3RhY2sgPSBzdGF0ZS5zdGFjaztcbiAgICBjb25zdCB5ID0gc3RhY2sucG9wKCk7XG4gICAgY29uc3QgeCA9IHN0YWNrLnBvcCgpO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdTUFZGU1tdJywgeSwgeCk7XG5cbiAgICBzdGF0ZS5wdiA9IHN0YXRlLmRwdiA9IGdldFVuaXRWZWN0b3IoeCwgeSk7XG59XG5cbi8vIFNGVkZTW10gU2V0IEZyZWVkb20gVmVjdG9yIEZyb20gU3RhY2tcbi8vIDB4MEJcbmZ1bmN0aW9uIFNGVkZTKHN0YXRlKSB7XG4gICAgY29uc3Qgc3RhY2sgPSBzdGF0ZS5zdGFjaztcbiAgICBjb25zdCB5ID0gc3RhY2sucG9wKCk7XG4gICAgY29uc3QgeCA9IHN0YWNrLnBvcCgpO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdTUFZGU1tdJywgeSwgeCk7XG5cbiAgICBzdGF0ZS5mdiA9IGdldFVuaXRWZWN0b3IoeCwgeSk7XG59XG5cbi8vIEdQVltdIEdldCBQcm9qZWN0aW9uIFZlY3RvclxuLy8gMHgwQ1xuZnVuY3Rpb24gR1BWKHN0YXRlKSB7XG4gICAgY29uc3Qgc3RhY2sgPSBzdGF0ZS5zdGFjaztcbiAgICBjb25zdCBwdiA9IHN0YXRlLnB2O1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdHUFZbXScpO1xuXG4gICAgc3RhY2sucHVzaChwdi54ICogMHg0MDAwKTtcbiAgICBzdGFjay5wdXNoKHB2LnkgKiAweDQwMDApO1xufVxuXG4vLyBHRlZbXSBHZXQgRnJlZWRvbSBWZWN0b3Jcbi8vIDB4MENcbmZ1bmN0aW9uIEdGVihzdGF0ZSkge1xuICAgIGNvbnN0IHN0YWNrID0gc3RhdGUuc3RhY2s7XG4gICAgY29uc3QgZnYgPSBzdGF0ZS5mdjtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnR0ZWW10nKTtcblxuICAgIHN0YWNrLnB1c2goZnYueCAqIDB4NDAwMCk7XG4gICAgc3RhY2sucHVzaChmdi55ICogMHg0MDAwKTtcbn1cblxuLy8gU0ZWVFBWW10gU2V0IEZyZWVkb20gVmVjdG9yIFRvIFByb2plY3Rpb24gVmVjdG9yXG4vLyAweDBFXG5mdW5jdGlvbiBTRlZUUFYoc3RhdGUpIHtcbiAgICBzdGF0ZS5mdiA9IHN0YXRlLnB2O1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdTRlZUUFZbXScpO1xufVxuXG4vLyBJU0VDVFtdIG1vdmVzIHBvaW50IHAgdG8gdGhlIEludGVyU0VDVGlvbiBvZiB0d28gbGluZXNcbi8vIDB4MEZcbmZ1bmN0aW9uIElTRUNUKHN0YXRlKVxue1xuICAgIGNvbnN0IHN0YWNrID0gc3RhdGUuc3RhY2s7XG4gICAgY29uc3QgcGEwaSA9IHN0YWNrLnBvcCgpO1xuICAgIGNvbnN0IHBhMWkgPSBzdGFjay5wb3AoKTtcbiAgICBjb25zdCBwYjBpID0gc3RhY2sucG9wKCk7XG4gICAgY29uc3QgcGIxaSA9IHN0YWNrLnBvcCgpO1xuICAgIGNvbnN0IHBpID0gc3RhY2sucG9wKCk7XG4gICAgY29uc3QgejAgPSBzdGF0ZS56MDtcbiAgICBjb25zdCB6MSA9IHN0YXRlLnoxO1xuICAgIGNvbnN0IHBhMCA9IHowW3BhMGldO1xuICAgIGNvbnN0IHBhMSA9IHowW3BhMWldO1xuICAgIGNvbnN0IHBiMCA9IHoxW3BiMGldO1xuICAgIGNvbnN0IHBiMSA9IHoxW3BiMWldO1xuICAgIGNvbnN0IHAgPSBzdGF0ZS56MltwaV07XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgY29uc29sZS5sb2coJ0lTRUNUW10sICcsIHBhMGksIHBhMWksIHBiMGksIHBiMWksIHBpKTtcblxuICAgIC8vIG1hdGggZnJvbVxuICAgIC8vIGVuLndpa2lwZWRpYS5vcmcvd2lraS9MaW5lJUUyJTgwJTkzbGluZV9pbnRlcnNlY3Rpb24jR2l2ZW5fdHdvX3BvaW50c19vbl9lYWNoX2xpbmVcblxuICAgIGNvbnN0IHgxID0gcGEwLng7XG4gICAgY29uc3QgeTEgPSBwYTAueTtcbiAgICBjb25zdCB4MiA9IHBhMS54O1xuICAgIGNvbnN0IHkyID0gcGExLnk7XG4gICAgY29uc3QgeDMgPSBwYjAueDtcbiAgICBjb25zdCB5MyA9IHBiMC55O1xuICAgIGNvbnN0IHg0ID0gcGIxLng7XG4gICAgY29uc3QgeTQgPSBwYjEueTtcblxuICAgIGNvbnN0IGRpdiA9ICh4MSAtIHgyKSAqICh5MyAtIHk0KSAtICh5MSAtIHkyKSAqICh4MyAtIHg0KTtcbiAgICBjb25zdCBmMSA9IHgxICogeTIgLSB5MSAqIHgyO1xuICAgIGNvbnN0IGYyID0geDMgKiB5NCAtIHkzICogeDQ7XG5cbiAgICBwLnggPSAoZjEgKiAoeDMgLSB4NCkgLSBmMiAqICh4MSAtIHgyKSkgLyBkaXY7XG4gICAgcC55ID0gKGYxICogKHkzIC0geTQpIC0gZjIgKiAoeTEgLSB5MikpIC8gZGl2O1xufVxuXG4vLyBTUlAwW10gU2V0IFJlZmVyZW5jZSBQb2ludCAwXG4vLyAweDEwXG5mdW5jdGlvbiBTUlAwKHN0YXRlKSB7XG4gICAgc3RhdGUucnAwID0gc3RhdGUuc3RhY2sucG9wKCk7XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ1NSUDBbXScsIHN0YXRlLnJwMCk7XG59XG5cbi8vIFNSUDFbXSBTZXQgUmVmZXJlbmNlIFBvaW50IDFcbi8vIDB4MTFcbmZ1bmN0aW9uIFNSUDEoc3RhdGUpIHtcbiAgICBzdGF0ZS5ycDEgPSBzdGF0ZS5zdGFjay5wb3AoKTtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnU1JQMVtdJywgc3RhdGUucnAxKTtcbn1cblxuLy8gU1JQMVtdIFNldCBSZWZlcmVuY2UgUG9pbnQgMlxuLy8gMHgxMlxuZnVuY3Rpb24gU1JQMihzdGF0ZSkge1xuICAgIHN0YXRlLnJwMiA9IHN0YXRlLnN0YWNrLnBvcCgpO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdTUlAyW10nLCBzdGF0ZS5ycDIpO1xufVxuXG4vLyBTWlAwW10gU2V0IFpvbmUgUG9pbnRlciAwXG4vLyAweDEzXG5mdW5jdGlvbiBTWlAwKHN0YXRlKSB7XG4gICAgY29uc3QgbiA9IHN0YXRlLnN0YWNrLnBvcCgpO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdTWlAwW10nLCBuKTtcblxuICAgIHN0YXRlLnpwMCA9IG47XG5cbiAgICBzd2l0Y2ggKG4pIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgaWYgKCFzdGF0ZS50Wm9uZSkgaW5pdFRab25lKHN0YXRlKTtcbiAgICAgICAgICAgIHN0YXRlLnowID0gc3RhdGUudFpvbmU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxIDpcbiAgICAgICAgICAgIHN0YXRlLnowID0gc3RhdGUuZ1pvbmU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdCA6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgem9uZSBwb2ludGVyJyk7XG4gICAgfVxufVxuXG4vLyBTWlAxW10gU2V0IFpvbmUgUG9pbnRlciAxXG4vLyAweDE0XG5mdW5jdGlvbiBTWlAxKHN0YXRlKSB7XG4gICAgY29uc3QgbiA9IHN0YXRlLnN0YWNrLnBvcCgpO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdTWlAxW10nLCBuKTtcblxuICAgIHN0YXRlLnpwMSA9IG47XG5cbiAgICBzd2l0Y2ggKG4pIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgaWYgKCFzdGF0ZS50Wm9uZSkgaW5pdFRab25lKHN0YXRlKTtcbiAgICAgICAgICAgIHN0YXRlLnoxID0gc3RhdGUudFpvbmU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxIDpcbiAgICAgICAgICAgIHN0YXRlLnoxID0gc3RhdGUuZ1pvbmU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdCA6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgem9uZSBwb2ludGVyJyk7XG4gICAgfVxufVxuXG4vLyBTWlAyW10gU2V0IFpvbmUgUG9pbnRlciAyXG4vLyAweDE1XG5mdW5jdGlvbiBTWlAyKHN0YXRlKSB7XG4gICAgY29uc3QgbiA9IHN0YXRlLnN0YWNrLnBvcCgpO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdTWlAyW10nLCBuKTtcblxuICAgIHN0YXRlLnpwMiA9IG47XG5cbiAgICBzd2l0Y2ggKG4pIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgaWYgKCFzdGF0ZS50Wm9uZSkgaW5pdFRab25lKHN0YXRlKTtcbiAgICAgICAgICAgIHN0YXRlLnoyID0gc3RhdGUudFpvbmU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxIDpcbiAgICAgICAgICAgIHN0YXRlLnoyID0gc3RhdGUuZ1pvbmU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdCA6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgem9uZSBwb2ludGVyJyk7XG4gICAgfVxufVxuXG4vLyBTWlBTW10gU2V0IFpvbmUgUG9pbnRlclNcbi8vIDB4MTZcbmZ1bmN0aW9uIFNaUFMoc3RhdGUpIHtcbiAgICBjb25zdCBuID0gc3RhdGUuc3RhY2sucG9wKCk7XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ1NaUFNbXScsIG4pO1xuXG4gICAgc3RhdGUuenAwID0gc3RhdGUuenAxID0gc3RhdGUuenAyID0gbjtcblxuICAgIHN3aXRjaCAobikge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBpZiAoIXN0YXRlLnRab25lKSBpbml0VFpvbmUoc3RhdGUpO1xuICAgICAgICAgICAgc3RhdGUuejAgPSBzdGF0ZS56MSA9IHN0YXRlLnoyID0gc3RhdGUudFpvbmU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxIDpcbiAgICAgICAgICAgIHN0YXRlLnowID0gc3RhdGUuejEgPSBzdGF0ZS56MiA9IHN0YXRlLmdab25lO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQgOlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHpvbmUgcG9pbnRlcicpO1xuICAgIH1cbn1cblxuLy8gU0xPT1BbXSBTZXQgTE9PUCB2YXJpYWJsZVxuLy8gMHgxN1xuZnVuY3Rpb24gU0xPT1Aoc3RhdGUpIHtcbiAgICBzdGF0ZS5sb29wID0gc3RhdGUuc3RhY2sucG9wKCk7XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ1NMT09QW10nLCBzdGF0ZS5sb29wKTtcbn1cblxuLy8gUlRHW10gUm91bmQgVG8gR3JpZFxuLy8gMHgxOFxuZnVuY3Rpb24gUlRHKHN0YXRlKSB7XG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdSVEdbXScpO1xuXG4gICAgc3RhdGUucm91bmQgPSByb3VuZFRvR3JpZDtcbn1cblxuLy8gUlRIR1tdIFJvdW5kIFRvIEhhbGYgR3JpZFxuLy8gMHgxOVxuZnVuY3Rpb24gUlRIRyhzdGF0ZSkge1xuICAgIGlmIChleHBvcnRzLkRFQlVHKSBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnUlRIR1tdJyk7XG5cbiAgICBzdGF0ZS5yb3VuZCA9IHJvdW5kVG9IYWxmR3JpZDtcbn1cblxuLy8gU01EW10gU2V0IE1pbmltdW0gRGlzdGFuY2Vcbi8vIDB4MUFcbmZ1bmN0aW9uIFNNRChzdGF0ZSkge1xuICAgIGNvbnN0IGQgPSBzdGF0ZS5zdGFjay5wb3AoKTtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnU01EW10nLCBkKTtcblxuICAgIHN0YXRlLm1pbkRpcyA9IGQgLyAweDQwO1xufVxuXG4vLyBFTFNFW10gRUxTRSBjbGF1c2Vcbi8vIDB4MUJcbmZ1bmN0aW9uIEVMU0Uoc3RhdGUpIHtcbiAgICAvLyBUaGlzIGluc3RydWN0aW9uIGhhcyBiZWVuIHJlYWNoZWQgYnkgZXhlY3V0aW5nIGEgdGhlbiBicmFuY2hcbiAgICAvLyBzbyBpdCBqdXN0IHNraXBzIGFoZWFkIHVudGlsIG1hdGNoaW5nIEVJRi5cbiAgICAvL1xuICAgIC8vIEluIGNhc2UgdGhlIElGIHdhcyBuZWdhdGl2ZSB0aGUgSUZbXSBpbnN0cnVjdGlvbiBhbHJlYWR5XG4gICAgLy8gc2tpcHBlZCBmb3J3YXJkIG92ZXIgdGhlIEVMU0VbXVxuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdFTFNFW10nKTtcblxuICAgIHNraXAoc3RhdGUsIGZhbHNlKTtcbn1cblxuLy8gSk1QUltdIEp1TVAgUmVsYXRpdmVcbi8vIDB4MUNcbmZ1bmN0aW9uIEpNUFIoc3RhdGUpIHtcbiAgICBjb25zdCBvID0gc3RhdGUuc3RhY2sucG9wKCk7XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ0pNUFJbXScsIG8pO1xuXG4gICAgLy8gQSBqdW1wIGJ5IDEgd291bGQgZG8gbm90aGluZy5cbiAgICBzdGF0ZS5pcCArPSBvIC0gMTtcbn1cblxuLy8gU0NWVENJW10gU2V0IENvbnRyb2wgVmFsdWUgVGFibGUgQ3V0LUluXG4vLyAweDFEXG5mdW5jdGlvbiBTQ1ZUQ0koc3RhdGUpIHtcbiAgICBjb25zdCBuID0gc3RhdGUuc3RhY2sucG9wKCk7XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ1NDVlRDSVtdJywgbik7XG5cbiAgICBzdGF0ZS5jdkN1dEluID0gbiAvIDB4NDA7XG59XG5cbi8vIERVUFtdIERVUGxpY2F0ZSB0b3Agc3RhY2sgZWxlbWVudFxuLy8gMHgyMFxuZnVuY3Rpb24gRFVQKHN0YXRlKSB7XG4gICAgY29uc3Qgc3RhY2sgPSBzdGF0ZS5zdGFjaztcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnRFVQW10nKTtcblxuICAgIHN0YWNrLnB1c2goc3RhY2tbc3RhY2subGVuZ3RoIC0gMV0pO1xufVxuXG4vLyBQT1BbXSBQT1AgdG9wIHN0YWNrIGVsZW1lbnRcbi8vIDB4MjFcbmZ1bmN0aW9uIFBPUChzdGF0ZSkge1xuICAgIGlmIChleHBvcnRzLkRFQlVHKSBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnUE9QW10nKTtcblxuICAgIHN0YXRlLnN0YWNrLnBvcCgpO1xufVxuXG4vLyBDTEVBUltdIENMRUFSIHRoZSBzdGFja1xuLy8gMHgyMlxuZnVuY3Rpb24gQ0xFQVIoc3RhdGUpIHtcbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ0NMRUFSW10nKTtcblxuICAgIHN0YXRlLnN0YWNrLmxlbmd0aCA9IDA7XG59XG5cbi8vIFNXQVBbXSBTV0FQIHRoZSB0b3AgdHdvIGVsZW1lbnRzIG9uIHRoZSBzdGFja1xuLy8gMHgyM1xuZnVuY3Rpb24gU1dBUChzdGF0ZSkge1xuICAgIGNvbnN0IHN0YWNrID0gc3RhdGUuc3RhY2s7XG5cbiAgICBjb25zdCBhID0gc3RhY2sucG9wKCk7XG4gICAgY29uc3QgYiA9IHN0YWNrLnBvcCgpO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdTV0FQW10nKTtcblxuICAgIHN0YWNrLnB1c2goYSk7XG4gICAgc3RhY2sucHVzaChiKTtcbn1cblxuLy8gREVQVEhbXSBERVBUSCBvZiB0aGUgc3RhY2tcbi8vIDB4MjRcbmZ1bmN0aW9uIERFUFRIKHN0YXRlKSB7XG4gICAgY29uc3Qgc3RhY2sgPSBzdGF0ZS5zdGFjaztcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnREVQVEhbXScpO1xuXG4gICAgc3RhY2sucHVzaChzdGFjay5sZW5ndGgpO1xufVxuXG4vLyBMT09QQ0FMTFtdIExPT1BDQUxMIGZ1bmN0aW9uXG4vLyAweDJBXG5mdW5jdGlvbiBMT09QQ0FMTChzdGF0ZSkge1xuICAgIGNvbnN0IHN0YWNrID0gc3RhdGUuc3RhY2s7XG4gICAgY29uc3QgZm4gPSBzdGFjay5wb3AoKTtcbiAgICBjb25zdCBjID0gc3RhY2sucG9wKCk7XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ0xPT1BDQUxMW10nLCBmbiwgYyk7XG5cbiAgICAvLyBzYXZlcyBjYWxsZXJzIHByb2dyYW1cbiAgICBjb25zdCBjaXAgPSBzdGF0ZS5pcDtcbiAgICBjb25zdCBjcHJvZyA9IHN0YXRlLnByb2c7XG5cbiAgICBzdGF0ZS5wcm9nID0gc3RhdGUuZnVuY3NbZm5dO1xuXG4gICAgLy8gZXhlY3V0ZXMgdGhlIGZ1bmN0aW9uXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjOyBpKyspIHtcbiAgICAgICAgZXhlYyhzdGF0ZSk7XG5cbiAgICAgICAgaWYgKGV4cG9ydHMuREVCVUcpIGNvbnNvbGUubG9nKFxuICAgICAgICAgICAgKytzdGF0ZS5zdGVwLFxuICAgICAgICAgICAgaSArIDEgPCBjID8gJ25leHQgbG9vcGNhbGwnIDogJ2RvbmUgbG9vcGNhbGwnLFxuICAgICAgICAgICAgaVxuICAgICAgICApO1xuICAgIH1cblxuICAgIC8vIHJlc3RvcmVzIHRoZSBjYWxsZXJzIHByb2dyYW1cbiAgICBzdGF0ZS5pcCA9IGNpcDtcbiAgICBzdGF0ZS5wcm9nID0gY3Byb2c7XG59XG5cbi8vIENBTExbXSBDQUxMIGZ1bmN0aW9uXG4vLyAweDJCXG5mdW5jdGlvbiBDQUxMKHN0YXRlKSB7XG4gICAgY29uc3QgZm4gPSBzdGF0ZS5zdGFjay5wb3AoKTtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnQ0FMTFtdJywgZm4pO1xuXG4gICAgLy8gc2F2ZXMgY2FsbGVycyBwcm9ncmFtXG4gICAgY29uc3QgY2lwID0gc3RhdGUuaXA7XG4gICAgY29uc3QgY3Byb2cgPSBzdGF0ZS5wcm9nO1xuXG4gICAgc3RhdGUucHJvZyA9IHN0YXRlLmZ1bmNzW2ZuXTtcblxuICAgIC8vIGV4ZWN1dGVzIHRoZSBmdW5jdGlvblxuICAgIGV4ZWMoc3RhdGUpO1xuXG4gICAgLy8gcmVzdG9yZXMgdGhlIGNhbGxlcnMgcHJvZ3JhbVxuICAgIHN0YXRlLmlwID0gY2lwO1xuICAgIHN0YXRlLnByb2cgPSBjcHJvZztcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSBjb25zb2xlLmxvZygrK3N0YXRlLnN0ZXAsICdyZXR1cm5pbmcgZnJvbScsIGZuKTtcbn1cblxuLy8gQ0lOREVYW10gQ29weSB0aGUgSU5ERVhlZCBlbGVtZW50IHRvIHRoZSB0b3Agb2YgdGhlIHN0YWNrXG4vLyAweDI1XG5mdW5jdGlvbiBDSU5ERVgoc3RhdGUpIHtcbiAgICBjb25zdCBzdGFjayA9IHN0YXRlLnN0YWNrO1xuICAgIGNvbnN0IGsgPSBzdGFjay5wb3AoKTtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnQ0lOREVYW10nLCBrKTtcblxuICAgIC8vIEluIGNhc2Ugb2YgayA9PSAxLCBpdCBjb3BpZXMgdGhlIGxhc3QgZWxlbWVudCBhZnRlciBwb3BwaW5nXG4gICAgLy8gdGh1cyBzdGFjay5sZW5ndGggLSBrLlxuICAgIHN0YWNrLnB1c2goc3RhY2tbc3RhY2subGVuZ3RoIC0ga10pO1xufVxuXG4vLyBNSU5ERVhbXSBNb3ZlIHRoZSBJTkRFWGVkIGVsZW1lbnQgdG8gdGhlIHRvcCBvZiB0aGUgc3RhY2tcbi8vIDB4MjZcbmZ1bmN0aW9uIE1JTkRFWChzdGF0ZSkge1xuICAgIGNvbnN0IHN0YWNrID0gc3RhdGUuc3RhY2s7XG4gICAgY29uc3QgayA9IHN0YWNrLnBvcCgpO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdNSU5ERVhbXScsIGspO1xuXG4gICAgc3RhY2sucHVzaChzdGFjay5zcGxpY2Uoc3RhY2subGVuZ3RoIC0gaywgMSlbMF0pO1xufVxuXG4vLyBGREVGW10gRnVuY3Rpb24gREVGaW5pdGlvblxuLy8gMHgyQ1xuZnVuY3Rpb24gRkRFRihzdGF0ZSkge1xuICAgIGlmIChzdGF0ZS5lbnYgIT09ICdmcGdtJykgdGhyb3cgbmV3IEVycm9yKCdGREVGIG5vdCBhbGxvd2VkIGhlcmUnKTtcbiAgICBjb25zdCBzdGFjayA9IHN0YXRlLnN0YWNrO1xuICAgIGNvbnN0IHByb2cgPSBzdGF0ZS5wcm9nO1xuICAgIGxldCBpcCA9IHN0YXRlLmlwO1xuXG4gICAgY29uc3QgZm4gPSBzdGFjay5wb3AoKTtcbiAgICBjb25zdCBpcEJlZ2luID0gaXA7XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ0ZERUZbXScsIGZuKTtcblxuICAgIHdoaWxlIChwcm9nWysraXBdICE9PSAweDJEKTtcblxuICAgIHN0YXRlLmlwID0gaXA7XG4gICAgc3RhdGUuZnVuY3NbZm5dID0gcHJvZy5zbGljZShpcEJlZ2luICsgMSwgaXApO1xufVxuXG4vLyBNREFQW2FdIE1vdmUgRGlyZWN0IEFic29sdXRlIFBvaW50XG4vLyAweDJFLTB4MkZcbmZ1bmN0aW9uIE1EQVAocm91bmQsIHN0YXRlKSB7XG4gICAgY29uc3QgcGkgPSBzdGF0ZS5zdGFjay5wb3AoKTtcbiAgICBjb25zdCBwID0gc3RhdGUuejBbcGldO1xuICAgIGNvbnN0IGZ2ID0gc3RhdGUuZnY7XG4gICAgY29uc3QgcHYgPSBzdGF0ZS5wdjtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnTURBUFsnICsgcm91bmQgKyAnXScsIHBpKTtcblxuICAgIGxldCBkID0gcHYuZGlzdGFuY2UocCwgSFBaZXJvKTtcblxuICAgIGlmIChyb3VuZCkgZCA9IHN0YXRlLnJvdW5kKGQpO1xuXG4gICAgZnYuc2V0UmVsYXRpdmUocCwgSFBaZXJvLCBkLCBwdik7XG4gICAgZnYudG91Y2gocCk7XG5cbiAgICBzdGF0ZS5ycDAgPSBzdGF0ZS5ycDEgPSBwaTtcbn1cblxuLy8gSVVQW2FdIEludGVycG9sYXRlIFVudG91Y2hlZCBQb2ludHMgdGhyb3VnaCB0aGUgb3V0bGluZVxuLy8gMHgzMFxuZnVuY3Rpb24gSVVQKHYsIHN0YXRlKSB7XG4gICAgY29uc3QgejIgPSBzdGF0ZS56MjtcbiAgICBjb25zdCBwTGVuID0gejIubGVuZ3RoIC0gMjtcbiAgICBsZXQgY3A7XG4gICAgbGV0IHBwO1xuICAgIGxldCBucDtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnSVVQWycgKyB2LmF4aXMgKyAnXScpO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwTGVuOyBpKyspIHtcbiAgICAgICAgY3AgPSB6MltpXTsgLy8gY3VycmVudCBwb2ludFxuXG4gICAgICAgIC8vIGlmIHRoaXMgcG9pbnQgaGFzIGJlZW4gdG91Y2hlZCBnbyBvblxuICAgICAgICBpZiAodi50b3VjaGVkKGNwKSkgY29udGludWU7XG5cbiAgICAgICAgcHAgPSBjcC5wcmV2VG91Y2hlZCh2KTtcblxuICAgICAgICAvLyBubyBwb2ludCBvbiB0aGUgY29udG91ciBoYXMgYmVlbiB0b3VjaGVkP1xuICAgICAgICBpZiAocHAgPT09IGNwKSBjb250aW51ZTtcblxuICAgICAgICBucCA9IGNwLm5leHRUb3VjaGVkKHYpO1xuXG4gICAgICAgIGlmIChwcCA9PT0gbnApIHtcbiAgICAgICAgICAgIC8vIG9ubHkgb25lIHBvaW50IG9uIHRoZSBjb250b3VyIGhhcyBiZWVuIHRvdWNoZWRcbiAgICAgICAgICAgIC8vIHNvIHNpbXBseSBtb3ZlcyB0aGUgcG9pbnQgbGlrZSB0aGF0XG5cbiAgICAgICAgICAgIHYuc2V0UmVsYXRpdmUoY3AsIGNwLCB2LmRpc3RhbmNlKHBwLCBwcCwgZmFsc2UsIHRydWUpLCB2LCB0cnVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHYuaW50ZXJwb2xhdGUoY3AsIHBwLCBucCwgdik7XG4gICAgfVxufVxuXG4vLyBTSFBbXSBTSGlmdCBQb2ludCB1c2luZyByZWZlcmVuY2UgcG9pbnRcbi8vIDB4MzItMHgzM1xuZnVuY3Rpb24gU0hQKGEsIHN0YXRlKSB7XG4gICAgY29uc3Qgc3RhY2sgPSBzdGF0ZS5zdGFjaztcbiAgICBjb25zdCBycGkgPSBhID8gc3RhdGUucnAxIDogc3RhdGUucnAyO1xuICAgIGNvbnN0IHJwID0gKGEgPyBzdGF0ZS56MCA6IHN0YXRlLnoxKVtycGldO1xuICAgIGNvbnN0IGZ2ID0gc3RhdGUuZnY7XG4gICAgY29uc3QgcHYgPSBzdGF0ZS5wdjtcbiAgICBsZXQgbG9vcCA9IHN0YXRlLmxvb3A7XG4gICAgY29uc3QgejIgPSBzdGF0ZS56MjtcblxuICAgIHdoaWxlIChsb29wLS0pXG4gICAge1xuICAgICAgICBjb25zdCBwaSA9IHN0YWNrLnBvcCgpO1xuICAgICAgICBjb25zdCBwID0gejJbcGldO1xuXG4gICAgICAgIGNvbnN0IGQgPSBwdi5kaXN0YW5jZShycCwgcnAsIGZhbHNlLCB0cnVlKTtcbiAgICAgICAgZnYuc2V0UmVsYXRpdmUocCwgcCwgZCwgcHYpO1xuICAgICAgICBmdi50b3VjaChwKTtcblxuICAgICAgICBpZiAoZXhwb3J0cy5ERUJVRykge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICAgICAgICAgc3RhdGUuc3RlcCxcbiAgICAgICAgICAgICAgICAoc3RhdGUubG9vcCA+IDEgP1xuICAgICAgICAgICAgICAgICAgICdsb29wICcgKyAoc3RhdGUubG9vcCAtIGxvb3ApICsgJzogJyA6XG4gICAgICAgICAgICAgICAgICAgJydcbiAgICAgICAgICAgICAgICApICtcbiAgICAgICAgICAgICAgICAnU0hQWycgKyAoYSA/ICdycDEnIDogJ3JwMicpICsgJ10nLCBwaVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHN0YXRlLmxvb3AgPSAxO1xufVxuXG4vLyBTSENbXSBTSGlmdCBDb250b3VyIHVzaW5nIHJlZmVyZW5jZSBwb2ludFxuLy8gMHgzNi0weDM3XG5mdW5jdGlvbiBTSEMoYSwgc3RhdGUpIHtcbiAgICBjb25zdCBzdGFjayA9IHN0YXRlLnN0YWNrO1xuICAgIGNvbnN0IHJwaSA9IGEgPyBzdGF0ZS5ycDEgOiBzdGF0ZS5ycDI7XG4gICAgY29uc3QgcnAgPSAoYSA/IHN0YXRlLnowIDogc3RhdGUuejEpW3JwaV07XG4gICAgY29uc3QgZnYgPSBzdGF0ZS5mdjtcbiAgICBjb25zdCBwdiA9IHN0YXRlLnB2O1xuICAgIGNvbnN0IGNpID0gc3RhY2sucG9wKCk7XG4gICAgY29uc3Qgc3AgPSBzdGF0ZS56MltzdGF0ZS5jb250b3Vyc1tjaV1dO1xuICAgIGxldCBwID0gc3A7XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ1NIQ1snICsgYSArICddJywgY2kpO1xuXG4gICAgY29uc3QgZCA9IHB2LmRpc3RhbmNlKHJwLCBycCwgZmFsc2UsIHRydWUpO1xuXG4gICAgZG8ge1xuICAgICAgICBpZiAocCAhPT0gcnApIGZ2LnNldFJlbGF0aXZlKHAsIHAsIGQsIHB2KTtcbiAgICAgICAgcCA9IHAubmV4dFBvaW50T25Db250b3VyO1xuICAgIH0gd2hpbGUgKHAgIT09IHNwKTtcbn1cblxuLy8gU0haW10gU0hpZnQgWm9uZSB1c2luZyByZWZlcmVuY2UgcG9pbnRcbi8vIDB4MzYtMHgzN1xuZnVuY3Rpb24gU0haKGEsIHN0YXRlKSB7XG4gICAgY29uc3Qgc3RhY2sgPSBzdGF0ZS5zdGFjaztcbiAgICBjb25zdCBycGkgPSBhID8gc3RhdGUucnAxIDogc3RhdGUucnAyO1xuICAgIGNvbnN0IHJwID0gKGEgPyBzdGF0ZS56MCA6IHN0YXRlLnoxKVtycGldO1xuICAgIGNvbnN0IGZ2ID0gc3RhdGUuZnY7XG4gICAgY29uc3QgcHYgPSBzdGF0ZS5wdjtcblxuICAgIGNvbnN0IGUgPSBzdGFjay5wb3AoKTtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnU0haWycgKyBhICsgJ10nLCBlKTtcblxuICAgIGxldCB6O1xuICAgIHN3aXRjaCAoZSkge1xuICAgICAgICBjYXNlIDAgOiB6ID0gc3RhdGUudFpvbmU7IGJyZWFrO1xuICAgICAgICBjYXNlIDEgOiB6ID0gc3RhdGUuZ1pvbmU7IGJyZWFrO1xuICAgICAgICBkZWZhdWx0IDogdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHpvbmUnKTtcbiAgICB9XG5cbiAgICBsZXQgcDtcbiAgICBjb25zdCBkID0gcHYuZGlzdGFuY2UocnAsIHJwLCBmYWxzZSwgdHJ1ZSk7XG4gICAgY29uc3QgcExlbiA9IHoubGVuZ3RoIC0gMjtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBMZW47IGkrKylcbiAgICB7XG4gICAgICAgIHAgPSB6W2ldO1xuICAgICAgICBpZiAocCAhPT0gcnApIGZ2LnNldFJlbGF0aXZlKHAsIHAsIGQsIHB2KTtcbiAgICB9XG59XG5cbi8vIFNIUElYW10gU0hpZnQgcG9pbnQgYnkgYSBQSVhlbCBhbW91bnRcbi8vIDB4MzhcbmZ1bmN0aW9uIFNIUElYKHN0YXRlKSB7XG4gICAgY29uc3Qgc3RhY2sgPSBzdGF0ZS5zdGFjaztcbiAgICBsZXQgbG9vcCA9IHN0YXRlLmxvb3A7XG4gICAgY29uc3QgZnYgPSBzdGF0ZS5mdjtcbiAgICBjb25zdCBkID0gc3RhY2sucG9wKCkgLyAweDQwO1xuICAgIGNvbnN0IHoyID0gc3RhdGUuejI7XG5cbiAgICB3aGlsZSAobG9vcC0tKSB7XG4gICAgICAgIGNvbnN0IHBpID0gc3RhY2sucG9wKCk7XG4gICAgICAgIGNvbnN0IHAgPSB6MltwaV07XG5cbiAgICAgICAgaWYgKGV4cG9ydHMuREVCVUcpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICAgICAgICAgIHN0YXRlLnN0ZXAsXG4gICAgICAgICAgICAgICAgKHN0YXRlLmxvb3AgPiAxID8gJ2xvb3AgJyArIChzdGF0ZS5sb29wIC0gbG9vcCkgKyAnOiAnIDogJycpICtcbiAgICAgICAgICAgICAgICAnU0hQSVhbXScsIHBpLCBkXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgZnYuc2V0UmVsYXRpdmUocCwgcCwgZCk7XG4gICAgICAgIGZ2LnRvdWNoKHApO1xuICAgIH1cblxuICAgIHN0YXRlLmxvb3AgPSAxO1xufVxuXG4vLyBJUFtdIEludGVycG9sYXRlIFBvaW50XG4vLyAweDM5XG5mdW5jdGlvbiBJUChzdGF0ZSkge1xuICAgIGNvbnN0IHN0YWNrID0gc3RhdGUuc3RhY2s7XG4gICAgY29uc3QgcnAxaSA9IHN0YXRlLnJwMTtcbiAgICBjb25zdCBycDJpID0gc3RhdGUucnAyO1xuICAgIGxldCBsb29wID0gc3RhdGUubG9vcDtcbiAgICBjb25zdCBycDEgPSBzdGF0ZS56MFtycDFpXTtcbiAgICBjb25zdCBycDIgPSBzdGF0ZS56MVtycDJpXTtcbiAgICBjb25zdCBmdiA9IHN0YXRlLmZ2O1xuICAgIGNvbnN0IHB2ID0gc3RhdGUuZHB2O1xuICAgIGNvbnN0IHoyID0gc3RhdGUuejI7XG5cbiAgICB3aGlsZSAobG9vcC0tKSB7XG4gICAgICAgIGNvbnN0IHBpID0gc3RhY2sucG9wKCk7XG4gICAgICAgIGNvbnN0IHAgPSB6MltwaV07XG5cbiAgICAgICAgaWYgKGV4cG9ydHMuREVCVUcpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICAgICAgICAgIHN0YXRlLnN0ZXAsXG4gICAgICAgICAgICAgICAgKHN0YXRlLmxvb3AgPiAxID8gJ2xvb3AgJyArIChzdGF0ZS5sb29wIC0gbG9vcCkgKyAnOiAnIDogJycpICtcbiAgICAgICAgICAgICAgICAnSVBbXScsIHBpLCBycDFpLCAnPC0+JywgcnAyaVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ2LmludGVycG9sYXRlKHAsIHJwMSwgcnAyLCBwdik7XG5cbiAgICAgICAgZnYudG91Y2gocCk7XG4gICAgfVxuXG4gICAgc3RhdGUubG9vcCA9IDE7XG59XG5cbi8vIE1TSVJQW2FdIE1vdmUgU3RhY2sgSW5kaXJlY3QgUmVsYXRpdmUgUG9pbnRcbi8vIDB4M0EtMHgzQlxuZnVuY3Rpb24gTVNJUlAoYSwgc3RhdGUpIHtcbiAgICBjb25zdCBzdGFjayA9IHN0YXRlLnN0YWNrO1xuICAgIGNvbnN0IGQgPSBzdGFjay5wb3AoKSAvIDY0O1xuICAgIGNvbnN0IHBpID0gc3RhY2sucG9wKCk7XG4gICAgY29uc3QgcCA9IHN0YXRlLnoxW3BpXTtcbiAgICBjb25zdCBycDAgPSBzdGF0ZS56MFtzdGF0ZS5ycDBdO1xuICAgIGNvbnN0IGZ2ID0gc3RhdGUuZnY7XG4gICAgY29uc3QgcHYgPSBzdGF0ZS5wdjtcblxuICAgIGZ2LnNldFJlbGF0aXZlKHAsIHJwMCwgZCwgcHYpO1xuICAgIGZ2LnRvdWNoKHApO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdNU0lSUFsnICsgYSArICddJywgZCwgcGkpO1xuXG4gICAgc3RhdGUucnAxID0gc3RhdGUucnAwO1xuICAgIHN0YXRlLnJwMiA9IHBpO1xuICAgIGlmIChhKSBzdGF0ZS5ycDAgPSBwaTtcbn1cblxuLy8gQUxJR05SUFtdIEFsaWduIHRvIHJlZmVyZW5jZSBwb2ludC5cbi8vIDB4M0NcbmZ1bmN0aW9uIEFMSUdOUlAoc3RhdGUpIHtcbiAgICBjb25zdCBzdGFjayA9IHN0YXRlLnN0YWNrO1xuICAgIGNvbnN0IHJwMGkgPSBzdGF0ZS5ycDA7XG4gICAgY29uc3QgcnAwID0gc3RhdGUuejBbcnAwaV07XG4gICAgbGV0IGxvb3AgPSBzdGF0ZS5sb29wO1xuICAgIGNvbnN0IGZ2ID0gc3RhdGUuZnY7XG4gICAgY29uc3QgcHYgPSBzdGF0ZS5wdjtcbiAgICBjb25zdCB6MSA9IHN0YXRlLnoxO1xuXG4gICAgd2hpbGUgKGxvb3AtLSkge1xuICAgICAgICBjb25zdCBwaSA9IHN0YWNrLnBvcCgpO1xuICAgICAgICBjb25zdCBwID0gejFbcGldO1xuXG4gICAgICAgIGlmIChleHBvcnRzLkRFQlVHKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgICAgICAgICBzdGF0ZS5zdGVwLFxuICAgICAgICAgICAgICAgIChzdGF0ZS5sb29wID4gMSA/ICdsb29wICcgKyAoc3RhdGUubG9vcCAtIGxvb3ApICsgJzogJyA6ICcnKSArXG4gICAgICAgICAgICAgICAgJ0FMSUdOUlBbXScsIHBpXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgZnYuc2V0UmVsYXRpdmUocCwgcnAwLCAwLCBwdik7XG4gICAgICAgIGZ2LnRvdWNoKHApO1xuICAgIH1cblxuICAgIHN0YXRlLmxvb3AgPSAxO1xufVxuXG4vLyBSVEdbXSBSb3VuZCBUbyBEb3VibGUgR3JpZFxuLy8gMHgzRFxuZnVuY3Rpb24gUlRERyhzdGF0ZSkge1xuICAgIGlmIChleHBvcnRzLkRFQlVHKSBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnUlRER1tdJyk7XG5cbiAgICBzdGF0ZS5yb3VuZCA9IHJvdW5kVG9Eb3VibGVHcmlkO1xufVxuXG4vLyBNSUFQW2FdIE1vdmUgSW5kaXJlY3QgQWJzb2x1dGUgUG9pbnRcbi8vIDB4M0UtMHgzRlxuZnVuY3Rpb24gTUlBUChyb3VuZCwgc3RhdGUpIHtcbiAgICBjb25zdCBzdGFjayA9IHN0YXRlLnN0YWNrO1xuICAgIGNvbnN0IG4gPSBzdGFjay5wb3AoKTtcbiAgICBjb25zdCBwaSA9IHN0YWNrLnBvcCgpO1xuICAgIGNvbnN0IHAgPSBzdGF0ZS56MFtwaV07XG4gICAgY29uc3QgZnYgPSBzdGF0ZS5mdjtcbiAgICBjb25zdCBwdiA9IHN0YXRlLnB2O1xuICAgIGxldCBjdiA9IHN0YXRlLmN2dFtuXTtcblxuICAgIC8vIFRPRE8gY3Z0Y3V0aW4gc2hvdWxkIGJlIGNvbnNpZGVyZWQgaGVyZVxuICAgIGlmIChyb3VuZCkgY3YgPSBzdGF0ZS5yb3VuZChjdik7XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykge1xuICAgICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgICAgIHN0YXRlLnN0ZXAsXG4gICAgICAgICAgICAnTUlBUFsnICsgcm91bmQgKyAnXScsXG4gICAgICAgICAgICBuLCAnKCcsIGN2LCAnKScsIHBpXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgZnYuc2V0UmVsYXRpdmUocCwgSFBaZXJvLCBjdiwgcHYpO1xuXG4gICAgaWYgKHN0YXRlLnpwMCA9PT0gMCkge1xuICAgICAgICBwLnhvID0gcC54O1xuICAgICAgICBwLnlvID0gcC55O1xuICAgIH1cblxuICAgIGZ2LnRvdWNoKHApO1xuXG4gICAgc3RhdGUucnAwID0gc3RhdGUucnAxID0gcGk7XG59XG5cbi8vIE5QVVNCW10gUFVTSCBOIEJ5dGVzXG4vLyAweDQwXG5mdW5jdGlvbiBOUFVTSEIoc3RhdGUpIHtcbiAgICBjb25zdCBwcm9nID0gc3RhdGUucHJvZztcbiAgICBsZXQgaXAgPSBzdGF0ZS5pcDtcbiAgICBjb25zdCBzdGFjayA9IHN0YXRlLnN0YWNrO1xuXG4gICAgY29uc3QgbiA9IHByb2dbKytpcF07XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ05QVVNIQltdJywgbik7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG47IGkrKykgc3RhY2sucHVzaChwcm9nWysraXBdKTtcblxuICAgIHN0YXRlLmlwID0gaXA7XG59XG5cbi8vIE5QVVNIV1tdIFBVU0ggTiBXb3Jkc1xuLy8gMHg0MVxuZnVuY3Rpb24gTlBVU0hXKHN0YXRlKSB7XG4gICAgbGV0IGlwID0gc3RhdGUuaXA7XG4gICAgY29uc3QgcHJvZyA9IHN0YXRlLnByb2c7XG4gICAgY29uc3Qgc3RhY2sgPSBzdGF0ZS5zdGFjaztcbiAgICBjb25zdCBuID0gcHJvZ1srK2lwXTtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnTlBVU0hXW10nLCBuKTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgIGxldCB3ID0gKHByb2dbKytpcF0gPDwgOCkgfCBwcm9nWysraXBdO1xuICAgICAgICBpZiAodyAmIDB4ODAwMCkgdyA9IC0oKHcgXiAweGZmZmYpICsgMSk7XG4gICAgICAgIHN0YWNrLnB1c2godyk7XG4gICAgfVxuXG4gICAgc3RhdGUuaXAgPSBpcDtcbn1cblxuLy8gV1NbXSBXcml0ZSBTdG9yZVxuLy8gMHg0MlxuZnVuY3Rpb24gV1Moc3RhdGUpIHtcbiAgICBjb25zdCBzdGFjayA9IHN0YXRlLnN0YWNrO1xuICAgIGxldCBzdG9yZSA9IHN0YXRlLnN0b3JlO1xuXG4gICAgaWYgKCFzdG9yZSkgc3RvcmUgPSBzdGF0ZS5zdG9yZSA9IFtdO1xuXG4gICAgY29uc3QgdiA9IHN0YWNrLnBvcCgpO1xuICAgIGNvbnN0IGwgPSBzdGFjay5wb3AoKTtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnV1MnLCB2LCBsKTtcblxuICAgIHN0b3JlW2xdID0gdjtcbn1cblxuLy8gUlNbXSBSZWFkIFN0b3JlXG4vLyAweDQzXG5mdW5jdGlvbiBSUyhzdGF0ZSkge1xuICAgIGNvbnN0IHN0YWNrID0gc3RhdGUuc3RhY2s7XG4gICAgY29uc3Qgc3RvcmUgPSBzdGF0ZS5zdG9yZTtcblxuICAgIGNvbnN0IGwgPSBzdGFjay5wb3AoKTtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnUlMnLCBsKTtcblxuICAgIGNvbnN0IHYgPSAoc3RvcmUgJiYgc3RvcmVbbF0pIHx8IDA7XG5cbiAgICBzdGFjay5wdXNoKHYpO1xufVxuXG4vLyBXQ1ZUUFtdIFdyaXRlIENvbnRyb2wgVmFsdWUgVGFibGUgaW4gUGl4ZWwgdW5pdHNcbi8vIDB4NDRcbmZ1bmN0aW9uIFdDVlRQKHN0YXRlKSB7XG4gICAgY29uc3Qgc3RhY2sgPSBzdGF0ZS5zdGFjaztcblxuICAgIGNvbnN0IHYgPSBzdGFjay5wb3AoKTtcbiAgICBjb25zdCBsID0gc3RhY2sucG9wKCk7XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ1dDVlRQJywgdiwgbCk7XG5cbiAgICBzdGF0ZS5jdnRbbF0gPSB2IC8gMHg0MDtcbn1cblxuLy8gUkNWVFtdIFJlYWQgQ29udHJvbCBWYWx1ZSBUYWJsZSBlbnRyeVxuLy8gMHg0NVxuZnVuY3Rpb24gUkNWVChzdGF0ZSkge1xuICAgIGNvbnN0IHN0YWNrID0gc3RhdGUuc3RhY2s7XG4gICAgY29uc3QgY3Z0ZSA9IHN0YWNrLnBvcCgpO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdSQ1ZUJywgY3Z0ZSk7XG5cbiAgICBzdGFjay5wdXNoKHN0YXRlLmN2dFtjdnRlXSAqIDB4NDApO1xufVxuXG4vLyBHQ1tdIEdldCBDb29yZGluYXRlIHByb2plY3RlZCBvbnRvIHRoZSBwcm9qZWN0aW9uIHZlY3RvclxuLy8gMHg0Ni0weDQ3XG5mdW5jdGlvbiBHQyhhLCBzdGF0ZSkge1xuICAgIGNvbnN0IHN0YWNrID0gc3RhdGUuc3RhY2s7XG4gICAgY29uc3QgcGkgPSBzdGFjay5wb3AoKTtcbiAgICBjb25zdCBwID0gc3RhdGUuejJbcGldO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdHQ1snICsgYSArICddJywgcGkpO1xuXG4gICAgc3RhY2sucHVzaChzdGF0ZS5kcHYuZGlzdGFuY2UocCwgSFBaZXJvLCBhLCBmYWxzZSkgKiAweDQwKTtcbn1cblxuLy8gTURbYV0gTWVhc3VyZSBEaXN0YW5jZVxuLy8gMHg0OS0weDRBXG5mdW5jdGlvbiBNRChhLCBzdGF0ZSkge1xuICAgIGNvbnN0IHN0YWNrID0gc3RhdGUuc3RhY2s7XG4gICAgY29uc3QgcGkyID0gc3RhY2sucG9wKCk7XG4gICAgY29uc3QgcGkxID0gc3RhY2sucG9wKCk7XG4gICAgY29uc3QgcDIgPSBzdGF0ZS56MVtwaTJdO1xuICAgIGNvbnN0IHAxID0gc3RhdGUuejBbcGkxXTtcbiAgICBjb25zdCBkID0gc3RhdGUuZHB2LmRpc3RhbmNlKHAxLCBwMiwgYSwgYSk7XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ01EWycgKyBhICsgJ10nLCBwaTIsIHBpMSwgJy0+JywgZCk7XG5cbiAgICBzdGF0ZS5zdGFjay5wdXNoKE1hdGgucm91bmQoZCAqIDY0KSk7XG59XG5cbi8vIE1QUEVNW10gTWVhc3VyZSBQaXhlbHMgUGVyIEVNXG4vLyAweDRCXG5mdW5jdGlvbiBNUFBFTShzdGF0ZSkge1xuICAgIGlmIChleHBvcnRzLkRFQlVHKSBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnTVBQRU1bXScpO1xuICAgIHN0YXRlLnN0YWNrLnB1c2goc3RhdGUucHBlbSk7XG59XG5cbi8vIEZMSVBPTltdIHNldCB0aGUgYXV0byBGTElQIEJvb2xlYW4gdG8gT05cbi8vIDB4NERcbmZ1bmN0aW9uIEZMSVBPTihzdGF0ZSkge1xuICAgIGlmIChleHBvcnRzLkRFQlVHKSBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnRkxJUE9OW10nKTtcbiAgICBzdGF0ZS5hdXRvRmxpcCA9IHRydWU7XG59XG5cbi8vIExUW10gTGVzcyBUaGFuXG4vLyAweDUwXG5mdW5jdGlvbiBMVChzdGF0ZSkge1xuICAgIGNvbnN0IHN0YWNrID0gc3RhdGUuc3RhY2s7XG4gICAgY29uc3QgZTIgPSBzdGFjay5wb3AoKTtcbiAgICBjb25zdCBlMSA9IHN0YWNrLnBvcCgpO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdMVFtdJywgZTIsIGUxKTtcblxuICAgIHN0YWNrLnB1c2goZTEgPCBlMiA/IDEgOiAwKTtcbn1cblxuLy8gTFRFUVtdIExlc3MgVGhhbiBvciBFUXVhbFxuLy8gMHg1M1xuZnVuY3Rpb24gTFRFUShzdGF0ZSkge1xuICAgIGNvbnN0IHN0YWNrID0gc3RhdGUuc3RhY2s7XG4gICAgY29uc3QgZTIgPSBzdGFjay5wb3AoKTtcbiAgICBjb25zdCBlMSA9IHN0YWNrLnBvcCgpO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdMVEVRW10nLCBlMiwgZTEpO1xuXG4gICAgc3RhY2sucHVzaChlMSA8PSBlMiA/IDEgOiAwKTtcbn1cblxuLy8gR1RFUVtdIEdyZWF0ZXIgVGhhblxuLy8gMHg1MlxuZnVuY3Rpb24gR1Qoc3RhdGUpIHtcbiAgICBjb25zdCBzdGFjayA9IHN0YXRlLnN0YWNrO1xuICAgIGNvbnN0IGUyID0gc3RhY2sucG9wKCk7XG4gICAgY29uc3QgZTEgPSBzdGFjay5wb3AoKTtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnR1RbXScsIGUyLCBlMSk7XG5cbiAgICBzdGFjay5wdXNoKGUxID4gZTIgPyAxIDogMCk7XG59XG5cbi8vIEdURVFbXSBHcmVhdGVyIFRoYW4gb3IgRVF1YWxcbi8vIDB4NTNcbmZ1bmN0aW9uIEdURVEoc3RhdGUpIHtcbiAgICBjb25zdCBzdGFjayA9IHN0YXRlLnN0YWNrO1xuICAgIGNvbnN0IGUyID0gc3RhY2sucG9wKCk7XG4gICAgY29uc3QgZTEgPSBzdGFjay5wb3AoKTtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnR1RFUVtdJywgZTIsIGUxKTtcblxuICAgIHN0YWNrLnB1c2goZTEgPj0gZTIgPyAxIDogMCk7XG59XG5cbi8vIEVRW10gRVF1YWxcbi8vIDB4NTRcbmZ1bmN0aW9uIEVRKHN0YXRlKSB7XG4gICAgY29uc3Qgc3RhY2sgPSBzdGF0ZS5zdGFjaztcbiAgICBjb25zdCBlMiA9IHN0YWNrLnBvcCgpO1xuICAgIGNvbnN0IGUxID0gc3RhY2sucG9wKCk7XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ0VRW10nLCBlMiwgZTEpO1xuXG4gICAgc3RhY2sucHVzaChlMiA9PT0gZTEgPyAxIDogMCk7XG59XG5cbi8vIE5FUVtdIE5vdCBFUXVhbFxuLy8gMHg1NVxuZnVuY3Rpb24gTkVRKHN0YXRlKSB7XG4gICAgY29uc3Qgc3RhY2sgPSBzdGF0ZS5zdGFjaztcbiAgICBjb25zdCBlMiA9IHN0YWNrLnBvcCgpO1xuICAgIGNvbnN0IGUxID0gc3RhY2sucG9wKCk7XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ05FUVtdJywgZTIsIGUxKTtcblxuICAgIHN0YWNrLnB1c2goZTIgIT09IGUxID8gMSA6IDApO1xufVxuXG4vLyBPRERbXSBPRERcbi8vIDB4NTZcbmZ1bmN0aW9uIE9ERChzdGF0ZSkge1xuICAgIGNvbnN0IHN0YWNrID0gc3RhdGUuc3RhY2s7XG4gICAgY29uc3QgbiA9IHN0YWNrLnBvcCgpO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdPRERbXScsIG4pO1xuXG4gICAgc3RhY2sucHVzaChNYXRoLnRydW5jKG4pICUgMiA/IDEgOiAwKTtcbn1cblxuLy8gRVZFTltdIEVWRU5cbi8vIDB4NTdcbmZ1bmN0aW9uIEVWRU4oc3RhdGUpIHtcbiAgICBjb25zdCBzdGFjayA9IHN0YXRlLnN0YWNrO1xuICAgIGNvbnN0IG4gPSBzdGFjay5wb3AoKTtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnRVZFTltdJywgbik7XG5cbiAgICBzdGFjay5wdXNoKE1hdGgudHJ1bmMobikgJSAyID8gMCA6IDEpO1xufVxuXG4vLyBJRltdIElGIHRlc3Rcbi8vIDB4NThcbmZ1bmN0aW9uIElGKHN0YXRlKSB7XG4gICAgbGV0IHRlc3QgPSBzdGF0ZS5zdGFjay5wb3AoKTtcbiAgICBsZXQgaW5zO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdJRltdJywgdGVzdCk7XG5cbiAgICAvLyBpZiB0ZXN0IGlzIHRydWUgaXQganVzdCBjb250aW51ZXNcbiAgICAvLyBpZiBub3QgdGhlIGlwIGlzIHNraXBwZWQgdW50aWwgbWF0Y2hpbmcgRUxTRSBvciBFSUZcbiAgICBpZiAoIXRlc3QpIHtcbiAgICAgICAgc2tpcChzdGF0ZSwgdHJ1ZSk7XG5cbiAgICAgICAgaWYgKGV4cG9ydHMuREVCVUcpIGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsIGlucyA9PT0gMHgxQiA/ICdFTFNFW10nIDogJ0VJRltdJyk7XG4gICAgfVxufVxuXG4vLyBFSUZbXSBFbmQgSUZcbi8vIDB4NTlcbmZ1bmN0aW9uIEVJRihzdGF0ZSkge1xuICAgIC8vIHRoaXMgY2FuIGJlIHJlYWNoZWQgbm9ybWFsbHkgd2hlblxuICAgIC8vIGV4ZWN1dGluZyBhbiBlbHNlIGJyYW5jaC5cbiAgICAvLyAtPiBqdXN0IGlnbm9yZSBpdFxuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdFSUZbXScpO1xufVxuXG4vLyBBTkRbXSBsb2dpY2FsIEFORFxuLy8gMHg1QVxuZnVuY3Rpb24gQU5EKHN0YXRlKSB7XG4gICAgY29uc3Qgc3RhY2sgPSBzdGF0ZS5zdGFjaztcbiAgICBjb25zdCBlMiA9IHN0YWNrLnBvcCgpO1xuICAgIGNvbnN0IGUxID0gc3RhY2sucG9wKCk7XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ0FORFtdJywgZTIsIGUxKTtcblxuICAgIHN0YWNrLnB1c2goZTIgJiYgZTEgPyAxIDogMCk7XG59XG5cbi8vIE9SW10gbG9naWNhbCBPUlxuLy8gMHg1QlxuZnVuY3Rpb24gT1Ioc3RhdGUpIHtcbiAgICBjb25zdCBzdGFjayA9IHN0YXRlLnN0YWNrO1xuICAgIGNvbnN0IGUyID0gc3RhY2sucG9wKCk7XG4gICAgY29uc3QgZTEgPSBzdGFjay5wb3AoKTtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnT1JbXScsIGUyLCBlMSk7XG5cbiAgICBzdGFjay5wdXNoKGUyIHx8IGUxID8gMSA6IDApO1xufVxuXG4vLyBOT1RbXSBsb2dpY2FsIE5PVFxuLy8gMHg1Q1xuZnVuY3Rpb24gTk9UKHN0YXRlKSB7XG4gICAgY29uc3Qgc3RhY2sgPSBzdGF0ZS5zdGFjaztcbiAgICBjb25zdCBlID0gc3RhY2sucG9wKCk7XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ05PVFtdJywgZSk7XG5cbiAgICBzdGFjay5wdXNoKGUgPyAwIDogMSk7XG59XG5cbi8vIERFTFRBUDFbXSBERUxUQSBleGNlcHRpb24gUDFcbi8vIERFTFRBUDJbXSBERUxUQSBleGNlcHRpb24gUDJcbi8vIERFTFRBUDNbXSBERUxUQSBleGNlcHRpb24gUDNcbi8vIDB4NUQsIDB4NzEsIDB4NzJcbmZ1bmN0aW9uIERFTFRBUDEyMyhiLCBzdGF0ZSkge1xuICAgIGNvbnN0IHN0YWNrID0gc3RhdGUuc3RhY2s7XG4gICAgY29uc3QgbiA9IHN0YWNrLnBvcCgpO1xuICAgIGNvbnN0IGZ2ID0gc3RhdGUuZnY7XG4gICAgY29uc3QgcHYgPSBzdGF0ZS5wdjtcbiAgICBjb25zdCBwcGVtID0gc3RhdGUucHBlbTtcbiAgICBjb25zdCBiYXNlID0gc3RhdGUuZGVsdGFCYXNlICsgKGIgLSAxKSAqIDE2O1xuICAgIGNvbnN0IGRzID0gc3RhdGUuZGVsdGFTaGlmdDtcbiAgICBjb25zdCB6MCA9IHN0YXRlLnowO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdERUxUQVBbJyArIGIgKyAnXScsIG4sIHN0YWNrKTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgaSsrKVxuICAgIHtcbiAgICAgICAgY29uc3QgcGkgPSBzdGFjay5wb3AoKTtcbiAgICAgICAgY29uc3QgYXJnID0gc3RhY2sucG9wKCk7XG4gICAgICAgIGNvbnN0IGFwcGVtID0gYmFzZSArICgoYXJnICYgMHhGMCkgPj4gNCk7XG4gICAgICAgIGlmIChhcHBlbSAhPT0gcHBlbSkgY29udGludWU7XG5cbiAgICAgICAgbGV0IG1hZyA9IChhcmcgJiAweDBGKSAtIDg7XG4gICAgICAgIGlmIChtYWcgPj0gMCkgbWFnKys7XG4gICAgICAgIGlmIChleHBvcnRzLkRFQlVHKSBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnREVMVEFQRklYJywgcGksICdieScsIG1hZyAqIGRzKTtcblxuICAgICAgICBjb25zdCBwID0gejBbcGldO1xuICAgICAgICBmdi5zZXRSZWxhdGl2ZShwLCBwLCBtYWcgKiBkcywgcHYpO1xuICAgIH1cbn1cblxuLy8gU0RCW10gU2V0IERlbHRhIEJhc2UgaW4gdGhlIGdyYXBoaWNzIHN0YXRlXG4vLyAweDVFXG5mdW5jdGlvbiBTREIoc3RhdGUpIHtcbiAgICBjb25zdCBzdGFjayA9IHN0YXRlLnN0YWNrO1xuICAgIGNvbnN0IG4gPSBzdGFjay5wb3AoKTtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnU0RCW10nLCBuKTtcblxuICAgIHN0YXRlLmRlbHRhQmFzZSA9IG47XG59XG5cbi8vIFNEU1tdIFNldCBEZWx0YSBTaGlmdCBpbiB0aGUgZ3JhcGhpY3Mgc3RhdGVcbi8vIDB4NUZcbmZ1bmN0aW9uIFNEUyhzdGF0ZSkge1xuICAgIGNvbnN0IHN0YWNrID0gc3RhdGUuc3RhY2s7XG4gICAgY29uc3QgbiA9IHN0YWNrLnBvcCgpO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdTRFNbXScsIG4pO1xuXG4gICAgc3RhdGUuZGVsdGFTaGlmdCA9IE1hdGgucG93KDAuNSwgbik7XG59XG5cbi8vIEFERFtdIEFERFxuLy8gMHg2MFxuZnVuY3Rpb24gQUREKHN0YXRlKSB7XG4gICAgY29uc3Qgc3RhY2sgPSBzdGF0ZS5zdGFjaztcbiAgICBjb25zdCBuMiA9IHN0YWNrLnBvcCgpO1xuICAgIGNvbnN0IG4xID0gc3RhY2sucG9wKCk7XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ0FERFtdJywgbjIsIG4xKTtcblxuICAgIHN0YWNrLnB1c2gobjEgKyBuMik7XG59XG5cbi8vIFNVQltdIFNVQlxuLy8gMHg2MVxuZnVuY3Rpb24gU1VCKHN0YXRlKSB7XG4gICAgY29uc3Qgc3RhY2sgPSBzdGF0ZS5zdGFjaztcbiAgICBjb25zdCBuMiA9IHN0YWNrLnBvcCgpO1xuICAgIGNvbnN0IG4xID0gc3RhY2sucG9wKCk7XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ1NVQltdJywgbjIsIG4xKTtcblxuICAgIHN0YWNrLnB1c2gobjEgLSBuMik7XG59XG5cbi8vIERJVltdIERJVlxuLy8gMHg2MlxuZnVuY3Rpb24gRElWKHN0YXRlKSB7XG4gICAgY29uc3Qgc3RhY2sgPSBzdGF0ZS5zdGFjaztcbiAgICBjb25zdCBuMiA9IHN0YWNrLnBvcCgpO1xuICAgIGNvbnN0IG4xID0gc3RhY2sucG9wKCk7XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ0RJVltdJywgbjIsIG4xKTtcblxuICAgIHN0YWNrLnB1c2gobjEgKiA2NCAvIG4yKTtcbn1cblxuLy8gTVVMW10gTVVMXG4vLyAweDYzXG5mdW5jdGlvbiBNVUwoc3RhdGUpIHtcbiAgICBjb25zdCBzdGFjayA9IHN0YXRlLnN0YWNrO1xuICAgIGNvbnN0IG4yID0gc3RhY2sucG9wKCk7XG4gICAgY29uc3QgbjEgPSBzdGFjay5wb3AoKTtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnTVVMW10nLCBuMiwgbjEpO1xuXG4gICAgc3RhY2sucHVzaChuMSAqIG4yIC8gNjQpO1xufVxuXG4vLyBBQlNbXSBBQlNvbHV0ZSB2YWx1ZVxuLy8gMHg2NFxuZnVuY3Rpb24gQUJTKHN0YXRlKSB7XG4gICAgY29uc3Qgc3RhY2sgPSBzdGF0ZS5zdGFjaztcbiAgICBjb25zdCBuID0gc3RhY2sucG9wKCk7XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ0FCU1tdJywgbik7XG5cbiAgICBzdGFjay5wdXNoKE1hdGguYWJzKG4pKTtcbn1cblxuLy8gTkVHW10gTkVHYXRlXG4vLyAweDY1XG5mdW5jdGlvbiBORUcoc3RhdGUpIHtcbiAgICBjb25zdCBzdGFjayA9IHN0YXRlLnN0YWNrO1xuICAgIGxldCBuID0gc3RhY2sucG9wKCk7XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ05FR1tdJywgbik7XG5cbiAgICBzdGFjay5wdXNoKC1uKTtcbn1cblxuLy8gRkxPT1JbXSBGTE9PUlxuLy8gMHg2NlxuZnVuY3Rpb24gRkxPT1Ioc3RhdGUpIHtcbiAgICBjb25zdCBzdGFjayA9IHN0YXRlLnN0YWNrO1xuICAgIGNvbnN0IG4gPSBzdGFjay5wb3AoKTtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnRkxPT1JbXScsIG4pO1xuXG4gICAgc3RhY2sucHVzaChNYXRoLmZsb29yKG4gLyAweDQwKSAqIDB4NDApO1xufVxuXG4vLyBDRUlMSU5HW10gQ0VJTElOR1xuLy8gMHg2N1xuZnVuY3Rpb24gQ0VJTElORyhzdGF0ZSkge1xuICAgIGNvbnN0IHN0YWNrID0gc3RhdGUuc3RhY2s7XG4gICAgY29uc3QgbiA9IHN0YWNrLnBvcCgpO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdDRUlMSU5HW10nLCBuKTtcblxuICAgIHN0YWNrLnB1c2goTWF0aC5jZWlsKG4gLyAweDQwKSAqIDB4NDApO1xufVxuXG4vLyBST1VORFthYl0gUk9VTkQgdmFsdWVcbi8vIDB4NjgtMHg2QlxuZnVuY3Rpb24gUk9VTkQoZHQsIHN0YXRlKSB7XG4gICAgY29uc3Qgc3RhY2sgPSBzdGF0ZS5zdGFjaztcbiAgICBjb25zdCBuID0gc3RhY2sucG9wKCk7XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ1JPVU5EW10nKTtcblxuICAgIHN0YWNrLnB1c2goc3RhdGUucm91bmQobiAvIDB4NDApICogMHg0MCk7XG59XG5cbi8vIFdDVlRGW10gV3JpdGUgQ29udHJvbCBWYWx1ZSBUYWJsZSBpbiBGdW5pdHNcbi8vIDB4NzBcbmZ1bmN0aW9uIFdDVlRGKHN0YXRlKSB7XG4gICAgY29uc3Qgc3RhY2sgPSBzdGF0ZS5zdGFjaztcbiAgICBjb25zdCB2ID0gc3RhY2sucG9wKCk7XG4gICAgY29uc3QgbCA9IHN0YWNrLnBvcCgpO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdXQ1ZURltdJywgdiwgbCk7XG5cbiAgICBzdGF0ZS5jdnRbbF0gPSB2ICogc3RhdGUucHBlbSAvIHN0YXRlLmZvbnQudW5pdHNQZXJFbTtcbn1cblxuLy8gREVMVEFDMVtdIERFTFRBIGV4Y2VwdGlvbiBDMVxuLy8gREVMVEFDMltdIERFTFRBIGV4Y2VwdGlvbiBDMlxuLy8gREVMVEFDM1tdIERFTFRBIGV4Y2VwdGlvbiBDM1xuLy8gMHg3MywgMHg3NCwgMHg3NVxuZnVuY3Rpb24gREVMVEFDMTIzKGIsIHN0YXRlKSB7XG4gICAgY29uc3Qgc3RhY2sgPSBzdGF0ZS5zdGFjaztcbiAgICBjb25zdCBuID0gc3RhY2sucG9wKCk7XG4gICAgY29uc3QgcHBlbSA9IHN0YXRlLnBwZW07XG4gICAgY29uc3QgYmFzZSA9IHN0YXRlLmRlbHRhQmFzZSArIChiIC0gMSkgKiAxNjtcbiAgICBjb25zdCBkcyA9IHN0YXRlLmRlbHRhU2hpZnQ7XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ0RFTFRBQ1snICsgYiArICddJywgbiwgc3RhY2spO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgY29uc3QgYyA9IHN0YWNrLnBvcCgpO1xuICAgICAgICBjb25zdCBhcmcgPSBzdGFjay5wb3AoKTtcbiAgICAgICAgY29uc3QgYXBwZW0gPSBiYXNlICsgKChhcmcgJiAweEYwKSA+PiA0KTtcbiAgICAgICAgaWYgKGFwcGVtICE9PSBwcGVtKSBjb250aW51ZTtcblxuICAgICAgICBsZXQgbWFnID0gKGFyZyAmIDB4MEYpIC0gODtcbiAgICAgICAgaWYgKG1hZyA+PSAwKSBtYWcrKztcblxuICAgICAgICBjb25zdCBkZWx0YSA9IG1hZyAqIGRzO1xuXG4gICAgICAgIGlmIChleHBvcnRzLkRFQlVHKSBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnREVMVEFDRklYJywgYywgJ2J5JywgZGVsdGEpO1xuXG4gICAgICAgIHN0YXRlLmN2dFtjXSArPSBkZWx0YTtcbiAgICB9XG59XG5cbi8vIFNST1VORFtdIFN1cGVyIFJPVU5EXG4vLyAweDc2XG5mdW5jdGlvbiBTUk9VTkQoc3RhdGUpIHtcbiAgICBsZXQgbiA9IHN0YXRlLnN0YWNrLnBvcCgpO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdTUk9VTkRbXScsIG4pO1xuXG4gICAgc3RhdGUucm91bmQgPSByb3VuZFN1cGVyO1xuXG4gICAgbGV0IHBlcmlvZDtcblxuICAgIHN3aXRjaCAobiAmIDB4QzApIHtcbiAgICAgICAgY2FzZSAweDAwOlxuICAgICAgICAgICAgcGVyaW9kID0gMC41O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMHg0MDpcbiAgICAgICAgICAgIHBlcmlvZCA9IDE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAweDgwOlxuICAgICAgICAgICAgcGVyaW9kID0gMjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIFNST1VORCB2YWx1ZScpO1xuICAgIH1cblxuICAgIHN0YXRlLnNyUGVyaW9kID0gcGVyaW9kO1xuXG4gICAgc3dpdGNoIChuICYgMHgzMCkge1xuICAgICAgICBjYXNlIDB4MDA6XG4gICAgICAgICAgICBzdGF0ZS5zclBoYXNlID0gMDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDB4MTA6XG4gICAgICAgICAgICBzdGF0ZS5zclBoYXNlID0gMC4yNSAqIHBlcmlvZDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDB4MjA6XG4gICAgICAgICAgICBzdGF0ZS5zclBoYXNlID0gMC41ICAqIHBlcmlvZDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDB4MzA6XG4gICAgICAgICAgICBzdGF0ZS5zclBoYXNlID0gMC43NSAqIHBlcmlvZDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OiB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgU1JPVU5EIHZhbHVlJyk7XG4gICAgfVxuXG4gICAgbiAmPSAweDBGO1xuXG4gICAgaWYgKG4gPT09IDApIHN0YXRlLnNyVGhyZXNob2xkID0gMDtcbiAgICBlbHNlIHN0YXRlLnNyVGhyZXNob2xkID0gKG4gLyA4IC0gMC41KSAqIHBlcmlvZDtcbn1cblxuLy8gUzQ1Uk9VTkRbXSBTdXBlciBST1VORCA0NSBkZWdyZWVzXG4vLyAweDc3XG5mdW5jdGlvbiBTNDVST1VORChzdGF0ZSkge1xuICAgIGxldCBuID0gc3RhdGUuc3RhY2sucG9wKCk7XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ1M0NVJPVU5EW10nLCBuKTtcblxuICAgIHN0YXRlLnJvdW5kID0gcm91bmRTdXBlcjtcblxuICAgIGxldCBwZXJpb2Q7XG5cbiAgICBzd2l0Y2ggKG4gJiAweEMwKSB7XG4gICAgICAgIGNhc2UgMHgwMDpcbiAgICAgICAgICAgIHBlcmlvZCA9IE1hdGguc3FydCgyKSAvIDI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAweDQwOlxuICAgICAgICAgICAgcGVyaW9kID0gTWF0aC5zcXJ0KDIpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMHg4MDpcbiAgICAgICAgICAgIHBlcmlvZCA9IDIgKiBNYXRoLnNxcnQoMik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBTNDVST1VORCB2YWx1ZScpO1xuICAgIH1cblxuICAgIHN0YXRlLnNyUGVyaW9kID0gcGVyaW9kO1xuXG4gICAgc3dpdGNoIChuICYgMHgzMCkge1xuICAgICAgICBjYXNlIDB4MDA6XG4gICAgICAgICAgICBzdGF0ZS5zclBoYXNlID0gMDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDB4MTA6XG4gICAgICAgICAgICBzdGF0ZS5zclBoYXNlID0gMC4yNSAqIHBlcmlvZDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDB4MjA6XG4gICAgICAgICAgICBzdGF0ZS5zclBoYXNlID0gMC41ICAqIHBlcmlvZDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDB4MzA6XG4gICAgICAgICAgICBzdGF0ZS5zclBoYXNlID0gMC43NSAqIHBlcmlvZDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIFM0NVJPVU5EIHZhbHVlJyk7XG4gICAgfVxuXG4gICAgbiAmPSAweDBGO1xuXG4gICAgaWYgKG4gPT09IDApIHN0YXRlLnNyVGhyZXNob2xkID0gMDtcbiAgICBlbHNlIHN0YXRlLnNyVGhyZXNob2xkID0gKG4gLyA4IC0gMC41KSAqIHBlcmlvZDtcbn1cblxuLy8gUk9GRltdIFJvdW5kIE9mZlxuLy8gMHg3QVxuZnVuY3Rpb24gUk9GRihzdGF0ZSkge1xuICAgIGlmIChleHBvcnRzLkRFQlVHKSBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnUk9GRltdJyk7XG5cbiAgICBzdGF0ZS5yb3VuZCA9IHJvdW5kT2ZmO1xufVxuXG4vLyBSVVRHW10gUm91bmQgVXAgVG8gR3JpZFxuLy8gMHg3Q1xuZnVuY3Rpb24gUlVURyhzdGF0ZSkge1xuICAgIGlmIChleHBvcnRzLkRFQlVHKSBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnUlVUR1tdJyk7XG5cbiAgICBzdGF0ZS5yb3VuZCA9IHJvdW5kVXBUb0dyaWQ7XG59XG5cbi8vIFJEVEdbXSBSb3VuZCBEb3duIFRvIEdyaWRcbi8vIDB4N0RcbmZ1bmN0aW9uIFJEVEcoc3RhdGUpIHtcbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ1JEVEdbXScpO1xuXG4gICAgc3RhdGUucm91bmQgPSByb3VuZERvd25Ub0dyaWQ7XG59XG5cbi8vIFNDQU5DVFJMW10gU0NBTiBjb252ZXJzaW9uIENvblRSb0xcbi8vIDB4ODVcbmZ1bmN0aW9uIFNDQU5DVFJMKHN0YXRlKSB7XG4gICAgY29uc3QgbiA9IHN0YXRlLnN0YWNrLnBvcCgpO1xuXG4gICAgLy8gaWdub3JlZCBieSBvcGVudHlwZS5qc1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdTQ0FOQ1RSTFtdJywgbik7XG59XG5cbi8vIFNEUFZUTFthXSBTZXQgRHVhbCBQcm9qZWN0aW9uIFZlY3RvciBUbyBMaW5lXG4vLyAweDg2LTB4ODdcbmZ1bmN0aW9uIFNEUFZUTChhLCBzdGF0ZSkge1xuICAgIGNvbnN0IHN0YWNrID0gc3RhdGUuc3RhY2s7XG4gICAgY29uc3QgcDJpID0gc3RhY2sucG9wKCk7XG4gICAgY29uc3QgcDFpID0gc3RhY2sucG9wKCk7XG4gICAgY29uc3QgcDIgPSBzdGF0ZS56MltwMmldO1xuICAgIGNvbnN0IHAxID0gc3RhdGUuejFbcDFpXTtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSBjb25zb2xlLmxvZygnU0RQVlRMWycgKyBhICsgJ10nLCBwMmksIHAxaSk7XG5cbiAgICBsZXQgZHg7XG4gICAgbGV0IGR5O1xuXG4gICAgaWYgKCFhKSB7XG4gICAgICAgIGR4ID0gcDEueCAtIHAyLng7XG4gICAgICAgIGR5ID0gcDEueSAtIHAyLnk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZHggPSBwMi55IC0gcDEueTtcbiAgICAgICAgZHkgPSBwMS54IC0gcDIueDtcbiAgICB9XG5cbiAgICBzdGF0ZS5kcHYgPSBnZXRVbml0VmVjdG9yKGR4LCBkeSk7XG59XG5cbi8vIEdFVElORk9bXSBHRVQgSU5GT3JtYXRpb25cbi8vIDB4ODhcbmZ1bmN0aW9uIEdFVElORk8oc3RhdGUpIHtcbiAgICBjb25zdCBzdGFjayA9IHN0YXRlLnN0YWNrO1xuICAgIGNvbnN0IHNlbCA9IHN0YWNrLnBvcCgpO1xuICAgIGxldCByID0gMDtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnR0VUSU5GT1tdJywgc2VsKTtcblxuICAgIC8vIHYzNSBhcyBpbiBubyBzdWJwaXhlbCBoaW50aW5nXG4gICAgaWYgKHNlbCAmIDB4MDEpIHIgPSAzNTtcblxuICAgIC8vIFRPRE8gcm90YXRpb24gYW5kIHN0cmV0Y2ggY3VycmVudGx5IG5vdCBzdXBwb3J0ZWRcbiAgICAvLyBhbmQgdGh1cyB0aG9zZSBHRVRJTkZPIGFyZSBhbHdheXMgMC5cblxuICAgIC8vIG9wZW50eXBlLmpzIGlzIGFsd2F5cyBncmF5IHNjYWxpbmdcbiAgICBpZiAoc2VsICYgMHgyMCkgciB8PSAweDEwMDA7XG5cbiAgICBzdGFjay5wdXNoKHIpO1xufVxuXG4vLyBST0xMW10gUk9MTCB0aGUgdG9wIHRocmVlIHN0YWNrIGVsZW1lbnRzXG4vLyAweDhBXG5mdW5jdGlvbiBST0xMKHN0YXRlKSB7XG4gICAgY29uc3Qgc3RhY2sgPSBzdGF0ZS5zdGFjaztcbiAgICBjb25zdCBhID0gc3RhY2sucG9wKCk7XG4gICAgY29uc3QgYiA9IHN0YWNrLnBvcCgpO1xuICAgIGNvbnN0IGMgPSBzdGFjay5wb3AoKTtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnUk9MTFtdJyk7XG5cbiAgICBzdGFjay5wdXNoKGIpO1xuICAgIHN0YWNrLnB1c2goYSk7XG4gICAgc3RhY2sucHVzaChjKTtcbn1cblxuLy8gTUFYW10gTUFYaW11bSBvZiB0b3AgdHdvIHN0YWNrIGVsZW1lbnRzXG4vLyAweDhCXG5mdW5jdGlvbiBNQVgoc3RhdGUpIHtcbiAgICBjb25zdCBzdGFjayA9IHN0YXRlLnN0YWNrO1xuICAgIGNvbnN0IGUyID0gc3RhY2sucG9wKCk7XG4gICAgY29uc3QgZTEgPSBzdGFjay5wb3AoKTtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnTUFYW10nLCBlMiwgZTEpO1xuXG4gICAgc3RhY2sucHVzaChNYXRoLm1heChlMSwgZTIpKTtcbn1cblxuLy8gTUlOW10gTUlOaW11bSBvZiB0b3AgdHdvIHN0YWNrIGVsZW1lbnRzXG4vLyAweDhDXG5mdW5jdGlvbiBNSU4oc3RhdGUpIHtcbiAgICBjb25zdCBzdGFjayA9IHN0YXRlLnN0YWNrO1xuICAgIGNvbnN0IGUyID0gc3RhY2sucG9wKCk7XG4gICAgY29uc3QgZTEgPSBzdGFjay5wb3AoKTtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnTUlOW10nLCBlMiwgZTEpO1xuXG4gICAgc3RhY2sucHVzaChNYXRoLm1pbihlMSwgZTIpKTtcbn1cblxuLy8gU0NBTlRZUEVbXSBTQ0FOVFlQRVxuLy8gMHg4RFxuZnVuY3Rpb24gU0NBTlRZUEUoc3RhdGUpIHtcbiAgICBjb25zdCBuID0gc3RhdGUuc3RhY2sucG9wKCk7XG4gICAgLy8gaWdub3JlZCBieSBvcGVudHlwZS5qc1xuICAgIGlmIChleHBvcnRzLkRFQlVHKSBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnU0NBTlRZUEVbXScsIG4pO1xufVxuXG4vLyBJTlNUQ1RSTFtdIElOU1RDVFJMXG4vLyAweDhEXG5mdW5jdGlvbiBJTlNUQ1RSTChzdGF0ZSkge1xuICAgIGNvbnN0IHMgPSBzdGF0ZS5zdGFjay5wb3AoKTtcbiAgICBsZXQgdiA9IHN0YXRlLnN0YWNrLnBvcCgpO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdJTlNUQ1RSTFtdJywgcywgdik7XG5cbiAgICBzd2l0Y2ggKHMpIHtcbiAgICAgICAgY2FzZSAxIDogc3RhdGUuaW5oaWJpdEdyaWRGaXQgPSAhIXY7IHJldHVybjtcbiAgICAgICAgY2FzZSAyIDogc3RhdGUuaWdub3JlQ3Z0ID0gISF2OyByZXR1cm47XG4gICAgICAgIGRlZmF1bHQ6IHRocm93IG5ldyBFcnJvcignaW52YWxpZCBJTlNUQ1RSTFtdIHNlbGVjdG9yJyk7XG4gICAgfVxufVxuXG4vLyBQVVNIQlthYmNdIFBVU0ggQnl0ZXNcbi8vIDB4QjAtMHhCN1xuZnVuY3Rpb24gUFVTSEIobiwgc3RhdGUpIHtcbiAgICBjb25zdCBzdGFjayA9IHN0YXRlLnN0YWNrO1xuICAgIGNvbnN0IHByb2cgPSBzdGF0ZS5wcm9nO1xuICAgIGxldCBpcCA9IHN0YXRlLmlwO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdQVVNIQlsnICsgbiArICddJyk7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG47IGkrKykgc3RhY2sucHVzaChwcm9nWysraXBdKTtcblxuICAgIHN0YXRlLmlwID0gaXA7XG59XG5cbi8vIFBVU0hXW2FiY10gUFVTSCBXb3Jkc1xuLy8gMHhCOC0weEJGXG5mdW5jdGlvbiBQVVNIVyhuLCBzdGF0ZSkge1xuICAgIGxldCBpcCA9IHN0YXRlLmlwO1xuICAgIGNvbnN0IHByb2cgPSBzdGF0ZS5wcm9nO1xuICAgIGNvbnN0IHN0YWNrID0gc3RhdGUuc3RhY2s7XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgY29uc29sZS5sb2coc3RhdGUuaXAsICdQVVNIV1snICsgbiArICddJyk7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgICBsZXQgdyA9IChwcm9nWysraXBdIDw8IDgpIHwgcHJvZ1srK2lwXTtcbiAgICAgICAgaWYgKHcgJiAweDgwMDApIHcgPSAtKCh3IF4gMHhmZmZmKSArIDEpO1xuICAgICAgICBzdGFjay5wdXNoKHcpO1xuICAgIH1cblxuICAgIHN0YXRlLmlwID0gaXA7XG59XG5cbi8vIE1EUlBbYWJjZGVdIE1vdmUgRGlyZWN0IFJlbGF0aXZlIFBvaW50XG4vLyAweEQwLTB4RUZcbi8vIChpZiBpbmRpcmVjdCBpcyAwKVxuLy9cbi8vIGFuZFxuLy9cbi8vIE1JUlBbYWJjZGVdIE1vdmUgSW5kaXJlY3QgUmVsYXRpdmUgUG9pbnRcbi8vIDB4RTAtMHhGRlxuLy8gKGlmIGluZGlyZWN0IGlzIDEpXG5cbmZ1bmN0aW9uIE1EUlBfTUlSUChpbmRpcmVjdCwgc2V0UnAwLCBrZWVwRCwgcm8sIGR0LCBzdGF0ZSkge1xuICAgIGNvbnN0IHN0YWNrID0gc3RhdGUuc3RhY2s7XG4gICAgY29uc3QgY3Z0ZSA9IGluZGlyZWN0ICYmIHN0YWNrLnBvcCgpO1xuICAgIGNvbnN0IHBpID0gc3RhY2sucG9wKCk7XG4gICAgY29uc3QgcnAwaSA9IHN0YXRlLnJwMDtcbiAgICBjb25zdCBycCA9IHN0YXRlLnowW3JwMGldO1xuICAgIGNvbnN0IHAgPSBzdGF0ZS56MVtwaV07XG5cbiAgICBjb25zdCBtZCA9IHN0YXRlLm1pbkRpcztcbiAgICBjb25zdCBmdiA9IHN0YXRlLmZ2O1xuICAgIGNvbnN0IHB2ID0gc3RhdGUuZHB2O1xuICAgIGxldCBvZDsgLy8gb3JpZ2luYWwgZGlzdGFuY2VcbiAgICBsZXQgZDsgLy8gbW92aW5nIGRpc3RhbmNlXG4gICAgbGV0IHNpZ247IC8vIHNpZ24gb2YgZGlzdGFuY2VcbiAgICBsZXQgY3Y7XG5cbiAgICBkID0gb2QgPSBwdi5kaXN0YW5jZShwLCBycCwgdHJ1ZSwgdHJ1ZSk7XG4gICAgc2lnbiA9IGQgPj0gMCA/IDEgOiAtMTsgLy8gTWF0aC5zaWduIHdvdWxkIGJlIDAgaW4gY2FzZSBvZiAwXG5cbiAgICAvLyBUT0RPIGNvbnNpZGVyIGF1dG9GbGlwXG4gICAgZCA9IE1hdGguYWJzKGQpO1xuXG4gICAgaWYgKGluZGlyZWN0KSB7XG4gICAgICAgIGN2ID0gc3RhdGUuY3Z0W2N2dGVdO1xuXG4gICAgICAgIGlmIChybyAmJiBNYXRoLmFicyhkIC0gY3YpIDwgc3RhdGUuY3ZDdXRJbikgZCA9IGN2O1xuICAgIH1cblxuICAgIGlmIChrZWVwRCAmJiBkIDwgbWQpIGQgPSBtZDtcblxuICAgIGlmIChybykgZCA9IHN0YXRlLnJvdW5kKGQpO1xuXG4gICAgZnYuc2V0UmVsYXRpdmUocCwgcnAsIHNpZ24gKiBkLCBwdik7XG4gICAgZnYudG91Y2gocCk7XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykge1xuICAgICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgICAgIHN0YXRlLnN0ZXAsXG4gICAgICAgICAgICAoaW5kaXJlY3QgPyAnTUlSUFsnIDogJ01EUlBbJykgK1xuICAgICAgICAgICAgKHNldFJwMCA/ICdNJyA6ICdtJykgK1xuICAgICAgICAgICAgKGtlZXBEID8gJz4nIDogJ18nKSArXG4gICAgICAgICAgICAocm8gPyAnUicgOiAnXycpICtcbiAgICAgICAgICAgIChkdCA9PT0gMCA/ICdHcicgOiAoZHQgPT09IDEgPyAnQmwnIDogKGR0ID09PSAyID8gJ1doJyA6ICcnKSkpICtcbiAgICAgICAgICAgICddJyxcbiAgICAgICAgICAgIGluZGlyZWN0ID9cbiAgICAgICAgICAgICAgICBjdnRlICsgJygnICsgc3RhdGUuY3Z0W2N2dGVdICsgJywnICsgIGN2ICsgJyknIDpcbiAgICAgICAgICAgICAgICAnJyxcbiAgICAgICAgICAgIHBpLFxuICAgICAgICAgICAgJyhkID0nLCBvZCwgJy0+Jywgc2lnbiAqIGQsICcpJ1xuICAgICAgICApO1xuICAgIH1cblxuICAgIHN0YXRlLnJwMSA9IHN0YXRlLnJwMDtcbiAgICBzdGF0ZS5ycDIgPSBwaTtcbiAgICBpZiAoc2V0UnAwKSBzdGF0ZS5ycDAgPSBwaTtcbn1cblxuLypcbiogVGhlIGluc3RydWN0aW9uIHRhYmxlLlxuKi9cbmluc3RydWN0aW9uVGFibGUgPSBbXG4gICAgLyogMHgwMCAqLyBTVlRDQS5iaW5kKHVuZGVmaW5lZCwgeVVuaXRWZWN0b3IpLFxuICAgIC8qIDB4MDEgKi8gU1ZUQ0EuYmluZCh1bmRlZmluZWQsIHhVbml0VmVjdG9yKSxcbiAgICAvKiAweDAyICovIFNQVlRDQS5iaW5kKHVuZGVmaW5lZCwgeVVuaXRWZWN0b3IpLFxuICAgIC8qIDB4MDMgKi8gU1BWVENBLmJpbmQodW5kZWZpbmVkLCB4VW5pdFZlY3RvciksXG4gICAgLyogMHgwNCAqLyBTRlZUQ0EuYmluZCh1bmRlZmluZWQsIHlVbml0VmVjdG9yKSxcbiAgICAvKiAweDA1ICovIFNGVlRDQS5iaW5kKHVuZGVmaW5lZCwgeFVuaXRWZWN0b3IpLFxuICAgIC8qIDB4MDYgKi8gU1BWVEwuYmluZCh1bmRlZmluZWQsIDApLFxuICAgIC8qIDB4MDcgKi8gU1BWVEwuYmluZCh1bmRlZmluZWQsIDEpLFxuICAgIC8qIDB4MDggKi8gU0ZWVEwuYmluZCh1bmRlZmluZWQsIDApLFxuICAgIC8qIDB4MDkgKi8gU0ZWVEwuYmluZCh1bmRlZmluZWQsIDEpLFxuICAgIC8qIDB4MEEgKi8gU1BWRlMsXG4gICAgLyogMHgwQiAqLyBTRlZGUyxcbiAgICAvKiAweDBDICovIEdQVixcbiAgICAvKiAweDBEICovIEdGVixcbiAgICAvKiAweDBFICovIFNGVlRQVixcbiAgICAvKiAweDBGICovIElTRUNULFxuICAgIC8qIDB4MTAgKi8gU1JQMCxcbiAgICAvKiAweDExICovIFNSUDEsXG4gICAgLyogMHgxMiAqLyBTUlAyLFxuICAgIC8qIDB4MTMgKi8gU1pQMCxcbiAgICAvKiAweDE0ICovIFNaUDEsXG4gICAgLyogMHgxNSAqLyBTWlAyLFxuICAgIC8qIDB4MTYgKi8gU1pQUyxcbiAgICAvKiAweDE3ICovIFNMT09QLFxuICAgIC8qIDB4MTggKi8gUlRHLFxuICAgIC8qIDB4MTkgKi8gUlRIRyxcbiAgICAvKiAweDFBICovIFNNRCxcbiAgICAvKiAweDFCICovIEVMU0UsXG4gICAgLyogMHgxQyAqLyBKTVBSLFxuICAgIC8qIDB4MUQgKi8gU0NWVENJLFxuICAgIC8qIDB4MUUgKi8gdW5kZWZpbmVkLCAgIC8vIFRPRE8gU1NXQ0lcbiAgICAvKiAweDFGICovIHVuZGVmaW5lZCwgICAvLyBUT0RPIFNTV1xuICAgIC8qIDB4MjAgKi8gRFVQLFxuICAgIC8qIDB4MjEgKi8gUE9QLFxuICAgIC8qIDB4MjIgKi8gQ0xFQVIsXG4gICAgLyogMHgyMyAqLyBTV0FQLFxuICAgIC8qIDB4MjQgKi8gREVQVEgsXG4gICAgLyogMHgyNSAqLyBDSU5ERVgsXG4gICAgLyogMHgyNiAqLyBNSU5ERVgsXG4gICAgLyogMHgyNyAqLyB1bmRlZmluZWQsICAgLy8gVE9ETyBBTElHTlBUU1xuICAgIC8qIDB4MjggKi8gdW5kZWZpbmVkLFxuICAgIC8qIDB4MjkgKi8gdW5kZWZpbmVkLCAgIC8vIFRPRE8gVVRQXG4gICAgLyogMHgyQSAqLyBMT09QQ0FMTCxcbiAgICAvKiAweDJCICovIENBTEwsXG4gICAgLyogMHgyQyAqLyBGREVGLFxuICAgIC8qIDB4MkQgKi8gdW5kZWZpbmVkLCAgIC8vIEVOREYgKGVhdGVuIGJ5IEZERUYpXG4gICAgLyogMHgyRSAqLyBNREFQLmJpbmQodW5kZWZpbmVkLCAwKSxcbiAgICAvKiAweDJGICovIE1EQVAuYmluZCh1bmRlZmluZWQsIDEpLFxuICAgIC8qIDB4MzAgKi8gSVVQLmJpbmQodW5kZWZpbmVkLCB5VW5pdFZlY3RvciksXG4gICAgLyogMHgzMSAqLyBJVVAuYmluZCh1bmRlZmluZWQsIHhVbml0VmVjdG9yKSxcbiAgICAvKiAweDMyICovIFNIUC5iaW5kKHVuZGVmaW5lZCwgMCksXG4gICAgLyogMHgzMyAqLyBTSFAuYmluZCh1bmRlZmluZWQsIDEpLFxuICAgIC8qIDB4MzQgKi8gU0hDLmJpbmQodW5kZWZpbmVkLCAwKSxcbiAgICAvKiAweDM1ICovIFNIQy5iaW5kKHVuZGVmaW5lZCwgMSksXG4gICAgLyogMHgzNiAqLyBTSFouYmluZCh1bmRlZmluZWQsIDApLFxuICAgIC8qIDB4MzcgKi8gU0haLmJpbmQodW5kZWZpbmVkLCAxKSxcbiAgICAvKiAweDM4ICovIFNIUElYLFxuICAgIC8qIDB4MzkgKi8gSVAsXG4gICAgLyogMHgzQSAqLyBNU0lSUC5iaW5kKHVuZGVmaW5lZCwgMCksXG4gICAgLyogMHgzQiAqLyBNU0lSUC5iaW5kKHVuZGVmaW5lZCwgMSksXG4gICAgLyogMHgzQyAqLyBBTElHTlJQLFxuICAgIC8qIDB4M0QgKi8gUlRERyxcbiAgICAvKiAweDNFICovIE1JQVAuYmluZCh1bmRlZmluZWQsIDApLFxuICAgIC8qIDB4M0YgKi8gTUlBUC5iaW5kKHVuZGVmaW5lZCwgMSksXG4gICAgLyogMHg0MCAqLyBOUFVTSEIsXG4gICAgLyogMHg0MSAqLyBOUFVTSFcsXG4gICAgLyogMHg0MiAqLyBXUyxcbiAgICAvKiAweDQzICovIFJTLFxuICAgIC8qIDB4NDQgKi8gV0NWVFAsXG4gICAgLyogMHg0NSAqLyBSQ1ZULFxuICAgIC8qIDB4NDYgKi8gR0MuYmluZCh1bmRlZmluZWQsIDApLFxuICAgIC8qIDB4NDcgKi8gR0MuYmluZCh1bmRlZmluZWQsIDEpLFxuICAgIC8qIDB4NDggKi8gdW5kZWZpbmVkLCAgIC8vIFRPRE8gU0NGU1xuICAgIC8qIDB4NDkgKi8gTUQuYmluZCh1bmRlZmluZWQsIDApLFxuICAgIC8qIDB4NEEgKi8gTUQuYmluZCh1bmRlZmluZWQsIDEpLFxuICAgIC8qIDB4NEIgKi8gTVBQRU0sXG4gICAgLyogMHg0QyAqLyB1bmRlZmluZWQsICAgLy8gVE9ETyBNUFNcbiAgICAvKiAweDREICovIEZMSVBPTixcbiAgICAvKiAweDRFICovIHVuZGVmaW5lZCwgICAvLyBUT0RPIEZMSVBPRkZcbiAgICAvKiAweDRGICovIHVuZGVmaW5lZCwgICAvLyBUT0RPIERFQlVHXG4gICAgLyogMHg1MCAqLyBMVCxcbiAgICAvKiAweDUxICovIExURVEsXG4gICAgLyogMHg1MiAqLyBHVCxcbiAgICAvKiAweDUzICovIEdURVEsXG4gICAgLyogMHg1NCAqLyBFUSxcbiAgICAvKiAweDU1ICovIE5FUSxcbiAgICAvKiAweDU2ICovIE9ERCxcbiAgICAvKiAweDU3ICovIEVWRU4sXG4gICAgLyogMHg1OCAqLyBJRixcbiAgICAvKiAweDU5ICovIEVJRixcbiAgICAvKiAweDVBICovIEFORCxcbiAgICAvKiAweDVCICovIE9SLFxuICAgIC8qIDB4NUMgKi8gTk9ULFxuICAgIC8qIDB4NUQgKi8gREVMVEFQMTIzLmJpbmQodW5kZWZpbmVkLCAxKSxcbiAgICAvKiAweDVFICovIFNEQixcbiAgICAvKiAweDVGICovIFNEUyxcbiAgICAvKiAweDYwICovIEFERCxcbiAgICAvKiAweDYxICovIFNVQixcbiAgICAvKiAweDYyICovIERJVixcbiAgICAvKiAweDYzICovIE1VTCxcbiAgICAvKiAweDY0ICovIEFCUyxcbiAgICAvKiAweDY1ICovIE5FRyxcbiAgICAvKiAweDY2ICovIEZMT09SLFxuICAgIC8qIDB4NjcgKi8gQ0VJTElORyxcbiAgICAvKiAweDY4ICovIFJPVU5ELmJpbmQodW5kZWZpbmVkLCAwKSxcbiAgICAvKiAweDY5ICovIFJPVU5ELmJpbmQodW5kZWZpbmVkLCAxKSxcbiAgICAvKiAweDZBICovIFJPVU5ELmJpbmQodW5kZWZpbmVkLCAyKSxcbiAgICAvKiAweDZCICovIFJPVU5ELmJpbmQodW5kZWZpbmVkLCAzKSxcbiAgICAvKiAweDZDICovIHVuZGVmaW5lZCwgICAvLyBUT0RPIE5ST1VORFthYl1cbiAgICAvKiAweDZEICovIHVuZGVmaW5lZCwgICAvLyBUT0RPIE5ST1VORFthYl1cbiAgICAvKiAweDZFICovIHVuZGVmaW5lZCwgICAvLyBUT0RPIE5ST1VORFthYl1cbiAgICAvKiAweDZGICovIHVuZGVmaW5lZCwgICAvLyBUT0RPIE5ST1VORFthYl1cbiAgICAvKiAweDcwICovIFdDVlRGLFxuICAgIC8qIDB4NzEgKi8gREVMVEFQMTIzLmJpbmQodW5kZWZpbmVkLCAyKSxcbiAgICAvKiAweDcyICovIERFTFRBUDEyMy5iaW5kKHVuZGVmaW5lZCwgMyksXG4gICAgLyogMHg3MyAqLyBERUxUQUMxMjMuYmluZCh1bmRlZmluZWQsIDEpLFxuICAgIC8qIDB4NzQgKi8gREVMVEFDMTIzLmJpbmQodW5kZWZpbmVkLCAyKSxcbiAgICAvKiAweDc1ICovIERFTFRBQzEyMy5iaW5kKHVuZGVmaW5lZCwgMyksXG4gICAgLyogMHg3NiAqLyBTUk9VTkQsXG4gICAgLyogMHg3NyAqLyBTNDVST1VORCxcbiAgICAvKiAweDc4ICovIHVuZGVmaW5lZCwgICAvLyBUT0RPIEpST1RbXVxuICAgIC8qIDB4NzkgKi8gdW5kZWZpbmVkLCAgIC8vIFRPRE8gSlJPRltdXG4gICAgLyogMHg3QSAqLyBST0ZGLFxuICAgIC8qIDB4N0IgKi8gdW5kZWZpbmVkLFxuICAgIC8qIDB4N0MgKi8gUlVURyxcbiAgICAvKiAweDdEICovIFJEVEcsXG4gICAgLyogMHg3RSAqLyBQT1AsIC8vIGFjdHVhbGx5IFNBTkdXLCBzdXBwb3NlZCB0byBkbyBvbmx5IGEgcG9wIHRob3VnaFxuICAgIC8qIDB4N0YgKi8gUE9QLCAvLyBhY3R1YWxseSBBQSwgc3VwcG9zZWQgdG8gZG8gb25seSBhIHBvcCB0aG91Z2hcbiAgICAvKiAweDgwICovIHVuZGVmaW5lZCwgICAvLyBUT0RPIEZMSVBQVFxuICAgIC8qIDB4ODEgKi8gdW5kZWZpbmVkLCAgIC8vIFRPRE8gRkxJUFJHT05cbiAgICAvKiAweDgyICovIHVuZGVmaW5lZCwgICAvLyBUT0RPIEZMSVBSR09GRlxuICAgIC8qIDB4ODMgKi8gdW5kZWZpbmVkLFxuICAgIC8qIDB4ODQgKi8gdW5kZWZpbmVkLFxuICAgIC8qIDB4ODUgKi8gU0NBTkNUUkwsXG4gICAgLyogMHg4NiAqLyBTRFBWVEwuYmluZCh1bmRlZmluZWQsIDApLFxuICAgIC8qIDB4ODcgKi8gU0RQVlRMLmJpbmQodW5kZWZpbmVkLCAxKSxcbiAgICAvKiAweDg4ICovIEdFVElORk8sXG4gICAgLyogMHg4OSAqLyB1bmRlZmluZWQsICAgLy8gVE9ETyBJREVGXG4gICAgLyogMHg4QSAqLyBST0xMLFxuICAgIC8qIDB4OEIgKi8gTUFYLFxuICAgIC8qIDB4OEMgKi8gTUlOLFxuICAgIC8qIDB4OEQgKi8gU0NBTlRZUEUsXG4gICAgLyogMHg4RSAqLyBJTlNUQ1RSTCxcbiAgICAvKiAweDhGICovIHVuZGVmaW5lZCxcbiAgICAvKiAweDkwICovIHVuZGVmaW5lZCxcbiAgICAvKiAweDkxICovIHVuZGVmaW5lZCxcbiAgICAvKiAweDkyICovIHVuZGVmaW5lZCxcbiAgICAvKiAweDkzICovIHVuZGVmaW5lZCxcbiAgICAvKiAweDk0ICovIHVuZGVmaW5lZCxcbiAgICAvKiAweDk1ICovIHVuZGVmaW5lZCxcbiAgICAvKiAweDk2ICovIHVuZGVmaW5lZCxcbiAgICAvKiAweDk3ICovIHVuZGVmaW5lZCxcbiAgICAvKiAweDk4ICovIHVuZGVmaW5lZCxcbiAgICAvKiAweDk5ICovIHVuZGVmaW5lZCxcbiAgICAvKiAweDlBICovIHVuZGVmaW5lZCxcbiAgICAvKiAweDlCICovIHVuZGVmaW5lZCxcbiAgICAvKiAweDlDICovIHVuZGVmaW5lZCxcbiAgICAvKiAweDlEICovIHVuZGVmaW5lZCxcbiAgICAvKiAweDlFICovIHVuZGVmaW5lZCxcbiAgICAvKiAweDlGICovIHVuZGVmaW5lZCxcbiAgICAvKiAweEEwICovIHVuZGVmaW5lZCxcbiAgICAvKiAweEExICovIHVuZGVmaW5lZCxcbiAgICAvKiAweEEyICovIHVuZGVmaW5lZCxcbiAgICAvKiAweEEzICovIHVuZGVmaW5lZCxcbiAgICAvKiAweEE0ICovIHVuZGVmaW5lZCxcbiAgICAvKiAweEE1ICovIHVuZGVmaW5lZCxcbiAgICAvKiAweEE2ICovIHVuZGVmaW5lZCxcbiAgICAvKiAweEE3ICovIHVuZGVmaW5lZCxcbiAgICAvKiAweEE4ICovIHVuZGVmaW5lZCxcbiAgICAvKiAweEE5ICovIHVuZGVmaW5lZCxcbiAgICAvKiAweEFBICovIHVuZGVmaW5lZCxcbiAgICAvKiAweEFCICovIHVuZGVmaW5lZCxcbiAgICAvKiAweEFDICovIHVuZGVmaW5lZCxcbiAgICAvKiAweEFEICovIHVuZGVmaW5lZCxcbiAgICAvKiAweEFFICovIHVuZGVmaW5lZCxcbiAgICAvKiAweEFGICovIHVuZGVmaW5lZCxcbiAgICAvKiAweEIwICovIFBVU0hCLmJpbmQodW5kZWZpbmVkLCAxKSxcbiAgICAvKiAweEIxICovIFBVU0hCLmJpbmQodW5kZWZpbmVkLCAyKSxcbiAgICAvKiAweEIyICovIFBVU0hCLmJpbmQodW5kZWZpbmVkLCAzKSxcbiAgICAvKiAweEIzICovIFBVU0hCLmJpbmQodW5kZWZpbmVkLCA0KSxcbiAgICAvKiAweEI0ICovIFBVU0hCLmJpbmQodW5kZWZpbmVkLCA1KSxcbiAgICAvKiAweEI1ICovIFBVU0hCLmJpbmQodW5kZWZpbmVkLCA2KSxcbiAgICAvKiAweEI2ICovIFBVU0hCLmJpbmQodW5kZWZpbmVkLCA3KSxcbiAgICAvKiAweEI3ICovIFBVU0hCLmJpbmQodW5kZWZpbmVkLCA4KSxcbiAgICAvKiAweEI4ICovIFBVU0hXLmJpbmQodW5kZWZpbmVkLCAxKSxcbiAgICAvKiAweEI5ICovIFBVU0hXLmJpbmQodW5kZWZpbmVkLCAyKSxcbiAgICAvKiAweEJBICovIFBVU0hXLmJpbmQodW5kZWZpbmVkLCAzKSxcbiAgICAvKiAweEJCICovIFBVU0hXLmJpbmQodW5kZWZpbmVkLCA0KSxcbiAgICAvKiAweEJDICovIFBVU0hXLmJpbmQodW5kZWZpbmVkLCA1KSxcbiAgICAvKiAweEJEICovIFBVU0hXLmJpbmQodW5kZWZpbmVkLCA2KSxcbiAgICAvKiAweEJFICovIFBVU0hXLmJpbmQodW5kZWZpbmVkLCA3KSxcbiAgICAvKiAweEJGICovIFBVU0hXLmJpbmQodW5kZWZpbmVkLCA4KSxcbiAgICAvKiAweEMwICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMCwgMCwgMCwgMCwgMCksXG4gICAgLyogMHhDMSAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDAsIDAsIDAsIDAsIDEpLFxuICAgIC8qIDB4QzIgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAwLCAwLCAwLCAwLCAyKSxcbiAgICAvKiAweEMzICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMCwgMCwgMCwgMCwgMyksXG4gICAgLyogMHhDNCAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDAsIDAsIDAsIDEsIDApLFxuICAgIC8qIDB4QzUgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAwLCAwLCAwLCAxLCAxKSxcbiAgICAvKiAweEM2ICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMCwgMCwgMCwgMSwgMiksXG4gICAgLyogMHhDNyAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDAsIDAsIDAsIDEsIDMpLFxuICAgIC8qIDB4QzggKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAwLCAwLCAxLCAwLCAwKSxcbiAgICAvKiAweEM5ICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMCwgMCwgMSwgMCwgMSksXG4gICAgLyogMHhDQSAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDAsIDAsIDEsIDAsIDIpLFxuICAgIC8qIDB4Q0IgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAwLCAwLCAxLCAwLCAzKSxcbiAgICAvKiAweENDICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMCwgMCwgMSwgMSwgMCksXG4gICAgLyogMHhDRCAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDAsIDAsIDEsIDEsIDEpLFxuICAgIC8qIDB4Q0UgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAwLCAwLCAxLCAxLCAyKSxcbiAgICAvKiAweENGICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMCwgMCwgMSwgMSwgMyksXG4gICAgLyogMHhEMCAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDAsIDEsIDAsIDAsIDApLFxuICAgIC8qIDB4RDEgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAwLCAxLCAwLCAwLCAxKSxcbiAgICAvKiAweEQyICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMCwgMSwgMCwgMCwgMiksXG4gICAgLyogMHhEMyAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDAsIDEsIDAsIDAsIDMpLFxuICAgIC8qIDB4RDQgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAwLCAxLCAwLCAxLCAwKSxcbiAgICAvKiAweEQ1ICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMCwgMSwgMCwgMSwgMSksXG4gICAgLyogMHhENiAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDAsIDEsIDAsIDEsIDIpLFxuICAgIC8qIDB4RDcgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAwLCAxLCAwLCAxLCAzKSxcbiAgICAvKiAweEQ4ICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMCwgMSwgMSwgMCwgMCksXG4gICAgLyogMHhEOSAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDAsIDEsIDEsIDAsIDEpLFxuICAgIC8qIDB4REEgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAwLCAxLCAxLCAwLCAyKSxcbiAgICAvKiAweERCICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMCwgMSwgMSwgMCwgMyksXG4gICAgLyogMHhEQyAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDAsIDEsIDEsIDEsIDApLFxuICAgIC8qIDB4REQgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAwLCAxLCAxLCAxLCAxKSxcbiAgICAvKiAweERFICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMCwgMSwgMSwgMSwgMiksXG4gICAgLyogMHhERiAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDAsIDEsIDEsIDEsIDMpLFxuICAgIC8qIDB4RTAgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAxLCAwLCAwLCAwLCAwKSxcbiAgICAvKiAweEUxICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMSwgMCwgMCwgMCwgMSksXG4gICAgLyogMHhFMiAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDEsIDAsIDAsIDAsIDIpLFxuICAgIC8qIDB4RTMgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAxLCAwLCAwLCAwLCAzKSxcbiAgICAvKiAweEU0ICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMSwgMCwgMCwgMSwgMCksXG4gICAgLyogMHhFNSAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDEsIDAsIDAsIDEsIDEpLFxuICAgIC8qIDB4RTYgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAxLCAwLCAwLCAxLCAyKSxcbiAgICAvKiAweEU3ICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMSwgMCwgMCwgMSwgMyksXG4gICAgLyogMHhFOCAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDEsIDAsIDEsIDAsIDApLFxuICAgIC8qIDB4RTkgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAxLCAwLCAxLCAwLCAxKSxcbiAgICAvKiAweEVBICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMSwgMCwgMSwgMCwgMiksXG4gICAgLyogMHhFQiAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDEsIDAsIDEsIDAsIDMpLFxuICAgIC8qIDB4RUMgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAxLCAwLCAxLCAxLCAwKSxcbiAgICAvKiAweEVEICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMSwgMCwgMSwgMSwgMSksXG4gICAgLyogMHhFRSAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDEsIDAsIDEsIDEsIDIpLFxuICAgIC8qIDB4RUYgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAxLCAwLCAxLCAxLCAzKSxcbiAgICAvKiAweEYwICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMSwgMSwgMCwgMCwgMCksXG4gICAgLyogMHhGMSAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDEsIDEsIDAsIDAsIDEpLFxuICAgIC8qIDB4RjIgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAxLCAxLCAwLCAwLCAyKSxcbiAgICAvKiAweEYzICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMSwgMSwgMCwgMCwgMyksXG4gICAgLyogMHhGNCAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDEsIDEsIDAsIDEsIDApLFxuICAgIC8qIDB4RjUgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAxLCAxLCAwLCAxLCAxKSxcbiAgICAvKiAweEY2ICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMSwgMSwgMCwgMSwgMiksXG4gICAgLyogMHhGNyAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDEsIDEsIDAsIDEsIDMpLFxuICAgIC8qIDB4RjggKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAxLCAxLCAxLCAwLCAwKSxcbiAgICAvKiAweEY5ICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMSwgMSwgMSwgMCwgMSksXG4gICAgLyogMHhGQSAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDEsIDEsIDEsIDAsIDIpLFxuICAgIC8qIDB4RkIgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAxLCAxLCAxLCAwLCAzKSxcbiAgICAvKiAweEZDICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMSwgMSwgMSwgMSwgMCksXG4gICAgLyogMHhGRCAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDEsIDEsIDEsIDEsIDEpLFxuICAgIC8qIDB4RkUgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAxLCAxLCAxLCAxLCAyKSxcbiAgICAvKiAweEZGICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMSwgMSwgMSwgMSwgMylcbl07XG5cbmV4cG9ydCBkZWZhdWx0IEhpbnRpbmc7XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICBNYXRoZW1hdGljYWwgQ29uc2lkZXJhdGlvbnNcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuXG5mdiAuLi4gcmVmZXJzIHRvIGZyZWVkb20gdmVjdG9yXG5wdiAuLi4gcmVmZXJzIHRvIHByb2plY3Rpb24gdmVjdG9yXG5ycCAuLi4gcmVmZXJzIHRvIHJlZmVyZW5jZSBwb2ludFxucCAgLi4uIHJlZmVycyB0byB0byBwb2ludCBiZWluZyBvcGVyYXRlZCBvblxuZCAgLi4uIHJlZmVycyB0byBkaXN0YW5jZVxuXG5TRVRSRUxBVElWRTpcbj09PT09PT09PT09PVxuXG5jYXNlIGZyZWVkb20gdmVjdG9yID09IHgtYXhpczpcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAocHYpXG4gICAgICAgICAgICAgICAgICAgICAuLSdcbiAgICAgICAgICAgICAgcnBkIC4tJ1xuICAgICAgICAgICAgICAgLi0qXG4gICAgICAgICAgZCAuLSc5MMKwJ1xuICAgICAgICAgLi0nICAgICAgICdcbiAgICAgIC4tJyAgICAgICAgICAgJ1xuICAgKi0nICAgICAgICAgICAgICAgJyBiXG4gIHJwICAgICAgICAgICAgICAgICAgJ1xuICAgICAgICAgICAgICAgICAgICAgICAnXG4gICAgICAgICAgICAgICAgICAgICAgICAnXG4gICAgICAgICAgICBwICotLS0tLS0tLS0tKi0tLS0tLS0tLS0tLS0tIChmdilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcG1cblxuICBycGR4ID0gcnB4ICsgZCAqIHB2LnhcbiAgcnBkeSA9IHJweSArIGQgKiBwdi55XG5cbiAgZXF1YXRpb24gb2YgbGluZSBiXG5cbiAgIHkgLSBycGR5ID0gcHZucyAqICh4LSBycGR4KVxuXG4gICB5ID0gcC55XG5cbiAgIHggPSBycGR4ICsgKCBwLnkgLSBycGR5ICkgLyBwdm5zXG5cblxuY2FzZSBmcmVlZG9tIHZlY3RvciA9PSB5LWF4aXM6XG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgICogcG1cbiAgICB8XFxcbiAgICB8IFxcXG4gICAgfCAgXFxcbiAgICB8ICAgXFxcbiAgICB8ICAgIFxcXG4gICAgfCAgICAgXFxcbiAgICB8ICAgICAgXFxcbiAgICB8ICAgICAgIFxcXG4gICAgfCAgICAgICAgXFxcbiAgICB8ICAgICAgICAgXFwgYlxuICAgIHwgICAgICAgICAgXFxcbiAgICB8ICAgICAgICAgICBcXFxuICAgIHwgICAgICAgICAgICBcXCAgICAuLScgKHB2KVxuICAgIHwgICAgICAgICA5MMKwIFxcLi0nXG4gICAgfCAgICAgICAgICAgLi0nKiBycGRcbiAgICB8ICAgICAgICAuLSdcbiAgICAqICAgICAqLScgIGRcbiAgICBwICAgICBycFxuXG4gIHJwZHggPSBycHggKyBkICogcHYueFxuICBycGR5ID0gcnB5ICsgZCAqIHB2LnlcblxuICBlcXVhdGlvbiBvZiBsaW5lIGI6XG4gICAgICAgICAgIHB2bnMgLi4uIG5vcm1hbCBzbG9wZSB0byBwdlxuXG4gICB5IC0gcnBkeSA9IHB2bnMgKiAoeCAtIHJwZHgpXG5cbiAgIHggPSBwLnhcblxuICAgeSA9IHJwZHkgKyAgcHZucyAqIChwLnggLSBycGR4KVxuXG5cblxuZ2VuZXJpYyBjYXNlOlxuLS0tLS0tLS0tLS0tLVxuXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4nKGZ2KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4nXG4gICAgICAgICAgICAgICAgICAgICAgICAgIC4qIHBtXG4gICAgICAgICAgICAgICAgICAgICAgICAuJyAhXG4gICAgICAgICAgICAgICAgICAgICAgLicgICAgLlxuICAgICAgICAgICAgICAgICAgICAuJyAgICAgICFcbiAgICAgICAgICAgICAgICAgIC4nICAgICAgICAgLiBiXG4gICAgICAgICAgICAgICAgLicgICAgICAgICAgICFcbiAgICAgICAgICAgICAgICogICAgICAgICAgICAgIC5cbiAgICAgICAgICAgICAgcCAgICAgICAgICAgICAgICFcbiAgICAgICAgICAgICAgICAgICAgICAgICA5MMKwICAgLiAgICAuLi4gKHB2KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4uLSotJycnXG4gICAgICAgICAgICAgICAgICAuLi4tLS0nJycgICAgcnBkXG4gICAgICAgICAuLi4tLS0nJycgICBkXG4gICAqLS0nJydcbiAgcnBcblxuICAgIHJwZHggPSBycHggKyBkICogcHYueFxuICAgIHJwZHkgPSBycHkgKyBkICogcHYueVxuXG4gZXF1YXRpb24gb2YgbGluZSBiOlxuICAgIHB2bnMuLi4gbm9ybWFsIHNsb3BlIHRvIHB2XG5cbiAgICB5IC0gcnBkeSA9IHB2bnMgKiAoeCAtIHJwZHgpXG5cbiBlcXVhdGlvbiBvZiBmcmVlZG9tIHZlY3RvciBsaW5lOlxuICAgIGZ2cyAuLi4gc2xvcGUgb2YgZnJlZWRvbSB2ZWN0b3IgKD1meS9meClcblxuICAgIHkgLSBweSA9IGZ2cyAqICh4IC0gcHgpXG5cblxuICBvbiBwbSBib3RoIGVxdWF0aW9ucyBhcmUgdHJ1ZSBmb3Igc2FtZSB4L3lcblxuICAgIHkgLSBycGR5ID0gcHZucyAqICh4IC0gcnBkeClcblxuICAgIHkgLSBweSA9IGZ2cyAqICh4IC0gcHgpXG5cbiAgZm9ybSB0byB5IGFuZCBzZXQgZXF1YWw6XG5cbiAgICBwdm5zICogKHggLSBycGR4KSArIHJwZHkgPSBmdnMgKiAoeCAtIHB4KSArIHB5XG5cbiAgZXhwYW5kOlxuXG4gICAgcHZucyAqIHggLSBwdm5zICogcnBkeCArIHJwZHkgPSBmdnMgKiB4IC0gZnZzICogcHggKyBweVxuXG4gIHN3aXRjaDpcblxuICAgIGZ2cyAqIHggLSBmdnMgKiBweCArIHB5ID0gcHZucyAqIHggLSBwdm5zICogcnBkeCArIHJwZHlcblxuICBzb2x2ZSBmb3IgeDpcblxuICAgIGZ2cyAqIHggLSBwdm5zICogeCA9IGZ2cyAqIHB4IC0gcHZucyAqIHJwZHggLSBweSArIHJwZHlcblxuXG5cbiAgICAgICAgICBmdnMgKiBweCAtIHB2bnMgKiBycGR4ICsgcnBkeSAtIHB5XG4gICAgeCA9ICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAgICAgICAgICBmdnMgLSBwdm5zXG5cbiAgYW5kOlxuXG4gICAgeSA9IGZ2cyAqICh4IC0gcHgpICsgcHlcblxuXG5cbklOVEVSUE9MQVRFOlxuPT09PT09PT09PT09XG5cbkV4YW1wbGVzIG9mIHBvaW50IGludGVycG9sYXRpb24uXG5cblRoZSB3ZWlnaHQgb2YgdGhlIG1vdmVtZW50IG9mIHRoZSByZWZlcmVuY2UgcG9pbnQgZ2V0cyBiaWdnZXJcbnRoZSBmdXJ0aGVyIHRoZSBvdGhlciByZWZlcmVuY2UgcG9pbnQgaXMgYXdheSwgdGh1cyB0aGUgc2FmZXN0XG5vcHRpb24gKHRoYXQgaXMgYXZvaWRpbmcgMC8wIGRpdmlzaW9ucykgaXMgdG8gd2VpZ2h0IHRoZVxub3JpZ2luYWwgZGlzdGFuY2Ugb2YgdGhlIG90aGVyIHBvaW50IGJ5IHRoZSBzdW0gb2YgYm90aCBkaXN0YW5jZXMuXG5cbklmIHRoZSBzdW0gb2YgYm90aCBkaXN0YW5jZXMgaXMgMCwgdGhlbiBtb3ZlIHRoZSBwb2ludCBieSB0aGVcbmFyaXRobWV0aWMgYXZlcmFnZSBvZiB0aGUgbW92ZW1lbnQgb2YgYm90aCByZWZlcmVuY2UgcG9pbnRzLlxuXG5cblxuXG4gICAgICAgICAgICgrNilcbiAgICBycDFvICotLS0tPipycDFcbiAgICAgICAgIC4gICAgIC4gICAgICAgICAgICAgICAgICAgICAgICAgICgrMTIpXG4gICAgICAgICAuICAgICAuICAgICAgICAgICAgICAgICAgcnAybyAqLS0tLS0tLS0tLT4qIHJwMlxuICAgICAgICAgLiAgICAgLiAgICAgICAgICAgICAgICAgICAgICAgLiAgICAgICAgICAgLlxuICAgICAgICAgLiAgICAgLiAgICAgICAgICAgICAgICAgICAgICAgLiAgICAgICAgICAgLlxuICAgICAgICAgLiAgICAxMCAgICAgICAgICAyMCAgICAgICAgICAgLiAgICAgICAgICAgLlxuICAgICAgICAgfC4uLi4uLi4uLnwuLi4uLi4uLi4uLi4uLi4uLi4ufCAgICAgICAgICAgLlxuICAgICAgICAgICAgICAgLiAgIC4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLlxuICAgICAgICAgICAgICAgLiAgIC4gKCs4KSAgICAgICAgICAgICAgICAgICAgICAgICAgLlxuICAgICAgICAgICAgICAgIHBvICotLS0tLS0+KnAgICAgICAgICAgICAgICAgICAgICAgLlxuICAgICAgICAgICAgICAgLiAgICAgICAgICAgLiAgICAgICAgICAgICAgICAgICAgICAgLlxuICAgICAgICAgICAgICAgLiAgICAxMiAgICAgLiAgICAgICAgICAyNCAgICAgICAgICAgLlxuICAgICAgICAgICAgICAgfC4uLi4uLi4uLi4ufC4uLi4uLi4uLi4uLi4uLi4uLi4uLi4ufFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDM2XG5cblxuLS0tLS0tLVxuXG5cblxuICAgICAgICAgICAoKzEwKVxuICAgIHJwMW8gKi0tLS0tLS0tPipycDFcbiAgICAgICAgIC4gICAgICAgICAuICAgICAgICAgICAgICAgICAgICAgICgtMTApXG4gICAgICAgICAuICAgICAgICAgLiAgICAgICAgICAgICAgcnAyICo8LS0tLS0tLS0tKiBycG8yXG4gICAgICAgICAuICAgICAgICAgLiAgICAgICAgICAgICAgICAgICAuICAgICAgICAgLlxuICAgICAgICAgLiAgICAgICAgIC4gICAgICAgICAgICAgICAgICAgLiAgICAgICAgIC5cbiAgICAgICAgIC4gICAgMTAgICAuICAgICAgICAgIDMwICAgICAgIC4gICAgICAgICAuXG4gICAgICAgICB8Li4uLi4uLi4ufC4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4ufFxuICAgICAgICAgICAgICAgICAgIC4gICAgICAgICAgICAgICAgICAgLlxuICAgICAgICAgICAgICAgICAgIC4gKCs1KSAgICAgICAgICAgICAgLlxuICAgICAgICAgICAgICAgIHBvICotLS0+KiBwICAgICAgICAgICAgLlxuICAgICAgICAgICAgICAgICAgIC4gICAgLiAgICAgICAgICAgICAgLlxuICAgICAgICAgICAgICAgICAgIC4gICAgLiAgIDIwICAgICAgICAgLlxuICAgICAgICAgICAgICAgICAgIHwuLi4ufC4uLi4uLi4uLi4uLi4ufFxuICAgICAgICAgICAgICAgICAgICAgNSAgICAgICAgMTVcblxuXG4tLS0tLS0tXG5cblxuICAgICAgICAgICAoKzEwKVxuICAgIHJwMW8gKi0tLS0tLS0tPipycDFcbiAgICAgICAgIC4gICAgICAgICAuXG4gICAgICAgICAuICAgICAgICAgLlxuICAgIHJwMm8gKi0tLS0tLS0tPipycDJcblxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCsxMClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcG8gKi0tLS0tLS0tPiogcFxuXG4tLS0tLS0tXG5cblxuICAgICAgICAgICAoKzEwKVxuICAgIHJwMW8gKi0tLS0tLS0tPipycDFcbiAgICAgICAgIC4gICAgICAgICAuXG4gICAgICAgICAuICAgICAgICAgLigrMzApXG4gICAgcnAybyAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLT4qcnAyXG5cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgrMjUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHBvICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLT4qIHBcblxuXG5cbnZpbTogc2V0IHRzPTQgc3c9NCBleHBhbmR0YWI6XG4qKioqKi9cbiIsIi8vIFRoZSBGb250IG9iamVjdFxuXG5pbXBvcnQgUGF0aCBmcm9tICcuL3BhdGgnO1xuaW1wb3J0IHNmbnQgZnJvbSAnLi90YWJsZXMvc2ZudCc7XG5pbXBvcnQgeyBEZWZhdWx0RW5jb2RpbmcgfSBmcm9tICcuL2VuY29kaW5nJztcbmltcG9ydCBnbHlwaHNldCBmcm9tICcuL2dseXBoc2V0JztcbmltcG9ydCBTdWJzdGl0dXRpb24gZnJvbSAnLi9zdWJzdGl0dXRpb24nO1xuaW1wb3J0IHsgaXNCcm93c2VyLCBjaGVja0FyZ3VtZW50LCBhcnJheUJ1ZmZlclRvTm9kZUJ1ZmZlciB9IGZyb20gJy4vdXRpbCc7XG5pbXBvcnQgSGludGluZ1RydWVUeXBlIGZyb20gJy4vaGludGluZ3R0JztcblxuLyoqXG4gKiBAdHlwZWRlZiBGb250T3B0aW9uc1xuICogQHR5cGUgT2JqZWN0XG4gKiBAcHJvcGVydHkge0Jvb2xlYW59IGVtcHR5IC0gd2hldGhlciB0byBjcmVhdGUgYSBuZXcgZW1wdHkgZm9udFxuICogQHByb3BlcnR5IHtzdHJpbmd9IGZhbWlseU5hbWVcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBzdHlsZU5hbWVcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nPX0gZnVsbE5hbWVcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nPX0gcG9zdFNjcmlwdE5hbWVcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nPX0gZGVzaWduZXJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nPX0gZGVzaWduZXJVUkxcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nPX0gbWFudWZhY3R1cmVyXG4gKiBAcHJvcGVydHkge3N0cmluZz19IG1hbnVmYWN0dXJlclVSTFxuICogQHByb3BlcnR5IHtzdHJpbmc9fSBsaWNlbnNlXG4gKiBAcHJvcGVydHkge3N0cmluZz19IGxpY2Vuc2VVUkxcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nPX0gdmVyc2lvblxuICogQHByb3BlcnR5IHtzdHJpbmc9fSBkZXNjcmlwdGlvblxuICogQHByb3BlcnR5IHtzdHJpbmc9fSBjb3B5cmlnaHRcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nPX0gdHJhZGVtYXJrXG4gKiBAcHJvcGVydHkge051bWJlcn0gdW5pdHNQZXJFbVxuICogQHByb3BlcnR5IHtOdW1iZXJ9IGFzY2VuZGVyXG4gKiBAcHJvcGVydHkge051bWJlcn0gZGVzY2VuZGVyXG4gKiBAcHJvcGVydHkge051bWJlcn0gY3JlYXRlZFRpbWVzdGFtcFxuICogQHByb3BlcnR5IHtzdHJpbmc9fSB3ZWlnaHRDbGFzc1xuICogQHByb3BlcnR5IHtzdHJpbmc9fSB3aWR0aENsYXNzXG4gKiBAcHJvcGVydHkge3N0cmluZz19IGZzU2VsZWN0aW9uXG4gKi9cblxuLyoqXG4gKiBBIEZvbnQgcmVwcmVzZW50cyBhIGxvYWRlZCBPcGVuVHlwZSBmb250IGZpbGUuXG4gKiBJdCBjb250YWlucyBhIHNldCBvZiBnbHlwaHMgYW5kIG1ldGhvZHMgdG8gZHJhdyB0ZXh0IG9uIGEgZHJhd2luZyBjb250ZXh0LFxuICogb3IgdG8gZ2V0IGEgcGF0aCByZXByZXNlbnRpbmcgdGhlIHRleHQuXG4gKiBAZXhwb3J0cyBvcGVudHlwZS5Gb250XG4gKiBAY2xhc3NcbiAqIEBwYXJhbSB7Rm9udE9wdGlvbnN9XG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gRm9udChvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICBpZiAoIW9wdGlvbnMuZW1wdHkpIHtcbiAgICAgICAgLy8gQ2hlY2sgdGhhdCB3ZSd2ZSBwcm92aWRlZCB0aGUgbWluaW11bSBzZXQgb2YgbmFtZXMuXG4gICAgICAgIGNoZWNrQXJndW1lbnQob3B0aW9ucy5mYW1pbHlOYW1lLCAnV2hlbiBjcmVhdGluZyBhIG5ldyBGb250IG9iamVjdCwgZmFtaWx5TmFtZSBpcyByZXF1aXJlZC4nKTtcbiAgICAgICAgY2hlY2tBcmd1bWVudChvcHRpb25zLnN0eWxlTmFtZSwgJ1doZW4gY3JlYXRpbmcgYSBuZXcgRm9udCBvYmplY3QsIHN0eWxlTmFtZSBpcyByZXF1aXJlZC4nKTtcbiAgICAgICAgY2hlY2tBcmd1bWVudChvcHRpb25zLnVuaXRzUGVyRW0sICdXaGVuIGNyZWF0aW5nIGEgbmV3IEZvbnQgb2JqZWN0LCB1bml0c1BlckVtIGlzIHJlcXVpcmVkLicpO1xuICAgICAgICBjaGVja0FyZ3VtZW50KG9wdGlvbnMuYXNjZW5kZXIsICdXaGVuIGNyZWF0aW5nIGEgbmV3IEZvbnQgb2JqZWN0LCBhc2NlbmRlciBpcyByZXF1aXJlZC4nKTtcbiAgICAgICAgY2hlY2tBcmd1bWVudChvcHRpb25zLmRlc2NlbmRlciwgJ1doZW4gY3JlYXRpbmcgYSBuZXcgRm9udCBvYmplY3QsIGRlc2NlbmRlciBpcyByZXF1aXJlZC4nKTtcbiAgICAgICAgY2hlY2tBcmd1bWVudChvcHRpb25zLmRlc2NlbmRlciA8IDAsICdEZXNjZW5kZXIgc2hvdWxkIGJlIG5lZ2F0aXZlIChlLmcuIC01MTIpLicpO1xuXG4gICAgICAgIC8vIE9TIFggd2lsbCBjb21wbGFpbiBpZiB0aGUgbmFtZXMgYXJlIGVtcHR5LCBzbyB3ZSBwdXQgYSBzaW5nbGUgc3BhY2UgZXZlcnl3aGVyZSBieSBkZWZhdWx0LlxuICAgICAgICB0aGlzLm5hbWVzID0ge1xuICAgICAgICAgICAgZm9udEZhbWlseToge2VuOiBvcHRpb25zLmZhbWlseU5hbWUgfHwgJyAnfSxcbiAgICAgICAgICAgIGZvbnRTdWJmYW1pbHk6IHtlbjogb3B0aW9ucy5zdHlsZU5hbWUgfHwgJyAnfSxcbiAgICAgICAgICAgIGZ1bGxOYW1lOiB7ZW46IG9wdGlvbnMuZnVsbE5hbWUgfHwgb3B0aW9ucy5mYW1pbHlOYW1lICsgJyAnICsgb3B0aW9ucy5zdHlsZU5hbWV9LFxuICAgICAgICAgICAgcG9zdFNjcmlwdE5hbWU6IHtlbjogb3B0aW9ucy5wb3N0U2NyaXB0TmFtZSB8fCBvcHRpb25zLmZhbWlseU5hbWUgKyBvcHRpb25zLnN0eWxlTmFtZX0sXG4gICAgICAgICAgICBkZXNpZ25lcjoge2VuOiBvcHRpb25zLmRlc2lnbmVyIHx8ICcgJ30sXG4gICAgICAgICAgICBkZXNpZ25lclVSTDoge2VuOiBvcHRpb25zLmRlc2lnbmVyVVJMIHx8ICcgJ30sXG4gICAgICAgICAgICBtYW51ZmFjdHVyZXI6IHtlbjogb3B0aW9ucy5tYW51ZmFjdHVyZXIgfHwgJyAnfSxcbiAgICAgICAgICAgIG1hbnVmYWN0dXJlclVSTDoge2VuOiBvcHRpb25zLm1hbnVmYWN0dXJlclVSTCB8fCAnICd9LFxuICAgICAgICAgICAgbGljZW5zZToge2VuOiBvcHRpb25zLmxpY2Vuc2UgfHwgJyAnfSxcbiAgICAgICAgICAgIGxpY2Vuc2VVUkw6IHtlbjogb3B0aW9ucy5saWNlbnNlVVJMIHx8ICcgJ30sXG4gICAgICAgICAgICB2ZXJzaW9uOiB7ZW46IG9wdGlvbnMudmVyc2lvbiB8fCAnVmVyc2lvbiAwLjEnfSxcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiB7ZW46IG9wdGlvbnMuZGVzY3JpcHRpb24gfHwgJyAnfSxcbiAgICAgICAgICAgIGNvcHlyaWdodDoge2VuOiBvcHRpb25zLmNvcHlyaWdodCB8fCAnICd9LFxuICAgICAgICAgICAgdHJhZGVtYXJrOiB7ZW46IG9wdGlvbnMudHJhZGVtYXJrIHx8ICcgJ31cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy51bml0c1BlckVtID0gb3B0aW9ucy51bml0c1BlckVtIHx8IDEwMDA7XG4gICAgICAgIHRoaXMuYXNjZW5kZXIgPSBvcHRpb25zLmFzY2VuZGVyO1xuICAgICAgICB0aGlzLmRlc2NlbmRlciA9IG9wdGlvbnMuZGVzY2VuZGVyO1xuICAgICAgICB0aGlzLmNyZWF0ZWRUaW1lc3RhbXAgPSBvcHRpb25zLmNyZWF0ZWRUaW1lc3RhbXA7XG4gICAgICAgIHRoaXMudGFibGVzID0geyBvczI6IHtcbiAgICAgICAgICAgIHVzV2VpZ2h0Q2xhc3M6IG9wdGlvbnMud2VpZ2h0Q2xhc3MgfHwgdGhpcy51c1dlaWdodENsYXNzZXMuTUVESVVNLFxuICAgICAgICAgICAgdXNXaWR0aENsYXNzOiBvcHRpb25zLndpZHRoQ2xhc3MgfHwgdGhpcy51c1dpZHRoQ2xhc3Nlcy5NRURJVU0sXG4gICAgICAgICAgICBmc1NlbGVjdGlvbjogb3B0aW9ucy5mc1NlbGVjdGlvbiB8fCB0aGlzLmZzU2VsZWN0aW9uVmFsdWVzLlJFR1VMQVJcbiAgICAgICAgfSB9O1xuICAgIH1cblxuICAgIHRoaXMuc3VwcG9ydGVkID0gdHJ1ZTsgLy8gRGVwcmVjYXRlZDogcGFyc2VCdWZmZXIgd2lsbCB0aHJvdyBhbiBlcnJvciBpZiBmb250IGlzIG5vdCBzdXBwb3J0ZWQuXG4gICAgdGhpcy5nbHlwaHMgPSBuZXcgZ2x5cGhzZXQuR2x5cGhTZXQodGhpcywgb3B0aW9ucy5nbHlwaHMgfHwgW10pO1xuICAgIHRoaXMuZW5jb2RpbmcgPSBuZXcgRGVmYXVsdEVuY29kaW5nKHRoaXMpO1xuICAgIHRoaXMuc3Vic3RpdHV0aW9uID0gbmV3IFN1YnN0aXR1dGlvbih0aGlzKTtcbiAgICB0aGlzLnRhYmxlcyA9IHRoaXMudGFibGVzIHx8IHt9O1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdoaW50aW5nJywge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2hpbnRpbmcpIHJldHVybiB0aGlzLl9oaW50aW5nO1xuICAgICAgICAgICAgaWYgKHRoaXMub3V0bGluZXNGb3JtYXQgPT09ICd0cnVldHlwZScpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKHRoaXMuX2hpbnRpbmcgPSBuZXcgSGludGluZ1RydWVUeXBlKHRoaXMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xufVxuXG4vKipcbiAqIENoZWNrIGlmIHRoZSBmb250IGhhcyBhIGdseXBoIGZvciB0aGUgZ2l2ZW4gY2hhcmFjdGVyLlxuICogQHBhcmFtICB7c3RyaW5nfVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuRm9udC5wcm90b3R5cGUuaGFzQ2hhciA9IGZ1bmN0aW9uKGMpIHtcbiAgICByZXR1cm4gdGhpcy5lbmNvZGluZy5jaGFyVG9HbHlwaEluZGV4KGMpICE9PSBudWxsO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0IHRoZSBnaXZlbiBjaGFyYWN0ZXIgdG8gYSBzaW5nbGUgZ2x5cGggaW5kZXguXG4gKiBOb3RlIHRoYXQgdGhpcyBmdW5jdGlvbiBhc3N1bWVzIHRoYXQgdGhlcmUgaXMgYSBvbmUtdG8tb25lIG1hcHBpbmcgYmV0d2VlblxuICogdGhlIGdpdmVuIGNoYXJhY3RlciBhbmQgYSBnbHlwaDsgZm9yIGNvbXBsZXggc2NyaXB0cyB0aGlzIG1pZ2h0IG5vdCBiZSB0aGUgY2FzZS5cbiAqIEBwYXJhbSAge3N0cmluZ31cbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuRm9udC5wcm90b3R5cGUuY2hhclRvR2x5cGhJbmRleCA9IGZ1bmN0aW9uKHMpIHtcbiAgICByZXR1cm4gdGhpcy5lbmNvZGluZy5jaGFyVG9HbHlwaEluZGV4KHMpO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0IHRoZSBnaXZlbiBjaGFyYWN0ZXIgdG8gYSBzaW5nbGUgR2x5cGggb2JqZWN0LlxuICogTm90ZSB0aGF0IHRoaXMgZnVuY3Rpb24gYXNzdW1lcyB0aGF0IHRoZXJlIGlzIGEgb25lLXRvLW9uZSBtYXBwaW5nIGJldHdlZW5cbiAqIHRoZSBnaXZlbiBjaGFyYWN0ZXIgYW5kIGEgZ2x5cGg7IGZvciBjb21wbGV4IHNjcmlwdHMgdGhpcyBtaWdodCBub3QgYmUgdGhlIGNhc2UuXG4gKiBAcGFyYW0gIHtzdHJpbmd9XG4gKiBAcmV0dXJuIHtvcGVudHlwZS5HbHlwaH1cbiAqL1xuRm9udC5wcm90b3R5cGUuY2hhclRvR2x5cGggPSBmdW5jdGlvbihjKSB7XG4gICAgY29uc3QgZ2x5cGhJbmRleCA9IHRoaXMuY2hhclRvR2x5cGhJbmRleChjKTtcbiAgICBsZXQgZ2x5cGggPSB0aGlzLmdseXBocy5nZXQoZ2x5cGhJbmRleCk7XG4gICAgaWYgKCFnbHlwaCkge1xuICAgICAgICAvLyAubm90ZGVmXG4gICAgICAgIGdseXBoID0gdGhpcy5nbHlwaHMuZ2V0KDApO1xuICAgIH1cblxuICAgIHJldHVybiBnbHlwaDtcbn07XG5cbi8qKlxuICogQ29udmVydCB0aGUgZ2l2ZW4gdGV4dCB0byBhIGxpc3Qgb2YgR2x5cGggb2JqZWN0cy5cbiAqIE5vdGUgdGhhdCB0aGVyZSBpcyBubyBzdHJpY3Qgb25lLXRvLW9uZSBtYXBwaW5nIGJldHdlZW4gY2hhcmFjdGVycyBhbmRcbiAqIGdseXBocywgc28gdGhlIGxpc3Qgb2YgcmV0dXJuZWQgZ2x5cGhzIGNhbiBiZSBsYXJnZXIgb3Igc21hbGxlciB0aGFuIHRoZVxuICogbGVuZ3RoIG9mIHRoZSBnaXZlbiBzdHJpbmcuXG4gKiBAcGFyYW0gIHtzdHJpbmd9XG4gKiBAcGFyYW0gIHtHbHlwaFJlbmRlck9wdGlvbnN9IFtvcHRpb25zXVxuICogQHJldHVybiB7b3BlbnR5cGUuR2x5cGhbXX1cbiAqL1xuRm9udC5wcm90b3R5cGUuc3RyaW5nVG9HbHlwaHMgPSBmdW5jdGlvbihzLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgdGhpcy5kZWZhdWx0UmVuZGVyT3B0aW9ucztcbiAgICAvLyBHZXQgZ2x5cGggaW5kZXhlc1xuICAgIGNvbnN0IGluZGV4ZXMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgY29uc3QgYyA9IHNbaV07XG4gICAgICAgIGluZGV4ZXMucHVzaCh0aGlzLmNoYXJUb0dseXBoSW5kZXgoYykpO1xuICAgIH1cbiAgICBsZXQgbGVuZ3RoID0gaW5kZXhlcy5sZW5ndGg7XG5cbiAgICAvLyBBcHBseSBzdWJzdGl0dXRpb25zIG9uIGdseXBoIGluZGV4ZXNcbiAgICBpZiAob3B0aW9ucy5mZWF0dXJlcykge1xuICAgICAgICBjb25zdCBzY3JpcHQgPSBvcHRpb25zLnNjcmlwdCB8fCB0aGlzLnN1YnN0aXR1dGlvbi5nZXREZWZhdWx0U2NyaXB0TmFtZSgpO1xuICAgICAgICBsZXQgbWFueVRvT25lID0gW107XG4gICAgICAgIGlmIChvcHRpb25zLmZlYXR1cmVzLmxpZ2EpIG1hbnlUb09uZSA9IG1hbnlUb09uZS5jb25jYXQodGhpcy5zdWJzdGl0dXRpb24uZ2V0RmVhdHVyZSgnbGlnYScsIHNjcmlwdCwgb3B0aW9ucy5sYW5ndWFnZSkpO1xuICAgICAgICBpZiAob3B0aW9ucy5mZWF0dXJlcy5ybGlnKSBtYW55VG9PbmUgPSBtYW55VG9PbmUuY29uY2F0KHRoaXMuc3Vic3RpdHV0aW9uLmdldEZlYXR1cmUoJ3JsaWcnLCBzY3JpcHQsIG9wdGlvbnMubGFuZ3VhZ2UpKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBtYW55VG9PbmUubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBsaWdhdHVyZSA9IG1hbnlUb09uZVtqXTtcbiAgICAgICAgICAgICAgICBjb25zdCBjb21wb25lbnRzID0gbGlnYXR1cmUuc3ViO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbXBDb3VudCA9IGNvbXBvbmVudHMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGxldCBrID0gMDtcbiAgICAgICAgICAgICAgICB3aGlsZSAoayA8IGNvbXBDb3VudCAmJiBjb21wb25lbnRzW2tdID09PSBpbmRleGVzW2kgKyBrXSkgaysrO1xuICAgICAgICAgICAgICAgIGlmIChrID09PSBjb21wQ291bnQpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXhlcy5zcGxpY2UoaSwgY29tcENvdW50LCBsaWdhdHVyZS5ieSk7XG4gICAgICAgICAgICAgICAgICAgIGxlbmd0aCA9IGxlbmd0aCAtIGNvbXBDb3VudCArIDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gY29udmVydCBnbHlwaCBpbmRleGVzIHRvIGdseXBoIG9iamVjdHNcbiAgICBjb25zdCBnbHlwaHMgPSBuZXcgQXJyYXkobGVuZ3RoKTtcbiAgICBjb25zdCBub3RkZWYgPSB0aGlzLmdseXBocy5nZXQoMCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBnbHlwaHNbaV0gPSB0aGlzLmdseXBocy5nZXQoaW5kZXhlc1tpXSkgfHwgbm90ZGVmO1xuICAgIH1cbiAgICByZXR1cm4gZ2x5cGhzO1xufTtcblxuLyoqXG4gKiBAcGFyYW0gIHtzdHJpbmd9XG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cbkZvbnQucHJvdG90eXBlLm5hbWVUb0dseXBoSW5kZXggPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2x5cGhOYW1lcy5uYW1lVG9HbHlwaEluZGV4KG5hbWUpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0gIHtzdHJpbmd9XG4gKiBAcmV0dXJuIHtvcGVudHlwZS5HbHlwaH1cbiAqL1xuRm9udC5wcm90b3R5cGUubmFtZVRvR2x5cGggPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgY29uc3QgZ2x5cGhJbmRleCA9IHRoaXMubmFtZVRvR2x5cGhJbmRleChuYW1lKTtcbiAgICBsZXQgZ2x5cGggPSB0aGlzLmdseXBocy5nZXQoZ2x5cGhJbmRleCk7XG4gICAgaWYgKCFnbHlwaCkge1xuICAgICAgICAvLyAubm90ZGVmXG4gICAgICAgIGdseXBoID0gdGhpcy5nbHlwaHMuZ2V0KDApO1xuICAgIH1cblxuICAgIHJldHVybiBnbHlwaDtcbn07XG5cbi8qKlxuICogQHBhcmFtICB7TnVtYmVyfVxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5Gb250LnByb3RvdHlwZS5nbHlwaEluZGV4VG9OYW1lID0gZnVuY3Rpb24oZ2lkKSB7XG4gICAgaWYgKCF0aGlzLmdseXBoTmFtZXMuZ2x5cGhJbmRleFRvTmFtZSkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuZ2x5cGhOYW1lcy5nbHlwaEluZGV4VG9OYW1lKGdpZCk7XG59O1xuXG4vKipcbiAqIFJldHJpZXZlIHRoZSB2YWx1ZSBvZiB0aGUga2VybmluZyBwYWlyIGJldHdlZW4gdGhlIGxlZnQgZ2x5cGggKG9yIGl0cyBpbmRleClcbiAqIGFuZCB0aGUgcmlnaHQgZ2x5cGggKG9yIGl0cyBpbmRleCkuIElmIG5vIGtlcm5pbmcgcGFpciBpcyBmb3VuZCwgcmV0dXJuIDAuXG4gKiBUaGUga2VybmluZyB2YWx1ZSBnZXRzIGFkZGVkIHRvIHRoZSBhZHZhbmNlIHdpZHRoIHdoZW4gY2FsY3VsYXRpbmcgdGhlIHNwYWNpbmdcbiAqIGJldHdlZW4gZ2x5cGhzLlxuICogQHBhcmFtICB7b3BlbnR5cGUuR2x5cGh9IGxlZnRHbHlwaFxuICogQHBhcmFtICB7b3BlbnR5cGUuR2x5cGh9IHJpZ2h0R2x5cGhcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuRm9udC5wcm90b3R5cGUuZ2V0S2VybmluZ1ZhbHVlID0gZnVuY3Rpb24obGVmdEdseXBoLCByaWdodEdseXBoKSB7XG4gICAgbGVmdEdseXBoID0gbGVmdEdseXBoLmluZGV4IHx8IGxlZnRHbHlwaDtcbiAgICByaWdodEdseXBoID0gcmlnaHRHbHlwaC5pbmRleCB8fCByaWdodEdseXBoO1xuICAgIGNvbnN0IGdwb3NLZXJuaW5nID0gdGhpcy5nZXRHcG9zS2VybmluZ1ZhbHVlO1xuICAgIHJldHVybiBncG9zS2VybmluZyA/IGdwb3NLZXJuaW5nKGxlZnRHbHlwaCwgcmlnaHRHbHlwaCkgOlxuICAgICAgICAodGhpcy5rZXJuaW5nUGFpcnNbbGVmdEdseXBoICsgJywnICsgcmlnaHRHbHlwaF0gfHwgMCk7XG59O1xuXG4vKipcbiAqIEB0eXBlZGVmIEdseXBoUmVuZGVyT3B0aW9uc1xuICogQHR5cGUgT2JqZWN0XG4gKiBAcHJvcGVydHkge3N0cmluZ30gW3NjcmlwdF0gLSBzY3JpcHQgdXNlZCB0byBkZXRlcm1pbmUgd2hpY2ggZmVhdHVyZXMgdG8gYXBwbHkuIEJ5IGRlZmF1bHQsICdERkxUJyBvciAnbGF0bicgaXMgdXNlZC5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFNlZSBodHRwczovL3d3dy5taWNyb3NvZnQuY29tL3R5cG9ncmFwaHkvb3RzcGVjL3NjcmlwdHRhZ3MuaHRtXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW2xhbmd1YWdlPSdkZmx0J10gLSBsYW5ndWFnZSBzeXN0ZW0gdXNlZCB0byBkZXRlcm1pbmUgd2hpY2ggZmVhdHVyZXMgdG8gYXBwbHkuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBTZWUgaHR0cHM6Ly93d3cubWljcm9zb2Z0LmNvbS90eXBvZ3JhcGh5L2RldmVsb3BlcnMvb3BlbnR5cGUvbGFuZ3VhZ2V0YWdzLmFzcHhcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2tlcm5pbmc9dHJ1ZV0gLSB3aGV0aGVyIHRvIGluY2x1ZGUga2VybmluZyB2YWx1ZXNcbiAqIEBwcm9wZXJ0eSB7b2JqZWN0fSBbZmVhdHVyZXNdIC0gT3BlblR5cGUgTGF5b3V0IGZlYXR1cmUgdGFncy4gVXNlZCB0byBlbmFibGUgb3IgZGlzYWJsZSB0aGUgZmVhdHVyZXMgb2YgdGhlIGdpdmVuIHNjcmlwdC9sYW5ndWFnZSBzeXN0ZW0uXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFNlZSBodHRwczovL3d3dy5taWNyb3NvZnQuY29tL3R5cG9ncmFwaHkvb3RzcGVjL2ZlYXR1cmV0YWdzLmh0bVxuICovXG5Gb250LnByb3RvdHlwZS5kZWZhdWx0UmVuZGVyT3B0aW9ucyA9IHtcbiAgICBrZXJuaW5nOiB0cnVlLFxuICAgIGZlYXR1cmVzOiB7XG4gICAgICAgIGxpZ2E6IHRydWUsXG4gICAgICAgIHJsaWc6IHRydWVcbiAgICB9XG59O1xuXG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiB0aGF0IGludm9rZXMgdGhlIGdpdmVuIGNhbGxiYWNrIGZvciBlYWNoIGdseXBoIGluIHRoZSBnaXZlbiB0ZXh0LlxuICogVGhlIGNhbGxiYWNrIGdldHMgYChnbHlwaCwgeCwgeSwgZm9udFNpemUsIG9wdGlvbnMpYC4qIEBwYXJhbSAge3N0cmluZ30gdGV4dFxuICogQHBhcmFtIHtzdHJpbmd9IHRleHQgLSBUaGUgdGV4dCB0byBhcHBseS5cbiAqIEBwYXJhbSAge251bWJlcn0gW3g9MF0gLSBIb3Jpem9udGFsIHBvc2l0aW9uIG9mIHRoZSBiZWdpbm5pbmcgb2YgdGhlIHRleHQuXG4gKiBAcGFyYW0gIHtudW1iZXJ9IFt5PTBdIC0gVmVydGljYWwgcG9zaXRpb24gb2YgdGhlICpiYXNlbGluZSogb2YgdGhlIHRleHQuXG4gKiBAcGFyYW0gIHtudW1iZXJ9IFtmb250U2l6ZT03Ml0gLSBGb250IHNpemUgaW4gcGl4ZWxzLiBXZSBzY2FsZSB0aGUgZ2x5cGggdW5pdHMgYnkgYDEgLyB1bml0c1BlckVtICogZm9udFNpemVgLlxuICogQHBhcmFtICB7R2x5cGhSZW5kZXJPcHRpb25zPX0gb3B0aW9uc1xuICogQHBhcmFtICB7RnVuY3Rpb259IGNhbGxiYWNrXG4gKi9cbkZvbnQucHJvdG90eXBlLmZvckVhY2hHbHlwaCA9IGZ1bmN0aW9uKHRleHQsIHgsIHksIGZvbnRTaXplLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICAgIHggPSB4ICE9PSB1bmRlZmluZWQgPyB4IDogMDtcbiAgICB5ID0geSAhPT0gdW5kZWZpbmVkID8geSA6IDA7XG4gICAgZm9udFNpemUgPSBmb250U2l6ZSAhPT0gdW5kZWZpbmVkID8gZm9udFNpemUgOiA3MjtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB0aGlzLmRlZmF1bHRSZW5kZXJPcHRpb25zO1xuICAgIGNvbnN0IGZvbnRTY2FsZSA9IDEgLyB0aGlzLnVuaXRzUGVyRW0gKiBmb250U2l6ZTtcbiAgICBjb25zdCBnbHlwaHMgPSB0aGlzLnN0cmluZ1RvR2x5cGhzKHRleHQsIG9wdGlvbnMpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZ2x5cGhzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGNvbnN0IGdseXBoID0gZ2x5cGhzW2ldO1xuICAgICAgICBjYWxsYmFjay5jYWxsKHRoaXMsIGdseXBoLCB4LCB5LCBmb250U2l6ZSwgb3B0aW9ucyk7XG4gICAgICAgIGlmIChnbHlwaC5hZHZhbmNlV2lkdGgpIHtcbiAgICAgICAgICAgIHggKz0gZ2x5cGguYWR2YW5jZVdpZHRoICogZm9udFNjYWxlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wdGlvbnMua2VybmluZyAmJiBpIDwgZ2x5cGhzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgIGNvbnN0IGtlcm5pbmdWYWx1ZSA9IHRoaXMuZ2V0S2VybmluZ1ZhbHVlKGdseXBoLCBnbHlwaHNbaSArIDFdKTtcbiAgICAgICAgICAgIHggKz0ga2VybmluZ1ZhbHVlICogZm9udFNjYWxlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wdGlvbnMubGV0dGVyU3BhY2luZykge1xuICAgICAgICAgICAgeCArPSBvcHRpb25zLmxldHRlclNwYWNpbmcgKiBmb250U2l6ZTtcbiAgICAgICAgfSBlbHNlIGlmIChvcHRpb25zLnRyYWNraW5nKSB7XG4gICAgICAgICAgICB4ICs9IChvcHRpb25zLnRyYWNraW5nIC8gMTAwMCkgKiBmb250U2l6ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geDtcbn07XG5cbi8qKlxuICogQ3JlYXRlIGEgUGF0aCBvYmplY3QgdGhhdCByZXByZXNlbnRzIHRoZSBnaXZlbiB0ZXh0LlxuICogQHBhcmFtICB7c3RyaW5nfSB0ZXh0IC0gVGhlIHRleHQgdG8gY3JlYXRlLlxuICogQHBhcmFtICB7bnVtYmVyfSBbeD0wXSAtIEhvcml6b250YWwgcG9zaXRpb24gb2YgdGhlIGJlZ2lubmluZyBvZiB0aGUgdGV4dC5cbiAqIEBwYXJhbSAge251bWJlcn0gW3k9MF0gLSBWZXJ0aWNhbCBwb3NpdGlvbiBvZiB0aGUgKmJhc2VsaW5lKiBvZiB0aGUgdGV4dC5cbiAqIEBwYXJhbSAge251bWJlcn0gW2ZvbnRTaXplPTcyXSAtIEZvbnQgc2l6ZSBpbiBwaXhlbHMuIFdlIHNjYWxlIHRoZSBnbHlwaCB1bml0cyBieSBgMSAvIHVuaXRzUGVyRW0gKiBmb250U2l6ZWAuXG4gKiBAcGFyYW0gIHtHbHlwaFJlbmRlck9wdGlvbnM9fSBvcHRpb25zXG4gKiBAcmV0dXJuIHtvcGVudHlwZS5QYXRofVxuICovXG5Gb250LnByb3RvdHlwZS5nZXRQYXRoID0gZnVuY3Rpb24odGV4dCwgeCwgeSwgZm9udFNpemUsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBmdWxsUGF0aCA9IG5ldyBQYXRoKCk7XG4gICAgdGhpcy5mb3JFYWNoR2x5cGgodGV4dCwgeCwgeSwgZm9udFNpemUsIG9wdGlvbnMsIGZ1bmN0aW9uKGdseXBoLCBnWCwgZ1ksIGdGb250U2l6ZSkge1xuICAgICAgICBjb25zdCBnbHlwaFBhdGggPSBnbHlwaC5nZXRQYXRoKGdYLCBnWSwgZ0ZvbnRTaXplLCBvcHRpb25zLCB0aGlzKTtcbiAgICAgICAgZnVsbFBhdGguZXh0ZW5kKGdseXBoUGF0aCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGZ1bGxQYXRoO1xufTtcblxuLyoqXG4gKiBDcmVhdGUgYW4gYXJyYXkgb2YgUGF0aCBvYmplY3RzIHRoYXQgcmVwcmVzZW50IHRoZSBnbHlwaHMgb2YgYSBnaXZlbiB0ZXh0LlxuICogQHBhcmFtICB7c3RyaW5nfSB0ZXh0IC0gVGhlIHRleHQgdG8gY3JlYXRlLlxuICogQHBhcmFtICB7bnVtYmVyfSBbeD0wXSAtIEhvcml6b250YWwgcG9zaXRpb24gb2YgdGhlIGJlZ2lubmluZyBvZiB0aGUgdGV4dC5cbiAqIEBwYXJhbSAge251bWJlcn0gW3k9MF0gLSBWZXJ0aWNhbCBwb3NpdGlvbiBvZiB0aGUgKmJhc2VsaW5lKiBvZiB0aGUgdGV4dC5cbiAqIEBwYXJhbSAge251bWJlcn0gW2ZvbnRTaXplPTcyXSAtIEZvbnQgc2l6ZSBpbiBwaXhlbHMuIFdlIHNjYWxlIHRoZSBnbHlwaCB1bml0cyBieSBgMSAvIHVuaXRzUGVyRW0gKiBmb250U2l6ZWAuXG4gKiBAcGFyYW0gIHtHbHlwaFJlbmRlck9wdGlvbnM9fSBvcHRpb25zXG4gKiBAcmV0dXJuIHtvcGVudHlwZS5QYXRoW119XG4gKi9cbkZvbnQucHJvdG90eXBlLmdldFBhdGhzID0gZnVuY3Rpb24odGV4dCwgeCwgeSwgZm9udFNpemUsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBnbHlwaFBhdGhzID0gW107XG4gICAgdGhpcy5mb3JFYWNoR2x5cGgodGV4dCwgeCwgeSwgZm9udFNpemUsIG9wdGlvbnMsIGZ1bmN0aW9uKGdseXBoLCBnWCwgZ1ksIGdGb250U2l6ZSkge1xuICAgICAgICBjb25zdCBnbHlwaFBhdGggPSBnbHlwaC5nZXRQYXRoKGdYLCBnWSwgZ0ZvbnRTaXplLCBvcHRpb25zLCB0aGlzKTtcbiAgICAgICAgZ2x5cGhQYXRocy5wdXNoKGdseXBoUGF0aCk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gZ2x5cGhQYXRocztcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgYWR2YW5jZSB3aWR0aCBvZiBhIHRleHQuXG4gKlxuICogVGhpcyBpcyBzb21ldGhpbmcgZGlmZmVyZW50IHRoYW4gUGF0aC5nZXRCb3VuZGluZ0JveCgpIGFzIGZvciBleGFtcGxlIGFcbiAqIHN1ZmZpeGVkIHdoaXRlc3BhY2UgaW5jcmVhc2VzIHRoZSBhZHZhbmNlV2lkdGggYnV0IG5vdCB0aGUgYm91bmRpbmcgYm94XG4gKiBvciBhbiBvdmVyaGFuZ2luZyBsZXR0ZXIgbGlrZSBhIGNhbGxpZ3JhcGhpYyAnZicgbWlnaHQgaGF2ZSBhIHF1aXRlIGxhcmdlclxuICogYm91bmRpbmcgYm94IHRoYW4gaXRzIGFkdmFuY2Ugd2lkdGguXG4gKlxuICogVGhpcyBjb3JyZXNwb25kcyB0byBjYW52YXMyZENvbnRleHQubWVhc3VyZVRleHQodGV4dCkud2lkdGhcbiAqXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHRleHQgLSBUaGUgdGV4dCB0byBjcmVhdGUuXG4gKiBAcGFyYW0gIHtudW1iZXJ9IFtmb250U2l6ZT03Ml0gLSBGb250IHNpemUgaW4gcGl4ZWxzLiBXZSBzY2FsZSB0aGUgZ2x5cGggdW5pdHMgYnkgYDEgLyB1bml0c1BlckVtICogZm9udFNpemVgLlxuICogQHBhcmFtICB7R2x5cGhSZW5kZXJPcHRpb25zPX0gb3B0aW9uc1xuICogQHJldHVybiBhZHZhbmNlIHdpZHRoXG4gKi9cbkZvbnQucHJvdG90eXBlLmdldEFkdmFuY2VXaWR0aCA9IGZ1bmN0aW9uKHRleHQsIGZvbnRTaXplLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMuZm9yRWFjaEdseXBoKHRleHQsIDAsIDAsIGZvbnRTaXplLCBvcHRpb25zLCBmdW5jdGlvbigpIHt9KTtcbn07XG5cbi8qKlxuICogRHJhdyB0aGUgdGV4dCBvbiB0aGUgZ2l2ZW4gZHJhd2luZyBjb250ZXh0LlxuICogQHBhcmFtICB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggLSBBIDJEIGRyYXdpbmcgY29udGV4dCwgbGlrZSBDYW52YXMuXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHRleHQgLSBUaGUgdGV4dCB0byBjcmVhdGUuXG4gKiBAcGFyYW0gIHtudW1iZXJ9IFt4PTBdIC0gSG9yaXpvbnRhbCBwb3NpdGlvbiBvZiB0aGUgYmVnaW5uaW5nIG9mIHRoZSB0ZXh0LlxuICogQHBhcmFtICB7bnVtYmVyfSBbeT0wXSAtIFZlcnRpY2FsIHBvc2l0aW9uIG9mIHRoZSAqYmFzZWxpbmUqIG9mIHRoZSB0ZXh0LlxuICogQHBhcmFtICB7bnVtYmVyfSBbZm9udFNpemU9NzJdIC0gRm9udCBzaXplIGluIHBpeGVscy4gV2Ugc2NhbGUgdGhlIGdseXBoIHVuaXRzIGJ5IGAxIC8gdW5pdHNQZXJFbSAqIGZvbnRTaXplYC5cbiAqIEBwYXJhbSAge0dseXBoUmVuZGVyT3B0aW9ucz19IG9wdGlvbnNcbiAqL1xuRm9udC5wcm90b3R5cGUuZHJhdyA9IGZ1bmN0aW9uKGN0eCwgdGV4dCwgeCwgeSwgZm9udFNpemUsIG9wdGlvbnMpIHtcbiAgICB0aGlzLmdldFBhdGgodGV4dCwgeCwgeSwgZm9udFNpemUsIG9wdGlvbnMpLmRyYXcoY3R4KTtcbn07XG5cbi8qKlxuICogRHJhdyB0aGUgcG9pbnRzIG9mIGFsbCBnbHlwaHMgaW4gdGhlIHRleHQuXG4gKiBPbi1jdXJ2ZSBwb2ludHMgd2lsbCBiZSBkcmF3biBpbiBibHVlLCBvZmYtY3VydmUgcG9pbnRzIHdpbGwgYmUgZHJhd24gaW4gcmVkLlxuICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCAtIEEgMkQgZHJhd2luZyBjb250ZXh0LCBsaWtlIENhbnZhcy5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IC0gVGhlIHRleHQgdG8gY3JlYXRlLlxuICogQHBhcmFtIHtudW1iZXJ9IFt4PTBdIC0gSG9yaXpvbnRhbCBwb3NpdGlvbiBvZiB0aGUgYmVnaW5uaW5nIG9mIHRoZSB0ZXh0LlxuICogQHBhcmFtIHtudW1iZXJ9IFt5PTBdIC0gVmVydGljYWwgcG9zaXRpb24gb2YgdGhlICpiYXNlbGluZSogb2YgdGhlIHRleHQuXG4gKiBAcGFyYW0ge251bWJlcn0gW2ZvbnRTaXplPTcyXSAtIEZvbnQgc2l6ZSBpbiBwaXhlbHMuIFdlIHNjYWxlIHRoZSBnbHlwaCB1bml0cyBieSBgMSAvIHVuaXRzUGVyRW0gKiBmb250U2l6ZWAuXG4gKiBAcGFyYW0ge0dseXBoUmVuZGVyT3B0aW9ucz19IG9wdGlvbnNcbiAqL1xuRm9udC5wcm90b3R5cGUuZHJhd1BvaW50cyA9IGZ1bmN0aW9uKGN0eCwgdGV4dCwgeCwgeSwgZm9udFNpemUsIG9wdGlvbnMpIHtcbiAgICB0aGlzLmZvckVhY2hHbHlwaCh0ZXh0LCB4LCB5LCBmb250U2l6ZSwgb3B0aW9ucywgZnVuY3Rpb24oZ2x5cGgsIGdYLCBnWSwgZ0ZvbnRTaXplKSB7XG4gICAgICAgIGdseXBoLmRyYXdQb2ludHMoY3R4LCBnWCwgZ1ksIGdGb250U2l6ZSk7XG4gICAgfSk7XG59O1xuXG4vKipcbiAqIERyYXcgbGluZXMgaW5kaWNhdGluZyBpbXBvcnRhbnQgZm9udCBtZWFzdXJlbWVudHMgZm9yIGFsbCBnbHlwaHMgaW4gdGhlIHRleHQuXG4gKiBCbGFjayBsaW5lcyBpbmRpY2F0ZSB0aGUgb3JpZ2luIG9mIHRoZSBjb29yZGluYXRlIHN5c3RlbSAocG9pbnQgMCwwKS5cbiAqIEJsdWUgbGluZXMgaW5kaWNhdGUgdGhlIGdseXBoIGJvdW5kaW5nIGJveC5cbiAqIEdyZWVuIGxpbmUgaW5kaWNhdGVzIHRoZSBhZHZhbmNlIHdpZHRoIG9mIHRoZSBnbHlwaC5cbiAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggLSBBIDJEIGRyYXdpbmcgY29udGV4dCwgbGlrZSBDYW52YXMuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dCAtIFRoZSB0ZXh0IHRvIGNyZWF0ZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbeD0wXSAtIEhvcml6b250YWwgcG9zaXRpb24gb2YgdGhlIGJlZ2lubmluZyBvZiB0aGUgdGV4dC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbeT0wXSAtIFZlcnRpY2FsIHBvc2l0aW9uIG9mIHRoZSAqYmFzZWxpbmUqIG9mIHRoZSB0ZXh0LlxuICogQHBhcmFtIHtudW1iZXJ9IFtmb250U2l6ZT03Ml0gLSBGb250IHNpemUgaW4gcGl4ZWxzLiBXZSBzY2FsZSB0aGUgZ2x5cGggdW5pdHMgYnkgYDEgLyB1bml0c1BlckVtICogZm9udFNpemVgLlxuICogQHBhcmFtIHtHbHlwaFJlbmRlck9wdGlvbnM9fSBvcHRpb25zXG4gKi9cbkZvbnQucHJvdG90eXBlLmRyYXdNZXRyaWNzID0gZnVuY3Rpb24oY3R4LCB0ZXh0LCB4LCB5LCBmb250U2l6ZSwgb3B0aW9ucykge1xuICAgIHRoaXMuZm9yRWFjaEdseXBoKHRleHQsIHgsIHksIGZvbnRTaXplLCBvcHRpb25zLCBmdW5jdGlvbihnbHlwaCwgZ1gsIGdZLCBnRm9udFNpemUpIHtcbiAgICAgICAgZ2x5cGguZHJhd01ldHJpY3MoY3R4LCBnWCwgZ1ksIGdGb250U2l6ZSk7XG4gICAgfSk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSAge3N0cmluZ31cbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuRm9udC5wcm90b3R5cGUuZ2V0RW5nbGlzaE5hbWUgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgY29uc3QgdHJhbnNsYXRpb25zID0gdGhpcy5uYW1lc1tuYW1lXTtcbiAgICBpZiAodHJhbnNsYXRpb25zKSB7XG4gICAgICAgIHJldHVybiB0cmFuc2xhdGlvbnMuZW47XG4gICAgfVxufTtcblxuLyoqXG4gKiBWYWxpZGF0ZVxuICovXG5Gb250LnByb3RvdHlwZS52YWxpZGF0ZSA9IGZ1bmN0aW9uKCkge1xuICAgIGNvbnN0IHdhcm5pbmdzID0gW107XG4gICAgY29uc3QgX3RoaXMgPSB0aGlzO1xuXG4gICAgZnVuY3Rpb24gYXNzZXJ0KHByZWRpY2F0ZSwgbWVzc2FnZSkge1xuICAgICAgICBpZiAoIXByZWRpY2F0ZSkge1xuICAgICAgICAgICAgd2FybmluZ3MucHVzaChtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFzc2VydE5hbWVQcmVzZW50KG5hbWUpIHtcbiAgICAgICAgY29uc3QgZW5nbGlzaE5hbWUgPSBfdGhpcy5nZXRFbmdsaXNoTmFtZShuYW1lKTtcbiAgICAgICAgYXNzZXJ0KGVuZ2xpc2hOYW1lICYmIGVuZ2xpc2hOYW1lLnRyaW0oKS5sZW5ndGggPiAwLFxuICAgICAgICAgICAgICAgJ05vIEVuZ2xpc2ggJyArIG5hbWUgKyAnIHNwZWNpZmllZC4nKTtcbiAgICB9XG5cbiAgICAvLyBJZGVudGlmaWNhdGlvbiBpbmZvcm1hdGlvblxuICAgIGFzc2VydE5hbWVQcmVzZW50KCdmb250RmFtaWx5Jyk7XG4gICAgYXNzZXJ0TmFtZVByZXNlbnQoJ3dlaWdodE5hbWUnKTtcbiAgICBhc3NlcnROYW1lUHJlc2VudCgnbWFudWZhY3R1cmVyJyk7XG4gICAgYXNzZXJ0TmFtZVByZXNlbnQoJ2NvcHlyaWdodCcpO1xuICAgIGFzc2VydE5hbWVQcmVzZW50KCd2ZXJzaW9uJyk7XG5cbiAgICAvLyBEaW1lbnNpb24gaW5mb3JtYXRpb25cbiAgICBhc3NlcnQodGhpcy51bml0c1BlckVtID4gMCwgJ05vIHVuaXRzUGVyRW0gc3BlY2lmaWVkLicpO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0IHRoZSBmb250IG9iamVjdCB0byBhIFNGTlQgZGF0YSBzdHJ1Y3R1cmUuXG4gKiBUaGlzIHN0cnVjdHVyZSBjb250YWlucyBhbGwgdGhlIG5lY2Vzc2FyeSB0YWJsZXMgYW5kIG1ldGFkYXRhIHRvIGNyZWF0ZSBhIGJpbmFyeSBPVEYgZmlsZS5cbiAqIEByZXR1cm4ge29wZW50eXBlLlRhYmxlfVxuICovXG5Gb250LnByb3RvdHlwZS50b1RhYmxlcyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBzZm50LmZvbnRUb1RhYmxlKHRoaXMpO1xufTtcbi8qKlxuICogQGRlcHJlY2F0ZWQgRm9udC50b0J1ZmZlciBpcyBkZXByZWNhdGVkLiBVc2UgRm9udC50b0FycmF5QnVmZmVyIGluc3RlYWQuXG4gKi9cbkZvbnQucHJvdG90eXBlLnRvQnVmZmVyID0gZnVuY3Rpb24oKSB7XG4gICAgY29uc29sZS53YXJuKCdGb250LnRvQnVmZmVyIGlzIGRlcHJlY2F0ZWQuIFVzZSBGb250LnRvQXJyYXlCdWZmZXIgaW5zdGVhZC4nKTtcbiAgICByZXR1cm4gdGhpcy50b0FycmF5QnVmZmVyKCk7XG59O1xuLyoqXG4gKiBDb252ZXJ0cyBhIGBvcGVudHlwZS5Gb250YCBpbnRvIGFuIGBBcnJheUJ1ZmZlcmBcbiAqIEByZXR1cm4ge0FycmF5QnVmZmVyfVxuICovXG5Gb250LnByb3RvdHlwZS50b0FycmF5QnVmZmVyID0gZnVuY3Rpb24oKSB7XG4gICAgY29uc3Qgc2ZudFRhYmxlID0gdGhpcy50b1RhYmxlcygpO1xuICAgIGNvbnN0IGJ5dGVzID0gc2ZudFRhYmxlLmVuY29kZSgpO1xuICAgIGNvbnN0IGJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcihieXRlcy5sZW5ndGgpO1xuICAgIGNvbnN0IGludEFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGludEFycmF5W2ldID0gYnl0ZXNbaV07XG4gICAgfVxuXG4gICAgcmV0dXJuIGJ1ZmZlcjtcbn07XG5cbi8qKlxuICogSW5pdGlhdGUgYSBkb3dubG9hZCBvZiB0aGUgT3BlblR5cGUgZm9udC5cbiAqL1xuRm9udC5wcm90b3R5cGUuZG93bmxvYWQgPSBmdW5jdGlvbihmaWxlTmFtZSkge1xuICAgIGNvbnN0IGZhbWlseU5hbWUgPSB0aGlzLmdldEVuZ2xpc2hOYW1lKCdmb250RmFtaWx5Jyk7XG4gICAgY29uc3Qgc3R5bGVOYW1lID0gdGhpcy5nZXRFbmdsaXNoTmFtZSgnZm9udFN1YmZhbWlseScpO1xuICAgIGZpbGVOYW1lID0gZmlsZU5hbWUgfHwgZmFtaWx5TmFtZS5yZXBsYWNlKC9cXHMvZywgJycpICsgJy0nICsgc3R5bGVOYW1lICsgJy5vdGYnO1xuICAgIGNvbnN0IGFycmF5QnVmZmVyID0gdGhpcy50b0FycmF5QnVmZmVyKCk7XG5cbiAgICBpZiAoaXNCcm93c2VyKCkpIHtcbiAgICAgICAgd2luZG93LnJlcXVlc3RGaWxlU3lzdGVtID0gd2luZG93LnJlcXVlc3RGaWxlU3lzdGVtIHx8IHdpbmRvdy53ZWJraXRSZXF1ZXN0RmlsZVN5c3RlbTtcbiAgICAgICAgd2luZG93LnJlcXVlc3RGaWxlU3lzdGVtKHdpbmRvdy5URU1QT1JBUlksIGFycmF5QnVmZmVyLmJ5dGVMZW5ndGgsIGZ1bmN0aW9uKGZzKSB7XG4gICAgICAgICAgICBmcy5yb290LmdldEZpbGUoZmlsZU5hbWUsIHtjcmVhdGU6IHRydWV9LCBmdW5jdGlvbihmaWxlRW50cnkpIHtcbiAgICAgICAgICAgICAgICBmaWxlRW50cnkuY3JlYXRlV3JpdGVyKGZ1bmN0aW9uKHdyaXRlcikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkYXRhVmlldyA9IG5ldyBEYXRhVmlldyhhcnJheUJ1ZmZlcik7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGJsb2IgPSBuZXcgQmxvYihbZGF0YVZpZXddLCB7dHlwZTogJ2ZvbnQvb3BlbnR5cGUnfSk7XG4gICAgICAgICAgICAgICAgICAgIHdyaXRlci53cml0ZShibG9iKTtcblxuICAgICAgICAgICAgICAgICAgICB3cml0ZXIuYWRkRXZlbnRMaXN0ZW5lcignd3JpdGVlbmQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5hdmlnYXRpbmcgdG8gdGhlIGZpbGUgd2lsbCBkb3dubG9hZCBpdC5cbiAgICAgICAgICAgICAgICAgICAgICAgIGxvY2F0aW9uLmhyZWYgPSBmaWxlRW50cnkudG9VUkwoKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVyci5uYW1lICsgJzogJyArIGVyci5tZXNzYWdlKTtcbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgZnMgPSByZXF1aXJlKCdmcycpO1xuICAgICAgICBjb25zdCBidWZmZXIgPSBhcnJheUJ1ZmZlclRvTm9kZUJ1ZmZlcihhcnJheUJ1ZmZlcik7XG4gICAgICAgIGZzLndyaXRlRmlsZVN5bmMoZmlsZU5hbWUsIGJ1ZmZlcik7XG4gICAgfVxufTtcbi8qKlxuICogQHByaXZhdGVcbiAqL1xuRm9udC5wcm90b3R5cGUuZnNTZWxlY3Rpb25WYWx1ZXMgPSB7XG4gICAgSVRBTElDOiAgICAgICAgICAgICAgMHgwMDEsIC8vMVxuICAgIFVOREVSU0NPUkU6ICAgICAgICAgIDB4MDAyLCAvLzJcbiAgICBORUdBVElWRTogICAgICAgICAgICAweDAwNCwgLy80XG4gICAgT1VUTElORUQ6ICAgICAgICAgICAgMHgwMDgsIC8vOFxuICAgIFNUUklLRU9VVDogICAgICAgICAgIDB4MDEwLCAvLzE2XG4gICAgQk9MRDogICAgICAgICAgICAgICAgMHgwMjAsIC8vMzJcbiAgICBSRUdVTEFSOiAgICAgICAgICAgICAweDA0MCwgLy82NFxuICAgIFVTRVJfVFlQT19NRVRSSUNTOiAgIDB4MDgwLCAvLzEyOFxuICAgIFdXUzogICAgICAgICAgICAgICAgIDB4MTAwLCAvLzI1NlxuICAgIE9CTElRVUU6ICAgICAgICAgICAgIDB4MjAwICAvLzUxMlxufTtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5Gb250LnByb3RvdHlwZS51c1dpZHRoQ2xhc3NlcyA9IHtcbiAgICBVTFRSQV9DT05ERU5TRUQ6IDEsXG4gICAgRVhUUkFfQ09OREVOU0VEOiAyLFxuICAgIENPTkRFTlNFRDogMyxcbiAgICBTRU1JX0NPTkRFTlNFRDogNCxcbiAgICBNRURJVU06IDUsXG4gICAgU0VNSV9FWFBBTkRFRDogNixcbiAgICBFWFBBTkRFRDogNyxcbiAgICBFWFRSQV9FWFBBTkRFRDogOCxcbiAgICBVTFRSQV9FWFBBTkRFRDogOVxufTtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5Gb250LnByb3RvdHlwZS51c1dlaWdodENsYXNzZXMgPSB7XG4gICAgVEhJTjogMTAwLFxuICAgIEVYVFJBX0xJR0hUOiAyMDAsXG4gICAgTElHSFQ6IDMwMCxcbiAgICBOT1JNQUw6IDQwMCxcbiAgICBNRURJVU06IDUwMCxcbiAgICBTRU1JX0JPTEQ6IDYwMCxcbiAgICBCT0xEOiA3MDAsXG4gICAgRVhUUkFfQk9MRDogODAwLFxuICAgIEJMQUNLOiAgICA5MDBcbn07XG5cbmV4cG9ydCBkZWZhdWx0IEZvbnQ7XG4iLCIvLyBUaGUgYGZ2YXJgIHRhYmxlIHN0b3JlcyBmb250IHZhcmlhdGlvbiBheGVzIGFuZCBpbnN0YW5jZXMuXG4vLyBodHRwczovL2RldmVsb3Blci5hcHBsZS5jb20vZm9udHMvVHJ1ZVR5cGUtUmVmZXJlbmNlLU1hbnVhbC9STTA2L0NoYXA2ZnZhci5odG1sXG5cbmltcG9ydCBjaGVjayBmcm9tICcuLi9jaGVjayc7XG5pbXBvcnQgcGFyc2UgZnJvbSAnLi4vcGFyc2UnO1xuaW1wb3J0IHRhYmxlIGZyb20gJy4uL3RhYmxlJztcblxuZnVuY3Rpb24gYWRkTmFtZShuYW1lLCBuYW1lcykge1xuICAgIGNvbnN0IG5hbWVTdHJpbmcgPSBKU09OLnN0cmluZ2lmeShuYW1lKTtcbiAgICBsZXQgbmFtZUlEID0gMjU2O1xuICAgIGZvciAobGV0IG5hbWVLZXkgaW4gbmFtZXMpIHtcbiAgICAgICAgbGV0IG4gPSBwYXJzZUludChuYW1lS2V5KTtcbiAgICAgICAgaWYgKCFuIHx8IG4gPCAyNTYpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKEpTT04uc3RyaW5naWZ5KG5hbWVzW25hbWVLZXldKSA9PT0gbmFtZVN0cmluZykge1xuICAgICAgICAgICAgcmV0dXJuIG47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobmFtZUlEIDw9IG4pIHtcbiAgICAgICAgICAgIG5hbWVJRCA9IG4gKyAxO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbmFtZXNbbmFtZUlEXSA9IG5hbWU7XG4gICAgcmV0dXJuIG5hbWVJRDtcbn1cblxuZnVuY3Rpb24gbWFrZUZ2YXJBeGlzKG4sIGF4aXMsIG5hbWVzKSB7XG4gICAgY29uc3QgbmFtZUlEID0gYWRkTmFtZShheGlzLm5hbWUsIG5hbWVzKTtcbiAgICByZXR1cm4gW1xuICAgICAgICB7bmFtZTogJ3RhZ18nICsgbiwgdHlwZTogJ1RBRycsIHZhbHVlOiBheGlzLnRhZ30sXG4gICAgICAgIHtuYW1lOiAnbWluVmFsdWVfJyArIG4sIHR5cGU6ICdGSVhFRCcsIHZhbHVlOiBheGlzLm1pblZhbHVlIDw8IDE2fSxcbiAgICAgICAge25hbWU6ICdkZWZhdWx0VmFsdWVfJyArIG4sIHR5cGU6ICdGSVhFRCcsIHZhbHVlOiBheGlzLmRlZmF1bHRWYWx1ZSA8PCAxNn0sXG4gICAgICAgIHtuYW1lOiAnbWF4VmFsdWVfJyArIG4sIHR5cGU6ICdGSVhFRCcsIHZhbHVlOiBheGlzLm1heFZhbHVlIDw8IDE2fSxcbiAgICAgICAge25hbWU6ICdmbGFnc18nICsgbiwgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICduYW1lSURfJyArIG4sIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogbmFtZUlEfVxuICAgIF07XG59XG5cbmZ1bmN0aW9uIHBhcnNlRnZhckF4aXMoZGF0YSwgc3RhcnQsIG5hbWVzKSB7XG4gICAgY29uc3QgYXhpcyA9IHt9O1xuICAgIGNvbnN0IHAgPSBuZXcgcGFyc2UuUGFyc2VyKGRhdGEsIHN0YXJ0KTtcbiAgICBheGlzLnRhZyA9IHAucGFyc2VUYWcoKTtcbiAgICBheGlzLm1pblZhbHVlID0gcC5wYXJzZUZpeGVkKCk7XG4gICAgYXhpcy5kZWZhdWx0VmFsdWUgPSBwLnBhcnNlRml4ZWQoKTtcbiAgICBheGlzLm1heFZhbHVlID0gcC5wYXJzZUZpeGVkKCk7XG4gICAgcC5za2lwKCd1U2hvcnQnLCAxKTsgIC8vIHJlc2VydmVkIGZvciBmbGFnczsgbm8gdmFsdWVzIGRlZmluZWRcbiAgICBheGlzLm5hbWUgPSBuYW1lc1twLnBhcnNlVVNob3J0KCldIHx8IHt9O1xuICAgIHJldHVybiBheGlzO1xufVxuXG5mdW5jdGlvbiBtYWtlRnZhckluc3RhbmNlKG4sIGluc3QsIGF4ZXMsIG5hbWVzKSB7XG4gICAgY29uc3QgbmFtZUlEID0gYWRkTmFtZShpbnN0Lm5hbWUsIG5hbWVzKTtcbiAgICBjb25zdCBmaWVsZHMgPSBbXG4gICAgICAgIHtuYW1lOiAnbmFtZUlEXycgKyBuLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IG5hbWVJRH0sXG4gICAgICAgIHtuYW1lOiAnZmxhZ3NfJyArIG4sIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogMH1cbiAgICBdO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBheGVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNvbnN0IGF4aXNUYWcgPSBheGVzW2ldLnRhZztcbiAgICAgICAgZmllbGRzLnB1c2goe1xuICAgICAgICAgICAgbmFtZTogJ2F4aXNfJyArIG4gKyAnICcgKyBheGlzVGFnLFxuICAgICAgICAgICAgdHlwZTogJ0ZJWEVEJyxcbiAgICAgICAgICAgIHZhbHVlOiBpbnN0LmNvb3JkaW5hdGVzW2F4aXNUYWddIDw8IDE2XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBmaWVsZHM7XG59XG5cbmZ1bmN0aW9uIHBhcnNlRnZhckluc3RhbmNlKGRhdGEsIHN0YXJ0LCBheGVzLCBuYW1lcykge1xuICAgIGNvbnN0IGluc3QgPSB7fTtcbiAgICBjb25zdCBwID0gbmV3IHBhcnNlLlBhcnNlcihkYXRhLCBzdGFydCk7XG4gICAgaW5zdC5uYW1lID0gbmFtZXNbcC5wYXJzZVVTaG9ydCgpXSB8fCB7fTtcbiAgICBwLnNraXAoJ3VTaG9ydCcsIDEpOyAgLy8gcmVzZXJ2ZWQgZm9yIGZsYWdzOyBubyB2YWx1ZXMgZGVmaW5lZFxuXG4gICAgaW5zdC5jb29yZGluYXRlcyA9IHt9O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXhlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICBpbnN0LmNvb3JkaW5hdGVzW2F4ZXNbaV0udGFnXSA9IHAucGFyc2VGaXhlZCgpO1xuICAgIH1cblxuICAgIHJldHVybiBpbnN0O1xufVxuXG5mdW5jdGlvbiBtYWtlRnZhclRhYmxlKGZ2YXIsIG5hbWVzKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gbmV3IHRhYmxlLlRhYmxlKCdmdmFyJywgW1xuICAgICAgICB7bmFtZTogJ3ZlcnNpb24nLCB0eXBlOiAnVUxPTkcnLCB2YWx1ZTogMHgxMDAwMH0sXG4gICAgICAgIHtuYW1lOiAnb2Zmc2V0VG9EYXRhJywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICdjb3VudFNpemVQYWlycycsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogMn0sXG4gICAgICAgIHtuYW1lOiAnYXhpc0NvdW50JywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiBmdmFyLmF4ZXMubGVuZ3RofSxcbiAgICAgICAge25hbWU6ICdheGlzU2l6ZScsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogMjB9LFxuICAgICAgICB7bmFtZTogJ2luc3RhbmNlQ291bnQnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IGZ2YXIuaW5zdGFuY2VzLmxlbmd0aH0sXG4gICAgICAgIHtuYW1lOiAnaW5zdGFuY2VTaXplJywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiA0ICsgZnZhci5heGVzLmxlbmd0aCAqIDR9XG4gICAgXSk7XG4gICAgcmVzdWx0Lm9mZnNldFRvRGF0YSA9IHJlc3VsdC5zaXplT2YoKTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZnZhci5heGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHJlc3VsdC5maWVsZHMgPSByZXN1bHQuZmllbGRzLmNvbmNhdChtYWtlRnZhckF4aXMoaSwgZnZhci5heGVzW2ldLCBuYW1lcykpO1xuICAgIH1cblxuICAgIGZvciAobGV0IGogPSAwOyBqIDwgZnZhci5pbnN0YW5jZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgcmVzdWx0LmZpZWxkcyA9IHJlc3VsdC5maWVsZHMuY29uY2F0KG1ha2VGdmFySW5zdGFuY2UoaiwgZnZhci5pbnN0YW5jZXNbal0sIGZ2YXIuYXhlcywgbmFtZXMpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBwYXJzZUZ2YXJUYWJsZShkYXRhLCBzdGFydCwgbmFtZXMpIHtcbiAgICBjb25zdCBwID0gbmV3IHBhcnNlLlBhcnNlcihkYXRhLCBzdGFydCk7XG4gICAgY29uc3QgdGFibGVWZXJzaW9uID0gcC5wYXJzZVVMb25nKCk7XG4gICAgY2hlY2suYXJndW1lbnQodGFibGVWZXJzaW9uID09PSAweDAwMDEwMDAwLCAnVW5zdXBwb3J0ZWQgZnZhciB0YWJsZSB2ZXJzaW9uLicpO1xuICAgIGNvbnN0IG9mZnNldFRvRGF0YSA9IHAucGFyc2VPZmZzZXQxNigpO1xuICAgIC8vIFNraXAgY291bnRTaXplUGFpcnMuXG4gICAgcC5za2lwKCd1U2hvcnQnLCAxKTtcbiAgICBjb25zdCBheGlzQ291bnQgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgY29uc3QgYXhpc1NpemUgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgY29uc3QgaW5zdGFuY2VDb3VudCA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICBjb25zdCBpbnN0YW5jZVNpemUgPSBwLnBhcnNlVVNob3J0KCk7XG5cbiAgICBjb25zdCBheGVzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBheGlzQ291bnQ7IGkrKykge1xuICAgICAgICBheGVzLnB1c2gocGFyc2VGdmFyQXhpcyhkYXRhLCBzdGFydCArIG9mZnNldFRvRGF0YSArIGkgKiBheGlzU2l6ZSwgbmFtZXMpKTtcbiAgICB9XG5cbiAgICBjb25zdCBpbnN0YW5jZXMgPSBbXTtcbiAgICBjb25zdCBpbnN0YW5jZVN0YXJ0ID0gc3RhcnQgKyBvZmZzZXRUb0RhdGEgKyBheGlzQ291bnQgKiBheGlzU2l6ZTtcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IGluc3RhbmNlQ291bnQ7IGorKykge1xuICAgICAgICBpbnN0YW5jZXMucHVzaChwYXJzZUZ2YXJJbnN0YW5jZShkYXRhLCBpbnN0YW5jZVN0YXJ0ICsgaiAqIGluc3RhbmNlU2l6ZSwgYXhlcywgbmFtZXMpKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge2F4ZXM6IGF4ZXMsIGluc3RhbmNlczogaW5zdGFuY2VzfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgeyBtYWtlOiBtYWtlRnZhclRhYmxlLCBwYXJzZTogcGFyc2VGdmFyVGFibGUgfTtcbiIsIi8vIFRoZSBgR1BPU2AgdGFibGUgY29udGFpbnMga2VybmluZyBwYWlycywgYW1vbmcgb3RoZXIgdGhpbmdzLlxuLy8gaHR0cHM6Ly93d3cubWljcm9zb2Z0LmNvbS90eXBvZ3JhcGh5L09UU1BFQy9ncG9zLmh0bVxuXG5pbXBvcnQgY2hlY2sgZnJvbSAnLi4vY2hlY2snO1xuaW1wb3J0IHBhcnNlIGZyb20gJy4uL3BhcnNlJztcblxuLy8gUGFyc2UgU2NyaXB0TGlzdCBhbmQgRmVhdHVyZUxpc3QgdGFibGVzIG9mIEdQT1MsIEdTVUIsIEdERUYsIEJBU0UsIEpTVEYgdGFibGVzLlxuLy8gVGhlc2UgbGlzdHMgYXJlIHVudXNlZCBieSBub3csIHRoaXMgZnVuY3Rpb24gaXMganVzdCB0aGUgYmFzaXMgZm9yIGEgcmVhbCBwYXJzaW5nLlxuZnVuY3Rpb24gcGFyc2VUYWdnZWRMaXN0VGFibGUoZGF0YSwgc3RhcnQpIHtcbiAgICBjb25zdCBwID0gbmV3IHBhcnNlLlBhcnNlcihkYXRhLCBzdGFydCk7XG4gICAgY29uc3QgbiA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICBjb25zdCBsaXN0ID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgbGlzdFtwLnBhcnNlVGFnKCldID0geyBvZmZzZXQ6IHAucGFyc2VVU2hvcnQoKSB9O1xuICAgIH1cblxuICAgIHJldHVybiBsaXN0O1xufVxuXG4vLyBQYXJzZSBhIGNvdmVyYWdlIHRhYmxlIGluIGEgR1NVQiwgR1BPUyBvciBHREVGIHRhYmxlLlxuLy8gRm9ybWF0IDEgaXMgYSBzaW1wbGUgbGlzdCBvZiBnbHlwaCBpZHMsXG4vLyBGb3JtYXQgMiBpcyBhIGxpc3Qgb2YgcmFuZ2VzLiBJdCBpcyBleHBhbmRlZCBpbiBhIGxpc3Qgb2YgZ2x5cGhzLCBtYXliZSBub3QgdGhlIGJlc3QgaWRlYS5cbmZ1bmN0aW9uIHBhcnNlQ292ZXJhZ2VUYWJsZShkYXRhLCBzdGFydCkge1xuICAgIGNvbnN0IHAgPSBuZXcgcGFyc2UuUGFyc2VyKGRhdGEsIHN0YXJ0KTtcbiAgICBjb25zdCBmb3JtYXQgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgbGV0IGNvdW50ID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgIGlmIChmb3JtYXQgPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIHAucGFyc2VVU2hvcnRMaXN0KGNvdW50KTtcbiAgICB9IGVsc2UgaWYgKGZvcm1hdCA9PT0gMikge1xuICAgICAgICBjb25zdCBjb3ZlcmFnZSA9IFtdO1xuICAgICAgICBmb3IgKDsgY291bnQtLTspIHtcbiAgICAgICAgICAgIGNvbnN0IGJlZ2luID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICAgICAgY29uc3QgZW5kID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICAgICAgbGV0IGluZGV4ID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IGJlZ2luOyBpIDw9IGVuZDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY292ZXJhZ2VbaW5kZXgrK10gPSBpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNvdmVyYWdlO1xuICAgIH1cbn1cblxuLy8gUGFyc2UgYSBDbGFzcyBEZWZpbml0aW9uIFRhYmxlIGluIGEgR1NVQiwgR1BPUyBvciBHREVGIHRhYmxlLlxuLy8gUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgZ2V0cyBhIGNsYXNzIHZhbHVlIGZyb20gYSBnbHlwaCBJRC5cbmZ1bmN0aW9uIHBhcnNlQ2xhc3NEZWZUYWJsZShkYXRhLCBzdGFydCkge1xuICAgIGNvbnN0IHAgPSBuZXcgcGFyc2UuUGFyc2VyKGRhdGEsIHN0YXJ0KTtcbiAgICBjb25zdCBmb3JtYXQgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgaWYgKGZvcm1hdCA9PT0gMSkge1xuICAgICAgICAvLyBGb3JtYXQgMSBzcGVjaWZpZXMgYSByYW5nZSBvZiBjb25zZWN1dGl2ZSBnbHlwaCBpbmRpY2VzLCBvbmUgY2xhc3MgcGVyIGdseXBoIElELlxuICAgICAgICBjb25zdCBzdGFydEdseXBoID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICBjb25zdCBnbHlwaENvdW50ID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICBjb25zdCBjbGFzc2VzID0gcC5wYXJzZVVTaG9ydExpc3QoZ2x5cGhDb3VudCk7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihnbHlwaElEKSB7XG4gICAgICAgICAgICByZXR1cm4gY2xhc3Nlc1tnbHlwaElEIC0gc3RhcnRHbHlwaF0gfHwgMDtcbiAgICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKGZvcm1hdCA9PT0gMikge1xuICAgICAgICAvLyBGb3JtYXQgMiBkZWZpbmVzIG11bHRpcGxlIGdyb3VwcyBvZiBnbHlwaCBpbmRpY2VzIHRoYXQgYmVsb25nIHRvIHRoZSBzYW1lIGNsYXNzLlxuICAgICAgICBjb25zdCByYW5nZUNvdW50ID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICBjb25zdCBzdGFydEdseXBocyA9IFtdO1xuICAgICAgICBjb25zdCBlbmRHbHlwaHMgPSBbXTtcbiAgICAgICAgY29uc3QgY2xhc3NWYWx1ZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByYW5nZUNvdW50OyBpKyspIHtcbiAgICAgICAgICAgIHN0YXJ0R2x5cGhzW2ldID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICAgICAgZW5kR2x5cGhzW2ldID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICAgICAgY2xhc3NWYWx1ZXNbaV0gPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24oZ2x5cGhJRCkge1xuICAgICAgICAgICAgbGV0IGwgPSAwO1xuICAgICAgICAgICAgbGV0IHIgPSBzdGFydEdseXBocy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgd2hpbGUgKGwgPCByKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYyA9IChsICsgciArIDEpID4+IDE7XG4gICAgICAgICAgICAgICAgaWYgKGdseXBoSUQgPCBzdGFydEdseXBoc1tjXSkge1xuICAgICAgICAgICAgICAgICAgICByID0gYyAtIDE7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbCA9IGM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoc3RhcnRHbHlwaHNbbF0gPD0gZ2x5cGhJRCAmJiBnbHlwaElEIDw9IGVuZEdseXBoc1tsXSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjbGFzc1ZhbHVlc1tsXSB8fCAwO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfTtcbiAgICB9XG59XG5cbi8vIFBhcnNlIGEgcGFpciBhZGp1c3RtZW50IHBvc2l0aW9uaW5nIHN1YnRhYmxlLCBmb3JtYXQgMSBvciBmb3JtYXQgMlxuLy8gVGhlIHN1YnRhYmxlIGlzIHJldHVybmVkIGluIHRoZSBmb3JtIG9mIGEgbG9va3VwIGZ1bmN0aW9uLlxuZnVuY3Rpb24gcGFyc2VQYWlyUG9zU3ViVGFibGUoZGF0YSwgc3RhcnQpIHtcbiAgICBjb25zdCBwID0gbmV3IHBhcnNlLlBhcnNlcihkYXRhLCBzdGFydCk7XG4gICAgLy8gVGhpcyBwYXJ0IGlzIGNvbW1vbiB0byBmb3JtYXQgMSBhbmQgZm9ybWF0IDIgc3VidGFibGVzXG4gICAgY29uc3QgZm9ybWF0ID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgIGNvbnN0IGNvdmVyYWdlT2Zmc2V0ID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgIGNvbnN0IGNvdmVyYWdlID0gcGFyc2VDb3ZlcmFnZVRhYmxlKGRhdGEsIHN0YXJ0ICsgY292ZXJhZ2VPZmZzZXQpO1xuICAgIC8vIHZhbHVlRm9ybWF0IDQ6IFhBZHZhbmNlIG9ubHksIDE6IFhQbGFjZW1lbnQgb25seSwgMDogbm8gVmFsdWVSZWNvcmQgZm9yIHNlY29uZCBnbHlwaFxuICAgIC8vIE9ubHkgdmFsdWVGb3JtYXQxPTQgYW5kIHZhbHVlRm9ybWF0Mj0wIGlzIHN1cHBvcnRlZC5cbiAgICBjb25zdCB2YWx1ZUZvcm1hdDEgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgY29uc3QgdmFsdWVGb3JtYXQyID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgIGxldCB2YWx1ZTE7XG4gICAgbGV0IHZhbHVlMjtcbiAgICBpZiAodmFsdWVGb3JtYXQxICE9PSA0IHx8IHZhbHVlRm9ybWF0MiAhPT0gMCkgcmV0dXJuO1xuICAgIGNvbnN0IHNoYXJlZFBhaXJTZXRzID0ge307XG4gICAgaWYgKGZvcm1hdCA9PT0gMSkge1xuICAgICAgICAvLyBQYWlyIFBvc2l0aW9uaW5nIEFkanVzdG1lbnQ6IEZvcm1hdCAxXG4gICAgICAgIGNvbnN0IHBhaXJTZXRDb3VudCA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgY29uc3QgcGFpclNldCA9IFtdO1xuICAgICAgICAvLyBBcnJheSBvZiBvZmZzZXRzIHRvIFBhaXJTZXQgdGFibGVzLWZyb20gYmVnaW5uaW5nIG9mIFBhaXJQb3Mgc3VidGFibGUtb3JkZXJlZCBieSBDb3ZlcmFnZSBJbmRleFxuICAgICAgICBjb25zdCBwYWlyU2V0T2Zmc2V0cyA9IHAucGFyc2VPZmZzZXQxNkxpc3QocGFpclNldENvdW50KTtcbiAgICAgICAgZm9yIChsZXQgZmlyc3RHbHlwaCA9IDA7IGZpcnN0R2x5cGggPCBwYWlyU2V0Q291bnQ7IGZpcnN0R2x5cGgrKykge1xuICAgICAgICAgICAgY29uc3QgcGFpclNldE9mZnNldCA9IHBhaXJTZXRPZmZzZXRzW2ZpcnN0R2x5cGhdO1xuICAgICAgICAgICAgbGV0IHNoYXJlZFBhaXJTZXQgPSBzaGFyZWRQYWlyU2V0c1twYWlyU2V0T2Zmc2V0XTtcbiAgICAgICAgICAgIGlmICghc2hhcmVkUGFpclNldCkge1xuICAgICAgICAgICAgICAgIC8vIFBhcnNlIGEgcGFpcnNldCB0YWJsZSBpbiBhIHBhaXIgYWRqdXN0bWVudCBzdWJ0YWJsZSBmb3JtYXQgMVxuICAgICAgICAgICAgICAgIHNoYXJlZFBhaXJTZXQgPSB7fTtcbiAgICAgICAgICAgICAgICBwLnJlbGF0aXZlT2Zmc2V0ID0gcGFpclNldE9mZnNldDtcbiAgICAgICAgICAgICAgICBsZXQgcGFpclZhbHVlQ291bnQgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgICAgICAgICAgZm9yICg7IHBhaXJWYWx1ZUNvdW50LS07KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNlY29uZEdseXBoID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWVGb3JtYXQxKSB2YWx1ZTEgPSBwLnBhcnNlU2hvcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlRm9ybWF0MikgdmFsdWUyID0gcC5wYXJzZVNob3J0KCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIG9ubHkgc3VwcG9ydCB2YWx1ZUZvcm1hdDEgPSA0IGFuZCB2YWx1ZUZvcm1hdDIgPSAwLFxuICAgICAgICAgICAgICAgICAgICAvLyBzbyB2YWx1ZTEgaXMgdGhlIFhBZHZhbmNlIGFuZCB2YWx1ZTIgaXMgZW1wdHkuXG4gICAgICAgICAgICAgICAgICAgIHNoYXJlZFBhaXJTZXRbc2Vjb25kR2x5cGhdID0gdmFsdWUxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcGFpclNldFtjb3ZlcmFnZVtmaXJzdEdseXBoXV0gPSBzaGFyZWRQYWlyU2V0O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGxlZnRHbHlwaCwgcmlnaHRHbHlwaCkge1xuICAgICAgICAgICAgY29uc3QgcGFpcnMgPSBwYWlyU2V0W2xlZnRHbHlwaF07XG4gICAgICAgICAgICBpZiAocGFpcnMpIHJldHVybiBwYWlyc1tyaWdodEdseXBoXTtcbiAgICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKGZvcm1hdCA9PT0gMikge1xuICAgICAgICAvLyBQYWlyIFBvc2l0aW9uaW5nIEFkanVzdG1lbnQ6IEZvcm1hdCAyXG4gICAgICAgIGNvbnN0IGNsYXNzRGVmMU9mZnNldCA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgY29uc3QgY2xhc3NEZWYyT2Zmc2V0ID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICBjb25zdCBjbGFzczFDb3VudCA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgY29uc3QgY2xhc3MyQ291bnQgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgIGNvbnN0IGdldENsYXNzMSA9IHBhcnNlQ2xhc3NEZWZUYWJsZShkYXRhLCBzdGFydCArIGNsYXNzRGVmMU9mZnNldCk7XG4gICAgICAgIGNvbnN0IGdldENsYXNzMiA9IHBhcnNlQ2xhc3NEZWZUYWJsZShkYXRhLCBzdGFydCArIGNsYXNzRGVmMk9mZnNldCk7XG5cbiAgICAgICAgLy8gUGFyc2Uga2VybmluZyB2YWx1ZXMgYnkgY2xhc3MgcGFpci5cbiAgICAgICAgY29uc3Qga2VybmluZ01hdHJpeCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNsYXNzMUNvdW50OyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGtlcm5pbmdSb3cgPSBrZXJuaW5nTWF0cml4W2ldID0gW107XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGNsYXNzMkNvdW50OyBqKyspIHtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWVGb3JtYXQxKSB2YWx1ZTEgPSBwLnBhcnNlU2hvcnQoKTtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWVGb3JtYXQyKSB2YWx1ZTIgPSBwLnBhcnNlU2hvcnQoKTtcbiAgICAgICAgICAgICAgICAvLyBXZSBvbmx5IHN1cHBvcnQgdmFsdWVGb3JtYXQxID0gNCBhbmQgdmFsdWVGb3JtYXQyID0gMCxcbiAgICAgICAgICAgICAgICAvLyBzbyB2YWx1ZTEgaXMgdGhlIFhBZHZhbmNlIGFuZCB2YWx1ZTIgaXMgZW1wdHkuXG4gICAgICAgICAgICAgICAga2VybmluZ1Jvd1tqXSA9IHZhbHVlMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENvbnZlcnQgY292ZXJhZ2UgbGlzdCB0byBhIGhhc2hcbiAgICAgICAgY29uc3QgY292ZXJlZCA9IHt9O1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdmVyYWdlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb3ZlcmVkW2NvdmVyYWdlW2ldXSA9IDE7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBHZXQgdGhlIGtlcm5pbmcgdmFsdWUgZm9yIGEgc3BlY2lmaWMgZ2x5cGggcGFpci5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGxlZnRHbHlwaCwgcmlnaHRHbHlwaCkge1xuICAgICAgICAgICAgaWYgKCFjb3ZlcmVkW2xlZnRHbHlwaF0pIHJldHVybjtcbiAgICAgICAgICAgIGNvbnN0IGNsYXNzMSA9IGdldENsYXNzMShsZWZ0R2x5cGgpO1xuICAgICAgICAgICAgY29uc3QgY2xhc3MyID0gZ2V0Q2xhc3MyKHJpZ2h0R2x5cGgpO1xuICAgICAgICAgICAgY29uc3Qga2VybmluZ1JvdyA9IGtlcm5pbmdNYXRyaXhbY2xhc3MxXTtcblxuICAgICAgICAgICAgaWYgKGtlcm5pbmdSb3cpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ga2VybmluZ1Jvd1tjbGFzczJdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbn1cblxuLy8gUGFyc2UgYSBMb29rdXBUYWJsZSAocHJlc2VudCBpbiBvZiBHUE9TLCBHU1VCLCBHREVGLCBCQVNFLCBKU1RGIHRhYmxlcykuXG5mdW5jdGlvbiBwYXJzZUxvb2t1cFRhYmxlKGRhdGEsIHN0YXJ0KSB7XG4gICAgY29uc3QgcCA9IG5ldyBwYXJzZS5QYXJzZXIoZGF0YSwgc3RhcnQpO1xuICAgIGNvbnN0IGxvb2t1cFR5cGUgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgY29uc3QgbG9va3VwRmxhZyA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICBjb25zdCB1c2VNYXJrRmlsdGVyaW5nU2V0ID0gbG9va3VwRmxhZyAmIDB4MTA7XG4gICAgY29uc3Qgc3ViVGFibGVDb3VudCA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICBjb25zdCBzdWJUYWJsZU9mZnNldHMgPSBwLnBhcnNlT2Zmc2V0MTZMaXN0KHN1YlRhYmxlQ291bnQpO1xuICAgIGNvbnN0IHRhYmxlID0ge1xuICAgICAgICBsb29rdXBUeXBlOiBsb29rdXBUeXBlLFxuICAgICAgICBsb29rdXBGbGFnOiBsb29rdXBGbGFnLFxuICAgICAgICBtYXJrRmlsdGVyaW5nU2V0OiB1c2VNYXJrRmlsdGVyaW5nU2V0ID8gcC5wYXJzZVVTaG9ydCgpIDogLTFcbiAgICB9O1xuICAgIC8vIExvb2t1cFR5cGUgMiwgUGFpciBhZGp1c3RtZW50XG4gICAgaWYgKGxvb2t1cFR5cGUgPT09IDIpIHtcbiAgICAgICAgY29uc3Qgc3VidGFibGVzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3ViVGFibGVDb3VudDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBwYWlyUG9zU3ViVGFibGUgPSBwYXJzZVBhaXJQb3NTdWJUYWJsZShkYXRhLCBzdGFydCArIHN1YlRhYmxlT2Zmc2V0c1tpXSk7XG4gICAgICAgICAgICBpZiAocGFpclBvc1N1YlRhYmxlKSBzdWJ0YWJsZXMucHVzaChwYWlyUG9zU3ViVGFibGUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJldHVybiBhIGZ1bmN0aW9uIHdoaWNoIGZpbmRzIHRoZSBrZXJuaW5nIHZhbHVlcyBpbiB0aGUgc3VidGFibGVzLlxuICAgICAgICB0YWJsZS5nZXRLZXJuaW5nVmFsdWUgPSBmdW5jdGlvbihsZWZ0R2x5cGgsIHJpZ2h0R2x5cGgpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSBzdWJ0YWJsZXMubGVuZ3RoOyBpLS07KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBzdWJ0YWJsZXNbaV0obGVmdEdseXBoLCByaWdodEdseXBoKTtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGFibGU7XG59XG5cbi8vIFBhcnNlIHRoZSBgR1BPU2AgdGFibGUgd2hpY2ggY29udGFpbnMsIGFtb25nIG90aGVyIHRoaW5ncywga2VybmluZyBwYWlycy5cbi8vIGh0dHBzOi8vd3d3Lm1pY3Jvc29mdC5jb20vdHlwb2dyYXBoeS9PVFNQRUMvZ3Bvcy5odG1cbmZ1bmN0aW9uIHBhcnNlR3Bvc1RhYmxlKGRhdGEsIHN0YXJ0LCBmb250KSB7XG4gICAgY29uc3QgcCA9IG5ldyBwYXJzZS5QYXJzZXIoZGF0YSwgc3RhcnQpO1xuICAgIGNvbnN0IHRhYmxlVmVyc2lvbiA9IHAucGFyc2VGaXhlZCgpO1xuICAgIGNoZWNrLmFyZ3VtZW50KHRhYmxlVmVyc2lvbiA9PT0gMSwgJ1Vuc3VwcG9ydGVkIEdQT1MgdGFibGUgdmVyc2lvbi4nKTtcblxuICAgIC8vIFNjcmlwdExpc3QgYW5kIEZlYXR1cmVMaXN0IC0gaWdub3JlZCBmb3Igbm93XG4gICAgcGFyc2VUYWdnZWRMaXN0VGFibGUoZGF0YSwgc3RhcnQgKyBwLnBhcnNlVVNob3J0KCkpO1xuICAgIC8vICdrZXJuJyBpcyB0aGUgZmVhdHVyZSB3ZSBhcmUgbG9va2luZyBmb3IuXG4gICAgcGFyc2VUYWdnZWRMaXN0VGFibGUoZGF0YSwgc3RhcnQgKyBwLnBhcnNlVVNob3J0KCkpO1xuXG4gICAgLy8gTG9va3VwTGlzdFxuICAgIGNvbnN0IGxvb2t1cExpc3RPZmZzZXQgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgcC5yZWxhdGl2ZU9mZnNldCA9IGxvb2t1cExpc3RPZmZzZXQ7XG4gICAgY29uc3QgbG9va3VwQ291bnQgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgY29uc3QgbG9va3VwVGFibGVPZmZzZXRzID0gcC5wYXJzZU9mZnNldDE2TGlzdChsb29rdXBDb3VudCk7XG4gICAgY29uc3QgbG9va3VwTGlzdEFic29sdXRlT2Zmc2V0ID0gc3RhcnQgKyBsb29rdXBMaXN0T2Zmc2V0O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbG9va3VwQ291bnQ7IGkrKykge1xuICAgICAgICBjb25zdCB0YWJsZSA9IHBhcnNlTG9va3VwVGFibGUoZGF0YSwgbG9va3VwTGlzdEFic29sdXRlT2Zmc2V0ICsgbG9va3VwVGFibGVPZmZzZXRzW2ldKTtcbiAgICAgICAgaWYgKHRhYmxlLmxvb2t1cFR5cGUgPT09IDIgJiYgIWZvbnQuZ2V0R3Bvc0tlcm5pbmdWYWx1ZSkgZm9udC5nZXRHcG9zS2VybmluZ1ZhbHVlID0gdGFibGUuZ2V0S2VybmluZ1ZhbHVlO1xuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgeyBwYXJzZTogcGFyc2VHcG9zVGFibGUgfTtcbiIsIi8vIFRoZSBga2VybmAgdGFibGUgY29udGFpbnMga2VybmluZyBwYWlycy5cbi8vIE5vdGUgdGhhdCBzb21lIGZvbnRzIHVzZSB0aGUgR1BPUyBPcGVuVHlwZSBsYXlvdXQgdGFibGUgdG8gc3BlY2lmeSBrZXJuaW5nLlxuLy8gaHR0cHM6Ly93d3cubWljcm9zb2Z0LmNvbS90eXBvZ3JhcGh5L09UU1BFQy9rZXJuLmh0bVxuXG5pbXBvcnQgY2hlY2sgZnJvbSAnLi4vY2hlY2snO1xuaW1wb3J0IHBhcnNlIGZyb20gJy4uL3BhcnNlJztcblxuZnVuY3Rpb24gcGFyc2VXaW5kb3dzS2VyblRhYmxlKHApIHtcbiAgICBjb25zdCBwYWlycyA9IHt9O1xuICAgIC8vIFNraXAgblRhYmxlcy5cbiAgICBwLnNraXAoJ3VTaG9ydCcpO1xuICAgIGNvbnN0IHN1YnRhYmxlVmVyc2lvbiA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICBjaGVjay5hcmd1bWVudChzdWJ0YWJsZVZlcnNpb24gPT09IDAsICdVbnN1cHBvcnRlZCBrZXJuIHN1Yi10YWJsZSB2ZXJzaW9uLicpO1xuICAgIC8vIFNraXAgc3VidGFibGVMZW5ndGgsIHN1YnRhYmxlQ292ZXJhZ2VcbiAgICBwLnNraXAoJ3VTaG9ydCcsIDIpO1xuICAgIGNvbnN0IG5QYWlycyA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICAvLyBTa2lwIHNlYXJjaFJhbmdlLCBlbnRyeVNlbGVjdG9yLCByYW5nZVNoaWZ0LlxuICAgIHAuc2tpcCgndVNob3J0JywgMyk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuUGFpcnM7IGkgKz0gMSkge1xuICAgICAgICBjb25zdCBsZWZ0SW5kZXggPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgIGNvbnN0IHJpZ2h0SW5kZXggPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gcC5wYXJzZVNob3J0KCk7XG4gICAgICAgIHBhaXJzW2xlZnRJbmRleCArICcsJyArIHJpZ2h0SW5kZXhdID0gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBwYWlycztcbn1cblxuZnVuY3Rpb24gcGFyc2VNYWNLZXJuVGFibGUocCkge1xuICAgIGNvbnN0IHBhaXJzID0ge307XG4gICAgLy8gVGhlIE1hYyBrZXJuIHRhYmxlIHN0b3JlcyB0aGUgdmVyc2lvbiBhcyBhIGZpeGVkICgzMiBiaXRzKSBidXQgd2Ugb25seSBsb2FkZWQgdGhlIGZpcnN0IDE2IGJpdHMuXG4gICAgLy8gU2tpcCB0aGUgcmVzdC5cbiAgICBwLnNraXAoJ3VTaG9ydCcpO1xuICAgIGNvbnN0IG5UYWJsZXMgPSBwLnBhcnNlVUxvbmcoKTtcbiAgICAvL2NoZWNrLmFyZ3VtZW50KG5UYWJsZXMgPT09IDEsICdPbmx5IDEgc3VidGFibGUgaXMgc3VwcG9ydGVkIChnb3QgJyArIG5UYWJsZXMgKyAnKS4nKTtcbiAgICBpZiAoblRhYmxlcyA+IDEpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdPbmx5IHRoZSBmaXJzdCBrZXJuIHN1YnRhYmxlIGlzIHN1cHBvcnRlZC4nKTtcbiAgICB9XG4gICAgcC5za2lwKCd1TG9uZycpO1xuICAgIGNvbnN0IGNvdmVyYWdlID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgIGNvbnN0IHN1YnRhYmxlVmVyc2lvbiA9IGNvdmVyYWdlICYgMHhGRjtcbiAgICBwLnNraXAoJ3VTaG9ydCcpO1xuICAgIGlmIChzdWJ0YWJsZVZlcnNpb24gPT09IDApIHtcbiAgICAgICAgY29uc3QgblBhaXJzID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICAvLyBTa2lwIHNlYXJjaFJhbmdlLCBlbnRyeVNlbGVjdG9yLCByYW5nZVNoaWZ0LlxuICAgICAgICBwLnNraXAoJ3VTaG9ydCcsIDMpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5QYWlyczsgaSArPSAxKSB7XG4gICAgICAgICAgICBjb25zdCBsZWZ0SW5kZXggPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgICAgICBjb25zdCByaWdodEluZGV4ID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBwLnBhcnNlU2hvcnQoKTtcbiAgICAgICAgICAgIHBhaXJzW2xlZnRJbmRleCArICcsJyArIHJpZ2h0SW5kZXhdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHBhaXJzO1xufVxuXG4vLyBQYXJzZSB0aGUgYGtlcm5gIHRhYmxlIHdoaWNoIGNvbnRhaW5zIGtlcm5pbmcgcGFpcnMuXG5mdW5jdGlvbiBwYXJzZUtlcm5UYWJsZShkYXRhLCBzdGFydCkge1xuICAgIGNvbnN0IHAgPSBuZXcgcGFyc2UuUGFyc2VyKGRhdGEsIHN0YXJ0KTtcbiAgICBjb25zdCB0YWJsZVZlcnNpb24gPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgaWYgKHRhYmxlVmVyc2lvbiA9PT0gMCkge1xuICAgICAgICByZXR1cm4gcGFyc2VXaW5kb3dzS2VyblRhYmxlKHApO1xuICAgIH0gZWxzZSBpZiAodGFibGVWZXJzaW9uID09PSAxKSB7XG4gICAgICAgIHJldHVybiBwYXJzZU1hY0tlcm5UYWJsZShwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIGtlcm4gdGFibGUgdmVyc2lvbiAoJyArIHRhYmxlVmVyc2lvbiArICcpLicpO1xuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgeyBwYXJzZTogcGFyc2VLZXJuVGFibGUgfTtcbiIsIi8vIFRoZSBgbG9jYWAgdGFibGUgc3RvcmVzIHRoZSBvZmZzZXRzIHRvIHRoZSBsb2NhdGlvbnMgb2YgdGhlIGdseXBocyBpbiB0aGUgZm9udC5cbi8vIGh0dHBzOi8vd3d3Lm1pY3Jvc29mdC5jb20vdHlwb2dyYXBoeS9PVFNQRUMvbG9jYS5odG1cblxuaW1wb3J0IHBhcnNlIGZyb20gJy4uL3BhcnNlJztcblxuLy8gUGFyc2UgdGhlIGBsb2NhYCB0YWJsZS4gVGhpcyB0YWJsZSBzdG9yZXMgdGhlIG9mZnNldHMgdG8gdGhlIGxvY2F0aW9ucyBvZiB0aGUgZ2x5cGhzIGluIHRoZSBmb250LFxuLy8gcmVsYXRpdmUgdG8gdGhlIGJlZ2lubmluZyBvZiB0aGUgZ2x5cGhEYXRhIHRhYmxlLlxuLy8gVGhlIG51bWJlciBvZiBnbHlwaHMgc3RvcmVkIGluIHRoZSBgbG9jYWAgdGFibGUgaXMgc3BlY2lmaWVkIGluIHRoZSBgbWF4cGAgdGFibGUgKHVuZGVyIG51bUdseXBocylcbi8vIFRoZSBsb2NhIHRhYmxlIGhhcyB0d28gdmVyc2lvbnM6IGEgc2hvcnQgdmVyc2lvbiB3aGVyZSBvZmZzZXRzIGFyZSBzdG9yZWQgYXMgdVNob3J0cywgYW5kIGEgbG9uZ1xuLy8gdmVyc2lvbiB3aGVyZSBvZmZzZXRzIGFyZSBzdG9yZWQgYXMgdUxvbmdzLiBUaGUgYGhlYWRgIHRhYmxlIHNwZWNpZmllcyB3aGljaCB2ZXJzaW9uIHRvIHVzZVxuLy8gKHVuZGVyIGluZGV4VG9Mb2NGb3JtYXQpLlxuZnVuY3Rpb24gcGFyc2VMb2NhVGFibGUoZGF0YSwgc3RhcnQsIG51bUdseXBocywgc2hvcnRWZXJzaW9uKSB7XG4gICAgY29uc3QgcCA9IG5ldyBwYXJzZS5QYXJzZXIoZGF0YSwgc3RhcnQpO1xuICAgIGNvbnN0IHBhcnNlRm4gPSBzaG9ydFZlcnNpb24gPyBwLnBhcnNlVVNob3J0IDogcC5wYXJzZVVMb25nO1xuICAgIC8vIFRoZXJlIGlzIGFuIGV4dHJhIGVudHJ5IGFmdGVyIHRoZSBsYXN0IGluZGV4IGVsZW1lbnQgdG8gY29tcHV0ZSB0aGUgbGVuZ3RoIG9mIHRoZSBsYXN0IGdseXBoLlxuICAgIC8vIFRoYXQncyB3aHkgd2UgdXNlIG51bUdseXBocyArIDEuXG4gICAgY29uc3QgZ2x5cGhPZmZzZXRzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1HbHlwaHMgKyAxOyBpICs9IDEpIHtcbiAgICAgICAgbGV0IGdseXBoT2Zmc2V0ID0gcGFyc2VGbi5jYWxsKHApO1xuICAgICAgICBpZiAoc2hvcnRWZXJzaW9uKSB7XG4gICAgICAgICAgICAvLyBUaGUgc2hvcnQgdGFibGUgdmVyc2lvbiBzdG9yZXMgdGhlIGFjdHVhbCBvZmZzZXQgZGl2aWRlZCBieSAyLlxuICAgICAgICAgICAgZ2x5cGhPZmZzZXQgKj0gMjtcbiAgICAgICAgfVxuXG4gICAgICAgIGdseXBoT2Zmc2V0cy5wdXNoKGdseXBoT2Zmc2V0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gZ2x5cGhPZmZzZXRzO1xufVxuXG5leHBvcnQgZGVmYXVsdCB7IHBhcnNlOiBwYXJzZUxvY2FUYWJsZSB9O1xuIiwiLy8gb3BlbnR5cGUuanNcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlYm94L29wZW50eXBlLmpzXG4vLyAoYykgMjAxNSBGcmVkZXJpayBEZSBCbGVzZXJcbi8vIG9wZW50eXBlLmpzIG1heSBiZSBmcmVlbHkgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuXG4vKiBnbG9iYWwgRGF0YVZpZXcsIFVpbnQ4QXJyYXksIFhNTEh0dHBSZXF1ZXN0ICAqL1xuXG5pbXBvcnQgaW5mbGF0ZSBmcm9tICd0aW55LWluZmxhdGUnO1xuaW1wb3J0IEZvbnQgZnJvbSAnLi9mb250JztcbmltcG9ydCBHbHlwaCBmcm9tICcuL2dseXBoJztcbmltcG9ydCB7IENtYXBFbmNvZGluZywgR2x5cGhOYW1lcywgYWRkR2x5cGhOYW1lcyB9IGZyb20gJy4vZW5jb2RpbmcnO1xuaW1wb3J0IHBhcnNlIGZyb20gJy4vcGFyc2UnO1xuaW1wb3J0IEJvdW5kaW5nQm94IGZyb20gJy4vYmJveCc7XG5pbXBvcnQgUGF0aCBmcm9tICcuL3BhdGgnO1xuaW1wb3J0IHsgbm9kZUJ1ZmZlclRvQXJyYXlCdWZmZXIgfSBmcm9tICcuL3V0aWwnO1xuaW1wb3J0IGNtYXAgZnJvbSAnLi90YWJsZXMvY21hcCc7XG5pbXBvcnQgY2ZmIGZyb20gJy4vdGFibGVzL2NmZic7XG5pbXBvcnQgZnZhciBmcm9tICcuL3RhYmxlcy9mdmFyJztcbmltcG9ydCBnbHlmIGZyb20gJy4vdGFibGVzL2dseWYnO1xuaW1wb3J0IGdwb3MgZnJvbSAnLi90YWJsZXMvZ3Bvcyc7XG5pbXBvcnQgZ3N1YiBmcm9tICcuL3RhYmxlcy9nc3ViJztcbmltcG9ydCBoZWFkIGZyb20gJy4vdGFibGVzL2hlYWQnO1xuaW1wb3J0IGhoZWEgZnJvbSAnLi90YWJsZXMvaGhlYSc7XG5pbXBvcnQgaG10eCBmcm9tICcuL3RhYmxlcy9obXR4JztcbmltcG9ydCBrZXJuIGZyb20gJy4vdGFibGVzL2tlcm4nO1xuaW1wb3J0IGx0YWcgZnJvbSAnLi90YWJsZXMvbHRhZyc7XG5pbXBvcnQgbG9jYSBmcm9tICcuL3RhYmxlcy9sb2NhJztcbmltcG9ydCBtYXhwIGZyb20gJy4vdGFibGVzL21heHAnO1xuaW1wb3J0IF9uYW1lIGZyb20gJy4vdGFibGVzL25hbWUnO1xuaW1wb3J0IG9zMiBmcm9tICcuL3RhYmxlcy9vczInO1xuaW1wb3J0IHBvc3QgZnJvbSAnLi90YWJsZXMvcG9zdCc7XG5pbXBvcnQgbWV0YSBmcm9tICcuL3RhYmxlcy9tZXRhJztcblxuLyoqXG4gKiBUaGUgb3BlbnR5cGUgbGlicmFyeS5cbiAqIEBuYW1lc3BhY2Ugb3BlbnR5cGVcbiAqL1xuXG4vLyBGaWxlIGxvYWRlcnMgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vKipcbiAqIExvYWRzIGEgZm9udCBmcm9tIGEgZmlsZS4gVGhlIGNhbGxiYWNrIHRocm93cyBhbiBlcnJvciBtZXNzYWdlIGFzIHRoZSBmaXJzdCBwYXJhbWV0ZXIgaWYgaXQgZmFpbHNcbiAqIGFuZCB0aGUgZm9udCBhcyBhbiBBcnJheUJ1ZmZlciBpbiB0aGUgc2Vjb25kIHBhcmFtZXRlciBpZiBpdCBzdWNjZWVkcy5cbiAqIEBwYXJhbSAge3N0cmluZ30gcGF0aCAtIFRoZSBwYXRoIG9mIHRoZSBmaWxlXG4gKiBAcGFyYW0gIHtGdW5jdGlvbn0gY2FsbGJhY2sgLSBUaGUgZnVuY3Rpb24gdG8gY2FsbCB3aGVuIHRoZSBmb250IGxvYWQgY29tcGxldGVzXG4gKi9cbmZ1bmN0aW9uIGxvYWRGcm9tRmlsZShwYXRoLCBjYWxsYmFjaykge1xuICAgIGNvbnN0IGZzID0gcmVxdWlyZSgnZnMnKTtcbiAgICBmcy5yZWFkRmlsZShwYXRoLCBmdW5jdGlvbihlcnIsIGJ1ZmZlcikge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyLm1lc3NhZ2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgY2FsbGJhY2sobnVsbCwgbm9kZUJ1ZmZlclRvQXJyYXlCdWZmZXIoYnVmZmVyKSk7XG4gICAgfSk7XG59XG4vKipcbiAqIExvYWRzIGEgZm9udCBmcm9tIGEgVVJMLiBUaGUgY2FsbGJhY2sgdGhyb3dzIGFuIGVycm9yIG1lc3NhZ2UgYXMgdGhlIGZpcnN0IHBhcmFtZXRlciBpZiBpdCBmYWlsc1xuICogYW5kIHRoZSBmb250IGFzIGFuIEFycmF5QnVmZmVyIGluIHRoZSBzZWNvbmQgcGFyYW1ldGVyIGlmIGl0IHN1Y2NlZWRzLlxuICogQHBhcmFtICB7c3RyaW5nfSB1cmwgLSBUaGUgVVJMIG9mIHRoZSBmb250IGZpbGUuXG4gKiBAcGFyYW0gIHtGdW5jdGlvbn0gY2FsbGJhY2sgLSBUaGUgZnVuY3Rpb24gdG8gY2FsbCB3aGVuIHRoZSBmb250IGxvYWQgY29tcGxldGVzXG4gKi9cbmZ1bmN0aW9uIGxvYWRGcm9tVXJsKHVybCwgY2FsbGJhY2spIHtcbiAgICBjb25zdCByZXF1ZXN0ID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgcmVxdWVzdC5vcGVuKCdnZXQnLCB1cmwsIHRydWUpO1xuICAgIHJlcXVlc3QucmVzcG9uc2VUeXBlID0gJ2FycmF5YnVmZmVyJztcbiAgICByZXF1ZXN0Lm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAocmVxdWVzdC5zdGF0dXMgIT09IDIwMCkge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKCdGb250IGNvdWxkIG5vdCBiZSBsb2FkZWQ6ICcgKyByZXF1ZXN0LnN0YXR1c1RleHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIHJlcXVlc3QucmVzcG9uc2UpO1xuICAgIH07XG5cbiAgICByZXF1ZXN0Lm9uZXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNhbGxiYWNrKCdGb250IGNvdWxkIG5vdCBiZSBsb2FkZWQnKTtcbiAgICB9O1xuXG4gICAgcmVxdWVzdC5zZW5kKCk7XG59XG5cbi8vIFRhYmxlIERpcmVjdG9yeSBFbnRyaWVzIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8qKlxuICogUGFyc2VzIE9wZW5UeXBlIHRhYmxlIGVudHJpZXMuXG4gKiBAcGFyYW0gIHtEYXRhVmlld31cbiAqIEBwYXJhbSAge051bWJlcn1cbiAqIEByZXR1cm4ge09iamVjdFtdfVxuICovXG5mdW5jdGlvbiBwYXJzZU9wZW5UeXBlVGFibGVFbnRyaWVzKGRhdGEsIG51bVRhYmxlcykge1xuICAgIGNvbnN0IHRhYmxlRW50cmllcyA9IFtdO1xuICAgIGxldCBwID0gMTI7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1UYWJsZXM7IGkgKz0gMSkge1xuICAgICAgICBjb25zdCB0YWcgPSBwYXJzZS5nZXRUYWcoZGF0YSwgcCk7XG4gICAgICAgIGNvbnN0IGNoZWNrc3VtID0gcGFyc2UuZ2V0VUxvbmcoZGF0YSwgcCArIDQpO1xuICAgICAgICBjb25zdCBvZmZzZXQgPSBwYXJzZS5nZXRVTG9uZyhkYXRhLCBwICsgOCk7XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IHBhcnNlLmdldFVMb25nKGRhdGEsIHAgKyAxMik7XG4gICAgICAgIHRhYmxlRW50cmllcy5wdXNoKHt0YWc6IHRhZywgY2hlY2tzdW06IGNoZWNrc3VtLCBvZmZzZXQ6IG9mZnNldCwgbGVuZ3RoOiBsZW5ndGgsIGNvbXByZXNzaW9uOiBmYWxzZX0pO1xuICAgICAgICBwICs9IDE2O1xuICAgIH1cblxuICAgIHJldHVybiB0YWJsZUVudHJpZXM7XG59XG5cbi8qKlxuICogUGFyc2VzIFdPRkYgdGFibGUgZW50cmllcy5cbiAqIEBwYXJhbSAge0RhdGFWaWV3fVxuICogQHBhcmFtICB7TnVtYmVyfVxuICogQHJldHVybiB7T2JqZWN0W119XG4gKi9cbmZ1bmN0aW9uIHBhcnNlV09GRlRhYmxlRW50cmllcyhkYXRhLCBudW1UYWJsZXMpIHtcbiAgICBjb25zdCB0YWJsZUVudHJpZXMgPSBbXTtcbiAgICBsZXQgcCA9IDQ0OyAvLyBvZmZzZXQgdG8gdGhlIGZpcnN0IHRhYmxlIGRpcmVjdG9yeSBlbnRyeS5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bVRhYmxlczsgaSArPSAxKSB7XG4gICAgICAgIGNvbnN0IHRhZyA9IHBhcnNlLmdldFRhZyhkYXRhLCBwKTtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gcGFyc2UuZ2V0VUxvbmcoZGF0YSwgcCArIDQpO1xuICAgICAgICBjb25zdCBjb21wTGVuZ3RoID0gcGFyc2UuZ2V0VUxvbmcoZGF0YSwgcCArIDgpO1xuICAgICAgICBjb25zdCBvcmlnTGVuZ3RoID0gcGFyc2UuZ2V0VUxvbmcoZGF0YSwgcCArIDEyKTtcbiAgICAgICAgbGV0IGNvbXByZXNzaW9uO1xuICAgICAgICBpZiAoY29tcExlbmd0aCA8IG9yaWdMZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbXByZXNzaW9uID0gJ1dPRkYnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29tcHJlc3Npb24gPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRhYmxlRW50cmllcy5wdXNoKHt0YWc6IHRhZywgb2Zmc2V0OiBvZmZzZXQsIGNvbXByZXNzaW9uOiBjb21wcmVzc2lvbixcbiAgICAgICAgICAgIGNvbXByZXNzZWRMZW5ndGg6IGNvbXBMZW5ndGgsIGxlbmd0aDogb3JpZ0xlbmd0aH0pO1xuICAgICAgICBwICs9IDIwO1xuICAgIH1cblxuICAgIHJldHVybiB0YWJsZUVudHJpZXM7XG59XG5cbi8qKlxuICogQHR5cGVkZWYgVGFibGVEYXRhXG4gKiBAdHlwZSBPYmplY3RcbiAqIEBwcm9wZXJ0eSB7RGF0YVZpZXd9IGRhdGEgLSBUaGUgRGF0YVZpZXdcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBvZmZzZXQgLSBUaGUgZGF0YSBvZmZzZXQuXG4gKi9cblxuLyoqXG4gKiBAcGFyYW0gIHtEYXRhVmlld31cbiAqIEBwYXJhbSAge09iamVjdH1cbiAqIEByZXR1cm4ge1RhYmxlRGF0YX1cbiAqL1xuZnVuY3Rpb24gdW5jb21wcmVzc1RhYmxlKGRhdGEsIHRhYmxlRW50cnkpIHtcbiAgICBpZiAodGFibGVFbnRyeS5jb21wcmVzc2lvbiA9PT0gJ1dPRkYnKSB7XG4gICAgICAgIGNvbnN0IGluQnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoZGF0YS5idWZmZXIsIHRhYmxlRW50cnkub2Zmc2V0ICsgMiwgdGFibGVFbnRyeS5jb21wcmVzc2VkTGVuZ3RoIC0gMik7XG4gICAgICAgIGNvbnN0IG91dEJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KHRhYmxlRW50cnkubGVuZ3RoKTtcbiAgICAgICAgaW5mbGF0ZShpbkJ1ZmZlciwgb3V0QnVmZmVyKTtcbiAgICAgICAgaWYgKG91dEJ1ZmZlci5ieXRlTGVuZ3RoICE9PSB0YWJsZUVudHJ5Lmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEZWNvbXByZXNzaW9uIGVycm9yOiAnICsgdGFibGVFbnRyeS50YWcgKyAnIGRlY29tcHJlc3NlZCBsZW5ndGggZG9lc25cXCd0IG1hdGNoIHJlY29yZGVkIGxlbmd0aCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgdmlldyA9IG5ldyBEYXRhVmlldyhvdXRCdWZmZXIuYnVmZmVyLCAwKTtcbiAgICAgICAgcmV0dXJuIHtkYXRhOiB2aWV3LCBvZmZzZXQ6IDB9O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB7ZGF0YTogZGF0YSwgb2Zmc2V0OiB0YWJsZUVudHJ5Lm9mZnNldH07XG4gICAgfVxufVxuXG4vLyBQdWJsaWMgQVBJIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbi8qKlxuICogUGFyc2UgdGhlIE9wZW5UeXBlIGZpbGUgZGF0YSAoYXMgYW4gQXJyYXlCdWZmZXIpIGFuZCByZXR1cm4gYSBGb250IG9iamVjdC5cbiAqIFRocm93cyBhbiBlcnJvciBpZiB0aGUgZm9udCBjb3VsZCBub3QgYmUgcGFyc2VkLlxuICogQHBhcmFtICB7QXJyYXlCdWZmZXJ9XG4gKiBAcmV0dXJuIHtvcGVudHlwZS5Gb250fVxuICovXG5mdW5jdGlvbiBwYXJzZUJ1ZmZlcihidWZmZXIpIHtcbiAgICBsZXQgaW5kZXhUb0xvY0Zvcm1hdDtcbiAgICBsZXQgbHRhZ1RhYmxlO1xuXG4gICAgLy8gU2luY2UgdGhlIGNvbnN0cnVjdG9yIGNhbiBhbHNvIGJlIGNhbGxlZCB0byBjcmVhdGUgbmV3IGZvbnRzIGZyb20gc2NyYXRjaCwgd2UgaW5kaWNhdGUgdGhpc1xuICAgIC8vIHNob3VsZCBiZSBhbiBlbXB0eSBmb250IHRoYXQgd2UnbGwgZmlsbCB3aXRoIG91ciBvd24gZGF0YS5cbiAgICBjb25zdCBmb250ID0gbmV3IEZvbnQoe2VtcHR5OiB0cnVlfSk7XG5cbiAgICAvLyBPcGVuVHlwZSBmb250cyB1c2UgYmlnIGVuZGlhbiBieXRlIG9yZGVyaW5nLlxuICAgIC8vIFdlIGNhbid0IHJlbHkgb24gdHlwZWQgYXJyYXkgdmlldyB0eXBlcywgYmVjYXVzZSB0aGV5IG9wZXJhdGUgd2l0aCB0aGUgZW5kaWFubmVzcyBvZiB0aGUgaG9zdCBjb21wdXRlci5cbiAgICAvLyBJbnN0ZWFkIHdlIHVzZSBEYXRhVmlld3Mgd2hlcmUgd2UgY2FuIHNwZWNpZnkgZW5kaWFubmVzcy5cbiAgICBjb25zdCBkYXRhID0gbmV3IERhdGFWaWV3KGJ1ZmZlciwgMCk7XG4gICAgbGV0IG51bVRhYmxlcztcbiAgICBsZXQgdGFibGVFbnRyaWVzID0gW107XG4gICAgY29uc3Qgc2lnbmF0dXJlID0gcGFyc2UuZ2V0VGFnKGRhdGEsIDApO1xuICAgIGlmIChzaWduYXR1cmUgPT09IFN0cmluZy5mcm9tQ2hhckNvZGUoMCwgMSwgMCwgMCkgfHwgc2lnbmF0dXJlID09PSAndHJ1ZScgfHwgc2lnbmF0dXJlID09PSAndHlwMScpIHtcbiAgICAgICAgZm9udC5vdXRsaW5lc0Zvcm1hdCA9ICd0cnVldHlwZSc7XG4gICAgICAgIG51bVRhYmxlcyA9IHBhcnNlLmdldFVTaG9ydChkYXRhLCA0KTtcbiAgICAgICAgdGFibGVFbnRyaWVzID0gcGFyc2VPcGVuVHlwZVRhYmxlRW50cmllcyhkYXRhLCBudW1UYWJsZXMpO1xuICAgIH0gZWxzZSBpZiAoc2lnbmF0dXJlID09PSAnT1RUTycpIHtcbiAgICAgICAgZm9udC5vdXRsaW5lc0Zvcm1hdCA9ICdjZmYnO1xuICAgICAgICBudW1UYWJsZXMgPSBwYXJzZS5nZXRVU2hvcnQoZGF0YSwgNCk7XG4gICAgICAgIHRhYmxlRW50cmllcyA9IHBhcnNlT3BlblR5cGVUYWJsZUVudHJpZXMoZGF0YSwgbnVtVGFibGVzKTtcbiAgICB9IGVsc2UgaWYgKHNpZ25hdHVyZSA9PT0gJ3dPRkYnKSB7XG4gICAgICAgIGNvbnN0IGZsYXZvciA9IHBhcnNlLmdldFRhZyhkYXRhLCA0KTtcbiAgICAgICAgaWYgKGZsYXZvciA9PT0gU3RyaW5nLmZyb21DaGFyQ29kZSgwLCAxLCAwLCAwKSkge1xuICAgICAgICAgICAgZm9udC5vdXRsaW5lc0Zvcm1hdCA9ICd0cnVldHlwZSc7XG4gICAgICAgIH0gZWxzZSBpZiAoZmxhdm9yID09PSAnT1RUTycpIHtcbiAgICAgICAgICAgIGZvbnQub3V0bGluZXNGb3JtYXQgPSAnY2ZmJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgT3BlblR5cGUgZmxhdm9yICcgKyBzaWduYXR1cmUpO1xuICAgICAgICB9XG5cbiAgICAgICAgbnVtVGFibGVzID0gcGFyc2UuZ2V0VVNob3J0KGRhdGEsIDEyKTtcbiAgICAgICAgdGFibGVFbnRyaWVzID0gcGFyc2VXT0ZGVGFibGVFbnRyaWVzKGRhdGEsIG51bVRhYmxlcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBPcGVuVHlwZSBzaWduYXR1cmUgJyArIHNpZ25hdHVyZSk7XG4gICAgfVxuXG4gICAgbGV0IGNmZlRhYmxlRW50cnk7XG4gICAgbGV0IGZ2YXJUYWJsZUVudHJ5O1xuICAgIGxldCBnbHlmVGFibGVFbnRyeTtcbiAgICBsZXQgZ3Bvc1RhYmxlRW50cnk7XG4gICAgbGV0IGdzdWJUYWJsZUVudHJ5O1xuICAgIGxldCBobXR4VGFibGVFbnRyeTtcbiAgICBsZXQga2VyblRhYmxlRW50cnk7XG4gICAgbGV0IGxvY2FUYWJsZUVudHJ5O1xuICAgIGxldCBuYW1lVGFibGVFbnRyeTtcbiAgICBsZXQgbWV0YVRhYmxlRW50cnk7XG4gICAgbGV0IHA7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bVRhYmxlczsgaSArPSAxKSB7XG4gICAgICAgIGNvbnN0IHRhYmxlRW50cnkgPSB0YWJsZUVudHJpZXNbaV07XG4gICAgICAgIGxldCB0YWJsZTtcbiAgICAgICAgc3dpdGNoICh0YWJsZUVudHJ5LnRhZykge1xuICAgICAgICAgICAgY2FzZSAnY21hcCc6XG4gICAgICAgICAgICAgICAgdGFibGUgPSB1bmNvbXByZXNzVGFibGUoZGF0YSwgdGFibGVFbnRyeSk7XG4gICAgICAgICAgICAgICAgZm9udC50YWJsZXMuY21hcCA9IGNtYXAucGFyc2UodGFibGUuZGF0YSwgdGFibGUub2Zmc2V0KTtcbiAgICAgICAgICAgICAgICBmb250LmVuY29kaW5nID0gbmV3IENtYXBFbmNvZGluZyhmb250LnRhYmxlcy5jbWFwKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2N2dCAnIDpcbiAgICAgICAgICAgICAgICB0YWJsZSA9IHVuY29tcHJlc3NUYWJsZShkYXRhLCB0YWJsZUVudHJ5KTtcbiAgICAgICAgICAgICAgICBwID0gbmV3IHBhcnNlLlBhcnNlcih0YWJsZS5kYXRhLCB0YWJsZS5vZmZzZXQpO1xuICAgICAgICAgICAgICAgIGZvbnQudGFibGVzLmN2dCA9IHAucGFyc2VTaG9ydExpc3QodGFibGVFbnRyeS5sZW5ndGggLyAyKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2Z2YXInOlxuICAgICAgICAgICAgICAgIGZ2YXJUYWJsZUVudHJ5ID0gdGFibGVFbnRyeTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2ZwZ20nIDpcbiAgICAgICAgICAgICAgICB0YWJsZSA9IHVuY29tcHJlc3NUYWJsZShkYXRhLCB0YWJsZUVudHJ5KTtcbiAgICAgICAgICAgICAgICBwID0gbmV3IHBhcnNlLlBhcnNlcih0YWJsZS5kYXRhLCB0YWJsZS5vZmZzZXQpO1xuICAgICAgICAgICAgICAgIGZvbnQudGFibGVzLmZwZ20gPSBwLnBhcnNlQnl0ZUxpc3QodGFibGVFbnRyeS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnaGVhZCc6XG4gICAgICAgICAgICAgICAgdGFibGUgPSB1bmNvbXByZXNzVGFibGUoZGF0YSwgdGFibGVFbnRyeSk7XG4gICAgICAgICAgICAgICAgZm9udC50YWJsZXMuaGVhZCA9IGhlYWQucGFyc2UodGFibGUuZGF0YSwgdGFibGUub2Zmc2V0KTtcbiAgICAgICAgICAgICAgICBmb250LnVuaXRzUGVyRW0gPSBmb250LnRhYmxlcy5oZWFkLnVuaXRzUGVyRW07XG4gICAgICAgICAgICAgICAgaW5kZXhUb0xvY0Zvcm1hdCA9IGZvbnQudGFibGVzLmhlYWQuaW5kZXhUb0xvY0Zvcm1hdDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2hoZWEnOlxuICAgICAgICAgICAgICAgIHRhYmxlID0gdW5jb21wcmVzc1RhYmxlKGRhdGEsIHRhYmxlRW50cnkpO1xuICAgICAgICAgICAgICAgIGZvbnQudGFibGVzLmhoZWEgPSBoaGVhLnBhcnNlKHRhYmxlLmRhdGEsIHRhYmxlLm9mZnNldCk7XG4gICAgICAgICAgICAgICAgZm9udC5hc2NlbmRlciA9IGZvbnQudGFibGVzLmhoZWEuYXNjZW5kZXI7XG4gICAgICAgICAgICAgICAgZm9udC5kZXNjZW5kZXIgPSBmb250LnRhYmxlcy5oaGVhLmRlc2NlbmRlcjtcbiAgICAgICAgICAgICAgICBmb250Lm51bWJlck9mSE1ldHJpY3MgPSBmb250LnRhYmxlcy5oaGVhLm51bWJlck9mSE1ldHJpY3M7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdobXR4JzpcbiAgICAgICAgICAgICAgICBobXR4VGFibGVFbnRyeSA9IHRhYmxlRW50cnk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdsdGFnJzpcbiAgICAgICAgICAgICAgICB0YWJsZSA9IHVuY29tcHJlc3NUYWJsZShkYXRhLCB0YWJsZUVudHJ5KTtcbiAgICAgICAgICAgICAgICBsdGFnVGFibGUgPSBsdGFnLnBhcnNlKHRhYmxlLmRhdGEsIHRhYmxlLm9mZnNldCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdtYXhwJzpcbiAgICAgICAgICAgICAgICB0YWJsZSA9IHVuY29tcHJlc3NUYWJsZShkYXRhLCB0YWJsZUVudHJ5KTtcbiAgICAgICAgICAgICAgICBmb250LnRhYmxlcy5tYXhwID0gbWF4cC5wYXJzZSh0YWJsZS5kYXRhLCB0YWJsZS5vZmZzZXQpO1xuICAgICAgICAgICAgICAgIGZvbnQubnVtR2x5cGhzID0gZm9udC50YWJsZXMubWF4cC5udW1HbHlwaHM7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICduYW1lJzpcbiAgICAgICAgICAgICAgICBuYW1lVGFibGVFbnRyeSA9IHRhYmxlRW50cnk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdPUy8yJzpcbiAgICAgICAgICAgICAgICB0YWJsZSA9IHVuY29tcHJlc3NUYWJsZShkYXRhLCB0YWJsZUVudHJ5KTtcbiAgICAgICAgICAgICAgICBmb250LnRhYmxlcy5vczIgPSBvczIucGFyc2UodGFibGUuZGF0YSwgdGFibGUub2Zmc2V0KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3Bvc3QnOlxuICAgICAgICAgICAgICAgIHRhYmxlID0gdW5jb21wcmVzc1RhYmxlKGRhdGEsIHRhYmxlRW50cnkpO1xuICAgICAgICAgICAgICAgIGZvbnQudGFibGVzLnBvc3QgPSBwb3N0LnBhcnNlKHRhYmxlLmRhdGEsIHRhYmxlLm9mZnNldCk7XG4gICAgICAgICAgICAgICAgZm9udC5nbHlwaE5hbWVzID0gbmV3IEdseXBoTmFtZXMoZm9udC50YWJsZXMucG9zdCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdwcmVwJyA6XG4gICAgICAgICAgICAgICAgdGFibGUgPSB1bmNvbXByZXNzVGFibGUoZGF0YSwgdGFibGVFbnRyeSk7XG4gICAgICAgICAgICAgICAgcCA9IG5ldyBwYXJzZS5QYXJzZXIodGFibGUuZGF0YSwgdGFibGUub2Zmc2V0KTtcbiAgICAgICAgICAgICAgICBmb250LnRhYmxlcy5wcmVwID0gcC5wYXJzZUJ5dGVMaXN0KHRhYmxlRW50cnkubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2dseWYnOlxuICAgICAgICAgICAgICAgIGdseWZUYWJsZUVudHJ5ID0gdGFibGVFbnRyeTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2xvY2EnOlxuICAgICAgICAgICAgICAgIGxvY2FUYWJsZUVudHJ5ID0gdGFibGVFbnRyeTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ0NGRiAnOlxuICAgICAgICAgICAgICAgIGNmZlRhYmxlRW50cnkgPSB0YWJsZUVudHJ5O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAna2Vybic6XG4gICAgICAgICAgICAgICAga2VyblRhYmxlRW50cnkgPSB0YWJsZUVudHJ5O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnR1BPUyc6XG4gICAgICAgICAgICAgICAgZ3Bvc1RhYmxlRW50cnkgPSB0YWJsZUVudHJ5O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnR1NVQic6XG4gICAgICAgICAgICAgICAgZ3N1YlRhYmxlRW50cnkgPSB0YWJsZUVudHJ5O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnbWV0YSc6XG4gICAgICAgICAgICAgICAgbWV0YVRhYmxlRW50cnkgPSB0YWJsZUVudHJ5O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgbmFtZVRhYmxlID0gdW5jb21wcmVzc1RhYmxlKGRhdGEsIG5hbWVUYWJsZUVudHJ5KTtcbiAgICBmb250LnRhYmxlcy5uYW1lID0gX25hbWUucGFyc2UobmFtZVRhYmxlLmRhdGEsIG5hbWVUYWJsZS5vZmZzZXQsIGx0YWdUYWJsZSk7XG4gICAgZm9udC5uYW1lcyA9IGZvbnQudGFibGVzLm5hbWU7XG5cbiAgICBpZiAoZ2x5ZlRhYmxlRW50cnkgJiYgbG9jYVRhYmxlRW50cnkpIHtcbiAgICAgICAgY29uc3Qgc2hvcnRWZXJzaW9uID0gaW5kZXhUb0xvY0Zvcm1hdCA9PT0gMDtcbiAgICAgICAgY29uc3QgbG9jYVRhYmxlID0gdW5jb21wcmVzc1RhYmxlKGRhdGEsIGxvY2FUYWJsZUVudHJ5KTtcbiAgICAgICAgY29uc3QgbG9jYU9mZnNldHMgPSBsb2NhLnBhcnNlKGxvY2FUYWJsZS5kYXRhLCBsb2NhVGFibGUub2Zmc2V0LCBmb250Lm51bUdseXBocywgc2hvcnRWZXJzaW9uKTtcbiAgICAgICAgY29uc3QgZ2x5ZlRhYmxlID0gdW5jb21wcmVzc1RhYmxlKGRhdGEsIGdseWZUYWJsZUVudHJ5KTtcbiAgICAgICAgZm9udC5nbHlwaHMgPSBnbHlmLnBhcnNlKGdseWZUYWJsZS5kYXRhLCBnbHlmVGFibGUub2Zmc2V0LCBsb2NhT2Zmc2V0cywgZm9udCk7XG4gICAgfSBlbHNlIGlmIChjZmZUYWJsZUVudHJ5KSB7XG4gICAgICAgIGNvbnN0IGNmZlRhYmxlID0gdW5jb21wcmVzc1RhYmxlKGRhdGEsIGNmZlRhYmxlRW50cnkpO1xuICAgICAgICBjZmYucGFyc2UoY2ZmVGFibGUuZGF0YSwgY2ZmVGFibGUub2Zmc2V0LCBmb250KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZvbnQgZG9lc25cXCd0IGNvbnRhaW4gVHJ1ZVR5cGUgb3IgQ0ZGIG91dGxpbmVzLicpO1xuICAgIH1cblxuICAgIGNvbnN0IGhtdHhUYWJsZSA9IHVuY29tcHJlc3NUYWJsZShkYXRhLCBobXR4VGFibGVFbnRyeSk7XG4gICAgaG10eC5wYXJzZShobXR4VGFibGUuZGF0YSwgaG10eFRhYmxlLm9mZnNldCwgZm9udC5udW1iZXJPZkhNZXRyaWNzLCBmb250Lm51bUdseXBocywgZm9udC5nbHlwaHMpO1xuICAgIGFkZEdseXBoTmFtZXMoZm9udCk7XG5cbiAgICBpZiAoa2VyblRhYmxlRW50cnkpIHtcbiAgICAgICAgY29uc3Qga2VyblRhYmxlID0gdW5jb21wcmVzc1RhYmxlKGRhdGEsIGtlcm5UYWJsZUVudHJ5KTtcbiAgICAgICAgZm9udC5rZXJuaW5nUGFpcnMgPSBrZXJuLnBhcnNlKGtlcm5UYWJsZS5kYXRhLCBrZXJuVGFibGUub2Zmc2V0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBmb250Lmtlcm5pbmdQYWlycyA9IHt9O1xuICAgIH1cblxuICAgIGlmIChncG9zVGFibGVFbnRyeSkge1xuICAgICAgICBjb25zdCBncG9zVGFibGUgPSB1bmNvbXByZXNzVGFibGUoZGF0YSwgZ3Bvc1RhYmxlRW50cnkpO1xuICAgICAgICBncG9zLnBhcnNlKGdwb3NUYWJsZS5kYXRhLCBncG9zVGFibGUub2Zmc2V0LCBmb250KTtcbiAgICB9XG5cbiAgICBpZiAoZ3N1YlRhYmxlRW50cnkpIHtcbiAgICAgICAgY29uc3QgZ3N1YlRhYmxlID0gdW5jb21wcmVzc1RhYmxlKGRhdGEsIGdzdWJUYWJsZUVudHJ5KTtcbiAgICAgICAgZm9udC50YWJsZXMuZ3N1YiA9IGdzdWIucGFyc2UoZ3N1YlRhYmxlLmRhdGEsIGdzdWJUYWJsZS5vZmZzZXQpO1xuICAgIH1cblxuICAgIGlmIChmdmFyVGFibGVFbnRyeSkge1xuICAgICAgICBjb25zdCBmdmFyVGFibGUgPSB1bmNvbXByZXNzVGFibGUoZGF0YSwgZnZhclRhYmxlRW50cnkpO1xuICAgICAgICBmb250LnRhYmxlcy5mdmFyID0gZnZhci5wYXJzZShmdmFyVGFibGUuZGF0YSwgZnZhclRhYmxlLm9mZnNldCwgZm9udC5uYW1lcyk7XG4gICAgfVxuXG4gICAgaWYgKG1ldGFUYWJsZUVudHJ5KSB7XG4gICAgICAgIGNvbnN0IG1ldGFUYWJsZSA9IHVuY29tcHJlc3NUYWJsZShkYXRhLCBtZXRhVGFibGVFbnRyeSk7XG4gICAgICAgIGZvbnQudGFibGVzLm1ldGEgPSBtZXRhLnBhcnNlKG1ldGFUYWJsZS5kYXRhLCBtZXRhVGFibGUub2Zmc2V0KTtcbiAgICAgICAgZm9udC5tZXRhcyA9IGZvbnQudGFibGVzLm1ldGE7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZvbnQ7XG59XG5cbi8qKlxuICogQXN5bmNocm9ub3VzbHkgbG9hZCB0aGUgZm9udCBmcm9tIGEgVVJMIG9yIGEgZmlsZXN5c3RlbS4gV2hlbiBkb25lLCBjYWxsIHRoZSBjYWxsYmFja1xuICogd2l0aCB0d28gYXJndW1lbnRzIGAoZXJyLCBmb250KWAuIFRoZSBgZXJyYCB3aWxsIGJlIG51bGwgb24gc3VjY2VzcyxcbiAqIHRoZSBgZm9udGAgaXMgYSBGb250IG9iamVjdC5cbiAqIFdlIHVzZSB0aGUgbm9kZS5qcyBjYWxsYmFjayBjb252ZW50aW9uIHNvIHRoYXRcbiAqIG9wZW50eXBlLmpzIGNhbiBpbnRlZ3JhdGUgd2l0aCBmcmFtZXdvcmtzIGxpa2UgYXN5bmMuanMuXG4gKiBAYWxpYXMgb3BlbnR5cGUubG9hZFxuICogQHBhcmFtICB7c3RyaW5nfSB1cmwgLSBUaGUgVVJMIG9mIHRoZSBmb250IHRvIGxvYWQuXG4gKiBAcGFyYW0gIHtGdW5jdGlvbn0gY2FsbGJhY2sgLSBUaGUgY2FsbGJhY2suXG4gKi9cbmZ1bmN0aW9uIGxvYWQodXJsLCBjYWxsYmFjaykge1xuICAgIGNvbnN0IGlzTm9kZSA9IHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnO1xuICAgIGNvbnN0IGxvYWRGbiA9IGlzTm9kZSA/IGxvYWRGcm9tRmlsZSA6IGxvYWRGcm9tVXJsO1xuICAgIGxvYWRGbih1cmwsIGZ1bmN0aW9uKGVyciwgYXJyYXlCdWZmZXIpIHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGZvbnQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb250ID0gcGFyc2VCdWZmZXIoYXJyYXlCdWZmZXIpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZSwgbnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIGZvbnQpO1xuICAgIH0pO1xufVxuXG4vKipcbiAqIFN5bmNocm9ub3VzbHkgbG9hZCB0aGUgZm9udCBmcm9tIGEgVVJMIG9yIGZpbGUuXG4gKiBXaGVuIGRvbmUsIHJldHVybnMgdGhlIGZvbnQgb2JqZWN0IG9yIHRocm93cyBhbiBlcnJvci5cbiAqIEBhbGlhcyBvcGVudHlwZS5sb2FkU3luY1xuICogQHBhcmFtICB7c3RyaW5nfSB1cmwgLSBUaGUgVVJMIG9mIHRoZSBmb250IHRvIGxvYWQuXG4gKiBAcmV0dXJuIHtvcGVudHlwZS5Gb250fVxuICovXG5mdW5jdGlvbiBsb2FkU3luYyh1cmwpIHtcbiAgICBjb25zdCBmcyA9IHJlcXVpcmUoJ2ZzJyk7XG4gICAgY29uc3QgYnVmZmVyID0gZnMucmVhZEZpbGVTeW5jKHVybCk7XG4gICAgcmV0dXJuIHBhcnNlQnVmZmVyKG5vZGVCdWZmZXJUb0FycmF5QnVmZmVyKGJ1ZmZlcikpO1xufVxuXG5leHBvcnQge1xuICAgIEZvbnQsXG4gICAgR2x5cGgsXG4gICAgUGF0aCxcbiAgICBCb3VuZGluZ0JveCxcbiAgICBwYXJzZSBhcyBfcGFyc2UsXG4gICAgcGFyc2VCdWZmZXIgYXMgcGFyc2UsXG4gICAgbG9hZCxcbiAgICBsb2FkU3luY1xufTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///2\n")},function(module,exports){eval("var TINF_OK = 0;\nvar TINF_DATA_ERROR = -3;\n\nfunction Tree() {\n  this.table = new Uint16Array(16);   /* table of code length counts */\n  this.trans = new Uint16Array(288);  /* code -> symbol translation table */\n}\n\nfunction Data(source, dest) {\n  this.source = source;\n  this.sourceIndex = 0;\n  this.tag = 0;\n  this.bitcount = 0;\n  \n  this.dest = dest;\n  this.destLen = 0;\n  \n  this.ltree = new Tree();  /* dynamic length/symbol tree */\n  this.dtree = new Tree();  /* dynamic distance tree */\n}\n\n/* --------------------------------------------------- *\n * -- uninitialized global data (static structures) -- *\n * --------------------------------------------------- */\n\nvar sltree = new Tree();\nvar sdtree = new Tree();\n\n/* extra bits and base tables for length codes */\nvar length_bits = new Uint8Array(30);\nvar length_base = new Uint16Array(30);\n\n/* extra bits and base tables for distance codes */\nvar dist_bits = new Uint8Array(30);\nvar dist_base = new Uint16Array(30);\n\n/* special ordering of code length codes */\nvar clcidx = new Uint8Array([\n  16, 17, 18, 0, 8, 7, 9, 6,\n  10, 5, 11, 4, 12, 3, 13, 2,\n  14, 1, 15\n]);\n\n/* used by tinf_decode_trees, avoids allocations every call */\nvar code_tree = new Tree();\nvar lengths = new Uint8Array(288 + 32);\n\n/* ----------------------- *\n * -- utility functions -- *\n * ----------------------- */\n\n/* build extra bits and base tables */\nfunction tinf_build_bits_base(bits, base, delta, first) {\n  var i, sum;\n\n  /* build bits table */\n  for (i = 0; i < delta; ++i) bits[i] = 0;\n  for (i = 0; i < 30 - delta; ++i) bits[i + delta] = i / delta | 0;\n\n  /* build base table */\n  for (sum = first, i = 0; i < 30; ++i) {\n    base[i] = sum;\n    sum += 1 << bits[i];\n  }\n}\n\n/* build the fixed huffman trees */\nfunction tinf_build_fixed_trees(lt, dt) {\n  var i;\n\n  /* build fixed length tree */\n  for (i = 0; i < 7; ++i) lt.table[i] = 0;\n\n  lt.table[7] = 24;\n  lt.table[8] = 152;\n  lt.table[9] = 112;\n\n  for (i = 0; i < 24; ++i) lt.trans[i] = 256 + i;\n  for (i = 0; i < 144; ++i) lt.trans[24 + i] = i;\n  for (i = 0; i < 8; ++i) lt.trans[24 + 144 + i] = 280 + i;\n  for (i = 0; i < 112; ++i) lt.trans[24 + 144 + 8 + i] = 144 + i;\n\n  /* build fixed distance tree */\n  for (i = 0; i < 5; ++i) dt.table[i] = 0;\n\n  dt.table[5] = 32;\n\n  for (i = 0; i < 32; ++i) dt.trans[i] = i;\n}\n\n/* given an array of code lengths, build a tree */\nvar offs = new Uint16Array(16);\n\nfunction tinf_build_tree(t, lengths, off, num) {\n  var i, sum;\n\n  /* clear code length count table */\n  for (i = 0; i < 16; ++i) t.table[i] = 0;\n\n  /* scan symbol lengths, and sum code length counts */\n  for (i = 0; i < num; ++i) t.table[lengths[off + i]]++;\n\n  t.table[0] = 0;\n\n  /* compute offset table for distribution sort */\n  for (sum = 0, i = 0; i < 16; ++i) {\n    offs[i] = sum;\n    sum += t.table[i];\n  }\n\n  /* create code->symbol translation table (symbols sorted by code) */\n  for (i = 0; i < num; ++i) {\n    if (lengths[off + i]) t.trans[offs[lengths[off + i]]++] = i;\n  }\n}\n\n/* ---------------------- *\n * -- decode functions -- *\n * ---------------------- */\n\n/* get one bit from source stream */\nfunction tinf_getbit(d) {\n  /* check if tag is empty */\n  if (!d.bitcount--) {\n    /* load next tag */\n    d.tag = d.source[d.sourceIndex++];\n    d.bitcount = 7;\n  }\n\n  /* shift bit out of tag */\n  var bit = d.tag & 1;\n  d.tag >>>= 1;\n\n  return bit;\n}\n\n/* read a num bit value from a stream and add base */\nfunction tinf_read_bits(d, num, base) {\n  if (!num)\n    return base;\n\n  while (d.bitcount < 24) {\n    d.tag |= d.source[d.sourceIndex++] << d.bitcount;\n    d.bitcount += 8;\n  }\n\n  var val = d.tag & (0xffff >>> (16 - num));\n  d.tag >>>= num;\n  d.bitcount -= num;\n  return val + base;\n}\n\n/* given a data stream and a tree, decode a symbol */\nfunction tinf_decode_symbol(d, t) {\n  while (d.bitcount < 24) {\n    d.tag |= d.source[d.sourceIndex++] << d.bitcount;\n    d.bitcount += 8;\n  }\n  \n  var sum = 0, cur = 0, len = 0;\n  var tag = d.tag;\n\n  /* get more bits while code value is above sum */\n  do {\n    cur = 2 * cur + (tag & 1);\n    tag >>>= 1;\n    ++len;\n\n    sum += t.table[len];\n    cur -= t.table[len];\n  } while (cur >= 0);\n  \n  d.tag = tag;\n  d.bitcount -= len;\n\n  return t.trans[sum + cur];\n}\n\n/* given a data stream, decode dynamic trees from it */\nfunction tinf_decode_trees(d, lt, dt) {\n  var hlit, hdist, hclen;\n  var i, num, length;\n\n  /* get 5 bits HLIT (257-286) */\n  hlit = tinf_read_bits(d, 5, 257);\n\n  /* get 5 bits HDIST (1-32) */\n  hdist = tinf_read_bits(d, 5, 1);\n\n  /* get 4 bits HCLEN (4-19) */\n  hclen = tinf_read_bits(d, 4, 4);\n\n  for (i = 0; i < 19; ++i) lengths[i] = 0;\n\n  /* read code lengths for code length alphabet */\n  for (i = 0; i < hclen; ++i) {\n    /* get 3 bits code length (0-7) */\n    var clen = tinf_read_bits(d, 3, 0);\n    lengths[clcidx[i]] = clen;\n  }\n\n  /* build code length tree */\n  tinf_build_tree(code_tree, lengths, 0, 19);\n\n  /* decode code lengths for the dynamic trees */\n  for (num = 0; num < hlit + hdist;) {\n    var sym = tinf_decode_symbol(d, code_tree);\n\n    switch (sym) {\n      case 16:\n        /* copy previous code length 3-6 times (read 2 bits) */\n        var prev = lengths[num - 1];\n        for (length = tinf_read_bits(d, 2, 3); length; --length) {\n          lengths[num++] = prev;\n        }\n        break;\n      case 17:\n        /* repeat code length 0 for 3-10 times (read 3 bits) */\n        for (length = tinf_read_bits(d, 3, 3); length; --length) {\n          lengths[num++] = 0;\n        }\n        break;\n      case 18:\n        /* repeat code length 0 for 11-138 times (read 7 bits) */\n        for (length = tinf_read_bits(d, 7, 11); length; --length) {\n          lengths[num++] = 0;\n        }\n        break;\n      default:\n        /* values 0-15 represent the actual code lengths */\n        lengths[num++] = sym;\n        break;\n    }\n  }\n\n  /* build dynamic trees */\n  tinf_build_tree(lt, lengths, 0, hlit);\n  tinf_build_tree(dt, lengths, hlit, hdist);\n}\n\n/* ----------------------------- *\n * -- block inflate functions -- *\n * ----------------------------- */\n\n/* given a stream and two trees, inflate a block of data */\nfunction tinf_inflate_block_data(d, lt, dt) {\n  while (1) {\n    var sym = tinf_decode_symbol(d, lt);\n\n    /* check for end of block */\n    if (sym === 256) {\n      return TINF_OK;\n    }\n\n    if (sym < 256) {\n      d.dest[d.destLen++] = sym;\n    } else {\n      var length, dist, offs;\n      var i;\n\n      sym -= 257;\n\n      /* possibly get more bits from length code */\n      length = tinf_read_bits(d, length_bits[sym], length_base[sym]);\n\n      dist = tinf_decode_symbol(d, dt);\n\n      /* possibly get more bits from distance code */\n      offs = d.destLen - tinf_read_bits(d, dist_bits[dist], dist_base[dist]);\n\n      /* copy match */\n      for (i = offs; i < offs + length; ++i) {\n        d.dest[d.destLen++] = d.dest[i];\n      }\n    }\n  }\n}\n\n/* inflate an uncompressed block of data */\nfunction tinf_inflate_uncompressed_block(d) {\n  var length, invlength;\n  var i;\n  \n  /* unread from bitbuffer */\n  while (d.bitcount > 8) {\n    d.sourceIndex--;\n    d.bitcount -= 8;\n  }\n\n  /* get length */\n  length = d.source[d.sourceIndex + 1];\n  length = 256 * length + d.source[d.sourceIndex];\n\n  /* get one's complement of length */\n  invlength = d.source[d.sourceIndex + 3];\n  invlength = 256 * invlength + d.source[d.sourceIndex + 2];\n\n  /* check length */\n  if (length !== (~invlength & 0x0000ffff))\n    return TINF_DATA_ERROR;\n\n  d.sourceIndex += 4;\n\n  /* copy block */\n  for (i = length; i; --i)\n    d.dest[d.destLen++] = d.source[d.sourceIndex++];\n\n  /* make sure we start next block on a byte boundary */\n  d.bitcount = 0;\n\n  return TINF_OK;\n}\n\n/* inflate stream from source to dest */\nfunction tinf_uncompress(source, dest) {\n  var d = new Data(source, dest);\n  var bfinal, btype, res;\n\n  do {\n    /* read final block flag */\n    bfinal = tinf_getbit(d);\n\n    /* read block type (2 bits) */\n    btype = tinf_read_bits(d, 2, 0);\n\n    /* decompress block */\n    switch (btype) {\n      case 0:\n        /* decompress uncompressed block */\n        res = tinf_inflate_uncompressed_block(d);\n        break;\n      case 1:\n        /* decompress block with fixed huffman trees */\n        res = tinf_inflate_block_data(d, sltree, sdtree);\n        break;\n      case 2:\n        /* decompress block with dynamic huffman trees */\n        tinf_decode_trees(d, d.ltree, d.dtree);\n        res = tinf_inflate_block_data(d, d.ltree, d.dtree);\n        break;\n      default:\n        res = TINF_DATA_ERROR;\n    }\n\n    if (res !== TINF_OK)\n      throw new Error('Data error');\n\n  } while (!bfinal);\n\n  if (d.destLen < d.dest.length) {\n    if (typeof d.dest.slice === 'function')\n      return d.dest.slice(0, d.destLen);\n    else\n      return d.dest.subarray(0, d.destLen);\n  }\n  \n  return d.dest;\n}\n\n/* -------------------- *\n * -- initialization -- *\n * -------------------- */\n\n/* build fixed huffman trees */\ntinf_build_fixed_trees(sltree, sdtree);\n\n/* build extra bits and base tables */\ntinf_build_bits_base(length_bits, length_base, 4, 3);\ntinf_build_bits_base(dist_bits, dist_base, 2, 1);\n\n/* fix a special case */\nlength_bits[28] = 0;\nlength_base[28] = 258;\n\nmodule.exports = tinf_uncompress;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Xcml0aW5nQW5pbWF0aW9uLy4vbm9kZV9tb2R1bGVzL3RpbnktaW5mbGF0ZS9pbmRleC5qcz81YWU1Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7O0FBRUE7QUFDQSxtQ0FBbUM7QUFDbkMsb0NBQW9DO0FBQ3BDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSwwQkFBMEI7QUFDMUIsMEJBQTBCO0FBQzFCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxXQUFXO0FBQ3hCLGFBQWEsZ0JBQWdCOztBQUU3QjtBQUNBLDBCQUEwQixRQUFRO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsT0FBTzs7QUFFcEI7QUFDQTtBQUNBOztBQUVBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFNBQVM7QUFDdEIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsU0FBUzs7QUFFdEI7QUFDQSxhQUFhLE9BQU87O0FBRXBCOztBQUVBLGFBQWEsUUFBUTtBQUNyQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLFFBQVE7O0FBRXJCO0FBQ0EsYUFBYSxTQUFTOztBQUV0Qjs7QUFFQTtBQUNBLHNCQUFzQixRQUFRO0FBQzlCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxhQUFhLFFBQVE7O0FBRXJCO0FBQ0EsYUFBYSxXQUFXO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLG9CQUFvQjtBQUNuQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxRQUFRO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsUUFBUTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLFFBQVE7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLG1CQUFtQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxrQkFBa0IsR0FBRztBQUNyQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBIiwiZmlsZSI6IjMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgVElORl9PSyA9IDA7XG52YXIgVElORl9EQVRBX0VSUk9SID0gLTM7XG5cbmZ1bmN0aW9uIFRyZWUoKSB7XG4gIHRoaXMudGFibGUgPSBuZXcgVWludDE2QXJyYXkoMTYpOyAgIC8qIHRhYmxlIG9mIGNvZGUgbGVuZ3RoIGNvdW50cyAqL1xuICB0aGlzLnRyYW5zID0gbmV3IFVpbnQxNkFycmF5KDI4OCk7ICAvKiBjb2RlIC0+IHN5bWJvbCB0cmFuc2xhdGlvbiB0YWJsZSAqL1xufVxuXG5mdW5jdGlvbiBEYXRhKHNvdXJjZSwgZGVzdCkge1xuICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgdGhpcy5zb3VyY2VJbmRleCA9IDA7XG4gIHRoaXMudGFnID0gMDtcbiAgdGhpcy5iaXRjb3VudCA9IDA7XG4gIFxuICB0aGlzLmRlc3QgPSBkZXN0O1xuICB0aGlzLmRlc3RMZW4gPSAwO1xuICBcbiAgdGhpcy5sdHJlZSA9IG5ldyBUcmVlKCk7ICAvKiBkeW5hbWljIGxlbmd0aC9zeW1ib2wgdHJlZSAqL1xuICB0aGlzLmR0cmVlID0gbmV3IFRyZWUoKTsgIC8qIGR5bmFtaWMgZGlzdGFuY2UgdHJlZSAqL1xufVxuXG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKlxuICogLS0gdW5pbml0aWFsaXplZCBnbG9iYWwgZGF0YSAoc3RhdGljIHN0cnVjdHVyZXMpIC0tICpcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG52YXIgc2x0cmVlID0gbmV3IFRyZWUoKTtcbnZhciBzZHRyZWUgPSBuZXcgVHJlZSgpO1xuXG4vKiBleHRyYSBiaXRzIGFuZCBiYXNlIHRhYmxlcyBmb3IgbGVuZ3RoIGNvZGVzICovXG52YXIgbGVuZ3RoX2JpdHMgPSBuZXcgVWludDhBcnJheSgzMCk7XG52YXIgbGVuZ3RoX2Jhc2UgPSBuZXcgVWludDE2QXJyYXkoMzApO1xuXG4vKiBleHRyYSBiaXRzIGFuZCBiYXNlIHRhYmxlcyBmb3IgZGlzdGFuY2UgY29kZXMgKi9cbnZhciBkaXN0X2JpdHMgPSBuZXcgVWludDhBcnJheSgzMCk7XG52YXIgZGlzdF9iYXNlID0gbmV3IFVpbnQxNkFycmF5KDMwKTtcblxuLyogc3BlY2lhbCBvcmRlcmluZyBvZiBjb2RlIGxlbmd0aCBjb2RlcyAqL1xudmFyIGNsY2lkeCA9IG5ldyBVaW50OEFycmF5KFtcbiAgMTYsIDE3LCAxOCwgMCwgOCwgNywgOSwgNixcbiAgMTAsIDUsIDExLCA0LCAxMiwgMywgMTMsIDIsXG4gIDE0LCAxLCAxNVxuXSk7XG5cbi8qIHVzZWQgYnkgdGluZl9kZWNvZGVfdHJlZXMsIGF2b2lkcyBhbGxvY2F0aW9ucyBldmVyeSBjYWxsICovXG52YXIgY29kZV90cmVlID0gbmV3IFRyZWUoKTtcbnZhciBsZW5ndGhzID0gbmV3IFVpbnQ4QXJyYXkoMjg4ICsgMzIpO1xuXG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqXG4gKiAtLSB1dGlsaXR5IGZ1bmN0aW9ucyAtLSAqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG4vKiBidWlsZCBleHRyYSBiaXRzIGFuZCBiYXNlIHRhYmxlcyAqL1xuZnVuY3Rpb24gdGluZl9idWlsZF9iaXRzX2Jhc2UoYml0cywgYmFzZSwgZGVsdGEsIGZpcnN0KSB7XG4gIHZhciBpLCBzdW07XG5cbiAgLyogYnVpbGQgYml0cyB0YWJsZSAqL1xuICBmb3IgKGkgPSAwOyBpIDwgZGVsdGE7ICsraSkgYml0c1tpXSA9IDA7XG4gIGZvciAoaSA9IDA7IGkgPCAzMCAtIGRlbHRhOyArK2kpIGJpdHNbaSArIGRlbHRhXSA9IGkgLyBkZWx0YSB8IDA7XG5cbiAgLyogYnVpbGQgYmFzZSB0YWJsZSAqL1xuICBmb3IgKHN1bSA9IGZpcnN0LCBpID0gMDsgaSA8IDMwOyArK2kpIHtcbiAgICBiYXNlW2ldID0gc3VtO1xuICAgIHN1bSArPSAxIDw8IGJpdHNbaV07XG4gIH1cbn1cblxuLyogYnVpbGQgdGhlIGZpeGVkIGh1ZmZtYW4gdHJlZXMgKi9cbmZ1bmN0aW9uIHRpbmZfYnVpbGRfZml4ZWRfdHJlZXMobHQsIGR0KSB7XG4gIHZhciBpO1xuXG4gIC8qIGJ1aWxkIGZpeGVkIGxlbmd0aCB0cmVlICovXG4gIGZvciAoaSA9IDA7IGkgPCA3OyArK2kpIGx0LnRhYmxlW2ldID0gMDtcblxuICBsdC50YWJsZVs3XSA9IDI0O1xuICBsdC50YWJsZVs4XSA9IDE1MjtcbiAgbHQudGFibGVbOV0gPSAxMTI7XG5cbiAgZm9yIChpID0gMDsgaSA8IDI0OyArK2kpIGx0LnRyYW5zW2ldID0gMjU2ICsgaTtcbiAgZm9yIChpID0gMDsgaSA8IDE0NDsgKytpKSBsdC50cmFuc1syNCArIGldID0gaTtcbiAgZm9yIChpID0gMDsgaSA8IDg7ICsraSkgbHQudHJhbnNbMjQgKyAxNDQgKyBpXSA9IDI4MCArIGk7XG4gIGZvciAoaSA9IDA7IGkgPCAxMTI7ICsraSkgbHQudHJhbnNbMjQgKyAxNDQgKyA4ICsgaV0gPSAxNDQgKyBpO1xuXG4gIC8qIGJ1aWxkIGZpeGVkIGRpc3RhbmNlIHRyZWUgKi9cbiAgZm9yIChpID0gMDsgaSA8IDU7ICsraSkgZHQudGFibGVbaV0gPSAwO1xuXG4gIGR0LnRhYmxlWzVdID0gMzI7XG5cbiAgZm9yIChpID0gMDsgaSA8IDMyOyArK2kpIGR0LnRyYW5zW2ldID0gaTtcbn1cblxuLyogZ2l2ZW4gYW4gYXJyYXkgb2YgY29kZSBsZW5ndGhzLCBidWlsZCBhIHRyZWUgKi9cbnZhciBvZmZzID0gbmV3IFVpbnQxNkFycmF5KDE2KTtcblxuZnVuY3Rpb24gdGluZl9idWlsZF90cmVlKHQsIGxlbmd0aHMsIG9mZiwgbnVtKSB7XG4gIHZhciBpLCBzdW07XG5cbiAgLyogY2xlYXIgY29kZSBsZW5ndGggY291bnQgdGFibGUgKi9cbiAgZm9yIChpID0gMDsgaSA8IDE2OyArK2kpIHQudGFibGVbaV0gPSAwO1xuXG4gIC8qIHNjYW4gc3ltYm9sIGxlbmd0aHMsIGFuZCBzdW0gY29kZSBsZW5ndGggY291bnRzICovXG4gIGZvciAoaSA9IDA7IGkgPCBudW07ICsraSkgdC50YWJsZVtsZW5ndGhzW29mZiArIGldXSsrO1xuXG4gIHQudGFibGVbMF0gPSAwO1xuXG4gIC8qIGNvbXB1dGUgb2Zmc2V0IHRhYmxlIGZvciBkaXN0cmlidXRpb24gc29ydCAqL1xuICBmb3IgKHN1bSA9IDAsIGkgPSAwOyBpIDwgMTY7ICsraSkge1xuICAgIG9mZnNbaV0gPSBzdW07XG4gICAgc3VtICs9IHQudGFibGVbaV07XG4gIH1cblxuICAvKiBjcmVhdGUgY29kZS0+c3ltYm9sIHRyYW5zbGF0aW9uIHRhYmxlIChzeW1ib2xzIHNvcnRlZCBieSBjb2RlKSAqL1xuICBmb3IgKGkgPSAwOyBpIDwgbnVtOyArK2kpIHtcbiAgICBpZiAobGVuZ3Roc1tvZmYgKyBpXSkgdC50cmFuc1tvZmZzW2xlbmd0aHNbb2ZmICsgaV1dKytdID0gaTtcbiAgfVxufVxuXG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tICpcbiAqIC0tIGRlY29kZSBmdW5jdGlvbnMgLS0gKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG4vKiBnZXQgb25lIGJpdCBmcm9tIHNvdXJjZSBzdHJlYW0gKi9cbmZ1bmN0aW9uIHRpbmZfZ2V0Yml0KGQpIHtcbiAgLyogY2hlY2sgaWYgdGFnIGlzIGVtcHR5ICovXG4gIGlmICghZC5iaXRjb3VudC0tKSB7XG4gICAgLyogbG9hZCBuZXh0IHRhZyAqL1xuICAgIGQudGFnID0gZC5zb3VyY2VbZC5zb3VyY2VJbmRleCsrXTtcbiAgICBkLmJpdGNvdW50ID0gNztcbiAgfVxuXG4gIC8qIHNoaWZ0IGJpdCBvdXQgb2YgdGFnICovXG4gIHZhciBiaXQgPSBkLnRhZyAmIDE7XG4gIGQudGFnID4+Pj0gMTtcblxuICByZXR1cm4gYml0O1xufVxuXG4vKiByZWFkIGEgbnVtIGJpdCB2YWx1ZSBmcm9tIGEgc3RyZWFtIGFuZCBhZGQgYmFzZSAqL1xuZnVuY3Rpb24gdGluZl9yZWFkX2JpdHMoZCwgbnVtLCBiYXNlKSB7XG4gIGlmICghbnVtKVxuICAgIHJldHVybiBiYXNlO1xuXG4gIHdoaWxlIChkLmJpdGNvdW50IDwgMjQpIHtcbiAgICBkLnRhZyB8PSBkLnNvdXJjZVtkLnNvdXJjZUluZGV4KytdIDw8IGQuYml0Y291bnQ7XG4gICAgZC5iaXRjb3VudCArPSA4O1xuICB9XG5cbiAgdmFyIHZhbCA9IGQudGFnICYgKDB4ZmZmZiA+Pj4gKDE2IC0gbnVtKSk7XG4gIGQudGFnID4+Pj0gbnVtO1xuICBkLmJpdGNvdW50IC09IG51bTtcbiAgcmV0dXJuIHZhbCArIGJhc2U7XG59XG5cbi8qIGdpdmVuIGEgZGF0YSBzdHJlYW0gYW5kIGEgdHJlZSwgZGVjb2RlIGEgc3ltYm9sICovXG5mdW5jdGlvbiB0aW5mX2RlY29kZV9zeW1ib2woZCwgdCkge1xuICB3aGlsZSAoZC5iaXRjb3VudCA8IDI0KSB7XG4gICAgZC50YWcgfD0gZC5zb3VyY2VbZC5zb3VyY2VJbmRleCsrXSA8PCBkLmJpdGNvdW50O1xuICAgIGQuYml0Y291bnQgKz0gODtcbiAgfVxuICBcbiAgdmFyIHN1bSA9IDAsIGN1ciA9IDAsIGxlbiA9IDA7XG4gIHZhciB0YWcgPSBkLnRhZztcblxuICAvKiBnZXQgbW9yZSBiaXRzIHdoaWxlIGNvZGUgdmFsdWUgaXMgYWJvdmUgc3VtICovXG4gIGRvIHtcbiAgICBjdXIgPSAyICogY3VyICsgKHRhZyAmIDEpO1xuICAgIHRhZyA+Pj49IDE7XG4gICAgKytsZW47XG5cbiAgICBzdW0gKz0gdC50YWJsZVtsZW5dO1xuICAgIGN1ciAtPSB0LnRhYmxlW2xlbl07XG4gIH0gd2hpbGUgKGN1ciA+PSAwKTtcbiAgXG4gIGQudGFnID0gdGFnO1xuICBkLmJpdGNvdW50IC09IGxlbjtcblxuICByZXR1cm4gdC50cmFuc1tzdW0gKyBjdXJdO1xufVxuXG4vKiBnaXZlbiBhIGRhdGEgc3RyZWFtLCBkZWNvZGUgZHluYW1pYyB0cmVlcyBmcm9tIGl0ICovXG5mdW5jdGlvbiB0aW5mX2RlY29kZV90cmVlcyhkLCBsdCwgZHQpIHtcbiAgdmFyIGhsaXQsIGhkaXN0LCBoY2xlbjtcbiAgdmFyIGksIG51bSwgbGVuZ3RoO1xuXG4gIC8qIGdldCA1IGJpdHMgSExJVCAoMjU3LTI4NikgKi9cbiAgaGxpdCA9IHRpbmZfcmVhZF9iaXRzKGQsIDUsIDI1Nyk7XG5cbiAgLyogZ2V0IDUgYml0cyBIRElTVCAoMS0zMikgKi9cbiAgaGRpc3QgPSB0aW5mX3JlYWRfYml0cyhkLCA1LCAxKTtcblxuICAvKiBnZXQgNCBiaXRzIEhDTEVOICg0LTE5KSAqL1xuICBoY2xlbiA9IHRpbmZfcmVhZF9iaXRzKGQsIDQsIDQpO1xuXG4gIGZvciAoaSA9IDA7IGkgPCAxOTsgKytpKSBsZW5ndGhzW2ldID0gMDtcblxuICAvKiByZWFkIGNvZGUgbGVuZ3RocyBmb3IgY29kZSBsZW5ndGggYWxwaGFiZXQgKi9cbiAgZm9yIChpID0gMDsgaSA8IGhjbGVuOyArK2kpIHtcbiAgICAvKiBnZXQgMyBiaXRzIGNvZGUgbGVuZ3RoICgwLTcpICovXG4gICAgdmFyIGNsZW4gPSB0aW5mX3JlYWRfYml0cyhkLCAzLCAwKTtcbiAgICBsZW5ndGhzW2NsY2lkeFtpXV0gPSBjbGVuO1xuICB9XG5cbiAgLyogYnVpbGQgY29kZSBsZW5ndGggdHJlZSAqL1xuICB0aW5mX2J1aWxkX3RyZWUoY29kZV90cmVlLCBsZW5ndGhzLCAwLCAxOSk7XG5cbiAgLyogZGVjb2RlIGNvZGUgbGVuZ3RocyBmb3IgdGhlIGR5bmFtaWMgdHJlZXMgKi9cbiAgZm9yIChudW0gPSAwOyBudW0gPCBobGl0ICsgaGRpc3Q7KSB7XG4gICAgdmFyIHN5bSA9IHRpbmZfZGVjb2RlX3N5bWJvbChkLCBjb2RlX3RyZWUpO1xuXG4gICAgc3dpdGNoIChzeW0pIHtcbiAgICAgIGNhc2UgMTY6XG4gICAgICAgIC8qIGNvcHkgcHJldmlvdXMgY29kZSBsZW5ndGggMy02IHRpbWVzIChyZWFkIDIgYml0cykgKi9cbiAgICAgICAgdmFyIHByZXYgPSBsZW5ndGhzW251bSAtIDFdO1xuICAgICAgICBmb3IgKGxlbmd0aCA9IHRpbmZfcmVhZF9iaXRzKGQsIDIsIDMpOyBsZW5ndGg7IC0tbGVuZ3RoKSB7XG4gICAgICAgICAgbGVuZ3Roc1tudW0rK10gPSBwcmV2O1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxNzpcbiAgICAgICAgLyogcmVwZWF0IGNvZGUgbGVuZ3RoIDAgZm9yIDMtMTAgdGltZXMgKHJlYWQgMyBiaXRzKSAqL1xuICAgICAgICBmb3IgKGxlbmd0aCA9IHRpbmZfcmVhZF9iaXRzKGQsIDMsIDMpOyBsZW5ndGg7IC0tbGVuZ3RoKSB7XG4gICAgICAgICAgbGVuZ3Roc1tudW0rK10gPSAwO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxODpcbiAgICAgICAgLyogcmVwZWF0IGNvZGUgbGVuZ3RoIDAgZm9yIDExLTEzOCB0aW1lcyAocmVhZCA3IGJpdHMpICovXG4gICAgICAgIGZvciAobGVuZ3RoID0gdGluZl9yZWFkX2JpdHMoZCwgNywgMTEpOyBsZW5ndGg7IC0tbGVuZ3RoKSB7XG4gICAgICAgICAgbGVuZ3Roc1tudW0rK10gPSAwO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgLyogdmFsdWVzIDAtMTUgcmVwcmVzZW50IHRoZSBhY3R1YWwgY29kZSBsZW5ndGhzICovXG4gICAgICAgIGxlbmd0aHNbbnVtKytdID0gc3ltO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICAvKiBidWlsZCBkeW5hbWljIHRyZWVzICovXG4gIHRpbmZfYnVpbGRfdHJlZShsdCwgbGVuZ3RocywgMCwgaGxpdCk7XG4gIHRpbmZfYnVpbGRfdHJlZShkdCwgbGVuZ3RocywgaGxpdCwgaGRpc3QpO1xufVxuXG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqXG4gKiAtLSBibG9jayBpbmZsYXRlIGZ1bmN0aW9ucyAtLSAqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG4vKiBnaXZlbiBhIHN0cmVhbSBhbmQgdHdvIHRyZWVzLCBpbmZsYXRlIGEgYmxvY2sgb2YgZGF0YSAqL1xuZnVuY3Rpb24gdGluZl9pbmZsYXRlX2Jsb2NrX2RhdGEoZCwgbHQsIGR0KSB7XG4gIHdoaWxlICgxKSB7XG4gICAgdmFyIHN5bSA9IHRpbmZfZGVjb2RlX3N5bWJvbChkLCBsdCk7XG5cbiAgICAvKiBjaGVjayBmb3IgZW5kIG9mIGJsb2NrICovXG4gICAgaWYgKHN5bSA9PT0gMjU2KSB7XG4gICAgICByZXR1cm4gVElORl9PSztcbiAgICB9XG5cbiAgICBpZiAoc3ltIDwgMjU2KSB7XG4gICAgICBkLmRlc3RbZC5kZXN0TGVuKytdID0gc3ltO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgbGVuZ3RoLCBkaXN0LCBvZmZzO1xuICAgICAgdmFyIGk7XG5cbiAgICAgIHN5bSAtPSAyNTc7XG5cbiAgICAgIC8qIHBvc3NpYmx5IGdldCBtb3JlIGJpdHMgZnJvbSBsZW5ndGggY29kZSAqL1xuICAgICAgbGVuZ3RoID0gdGluZl9yZWFkX2JpdHMoZCwgbGVuZ3RoX2JpdHNbc3ltXSwgbGVuZ3RoX2Jhc2Vbc3ltXSk7XG5cbiAgICAgIGRpc3QgPSB0aW5mX2RlY29kZV9zeW1ib2woZCwgZHQpO1xuXG4gICAgICAvKiBwb3NzaWJseSBnZXQgbW9yZSBiaXRzIGZyb20gZGlzdGFuY2UgY29kZSAqL1xuICAgICAgb2ZmcyA9IGQuZGVzdExlbiAtIHRpbmZfcmVhZF9iaXRzKGQsIGRpc3RfYml0c1tkaXN0XSwgZGlzdF9iYXNlW2Rpc3RdKTtcblxuICAgICAgLyogY29weSBtYXRjaCAqL1xuICAgICAgZm9yIChpID0gb2ZmczsgaSA8IG9mZnMgKyBsZW5ndGg7ICsraSkge1xuICAgICAgICBkLmRlc3RbZC5kZXN0TGVuKytdID0gZC5kZXN0W2ldO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKiBpbmZsYXRlIGFuIHVuY29tcHJlc3NlZCBibG9jayBvZiBkYXRhICovXG5mdW5jdGlvbiB0aW5mX2luZmxhdGVfdW5jb21wcmVzc2VkX2Jsb2NrKGQpIHtcbiAgdmFyIGxlbmd0aCwgaW52bGVuZ3RoO1xuICB2YXIgaTtcbiAgXG4gIC8qIHVucmVhZCBmcm9tIGJpdGJ1ZmZlciAqL1xuICB3aGlsZSAoZC5iaXRjb3VudCA+IDgpIHtcbiAgICBkLnNvdXJjZUluZGV4LS07XG4gICAgZC5iaXRjb3VudCAtPSA4O1xuICB9XG5cbiAgLyogZ2V0IGxlbmd0aCAqL1xuICBsZW5ndGggPSBkLnNvdXJjZVtkLnNvdXJjZUluZGV4ICsgMV07XG4gIGxlbmd0aCA9IDI1NiAqIGxlbmd0aCArIGQuc291cmNlW2Quc291cmNlSW5kZXhdO1xuXG4gIC8qIGdldCBvbmUncyBjb21wbGVtZW50IG9mIGxlbmd0aCAqL1xuICBpbnZsZW5ndGggPSBkLnNvdXJjZVtkLnNvdXJjZUluZGV4ICsgM107XG4gIGludmxlbmd0aCA9IDI1NiAqIGludmxlbmd0aCArIGQuc291cmNlW2Quc291cmNlSW5kZXggKyAyXTtcblxuICAvKiBjaGVjayBsZW5ndGggKi9cbiAgaWYgKGxlbmd0aCAhPT0gKH5pbnZsZW5ndGggJiAweDAwMDBmZmZmKSlcbiAgICByZXR1cm4gVElORl9EQVRBX0VSUk9SO1xuXG4gIGQuc291cmNlSW5kZXggKz0gNDtcblxuICAvKiBjb3B5IGJsb2NrICovXG4gIGZvciAoaSA9IGxlbmd0aDsgaTsgLS1pKVxuICAgIGQuZGVzdFtkLmRlc3RMZW4rK10gPSBkLnNvdXJjZVtkLnNvdXJjZUluZGV4KytdO1xuXG4gIC8qIG1ha2Ugc3VyZSB3ZSBzdGFydCBuZXh0IGJsb2NrIG9uIGEgYnl0ZSBib3VuZGFyeSAqL1xuICBkLmJpdGNvdW50ID0gMDtcblxuICByZXR1cm4gVElORl9PSztcbn1cblxuLyogaW5mbGF0ZSBzdHJlYW0gZnJvbSBzb3VyY2UgdG8gZGVzdCAqL1xuZnVuY3Rpb24gdGluZl91bmNvbXByZXNzKHNvdXJjZSwgZGVzdCkge1xuICB2YXIgZCA9IG5ldyBEYXRhKHNvdXJjZSwgZGVzdCk7XG4gIHZhciBiZmluYWwsIGJ0eXBlLCByZXM7XG5cbiAgZG8ge1xuICAgIC8qIHJlYWQgZmluYWwgYmxvY2sgZmxhZyAqL1xuICAgIGJmaW5hbCA9IHRpbmZfZ2V0Yml0KGQpO1xuXG4gICAgLyogcmVhZCBibG9jayB0eXBlICgyIGJpdHMpICovXG4gICAgYnR5cGUgPSB0aW5mX3JlYWRfYml0cyhkLCAyLCAwKTtcblxuICAgIC8qIGRlY29tcHJlc3MgYmxvY2sgKi9cbiAgICBzd2l0Y2ggKGJ0eXBlKSB7XG4gICAgICBjYXNlIDA6XG4gICAgICAgIC8qIGRlY29tcHJlc3MgdW5jb21wcmVzc2VkIGJsb2NrICovXG4gICAgICAgIHJlcyA9IHRpbmZfaW5mbGF0ZV91bmNvbXByZXNzZWRfYmxvY2soZCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxOlxuICAgICAgICAvKiBkZWNvbXByZXNzIGJsb2NrIHdpdGggZml4ZWQgaHVmZm1hbiB0cmVlcyAqL1xuICAgICAgICByZXMgPSB0aW5mX2luZmxhdGVfYmxvY2tfZGF0YShkLCBzbHRyZWUsIHNkdHJlZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyOlxuICAgICAgICAvKiBkZWNvbXByZXNzIGJsb2NrIHdpdGggZHluYW1pYyBodWZmbWFuIHRyZWVzICovXG4gICAgICAgIHRpbmZfZGVjb2RlX3RyZWVzKGQsIGQubHRyZWUsIGQuZHRyZWUpO1xuICAgICAgICByZXMgPSB0aW5mX2luZmxhdGVfYmxvY2tfZGF0YShkLCBkLmx0cmVlLCBkLmR0cmVlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXMgPSBUSU5GX0RBVEFfRVJST1I7XG4gICAgfVxuXG4gICAgaWYgKHJlcyAhPT0gVElORl9PSylcbiAgICAgIHRocm93IG5ldyBFcnJvcignRGF0YSBlcnJvcicpO1xuXG4gIH0gd2hpbGUgKCFiZmluYWwpO1xuXG4gIGlmIChkLmRlc3RMZW4gPCBkLmRlc3QubGVuZ3RoKSB7XG4gICAgaWYgKHR5cGVvZiBkLmRlc3Quc2xpY2UgPT09ICdmdW5jdGlvbicpXG4gICAgICByZXR1cm4gZC5kZXN0LnNsaWNlKDAsIGQuZGVzdExlbik7XG4gICAgZWxzZVxuICAgICAgcmV0dXJuIGQuZGVzdC5zdWJhcnJheSgwLCBkLmRlc3RMZW4pO1xuICB9XG4gIFxuICByZXR1cm4gZC5kZXN0O1xufVxuXG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLSAqXG4gKiAtLSBpbml0aWFsaXphdGlvbiAtLSAqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG4vKiBidWlsZCBmaXhlZCBodWZmbWFuIHRyZWVzICovXG50aW5mX2J1aWxkX2ZpeGVkX3RyZWVzKHNsdHJlZSwgc2R0cmVlKTtcblxuLyogYnVpbGQgZXh0cmEgYml0cyBhbmQgYmFzZSB0YWJsZXMgKi9cbnRpbmZfYnVpbGRfYml0c19iYXNlKGxlbmd0aF9iaXRzLCBsZW5ndGhfYmFzZSwgNCwgMyk7XG50aW5mX2J1aWxkX2JpdHNfYmFzZShkaXN0X2JpdHMsIGRpc3RfYmFzZSwgMiwgMSk7XG5cbi8qIGZpeCBhIHNwZWNpYWwgY2FzZSAqL1xubGVuZ3RoX2JpdHNbMjhdID0gMDtcbmxlbmd0aF9iYXNlWzI4XSA9IDI1ODtcblxubW9kdWxlLmV4cG9ydHMgPSB0aW5mX3VuY29tcHJlc3M7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///3\n")},function(module,exports,__webpack_require__){"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\nexports.default = void 0;\n\nvar _svg = _interopRequireDefault(__webpack_require__(5));\n\nvar opentype = _interopRequireWildcard(__webpack_require__(2));\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _instanceof(left, right) { if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) { return right[Symbol.hasInstance](left); } else { return left instanceof right; } }\n\nfunction _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!_instanceof(instance, Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nvar WritingAnimation =\n/*#__PURE__*/\nfunction (_TextToSvg) {\n  _inherits(WritingAnimation, _TextToSvg);\n\n  function WritingAnimation() {\n    _classCallCheck(this, WritingAnimation);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(WritingAnimation).apply(this, arguments));\n  }\n\n  _createClass(WritingAnimation, [{\n    key: "animateText",\n    value: function animateText(text, domElementId) {\n      var attributes = {\n        fill: \'#fff\',\n        stroke: \'black\'\n      };\n      var options = options || {\n        x: 0,\n        y: 0,\n        fontSize: 72,\n        anchor: \'top\',\n        attributes: attributes\n      };\n      var el = document.getElementById(domElementId);\n\n      var pathsCount = _get(_getPrototypeOf(WritingAnimation.prototype), "getPath", this).call(this, text).length;\n\n      var svg = _get(_getPrototypeOf(WritingAnimation.prototype), "getSVG", this).call(this, text, options);\n\n      el.innerHTML = svg;\n      var style = document.createElement(\'style\');\n      var styleText = "\\n\\t\\t\\t.textPath{\\n\\t\\t\\t\\tstroke-dasharray: 1000;\\n\\t\\t\\t\\tstroke-dashoffset: 1000;\\n\\t\\t\\t\\tanimation: pathAnimation 4s linear forwards;\\n\\t\\t\\t}\\n\\t\\t\\t@keyframes pathAnimation{\\n\\t\\t\\t\\t100%{\\n\\t\\t\\t\\t\\tstroke-dashoffset: 0;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t";\n\n      for (var i = 0; i < pathsCount; i++) {\n        styleText += "\\n\\t\\t\\t\\t.textPath".concat(i, "{\\n\\t\\t\\t\\t\\tanimation-delay: ").concat(i, "s;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t");\n      }\n\n      style.innerHTML = styleText;\n      var ref = document.querySelector(\'body\');\n      ref.parentNode.insertBefore(style, ref);\n      console.log(\'working\');\n    }\n  }], [{\n    key: "load",\n    value: function load(url, cb) {\n      opentype.load(url, function (err, font) {\n        if (err !== null) {\n          return cb(err, null);\n        }\n\n        return cb(null, new WritingAnimation(font));\n      });\n    }\n  }]);\n\n  return WritingAnimation;\n}(_svg.default); // document.addEventListener("DOMContentLoaded", function() {\n//   WritingAnimation.load(\'http://localhost:8080/Felipa-Regular.otf\', function(err,WritingAnimation){\n// \tWritingAnimation.animateText(\'Abhay Srivastav\',\'test\');\n//   })\n// });\n\n\nexports.default = WritingAnimation;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Xcml0aW5nQW5pbWF0aW9uLy4vc3JjL2luZGV4LmpzP2I2MzUiXSwibmFtZXMiOlsiV3JpdGluZ0FuaW1hdGlvbiIsInRleHQiLCJkb21FbGVtZW50SWQiLCJhdHRyaWJ1dGVzIiwiZmlsbCIsInN0cm9rZSIsIm9wdGlvbnMiLCJ4IiwieSIsImZvbnRTaXplIiwiYW5jaG9yIiwiZWwiLCJkb2N1bWVudCIsImdldEVsZW1lbnRCeUlkIiwicGF0aHNDb3VudCIsImxlbmd0aCIsInN2ZyIsImlubmVySFRNTCIsInN0eWxlIiwiY3JlYXRlRWxlbWVudCIsInN0eWxlVGV4dCIsImkiLCJyZWYiLCJxdWVyeVNlbGVjdG9yIiwicGFyZW50Tm9kZSIsImluc2VydEJlZm9yZSIsImNvbnNvbGUiLCJsb2ciLCJ1cmwiLCJjYiIsIm9wZW50eXBlIiwibG9hZCIsImVyciIsImZvbnQiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTs7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lBR3FCQSxnQjs7Ozs7Ozs7Ozs7OztnQ0FZUkMsSSxFQUFLQyxZLEVBQWE7QUFDN0IsVUFBTUMsVUFBVSxHQUFHO0FBQUNDLFlBQUksRUFBRSxNQUFQO0FBQWVDLGNBQU0sRUFBRTtBQUF2QixPQUFuQjtBQUNBLFVBQUlDLE9BQU8sR0FBR0EsT0FBTyxJQUFJO0FBQUNDLFNBQUMsRUFBRSxDQUFKO0FBQU9DLFNBQUMsRUFBRSxDQUFWO0FBQWFDLGdCQUFRLEVBQUUsRUFBdkI7QUFBMkJDLGNBQU0sRUFBRSxLQUFuQztBQUEwQ1Asa0JBQVUsRUFBRUE7QUFBdEQsT0FBekI7QUFDQSxVQUFNUSxFQUFFLEdBQUdDLFFBQVEsQ0FBQ0MsY0FBVCxDQUF3QlgsWUFBeEIsQ0FBWDs7QUFDQSxVQUFNWSxVQUFVLEdBQUcsOEVBQWNiLElBQWQsRUFBb0JjLE1BQXZDOztBQUNBLFVBQU1DLEdBQUcsZ0ZBQWdCZixJQUFoQixFQUFzQkssT0FBdEIsQ0FBVDs7QUFDQUssUUFBRSxDQUFDTSxTQUFILEdBQWVELEdBQWY7QUFDQSxVQUFNRSxLQUFLLEdBQUdOLFFBQVEsQ0FBQ08sYUFBVCxDQUF1QixPQUF2QixDQUFkO0FBQ0EsVUFBSUMsU0FBUyxvUUFBYjs7QUFZQSxXQUFJLElBQUlDLENBQUMsR0FBQyxDQUFWLEVBQVlBLENBQUMsR0FBQ1AsVUFBZCxFQUF5Qk8sQ0FBQyxFQUExQixFQUE2QjtBQUM1QkQsaUJBQVMsaUNBQ0dDLENBREgsMkNBRVlBLENBRlosNEJBQVQ7QUFNQTs7QUFFREgsV0FBSyxDQUFDRCxTQUFOLEdBQWtCRyxTQUFsQjtBQUVBLFVBQU1FLEdBQUcsR0FBR1YsUUFBUSxDQUFDVyxhQUFULENBQXVCLE1BQXZCLENBQVo7QUFDQUQsU0FBRyxDQUFDRSxVQUFKLENBQWVDLFlBQWYsQ0FBNEJQLEtBQTVCLEVBQW1DSSxHQUFuQztBQUNBSSxhQUFPLENBQUNDLEdBQVIsQ0FBWSxTQUFaO0FBQ0E7Ozt5QkE1Q1dDLEcsRUFBS0MsRSxFQUFJO0FBQ2pCQyxjQUFRLENBQUNDLElBQVQsQ0FBY0gsR0FBZCxFQUFtQixVQUFDSSxHQUFELEVBQU1DLElBQU4sRUFBZTtBQUNoQyxZQUFJRCxHQUFHLEtBQUssSUFBWixFQUFrQjtBQUNoQixpQkFBT0gsRUFBRSxDQUFDRyxHQUFELEVBQU0sSUFBTixDQUFUO0FBQ0Q7O0FBRUQsZUFBT0gsRUFBRSxDQUFDLElBQUQsRUFBTyxJQUFJN0IsZ0JBQUosQ0FBcUJpQyxJQUFyQixDQUFQLENBQVQ7QUFDRCxPQU5EO0FBT0Q7Ozs7aUJBdUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiNC5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBUZXh0VG9TdmcgZnJvbSAnLi9zdmcuanMnO1xuaW1wb3J0ICogYXMgb3BlbnR5cGUgZnJvbSAnb3BlbnR5cGUuanMnO1xuXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFdyaXRpbmdBbmltYXRpb24gZXh0ZW5kcyBUZXh0VG9Tdmcge1xuXG5cdHN0YXRpYyBsb2FkKHVybCwgY2IpIHtcblx0ICAgIG9wZW50eXBlLmxvYWQodXJsLCAoZXJyLCBmb250KSA9PiB7XG5cdCAgICAgIGlmIChlcnIgIT09IG51bGwpIHtcblx0ICAgICAgICByZXR1cm4gY2IoZXJyLCBudWxsKTtcblx0ICAgICAgfVxuXG5cdCAgICAgIHJldHVybiBjYihudWxsLCBuZXcgV3JpdGluZ0FuaW1hdGlvbihmb250KSk7XG5cdCAgICB9KTtcbiAgXHR9XG5cblx0YW5pbWF0ZVRleHQodGV4dCxkb21FbGVtZW50SWQpe1xuXHRcdGNvbnN0IGF0dHJpYnV0ZXMgPSB7ZmlsbDogJyNmZmYnLCBzdHJva2U6ICdibGFjayd9O1xuXHRcdGxldCBvcHRpb25zID0gb3B0aW9ucyB8fCB7eDogMCwgeTogMCwgZm9udFNpemU6IDcyLCBhbmNob3I6ICd0b3AnLCBhdHRyaWJ1dGVzOiBhdHRyaWJ1dGVzfTtcblx0XHRjb25zdCBlbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGRvbUVsZW1lbnRJZCk7XG5cdFx0Y29uc3QgcGF0aHNDb3VudCA9IHN1cGVyLmdldFBhdGgodGV4dCkubGVuZ3RoO1xuXHRcdGNvbnN0IHN2ZyA9IHN1cGVyLmdldFNWRyh0ZXh0LCBvcHRpb25zKTtcblx0XHRlbC5pbm5lckhUTUwgPSBzdmc7XG5cdFx0Y29uc3Qgc3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xuXHRcdGxldCBzdHlsZVRleHQgPSBgXG5cdFx0XHQudGV4dFBhdGh7XG5cdFx0XHRcdHN0cm9rZS1kYXNoYXJyYXk6IDEwMDA7XG5cdFx0XHRcdHN0cm9rZS1kYXNob2Zmc2V0OiAxMDAwO1xuXHRcdFx0XHRhbmltYXRpb246IHBhdGhBbmltYXRpb24gNHMgbGluZWFyIGZvcndhcmRzO1xuXHRcdFx0fVxuXHRcdFx0QGtleWZyYW1lcyBwYXRoQW5pbWF0aW9ue1xuXHRcdFx0XHQxMDAle1xuXHRcdFx0XHRcdHN0cm9rZS1kYXNob2Zmc2V0OiAwO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0YDtcblx0XHRmb3IobGV0IGk9MDtpPHBhdGhzQ291bnQ7aSsrKXtcblx0XHRcdHN0eWxlVGV4dCs9YFxuXHRcdFx0XHQudGV4dFBhdGgke2l9e1xuXHRcdFx0XHRcdGFuaW1hdGlvbi1kZWxheTogJHtpfXM7XG5cdFx0XHRcdH1cblxuXHRcdFx0YFxuXHRcdH1cblxuXHRcdHN0eWxlLmlubmVySFRNTCA9IHN0eWxlVGV4dDtcblxuXHRcdGNvbnN0IHJlZiA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ2JvZHknKTtcblx0XHRyZWYucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoc3R5bGUsIHJlZik7XG5cdFx0Y29uc29sZS5sb2coJ3dvcmtpbmcnKVxuXHR9XG59XG5cbi8vIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJET01Db250ZW50TG9hZGVkXCIsIGZ1bmN0aW9uKCkge1xuLy8gICBXcml0aW5nQW5pbWF0aW9uLmxvYWQoJ2h0dHA6Ly9sb2NhbGhvc3Q6ODA4MC9GZWxpcGEtUmVndWxhci5vdGYnLCBmdW5jdGlvbihlcnIsV3JpdGluZ0FuaW1hdGlvbil7XG4vLyBcdFdyaXRpbmdBbmltYXRpb24uYW5pbWF0ZVRleHQoJ0FiaGF5IFNyaXZhc3RhdicsJ3Rlc3QnKTtcbi8vICAgfSlcbi8vIH0pO1xuXG5cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///4\n')},function(module,exports,__webpack_require__){"use strict";eval('/* WEBPACK VAR INJECTION */(function(__dirname) {\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\nexports.default = void 0;\n\nvar opentype = _interopRequireWildcard(__webpack_require__(2));\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }\n\nfunction _instanceof(left, right) { if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) { return right[Symbol.hasInstance](left); } else { return left instanceof right; } }\n\nfunction _classCallCheck(instance, Constructor) { if (!_instanceof(instance, Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar DEFAULT_FONT = __webpack_require__(11).join(__dirname, \'../fonts/ipag.ttf\'); // Private method\n\n\nfunction parseAnchorOption(anchor) {\n  var horizontal = anchor.match(/left|center|right/gi) || [];\n  horizontal = horizontal.length === 0 ? \'left\' : horizontal[0];\n  var vertical = anchor.match(/baseline|top|bottom|middle/gi) || [];\n  vertical = vertical.length === 0 ? \'baseline\' : vertical[0];\n  return {\n    horizontal: horizontal,\n    vertical: vertical\n  };\n}\n\nvar TextToSVG =\n/*#__PURE__*/\nfunction () {\n  function TextToSVG(font) {\n    _classCallCheck(this, TextToSVG);\n\n    this.font = font;\n  }\n\n  _createClass(TextToSVG, [{\n    key: "getWidth",\n    value: function getWidth(text, options) {\n      var fontSize = options.fontSize || 72;\n      var kerning = \'kerning\' in options ? options.kerning : true;\n      var fontScale = 1 / this.font.unitsPerEm * fontSize;\n      var width = 0;\n      var glyphs = this.font.stringToGlyphs(text);\n\n      for (var i = 0; i < glyphs.length; i++) {\n        var glyph = glyphs[i];\n\n        if (glyph.advanceWidth) {\n          width += glyph.advanceWidth * fontScale;\n        }\n\n        if (kerning && i < glyphs.length - 1) {\n          var kerningValue = this.font.getKerningValue(glyph, glyphs[i + 1]);\n          width += kerningValue * fontScale;\n        }\n\n        if (options.letterSpacing) {\n          width += options.letterSpacing * fontSize;\n        } else if (options.tracking) {\n          width += options.tracking / 1000 * fontSize;\n        }\n      }\n\n      return width;\n    }\n  }, {\n    key: "getHeight",\n    value: function getHeight(fontSize) {\n      var fontScale = 1 / this.font.unitsPerEm * fontSize;\n      return (this.font.ascender - this.font.descender) * fontScale;\n    }\n  }, {\n    key: "getMetrics",\n    value: function getMetrics(text) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var fontSize = options.fontSize || 72;\n      var anchor = parseAnchorOption(options.anchor || \'\');\n      var width = this.getWidth(text, options);\n      var height = this.getHeight(fontSize);\n      var fontScale = 1 / this.font.unitsPerEm * fontSize;\n      var ascender = this.font.ascender * fontScale;\n      var descender = this.font.descender * fontScale;\n      var x = options.x || 0;\n\n      switch (anchor.horizontal) {\n        case \'left\':\n          x -= 0;\n          break;\n\n        case \'center\':\n          x -= width / 2;\n          break;\n\n        case \'right\':\n          x -= width;\n          break;\n\n        default:\n          throw new Error("Unknown anchor option: ".concat(anchor.horizontal));\n      }\n\n      var y = options.y || 0;\n\n      switch (anchor.vertical) {\n        case \'baseline\':\n          y -= ascender;\n          break;\n\n        case \'top\':\n          y -= 0;\n          break;\n\n        case \'middle\':\n          y -= height / 2;\n          break;\n\n        case \'bottom\':\n          y -= height;\n          break;\n\n        default:\n          throw new Error("Unknown anchor option: ".concat(anchor.vertical));\n      }\n\n      var baseline = y + ascender;\n      return {\n        x: x,\n        y: y,\n        baseline: baseline,\n        width: width,\n        height: height,\n        ascender: ascender,\n        descender: descender\n      };\n    }\n  }, {\n    key: "getD",\n    value: function getD(text) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var fontSize = options.fontSize || 72;\n      var kerning = \'kerning\' in options ? options.kerning : true;\n      var letterSpacing = \'letterSpacing\' in options ? options.letterSpacing : false;\n      var tracking = \'tracking\' in options ? options.tracking : false;\n      var metrics = this.getMetrics(text, options);\n      var paths = this.font.getPaths(text, metrics.x, metrics.baseline, fontSize, {\n        kerning: kerning,\n        letterSpacing: letterSpacing,\n        tracking: tracking\n      });\n      var pathDatas = [];\n      paths.forEach(function (n) {\n        pathDatas.push(n.toPathData());\n      });\n      return pathDatas;\n    }\n  }, {\n    key: "getPath",\n    value: function getPath(text) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var attributes = Object.keys(options.attributes || {}).map(function (key) {\n        return "".concat(key, "=\\"").concat(options.attributes[key], "\\"");\n      }).join(\' \');\n      var d = this.getD(text, options);\n      var paths = \'\';\n      d.forEach(function (n, i) {\n        if (attributes) {\n          paths = "".concat(paths, "\\n          <path ").concat(attributes, " class=\\"textPath textPath").concat(i, "\\" d=\\"").concat(n, "\\"/>\\n        ");\n        } else {\n          paths = "".concat(paths, "\\n          <path d=\\"").concat(n, "\\" class=\\"textPath textPath").concat(i, "\\" fill=\\"red\\" stroke=\\"black\\"/>\\n        ");\n        }\n      });\n      return paths;\n    }\n  }, {\n    key: "getSVG",\n    value: function getSVG(text) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var metrics = this.getMetrics(text, options);\n      var svg = "<svg xmlns=\\"http://www.w3.org/2000/svg\\" xmlns:xlink=\\"http://www.w3.org/1999/xlink\\" width=\\"".concat(metrics.width, "\\" height=\\"").concat(metrics.height, "\\">");\n      svg += this.getPath(text, options);\n      svg += \'</svg>\';\n      return svg;\n    }\n  }, {\n    key: "getDebugSVG",\n    value: function getDebugSVG(text) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      options = JSON.parse(JSON.stringify(options));\n      options.x = options.x || 0;\n      options.y = options.y || 0;\n      var metrics = this.getMetrics(text, options);\n      var box = {\n        width: Math.max(metrics.x + metrics.width, 0) - Math.min(metrics.x, 0),\n        height: Math.max(metrics.y + metrics.height, 0) - Math.min(metrics.y, 0)\n      };\n      var origin = {\n        x: box.width - Math.max(metrics.x + metrics.width, 0),\n        y: box.height - Math.max(metrics.y + metrics.height, 0)\n      }; // Shift text based on origin\n\n      options.x += origin.x;\n      options.y += origin.y;\n      var svg = "<svg xmlns=\\"http://www.w3.org/2000/svg\\" xmlns:xlink=\\"http://www.w3.org/1999/xlink\\" width=\\"".concat(box.width, "\\" height=\\"").concat(box.height, "\\">");\n      svg += "<path fill=\\"none\\" stroke=\\"red\\" stroke-width=\\"1\\" d=\\"M0,".concat(origin.y, "L").concat(box.width, ",").concat(origin.y, "\\"/>"); // X Axis\n\n      svg += "<path fill=\\"none\\" stroke=\\"red\\" stroke-width=\\"1\\" d=\\"M".concat(origin.x, ",0L").concat(origin.x, ",").concat(box.height, "\\"/>"); // Y Axis\n\n      svg += this.getPath(text, options);\n      svg += \'</svg>\';\n      return svg;\n    }\n  }], [{\n    key: "loadSync",\n    value: function loadSync() {\n      var file = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DEFAULT_FONT;\n      return new TextToSVG(opentype.loadSync(file));\n    }\n  }, {\n    key: "load",\n    value: function load(url, cb) {\n      opentype.load(url, function (err, font) {\n        if (err !== null) {\n          return cb(err, null);\n        }\n\n        return cb(null, new TextToSVG(font));\n      });\n    }\n  }]);\n\n  return TextToSVG;\n}();\n\nexports.default = TextToSVG;\nmodule.exports = exports.default;\n/* WEBPACK VAR INJECTION */}.call(this, "/"))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Xcml0aW5nQW5pbWF0aW9uLy4vc3JjL3N2Zy5qcz9hNWRkIl0sIm5hbWVzIjpbIkRFRkFVTFRfRk9OVCIsInJlcXVpcmUiLCJqb2luIiwiX19kaXJuYW1lIiwicGFyc2VBbmNob3JPcHRpb24iLCJhbmNob3IiLCJob3Jpem9udGFsIiwibWF0Y2giLCJsZW5ndGgiLCJ2ZXJ0aWNhbCIsIlRleHRUb1NWRyIsImZvbnQiLCJ0ZXh0Iiwib3B0aW9ucyIsImZvbnRTaXplIiwia2VybmluZyIsImZvbnRTY2FsZSIsInVuaXRzUGVyRW0iLCJ3aWR0aCIsImdseXBocyIsInN0cmluZ1RvR2x5cGhzIiwiaSIsImdseXBoIiwiYWR2YW5jZVdpZHRoIiwia2VybmluZ1ZhbHVlIiwiZ2V0S2VybmluZ1ZhbHVlIiwibGV0dGVyU3BhY2luZyIsInRyYWNraW5nIiwiYXNjZW5kZXIiLCJkZXNjZW5kZXIiLCJnZXRXaWR0aCIsImhlaWdodCIsImdldEhlaWdodCIsIngiLCJFcnJvciIsInkiLCJiYXNlbGluZSIsIm1ldHJpY3MiLCJnZXRNZXRyaWNzIiwicGF0aHMiLCJnZXRQYXRocyIsInBhdGhEYXRhcyIsImZvckVhY2giLCJuIiwicHVzaCIsInRvUGF0aERhdGEiLCJhdHRyaWJ1dGVzIiwiT2JqZWN0Iiwia2V5cyIsIm1hcCIsImtleSIsImQiLCJnZXREIiwic3ZnIiwiZ2V0UGF0aCIsIkpTT04iLCJwYXJzZSIsInN0cmluZ2lmeSIsImJveCIsIk1hdGgiLCJtYXgiLCJtaW4iLCJvcmlnaW4iLCJmaWxlIiwib3BlbnR5cGUiLCJsb2FkU3luYyIsInVybCIsImNiIiwibG9hZCIsImVyciIsIm1vZHVsZSIsImV4cG9ydHMiLCJkZWZhdWx0Il0sIm1hcHBpbmdzIjoiOzs7Ozs7O0FBSUE7Ozs7Ozs7Ozs7OztBQUVBLElBQU1BLFlBQVksR0FBR0MsbUJBQU8sQ0FBQyxFQUFELENBQVAsQ0FBZ0JDLElBQWhCLENBQXFCQyxTQUFyQixFQUFnQyxtQkFBaEMsQ0FB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QUFNLENBQUNDLE9BQVAsR0FBaUJBLE9BQU8sQ0FBQ0MsT0FBekIsQyIsImZpbGUiOiI1LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYgSGlkZWtpIFNoaXJvXG4gKi9cblxuaW1wb3J0ICogYXMgb3BlbnR5cGUgZnJvbSAnb3BlbnR5cGUuanMnO1xuXG5jb25zdCBERUZBVUxUX0ZPTlQgPSByZXF1aXJlKCdwYXRoJykuam9pbihfX2Rpcm5hbWUsICcuLi9mb250cy9pcGFnLnR0ZicpO1xuXG4vLyBQcml2YXRlIG1ldGhvZFxuXG5mdW5jdGlvbiBwYXJzZUFuY2hvck9wdGlvbihhbmNob3IpIHtcbiAgbGV0IGhvcml6b250YWwgPSBhbmNob3IubWF0Y2goL2xlZnR8Y2VudGVyfHJpZ2h0L2dpKSB8fCBbXTtcbiAgaG9yaXpvbnRhbCA9IGhvcml6b250YWwubGVuZ3RoID09PSAwID8gJ2xlZnQnIDogaG9yaXpvbnRhbFswXTtcblxuICBsZXQgdmVydGljYWwgPSBhbmNob3IubWF0Y2goL2Jhc2VsaW5lfHRvcHxib3R0b218bWlkZGxlL2dpKSB8fCBbXTtcbiAgdmVydGljYWwgPSB2ZXJ0aWNhbC5sZW5ndGggPT09IDAgPyAnYmFzZWxpbmUnIDogdmVydGljYWxbMF07XG5cbiAgcmV0dXJuIHsgaG9yaXpvbnRhbCwgdmVydGljYWwgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVGV4dFRvU1ZHIHtcbiAgY29uc3RydWN0b3IoZm9udCkge1xuICAgIHRoaXMuZm9udCA9IGZvbnQ7XG4gIH1cblxuICBzdGF0aWMgbG9hZFN5bmMoZmlsZSA9IERFRkFVTFRfRk9OVCkge1xuICAgIHJldHVybiBuZXcgVGV4dFRvU1ZHKG9wZW50eXBlLmxvYWRTeW5jKGZpbGUpKTtcbiAgfVxuXG4gIHN0YXRpYyBsb2FkKHVybCwgY2IpIHtcbiAgICBvcGVudHlwZS5sb2FkKHVybCwgKGVyciwgZm9udCkgPT4ge1xuICAgICAgaWYgKGVyciAhPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gY2IoZXJyLCBudWxsKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNiKG51bGwsIG5ldyBUZXh0VG9TVkcoZm9udCkpO1xuICAgIH0pO1xuICB9XG5cbiAgZ2V0V2lkdGgodGV4dCwgb3B0aW9ucykge1xuICAgIGNvbnN0IGZvbnRTaXplID0gb3B0aW9ucy5mb250U2l6ZSB8fCA3MjtcbiAgICBjb25zdCBrZXJuaW5nID0gJ2tlcm5pbmcnIGluIG9wdGlvbnMgPyBvcHRpb25zLmtlcm5pbmcgOiB0cnVlO1xuICAgIGNvbnN0IGZvbnRTY2FsZSA9IDEgLyB0aGlzLmZvbnQudW5pdHNQZXJFbSAqIGZvbnRTaXplO1xuXG4gICAgbGV0IHdpZHRoID0gMDtcbiAgICBjb25zdCBnbHlwaHMgPSB0aGlzLmZvbnQuc3RyaW5nVG9HbHlwaHModGV4dCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBnbHlwaHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGdseXBoID0gZ2x5cGhzW2ldO1xuXG4gICAgICBpZiAoZ2x5cGguYWR2YW5jZVdpZHRoKSB7XG4gICAgICAgIHdpZHRoICs9IGdseXBoLmFkdmFuY2VXaWR0aCAqIGZvbnRTY2FsZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGtlcm5pbmcgJiYgaSA8IGdseXBocy5sZW5ndGggLSAxKSB7XG4gICAgICAgIGNvbnN0IGtlcm5pbmdWYWx1ZSA9IHRoaXMuZm9udC5nZXRLZXJuaW5nVmFsdWUoZ2x5cGgsIGdseXBoc1tpICsgMV0pO1xuICAgICAgICB3aWR0aCArPSBrZXJuaW5nVmFsdWUgKiBmb250U2NhbGU7XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLmxldHRlclNwYWNpbmcpIHtcbiAgICAgICAgd2lkdGggKz0gb3B0aW9ucy5sZXR0ZXJTcGFjaW5nICogZm9udFNpemU7XG4gICAgICB9IGVsc2UgaWYgKG9wdGlvbnMudHJhY2tpbmcpIHtcbiAgICAgICAgd2lkdGggKz0gKG9wdGlvbnMudHJhY2tpbmcgLyAxMDAwKSAqIGZvbnRTaXplO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gd2lkdGg7XG4gIH1cblxuICBnZXRIZWlnaHQoZm9udFNpemUpIHtcbiAgICBjb25zdCBmb250U2NhbGUgPSAxIC8gdGhpcy5mb250LnVuaXRzUGVyRW0gKiBmb250U2l6ZTtcbiAgICByZXR1cm4gKHRoaXMuZm9udC5hc2NlbmRlciAtIHRoaXMuZm9udC5kZXNjZW5kZXIpICogZm9udFNjYWxlO1xuICB9XG5cbiAgZ2V0TWV0cmljcyh0ZXh0LCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCBmb250U2l6ZSA9IG9wdGlvbnMuZm9udFNpemUgfHwgNzI7XG4gICAgY29uc3QgYW5jaG9yID0gcGFyc2VBbmNob3JPcHRpb24ob3B0aW9ucy5hbmNob3IgfHwgJycpO1xuXG4gICAgY29uc3Qgd2lkdGggPSB0aGlzLmdldFdpZHRoKHRleHQsIG9wdGlvbnMpO1xuICAgIGNvbnN0IGhlaWdodCA9IHRoaXMuZ2V0SGVpZ2h0KGZvbnRTaXplKTtcblxuICAgIGNvbnN0IGZvbnRTY2FsZSA9IDEgLyB0aGlzLmZvbnQudW5pdHNQZXJFbSAqIGZvbnRTaXplO1xuICAgIGNvbnN0IGFzY2VuZGVyID0gdGhpcy5mb250LmFzY2VuZGVyICogZm9udFNjYWxlO1xuICAgIGNvbnN0IGRlc2NlbmRlciA9IHRoaXMuZm9udC5kZXNjZW5kZXIgKiBmb250U2NhbGU7XG5cbiAgICBsZXQgeCA9IG9wdGlvbnMueCB8fCAwO1xuICAgIHN3aXRjaCAoYW5jaG9yLmhvcml6b250YWwpIHtcbiAgICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgICB4IC09IDA7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnY2VudGVyJzpcbiAgICAgICAgeCAtPSB3aWR0aCAvIDI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAncmlnaHQnOlxuICAgICAgICB4IC09IHdpZHRoO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBhbmNob3Igb3B0aW9uOiAke2FuY2hvci5ob3Jpem9udGFsfWApO1xuICAgIH1cblxuICAgIGxldCB5ID0gb3B0aW9ucy55IHx8IDA7XG4gICAgc3dpdGNoIChhbmNob3IudmVydGljYWwpIHtcbiAgICAgIGNhc2UgJ2Jhc2VsaW5lJzpcbiAgICAgICAgeSAtPSBhc2NlbmRlcjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd0b3AnOlxuICAgICAgICB5IC09IDA7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnbWlkZGxlJzpcbiAgICAgICAgeSAtPSBoZWlnaHQgLyAyO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgICAgIHkgLT0gaGVpZ2h0O1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBhbmNob3Igb3B0aW9uOiAke2FuY2hvci52ZXJ0aWNhbH1gKTtcbiAgICB9XG5cbiAgICBjb25zdCBiYXNlbGluZSA9IHkgKyBhc2NlbmRlcjtcblxuICAgIHJldHVybiB7XG4gICAgICB4LFxuICAgICAgeSxcbiAgICAgIGJhc2VsaW5lLFxuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHQsXG4gICAgICBhc2NlbmRlcixcbiAgICAgIGRlc2NlbmRlcixcbiAgICB9O1xuICB9XG5cbiAgZ2V0RCh0ZXh0LCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCBmb250U2l6ZSA9IG9wdGlvbnMuZm9udFNpemUgfHwgNzI7XG4gICAgY29uc3Qga2VybmluZyA9ICdrZXJuaW5nJyBpbiBvcHRpb25zID8gb3B0aW9ucy5rZXJuaW5nIDogdHJ1ZTtcbiAgICBjb25zdCBsZXR0ZXJTcGFjaW5nID0gJ2xldHRlclNwYWNpbmcnIGluIG9wdGlvbnMgPyBvcHRpb25zLmxldHRlclNwYWNpbmcgOiBmYWxzZTtcbiAgICBjb25zdCB0cmFja2luZyA9ICd0cmFja2luZycgaW4gb3B0aW9ucyA/IG9wdGlvbnMudHJhY2tpbmcgOiBmYWxzZTtcbiAgICBjb25zdCBtZXRyaWNzID0gdGhpcy5nZXRNZXRyaWNzKHRleHQsIG9wdGlvbnMpO1xuICAgIGNvbnN0IHBhdGhzID0gdGhpcy5mb250LmdldFBhdGhzKHRleHQsIG1ldHJpY3MueCwgbWV0cmljcy5iYXNlbGluZSwgZm9udFNpemUsIHsga2VybmluZywgbGV0dGVyU3BhY2luZywgdHJhY2tpbmcgfSk7XG4gICAgY29uc3QgcGF0aERhdGFzID0gW107XG4gICAgcGF0aHMuZm9yRWFjaCgobikgPT4ge1xuICAgICAgcGF0aERhdGFzLnB1c2gobi50b1BhdGhEYXRhKCkpXG4gICAgfSlcbiAgICByZXR1cm4gcGF0aERhdGFzO1xuICB9XG5cbiAgZ2V0UGF0aCh0ZXh0LCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCBhdHRyaWJ1dGVzID0gT2JqZWN0LmtleXMob3B0aW9ucy5hdHRyaWJ1dGVzIHx8IHt9KVxuICAgICAgLm1hcChrZXkgPT4gYCR7a2V5fT1cIiR7b3B0aW9ucy5hdHRyaWJ1dGVzW2tleV19XCJgKVxuICAgICAgLmpvaW4oJyAnKTtcbiAgICBjb25zdCBkID0gdGhpcy5nZXREKHRleHQsIG9wdGlvbnMpO1xuICAgIGxldCBwYXRocyA9ICcnO1xuICAgIGQuZm9yRWFjaCgobixpKSA9PiB7XG4gICAgICBpZiAoYXR0cmlidXRlcykge1xuICAgICAgICBwYXRocyA9IGAke3BhdGhzfVxuICAgICAgICAgIDxwYXRoICR7YXR0cmlidXRlc30gY2xhc3M9XCJ0ZXh0UGF0aCB0ZXh0UGF0aCR7aX1cIiBkPVwiJHtufVwiLz5cbiAgICAgICAgYFxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHBhdGhzID0gYCR7cGF0aHN9XG4gICAgICAgICAgPHBhdGggZD1cIiR7bn1cIiBjbGFzcz1cInRleHRQYXRoIHRleHRQYXRoJHtpfVwiIGZpbGw9XCJyZWRcIiBzdHJva2U9XCJibGFja1wiLz5cbiAgICAgICAgYDtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBwYXRocztcbiAgfVxuXG4gIGdldFNWRyh0ZXh0LCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCBtZXRyaWNzID0gdGhpcy5nZXRNZXRyaWNzKHRleHQsIG9wdGlvbnMpO1xuICAgIGxldCBzdmcgPSBgPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgeG1sbnM6eGxpbms9XCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rXCIgd2lkdGg9XCIke21ldHJpY3Mud2lkdGh9XCIgaGVpZ2h0PVwiJHttZXRyaWNzLmhlaWdodH1cIj5gO1xuICAgIHN2ZyArPSB0aGlzLmdldFBhdGgodGV4dCwgb3B0aW9ucyk7XG4gICAgc3ZnICs9ICc8L3N2Zz4nO1xuXG4gICAgcmV0dXJuIHN2ZztcbiAgfVxuXG4gIGdldERlYnVnU1ZHKHRleHQsIG9wdGlvbnMgPSB7fSkge1xuICAgIG9wdGlvbnMgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KG9wdGlvbnMpKTtcblxuICAgIG9wdGlvbnMueCA9IG9wdGlvbnMueCB8fCAwO1xuICAgIG9wdGlvbnMueSA9IG9wdGlvbnMueSB8fCAwO1xuICAgIGNvbnN0IG1ldHJpY3MgPSB0aGlzLmdldE1ldHJpY3ModGV4dCwgb3B0aW9ucyk7XG4gICAgY29uc3QgYm94ID0ge1xuICAgICAgd2lkdGg6IE1hdGgubWF4KG1ldHJpY3MueCArIG1ldHJpY3Mud2lkdGgsIDApIC0gTWF0aC5taW4obWV0cmljcy54LCAwKSxcbiAgICAgIGhlaWdodDogTWF0aC5tYXgobWV0cmljcy55ICsgbWV0cmljcy5oZWlnaHQsIDApIC0gTWF0aC5taW4obWV0cmljcy55LCAwKSxcbiAgICB9O1xuICAgIGNvbnN0IG9yaWdpbiA9IHtcbiAgICAgIHg6IGJveC53aWR0aCAtIE1hdGgubWF4KG1ldHJpY3MueCArIG1ldHJpY3Mud2lkdGgsIDApLFxuICAgICAgeTogYm94LmhlaWdodCAtIE1hdGgubWF4KG1ldHJpY3MueSArIG1ldHJpY3MuaGVpZ2h0LCAwKSxcbiAgICB9O1xuXG4gICAgLy8gU2hpZnQgdGV4dCBiYXNlZCBvbiBvcmlnaW5cbiAgICBvcHRpb25zLnggKz0gb3JpZ2luLng7XG4gICAgb3B0aW9ucy55ICs9IG9yaWdpbi55O1xuXG4gICAgbGV0IHN2ZyA9IGA8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB4bWxuczp4bGluaz1cImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmtcIiB3aWR0aD1cIiR7Ym94LndpZHRofVwiIGhlaWdodD1cIiR7Ym94LmhlaWdodH1cIj5gO1xuICAgIHN2ZyArPSBgPHBhdGggZmlsbD1cIm5vbmVcIiBzdHJva2U9XCJyZWRcIiBzdHJva2Utd2lkdGg9XCIxXCIgZD1cIk0wLCR7b3JpZ2luLnl9TCR7Ym94LndpZHRofSwke29yaWdpbi55fVwiLz5gOyAvLyBYIEF4aXNcbiAgICBzdmcgKz0gYDxwYXRoIGZpbGw9XCJub25lXCIgc3Ryb2tlPVwicmVkXCIgc3Ryb2tlLXdpZHRoPVwiMVwiIGQ9XCJNJHtvcmlnaW4ueH0sMEwke29yaWdpbi54fSwke2JveC5oZWlnaHR9XCIvPmA7IC8vIFkgQXhpc1xuICAgIHN2ZyArPSB0aGlzLmdldFBhdGgodGV4dCwgb3B0aW9ucyk7XG4gICAgc3ZnICs9ICc8L3N2Zz4nO1xuXG4gICAgcmV0dXJuIHN2ZztcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///5\n')},function(module,exports,__webpack_require__){"use strict";eval("/* WEBPACK VAR INJECTION */(function(global) {/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n\n\nvar base64 = __webpack_require__(8)\nvar ieee754 = __webpack_require__(9)\nvar isArray = __webpack_require__(10)\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Use Object implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * Due to various browser bugs, sometimes the Object implementation will be used even\n * when the browser supports typed arrays.\n *\n * Note:\n *\n *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\n *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n *\n *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n *\n *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n *     incorrect length in some situations.\n\n * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\n * get the Object implementation, which is slower but behaves correctly.\n */\nBuffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined\n  ? global.TYPED_ARRAY_SUPPORT\n  : typedArraySupport()\n\n/*\n * Export kMaxLength after typed array support is determined.\n */\nexports.kMaxLength = kMaxLength()\n\nfunction typedArraySupport () {\n  try {\n    var arr = new Uint8Array(1)\n    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}\n    return arr.foo() === 42 && // typed array instances can be augmented\n        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`\n        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`\n  } catch (e) {\n    return false\n  }\n}\n\nfunction kMaxLength () {\n  return Buffer.TYPED_ARRAY_SUPPORT\n    ? 0x7fffffff\n    : 0x3fffffff\n}\n\nfunction createBuffer (that, length) {\n  if (kMaxLength() < length) {\n    throw new RangeError('Invalid typed array length')\n  }\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = new Uint8Array(length)\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    if (that === null) {\n      that = new Buffer(length)\n    }\n    that.length = length\n  }\n\n  return that\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {\n    return new Buffer(arg, encodingOrOffset, length)\n  }\n\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new Error(\n        'If encoding is specified then the first argument must be a string'\n      )\n    }\n    return allocUnsafe(this, arg)\n  }\n  return from(this, arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\n// TODO: Legacy, not needed anymore. Remove in next major version.\nBuffer._augment = function (arr) {\n  arr.__proto__ = Buffer.prototype\n  return arr\n}\n\nfunction from (that, value, encodingOrOffset, length) {\n  if (typeof value === 'number') {\n    throw new TypeError('\"value\" argument must not be a number')\n  }\n\n  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {\n    return fromArrayBuffer(that, value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'string') {\n    return fromString(that, value, encodingOrOffset)\n  }\n\n  return fromObject(that, value)\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(null, value, encodingOrOffset, length)\n}\n\nif (Buffer.TYPED_ARRAY_SUPPORT) {\n  Buffer.prototype.__proto__ = Uint8Array.prototype\n  Buffer.__proto__ = Uint8Array\n  if (typeof Symbol !== 'undefined' && Symbol.species &&\n      Buffer[Symbol.species] === Buffer) {\n    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\n    Object.defineProperty(Buffer, Symbol.species, {\n      value: null,\n      configurable: true\n    })\n  }\n}\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be a number')\n  } else if (size < 0) {\n    throw new RangeError('\"size\" argument must not be negative')\n  }\n}\n\nfunction alloc (that, size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(that, size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpretted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(that, size).fill(fill, encoding)\n      : createBuffer(that, size).fill(fill)\n  }\n  return createBuffer(that, size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(null, size, fill, encoding)\n}\n\nfunction allocUnsafe (that, size) {\n  assertSize(size)\n  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n    for (var i = 0; i < size; ++i) {\n      that[i] = 0\n    }\n  }\n  return that\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(null, size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(null, size)\n}\n\nfunction fromString (that, string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('\"encoding\" must be a valid string encoding')\n  }\n\n  var length = byteLength(string, encoding) | 0\n  that = createBuffer(that, length)\n\n  var actual = that.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    that = that.slice(0, actual)\n  }\n\n  return that\n}\n\nfunction fromArrayLike (that, array) {\n  var length = array.length < 0 ? 0 : checked(array.length) | 0\n  that = createBuffer(that, length)\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\nfunction fromArrayBuffer (that, array, byteOffset, length) {\n  array.byteLength // this throws if `array` is not a valid ArrayBuffer\n\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\\'offset\\' is out of bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\\'length\\' is out of bounds')\n  }\n\n  if (byteOffset === undefined && length === undefined) {\n    array = new Uint8Array(array)\n  } else if (length === undefined) {\n    array = new Uint8Array(array, byteOffset)\n  } else {\n    array = new Uint8Array(array, byteOffset, length)\n  }\n\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = array\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    that = fromArrayLike(that, array)\n  }\n  return that\n}\n\nfunction fromObject (that, obj) {\n  if (Buffer.isBuffer(obj)) {\n    var len = checked(obj.length) | 0\n    that = createBuffer(that, len)\n\n    if (that.length === 0) {\n      return that\n    }\n\n    obj.copy(that, 0, 0, len)\n    return that\n  }\n\n  if (obj) {\n    if ((typeof ArrayBuffer !== 'undefined' &&\n        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {\n      if (typeof obj.length !== 'number' || isnan(obj.length)) {\n        return createBuffer(that, 0)\n      }\n      return fromArrayLike(that, obj)\n    }\n\n    if (obj.type === 'Buffer' && isArray(obj.data)) {\n      return fromArrayLike(that, obj.data)\n    }\n  }\n\n  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < kMaxLength()` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= kMaxLength()) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + kMaxLength().toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return !!(b != null && b._isBuffer)\n}\n\nBuffer.compare = function compare (a, b) {\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError('Arguments must be Buffers')\n  }\n\n  if (a === b) return 0\n\n  var x = a.length\n  var y = b.length\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  var i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  var buffer = Buffer.allocUnsafe(length)\n  var pos = 0\n  for (i = 0; i < list.length; ++i) {\n    var buf = list[i]\n    if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    }\n    buf.copy(buffer, pos)\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&\n      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    string = '' + string\n  }\n\n  var len = string.length\n  if (len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n      case undefined:\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) return utf8ToBytes(string).length // assume utf8\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect\n// Buffer instances.\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  var i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  var len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (var i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  var len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (var i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  var len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (var i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  var length = this.length | 0\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  var str = ''\n  var max = exports.INSPECT_MAX_BYTES\n  if (this.length > 0) {\n    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')\n    if (this.length > max) str += ' ... '\n  }\n  return '<Buffer ' + str + '>'\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError('Argument must be a Buffer')\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  var x = thisEnd - thisStart\n  var y = end - start\n  var len = Math.min(x, y)\n\n  var thisCopy = this.slice(thisStart, thisEnd)\n  var targetCopy = target.slice(start, end)\n\n  for (var i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset  // Coerce to Number.\n  if (isNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (Buffer.TYPED_ARRAY_SUPPORT &&\n        typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  var indexSize = 1\n  var arrLength = arr.length\n  var valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  var i\n  if (dir) {\n    var foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      var found = true\n      for (var j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  // must be an even number of digits\n  var strLen = string.length\n  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; ++i) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (isNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction latin1Write (buf, string, offset, length) {\n  return asciiWrite(buf, string, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset | 0\n    if (isFinite(length)) {\n      length = length | 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  // legacy write(string, encoding, offset, length) - remove in v0.13\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  var remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n        return asciiWrite(this, string, offset, length)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Write(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  var res = []\n\n  var i = start\n  while (i < end) {\n    var firstByte = buf[i]\n    var codePoint = null\n    var bytesPerSequence = (firstByte > 0xEF) ? 4\n      : (firstByte > 0xDF) ? 3\n      : (firstByte > 0xBF) ? 2\n      : 1\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  var len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = ''\n  var i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; ++i) {\n    out += toHex(buf[i])\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  var newBuf\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    newBuf = this.subarray(start, end)\n    newBuf.__proto__ = Buffer.prototype\n  } else {\n    var sliceLen = end - start\n    newBuf = new Buffer(sliceLen, undefined)\n    for (var i = 0; i < sliceLen; ++i) {\n      newBuf[i] = this[i + start]\n    }\n  }\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  var val = this[offset + --byteLength]\n  var mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var i = byteLength\n  var mul = 1\n  var val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var mul = 1\n  var i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nfunction objectWriteUInt16 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {\n    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>\n      (littleEndian ? i : 1 - i) * 8\n  }\n}\n\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nfunction objectWriteUInt32 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffffffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {\n    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff\n  }\n}\n\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset + 3] = (value >>> 24)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 1] = (value >>> 8)\n    this[offset] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = 0\n  var mul = 1\n  var sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  var sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 3] = (value >>> 24)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  var len = end - start\n  var i\n\n  if (this === target && start < targetStart && targetStart < end) {\n    // descending copy from end\n    for (i = len - 1; i >= 0; --i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n    // ascending copy from start\n    for (i = 0; i < len; ++i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, start + len),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (val.length === 1) {\n      var code = val.charCodeAt(0)\n      if (code < 256) {\n        val = code\n      }\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  var i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    var bytes = Buffer.isBuffer(val)\n      ? val\n      : utf8ToBytes(new Buffer(val, encoding).toString())\n    var len = bytes.length\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// HELPER FUNCTIONS\n// ================\n\nvar INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = stringtrim(str).replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction stringtrim (str) {\n  if (str.trim) return str.trim()\n  return str.replace(/^\\s+|\\s+$/g, '')\n}\n\nfunction toHex (n) {\n  if (n < 16) return '0' + n.toString(16)\n  return n.toString(16)\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  var codePoint\n  var length = string.length\n  var leadSurrogate = null\n  var bytes = []\n\n  for (var i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\nfunction isnan (val) {\n  return val !== val // eslint-disable-line no-self-compare\n}\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(7)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Xcml0aW5nQW5pbWF0aW9uLy4vbm9kZV9tb2R1bGVzL2J1ZmZlci9pbmRleC5qcz9iNjM5Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVZOztBQUVaLGFBQWEsbUJBQU8sQ0FBQyxDQUFXO0FBQ2hDLGNBQWMsbUJBQU8sQ0FBQyxDQUFTO0FBQy9CLGNBQWMsbUJBQU8sQ0FBQyxFQUFTOztBQUUvQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLG1EQUFtRDtBQUN4RTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFVBQVU7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFlBQVk7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSx1Q0FBdUMsU0FBUztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGlCQUFpQjtBQUNoQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsaUJBQWlCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxFQUFFO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixlQUFlO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0EscUJBQXFCLGVBQWU7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFlBQVk7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHFCQUFxQixTQUFTO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUIsU0FBUztBQUM5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUIsU0FBUztBQUM5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsa0JBQWtCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxtQkFBbUIsY0FBYztBQUNqQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdURBQXVELE9BQU87QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVEQUF1RCxPQUFPO0FBQzlEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFCQUFxQixRQUFRO0FBQzdCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIsU0FBUztBQUM1QjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxpQkFBaUI7QUFDaEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsWUFBWTtBQUM3Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLGdCQUFnQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixnQkFBZ0I7QUFDakM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLFlBQVk7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EiLCJmaWxlIjoiNi5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogVGhlIGJ1ZmZlciBtb2R1bGUgZnJvbSBub2RlLmpzLCBmb3IgdGhlIGJyb3dzZXIuXG4gKlxuICogQGF1dGhvciAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGZlcm9zc0BmZXJvc3Mub3JnPiA8aHR0cDovL2Zlcm9zcy5vcmc+XG4gKiBAbGljZW5zZSAgTUlUXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXG5cbid1c2Ugc3RyaWN0J1xuXG52YXIgYmFzZTY0ID0gcmVxdWlyZSgnYmFzZTY0LWpzJylcbnZhciBpZWVlNzU0ID0gcmVxdWlyZSgnaWVlZTc1NCcpXG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJ2lzYXJyYXknKVxuXG5leHBvcnRzLkJ1ZmZlciA9IEJ1ZmZlclxuZXhwb3J0cy5TbG93QnVmZmVyID0gU2xvd0J1ZmZlclxuZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFUyA9IDUwXG5cbi8qKlxuICogSWYgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYDpcbiAqICAgPT09IHRydWUgICAgVXNlIFVpbnQ4QXJyYXkgaW1wbGVtZW50YXRpb24gKGZhc3Rlc3QpXG4gKiAgID09PSBmYWxzZSAgIFVzZSBPYmplY3QgaW1wbGVtZW50YXRpb24gKG1vc3QgY29tcGF0aWJsZSwgZXZlbiBJRTYpXG4gKlxuICogQnJvd3NlcnMgdGhhdCBzdXBwb3J0IHR5cGVkIGFycmF5cyBhcmUgSUUgMTArLCBGaXJlZm94IDQrLCBDaHJvbWUgNyssIFNhZmFyaSA1LjErLFxuICogT3BlcmEgMTEuNissIGlPUyA0LjIrLlxuICpcbiAqIER1ZSB0byB2YXJpb3VzIGJyb3dzZXIgYnVncywgc29tZXRpbWVzIHRoZSBPYmplY3QgaW1wbGVtZW50YXRpb24gd2lsbCBiZSB1c2VkIGV2ZW5cbiAqIHdoZW4gdGhlIGJyb3dzZXIgc3VwcG9ydHMgdHlwZWQgYXJyYXlzLlxuICpcbiAqIE5vdGU6XG4gKlxuICogICAtIEZpcmVmb3ggNC0yOSBsYWNrcyBzdXBwb3J0IGZvciBhZGRpbmcgbmV3IHByb3BlcnRpZXMgdG8gYFVpbnQ4QXJyYXlgIGluc3RhbmNlcyxcbiAqICAgICBTZWU6IGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY5NTQzOC5cbiAqXG4gKiAgIC0gQ2hyb21lIDktMTAgaXMgbWlzc2luZyB0aGUgYFR5cGVkQXJyYXkucHJvdG90eXBlLnN1YmFycmF5YCBmdW5jdGlvbi5cbiAqXG4gKiAgIC0gSUUxMCBoYXMgYSBicm9rZW4gYFR5cGVkQXJyYXkucHJvdG90eXBlLnN1YmFycmF5YCBmdW5jdGlvbiB3aGljaCByZXR1cm5zIGFycmF5cyBvZlxuICogICAgIGluY29ycmVjdCBsZW5ndGggaW4gc29tZSBzaXR1YXRpb25zLlxuXG4gKiBXZSBkZXRlY3QgdGhlc2UgYnVnZ3kgYnJvd3NlcnMgYW5kIHNldCBgQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRgIHRvIGBmYWxzZWAgc28gdGhleVxuICogZ2V0IHRoZSBPYmplY3QgaW1wbGVtZW50YXRpb24sIHdoaWNoIGlzIHNsb3dlciBidXQgYmVoYXZlcyBjb3JyZWN0bHkuXG4gKi9cbkJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUID0gZ2xvYmFsLlRZUEVEX0FSUkFZX1NVUFBPUlQgIT09IHVuZGVmaW5lZFxuICA/IGdsb2JhbC5UWVBFRF9BUlJBWV9TVVBQT1JUXG4gIDogdHlwZWRBcnJheVN1cHBvcnQoKVxuXG4vKlxuICogRXhwb3J0IGtNYXhMZW5ndGggYWZ0ZXIgdHlwZWQgYXJyYXkgc3VwcG9ydCBpcyBkZXRlcm1pbmVkLlxuICovXG5leHBvcnRzLmtNYXhMZW5ndGggPSBrTWF4TGVuZ3RoKClcblxuZnVuY3Rpb24gdHlwZWRBcnJheVN1cHBvcnQgKCkge1xuICB0cnkge1xuICAgIHZhciBhcnIgPSBuZXcgVWludDhBcnJheSgxKVxuICAgIGFyci5fX3Byb3RvX18gPSB7X19wcm90b19fOiBVaW50OEFycmF5LnByb3RvdHlwZSwgZm9vOiBmdW5jdGlvbiAoKSB7IHJldHVybiA0MiB9fVxuICAgIHJldHVybiBhcnIuZm9vKCkgPT09IDQyICYmIC8vIHR5cGVkIGFycmF5IGluc3RhbmNlcyBjYW4gYmUgYXVnbWVudGVkXG4gICAgICAgIHR5cGVvZiBhcnIuc3ViYXJyYXkgPT09ICdmdW5jdGlvbicgJiYgLy8gY2hyb21lIDktMTAgbGFjayBgc3ViYXJyYXlgXG4gICAgICAgIGFyci5zdWJhcnJheSgxLCAxKS5ieXRlTGVuZ3RoID09PSAwIC8vIGllMTAgaGFzIGJyb2tlbiBgc3ViYXJyYXlgXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5mdW5jdGlvbiBrTWF4TGVuZ3RoICgpIHtcbiAgcmV0dXJuIEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUXG4gICAgPyAweDdmZmZmZmZmXG4gICAgOiAweDNmZmZmZmZmXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUJ1ZmZlciAodGhhdCwgbGVuZ3RoKSB7XG4gIGlmIChrTWF4TGVuZ3RoKCkgPCBsZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW52YWxpZCB0eXBlZCBhcnJheSBsZW5ndGgnKVxuICB9XG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlLCBmb3IgYmVzdCBwZXJmb3JtYW5jZVxuICAgIHRoYXQgPSBuZXcgVWludDhBcnJheShsZW5ndGgpXG4gICAgdGhhdC5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIH0gZWxzZSB7XG4gICAgLy8gRmFsbGJhY2s6IFJldHVybiBhbiBvYmplY3QgaW5zdGFuY2Ugb2YgdGhlIEJ1ZmZlciBjbGFzc1xuICAgIGlmICh0aGF0ID09PSBudWxsKSB7XG4gICAgICB0aGF0ID0gbmV3IEJ1ZmZlcihsZW5ndGgpXG4gICAgfVxuICAgIHRoYXQubGVuZ3RoID0gbGVuZ3RoXG4gIH1cblxuICByZXR1cm4gdGhhdFxufVxuXG4vKipcbiAqIFRoZSBCdWZmZXIgY29uc3RydWN0b3IgcmV0dXJucyBpbnN0YW5jZXMgb2YgYFVpbnQ4QXJyYXlgIHRoYXQgaGF2ZSB0aGVpclxuICogcHJvdG90eXBlIGNoYW5nZWQgdG8gYEJ1ZmZlci5wcm90b3R5cGVgLiBGdXJ0aGVybW9yZSwgYEJ1ZmZlcmAgaXMgYSBzdWJjbGFzcyBvZlxuICogYFVpbnQ4QXJyYXlgLCBzbyB0aGUgcmV0dXJuZWQgaW5zdGFuY2VzIHdpbGwgaGF2ZSBhbGwgdGhlIG5vZGUgYEJ1ZmZlcmAgbWV0aG9kc1xuICogYW5kIHRoZSBgVWludDhBcnJheWAgbWV0aG9kcy4gU3F1YXJlIGJyYWNrZXQgbm90YXRpb24gd29ya3MgYXMgZXhwZWN0ZWQgLS0gaXRcbiAqIHJldHVybnMgYSBzaW5nbGUgb2N0ZXQuXG4gKlxuICogVGhlIGBVaW50OEFycmF5YCBwcm90b3R5cGUgcmVtYWlucyB1bm1vZGlmaWVkLlxuICovXG5cbmZ1bmN0aW9uIEJ1ZmZlciAoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCAmJiAhKHRoaXMgaW5zdGFuY2VvZiBCdWZmZXIpKSB7XG4gICAgcmV0dXJuIG5ldyBCdWZmZXIoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICAvLyBDb21tb24gY2FzZS5cbiAgaWYgKHR5cGVvZiBhcmcgPT09ICdudW1iZXInKSB7XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZ09yT2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnSWYgZW5jb2RpbmcgaXMgc3BlY2lmaWVkIHRoZW4gdGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBzdHJpbmcnXG4gICAgICApXG4gICAgfVxuICAgIHJldHVybiBhbGxvY1Vuc2FmZSh0aGlzLCBhcmcpXG4gIH1cbiAgcmV0dXJuIGZyb20odGhpcywgYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbkJ1ZmZlci5wb29sU2l6ZSA9IDgxOTIgLy8gbm90IHVzZWQgYnkgdGhpcyBpbXBsZW1lbnRhdGlvblxuXG4vLyBUT0RPOiBMZWdhY3ksIG5vdCBuZWVkZWQgYW55bW9yZS4gUmVtb3ZlIGluIG5leHQgbWFqb3IgdmVyc2lvbi5cbkJ1ZmZlci5fYXVnbWVudCA9IGZ1bmN0aW9uIChhcnIpIHtcbiAgYXJyLl9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgcmV0dXJuIGFyclxufVxuXG5mdW5jdGlvbiBmcm9tICh0aGF0LCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJ2YWx1ZVwiIGFyZ3VtZW50IG11c3Qgbm90IGJlIGEgbnVtYmVyJylcbiAgfVxuXG4gIGlmICh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIHZhbHVlIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICByZXR1cm4gZnJvbUFycmF5QnVmZmVyKHRoYXQsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBmcm9tU3RyaW5nKHRoYXQsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0KVxuICB9XG5cbiAgcmV0dXJuIGZyb21PYmplY3QodGhhdCwgdmFsdWUpXG59XG5cbi8qKlxuICogRnVuY3Rpb25hbGx5IGVxdWl2YWxlbnQgdG8gQnVmZmVyKGFyZywgZW5jb2RpbmcpIGJ1dCB0aHJvd3MgYSBUeXBlRXJyb3JcbiAqIGlmIHZhbHVlIGlzIGEgbnVtYmVyLlxuICogQnVmZmVyLmZyb20oc3RyWywgZW5jb2RpbmddKVxuICogQnVmZmVyLmZyb20oYXJyYXkpXG4gKiBCdWZmZXIuZnJvbShidWZmZXIpXG4gKiBCdWZmZXIuZnJvbShhcnJheUJ1ZmZlclssIGJ5dGVPZmZzZXRbLCBsZW5ndGhdXSlcbiAqKi9cbkJ1ZmZlci5mcm9tID0gZnVuY3Rpb24gKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGZyb20obnVsbCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gIEJ1ZmZlci5wcm90b3R5cGUuX19wcm90b19fID0gVWludDhBcnJheS5wcm90b3R5cGVcbiAgQnVmZmVyLl9fcHJvdG9fXyA9IFVpbnQ4QXJyYXlcbiAgaWYgKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC5zcGVjaWVzICYmXG4gICAgICBCdWZmZXJbU3ltYm9sLnNwZWNpZXNdID09PSBCdWZmZXIpIHtcbiAgICAvLyBGaXggc3ViYXJyYXkoKSBpbiBFUzIwMTYuIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvcHVsbC85N1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCdWZmZXIsIFN5bWJvbC5zcGVjaWVzLCB7XG4gICAgICB2YWx1ZTogbnVsbCxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pXG4gIH1cbn1cblxuZnVuY3Rpb24gYXNzZXJ0U2l6ZSAoc2l6ZSkge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJzaXplXCIgYXJndW1lbnQgbXVzdCBiZSBhIG51bWJlcicpXG4gIH0gZWxzZSBpZiAoc2l6ZSA8IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJzaXplXCIgYXJndW1lbnQgbXVzdCBub3QgYmUgbmVnYXRpdmUnKVxuICB9XG59XG5cbmZ1bmN0aW9uIGFsbG9jICh0aGF0LCBzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICBhc3NlcnRTaXplKHNpemUpXG4gIGlmIChzaXplIDw9IDApIHtcbiAgICByZXR1cm4gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpXG4gIH1cbiAgaWYgKGZpbGwgIT09IHVuZGVmaW5lZCkge1xuICAgIC8vIE9ubHkgcGF5IGF0dGVudGlvbiB0byBlbmNvZGluZyBpZiBpdCdzIGEgc3RyaW5nLiBUaGlzXG4gICAgLy8gcHJldmVudHMgYWNjaWRlbnRhbGx5IHNlbmRpbmcgaW4gYSBudW1iZXIgdGhhdCB3b3VsZFxuICAgIC8vIGJlIGludGVycHJldHRlZCBhcyBhIHN0YXJ0IG9mZnNldC5cbiAgICByZXR1cm4gdHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJ1xuICAgICAgPyBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSkuZmlsbChmaWxsLCBlbmNvZGluZylcbiAgICAgIDogY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpLmZpbGwoZmlsbClcbiAgfVxuICByZXR1cm4gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpXG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBmaWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICogYWxsb2Moc2l6ZVssIGZpbGxbLCBlbmNvZGluZ11dKVxuICoqL1xuQnVmZmVyLmFsbG9jID0gZnVuY3Rpb24gKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIHJldHVybiBhbGxvYyhudWxsLCBzaXplLCBmaWxsLCBlbmNvZGluZylcbn1cblxuZnVuY3Rpb24gYWxsb2NVbnNhZmUgKHRoYXQsIHNpemUpIHtcbiAgYXNzZXJ0U2l6ZShzaXplKVxuICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUgPCAwID8gMCA6IGNoZWNrZWQoc2l6ZSkgfCAwKVxuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaXplOyArK2kpIHtcbiAgICAgIHRoYXRbaV0gPSAwXG4gICAgfVxuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbi8qKlxuICogRXF1aXZhbGVudCB0byBCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqICovXG5CdWZmZXIuYWxsb2NVbnNhZmUgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4gYWxsb2NVbnNhZmUobnVsbCwgc2l6ZSlcbn1cbi8qKlxuICogRXF1aXZhbGVudCB0byBTbG93QnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKi9cbkJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4gYWxsb2NVbnNhZmUobnVsbCwgc2l6ZSlcbn1cblxuZnVuY3Rpb24gZnJvbVN0cmluZyAodGhhdCwgc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAodHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJyB8fCBlbmNvZGluZyA9PT0gJycpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xuICB9XG5cbiAgaWYgKCFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImVuY29kaW5nXCIgbXVzdCBiZSBhIHZhbGlkIHN0cmluZyBlbmNvZGluZycpXG4gIH1cblxuICB2YXIgbGVuZ3RoID0gYnl0ZUxlbmd0aChzdHJpbmcsIGVuY29kaW5nKSB8IDBcbiAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBsZW5ndGgpXG5cbiAgdmFyIGFjdHVhbCA9IHRoYXQud3JpdGUoc3RyaW5nLCBlbmNvZGluZylcblxuICBpZiAoYWN0dWFsICE9PSBsZW5ndGgpIHtcbiAgICAvLyBXcml0aW5nIGEgaGV4IHN0cmluZywgZm9yIGV4YW1wbGUsIHRoYXQgY29udGFpbnMgaW52YWxpZCBjaGFyYWN0ZXJzIHdpbGxcbiAgICAvLyBjYXVzZSBldmVyeXRoaW5nIGFmdGVyIHRoZSBmaXJzdCBpbnZhbGlkIGNoYXJhY3RlciB0byBiZSBpZ25vcmVkLiAoZS5nLlxuICAgIC8vICdhYnh4Y2QnIHdpbGwgYmUgdHJlYXRlZCBhcyAnYWInKVxuICAgIHRoYXQgPSB0aGF0LnNsaWNlKDAsIGFjdHVhbClcbiAgfVxuXG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUxpa2UgKHRoYXQsIGFycmF5KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGggPCAwID8gMCA6IGNoZWNrZWQoYXJyYXkubGVuZ3RoKSB8IDBcbiAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBsZW5ndGgpXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICB0aGF0W2ldID0gYXJyYXlbaV0gJiAyNTVcbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlCdWZmZXIgKHRoYXQsIGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgYXJyYXkuYnl0ZUxlbmd0aCAvLyB0aGlzIHRocm93cyBpZiBgYXJyYXlgIGlzIG5vdCBhIHZhbGlkIEFycmF5QnVmZmVyXG5cbiAgaWYgKGJ5dGVPZmZzZXQgPCAwIHx8IGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0KSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1xcJ29mZnNldFxcJyBpcyBvdXQgb2YgYm91bmRzJylcbiAgfVxuXG4gIGlmIChhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCArIChsZW5ndGggfHwgMCkpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXFwnbGVuZ3RoXFwnIGlzIG91dCBvZiBib3VuZHMnKVxuICB9XG5cbiAgaWYgKGJ5dGVPZmZzZXQgPT09IHVuZGVmaW5lZCAmJiBsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXkpXG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0KVxuICB9IGVsc2Uge1xuICAgIGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlLCBmb3IgYmVzdCBwZXJmb3JtYW5jZVxuICAgIHRoYXQgPSBhcnJheVxuICAgIHRoYXQuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICB9IGVsc2Uge1xuICAgIC8vIEZhbGxiYWNrOiBSZXR1cm4gYW4gb2JqZWN0IGluc3RhbmNlIG9mIHRoZSBCdWZmZXIgY2xhc3NcbiAgICB0aGF0ID0gZnJvbUFycmF5TGlrZSh0aGF0LCBhcnJheSlcbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tT2JqZWN0ICh0aGF0LCBvYmopIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihvYmopKSB7XG4gICAgdmFyIGxlbiA9IGNoZWNrZWQob2JqLmxlbmd0aCkgfCAwXG4gICAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBsZW4pXG5cbiAgICBpZiAodGhhdC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiB0aGF0XG4gICAgfVxuXG4gICAgb2JqLmNvcHkodGhhdCwgMCwgMCwgbGVuKVxuICAgIHJldHVybiB0aGF0XG4gIH1cblxuICBpZiAob2JqKSB7XG4gICAgaWYgKCh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgIG9iai5idWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikgfHwgJ2xlbmd0aCcgaW4gb2JqKSB7XG4gICAgICBpZiAodHlwZW9mIG9iai5sZW5ndGggIT09ICdudW1iZXInIHx8IGlzbmFuKG9iai5sZW5ndGgpKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVCdWZmZXIodGhhdCwgMClcbiAgICAgIH1cbiAgICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKHRoYXQsIG9iailcbiAgICB9XG5cbiAgICBpZiAob2JqLnR5cGUgPT09ICdCdWZmZXInICYmIGlzQXJyYXkob2JqLmRhdGEpKSB7XG4gICAgICByZXR1cm4gZnJvbUFycmF5TGlrZSh0aGF0LCBvYmouZGF0YSlcbiAgICB9XG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCdGaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgc3RyaW5nLCBCdWZmZXIsIEFycmF5QnVmZmVyLCBBcnJheSwgb3IgYXJyYXktbGlrZSBvYmplY3QuJylcbn1cblxuZnVuY3Rpb24gY2hlY2tlZCAobGVuZ3RoKSB7XG4gIC8vIE5vdGU6IGNhbm5vdCB1c2UgYGxlbmd0aCA8IGtNYXhMZW5ndGgoKWAgaGVyZSBiZWNhdXNlIHRoYXQgZmFpbHMgd2hlblxuICAvLyBsZW5ndGggaXMgTmFOICh3aGljaCBpcyBvdGhlcndpc2UgY29lcmNlZCB0byB6ZXJvLilcbiAgaWYgKGxlbmd0aCA+PSBrTWF4TGVuZ3RoKCkpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byBhbGxvY2F0ZSBCdWZmZXIgbGFyZ2VyIHRoYW4gbWF4aW11bSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAnc2l6ZTogMHgnICsga01heExlbmd0aCgpLnRvU3RyaW5nKDE2KSArICcgYnl0ZXMnKVxuICB9XG4gIHJldHVybiBsZW5ndGggfCAwXG59XG5cbmZ1bmN0aW9uIFNsb3dCdWZmZXIgKGxlbmd0aCkge1xuICBpZiAoK2xlbmd0aCAhPSBsZW5ndGgpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBlcWVxZXFcbiAgICBsZW5ndGggPSAwXG4gIH1cbiAgcmV0dXJuIEJ1ZmZlci5hbGxvYygrbGVuZ3RoKVxufVxuXG5CdWZmZXIuaXNCdWZmZXIgPSBmdW5jdGlvbiBpc0J1ZmZlciAoYikge1xuICByZXR1cm4gISEoYiAhPSBudWxsICYmIGIuX2lzQnVmZmVyKVxufVxuXG5CdWZmZXIuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKGEsIGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYSkgfHwgIUJ1ZmZlci5pc0J1ZmZlcihiKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50cyBtdXN0IGJlIEJ1ZmZlcnMnKVxuICB9XG5cbiAgaWYgKGEgPT09IGIpIHJldHVybiAwXG5cbiAgdmFyIHggPSBhLmxlbmd0aFxuICB2YXIgeSA9IGIubGVuZ3RoXG5cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IE1hdGgubWluKHgsIHkpOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAoYVtpXSAhPT0gYltpXSkge1xuICAgICAgeCA9IGFbaV1cbiAgICAgIHkgPSBiW2ldXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcbiAgcmV0dXJuIDBcbn1cblxuQnVmZmVyLmlzRW5jb2RpbmcgPSBmdW5jdGlvbiBpc0VuY29kaW5nIChlbmNvZGluZykge1xuICBzd2l0Y2ggKFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKSkge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICBjYXNlICdsYXRpbjEnOlxuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgcmV0dXJuIHRydWVcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuQnVmZmVyLmNvbmNhdCA9IGZ1bmN0aW9uIGNvbmNhdCAobGlzdCwgbGVuZ3RoKSB7XG4gIGlmICghaXNBcnJheShsaXN0KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpXG4gIH1cblxuICBpZiAobGlzdC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gQnVmZmVyLmFsbG9jKDApXG4gIH1cblxuICB2YXIgaVxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBsZW5ndGggPSAwXG4gICAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICAgIGxlbmd0aCArPSBsaXN0W2ldLmxlbmd0aFxuICAgIH1cbiAgfVxuXG4gIHZhciBidWZmZXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUobGVuZ3RoKVxuICB2YXIgcG9zID0gMFxuICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xuICAgIHZhciBidWYgPSBsaXN0W2ldXG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJylcbiAgICB9XG4gICAgYnVmLmNvcHkoYnVmZmVyLCBwb3MpXG4gICAgcG9zICs9IGJ1Zi5sZW5ndGhcbiAgfVxuICByZXR1cm4gYnVmZmVyXG59XG5cbmZ1bmN0aW9uIGJ5dGVMZW5ndGggKHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihzdHJpbmcpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5sZW5ndGhcbiAgfVxuICBpZiAodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgQXJyYXlCdWZmZXIuaXNWaWV3ID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAoQXJyYXlCdWZmZXIuaXNWaWV3KHN0cmluZykgfHwgc3RyaW5nIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5ieXRlTGVuZ3RoXG4gIH1cbiAgaWYgKHR5cGVvZiBzdHJpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgc3RyaW5nID0gJycgKyBzdHJpbmdcbiAgfVxuXG4gIHZhciBsZW4gPSBzdHJpbmcubGVuZ3RoXG4gIGlmIChsZW4gPT09IDApIHJldHVybiAwXG5cbiAgLy8gVXNlIGEgZm9yIGxvb3AgdG8gYXZvaWQgcmVjdXJzaW9uXG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxlblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICBjYXNlIHVuZGVmaW5lZDpcbiAgICAgICAgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gbGVuICogMlxuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGxlbiA+Pj4gMVxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoIC8vIGFzc3VtZSB1dGY4XG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5CdWZmZXIuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGhcblxuZnVuY3Rpb24gc2xvd1RvU3RyaW5nIChlbmNvZGluZywgc3RhcnQsIGVuZCkge1xuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuXG4gIC8vIE5vIG5lZWQgdG8gdmVyaWZ5IHRoYXQgXCJ0aGlzLmxlbmd0aCA8PSBNQVhfVUlOVDMyXCIgc2luY2UgaXQncyBhIHJlYWQtb25seVxuICAvLyBwcm9wZXJ0eSBvZiBhIHR5cGVkIGFycmF5LlxuXG4gIC8vIFRoaXMgYmVoYXZlcyBuZWl0aGVyIGxpa2UgU3RyaW5nIG5vciBVaW50OEFycmF5IGluIHRoYXQgd2Ugc2V0IHN0YXJ0L2VuZFxuICAvLyB0byB0aGVpciB1cHBlci9sb3dlciBib3VuZHMgaWYgdGhlIHZhbHVlIHBhc3NlZCBpcyBvdXQgb2YgcmFuZ2UuXG4gIC8vIHVuZGVmaW5lZCBpcyBoYW5kbGVkIHNwZWNpYWxseSBhcyBwZXIgRUNNQS0yNjIgNnRoIEVkaXRpb24sXG4gIC8vIFNlY3Rpb24gMTMuMy4zLjcgUnVudGltZSBTZW1hbnRpY3M6IEtleWVkQmluZGluZ0luaXRpYWxpemF0aW9uLlxuICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCB8fCBzdGFydCA8IDApIHtcbiAgICBzdGFydCA9IDBcbiAgfVxuICAvLyBSZXR1cm4gZWFybHkgaWYgc3RhcnQgPiB0aGlzLmxlbmd0aC4gRG9uZSBoZXJlIHRvIHByZXZlbnQgcG90ZW50aWFsIHVpbnQzMlxuICAvLyBjb2VyY2lvbiBmYWlsIGJlbG93LlxuICBpZiAoc3RhcnQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkIHx8IGVuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgfVxuXG4gIGlmIChlbmQgPD0gMCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgLy8gRm9yY2UgY29lcnNpb24gdG8gdWludDMyLiBUaGlzIHdpbGwgYWxzbyBjb2VyY2UgZmFsc2V5L05hTiB2YWx1ZXMgdG8gMC5cbiAgZW5kID4+Pj0gMFxuICBzdGFydCA+Pj49IDBcblxuICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgcmV0dXJuIGFzY2lpU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsYXRpbjFTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHV0ZjE2bGVTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoZW5jb2RpbmcgKyAnJykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cblxuLy8gVGhlIHByb3BlcnR5IGlzIHVzZWQgYnkgYEJ1ZmZlci5pc0J1ZmZlcmAgYW5kIGBpcy1idWZmZXJgIChpbiBTYWZhcmkgNS03KSB0byBkZXRlY3Rcbi8vIEJ1ZmZlciBpbnN0YW5jZXMuXG5CdWZmZXIucHJvdG90eXBlLl9pc0J1ZmZlciA9IHRydWVcblxuZnVuY3Rpb24gc3dhcCAoYiwgbiwgbSkge1xuICB2YXIgaSA9IGJbbl1cbiAgYltuXSA9IGJbbV1cbiAgYlttXSA9IGlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwMTYgPSBmdW5jdGlvbiBzd2FwMTYgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDIgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDE2LWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDIpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyAxKVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDMyID0gZnVuY3Rpb24gc3dhcDMyICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSA0ICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAzMi1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgMylcbiAgICBzd2FwKHRoaXMsIGkgKyAxLCBpICsgMilcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXA2NCA9IGZ1bmN0aW9uIHN3YXA2NCAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgOCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNjQtYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gOCkge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDcpXG4gICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDYpXG4gICAgc3dhcCh0aGlzLCBpICsgMiwgaSArIDUpXG4gICAgc3dhcCh0aGlzLCBpICsgMywgaSArIDQpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcbiAgdmFyIGxlbmd0aCA9IHRoaXMubGVuZ3RoIHwgMFxuICBpZiAobGVuZ3RoID09PSAwKSByZXR1cm4gJydcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB1dGY4U2xpY2UodGhpcywgMCwgbGVuZ3RoKVxuICByZXR1cm4gc2xvd1RvU3RyaW5nLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMgKGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxuICBpZiAodGhpcyA9PT0gYikgcmV0dXJuIHRydWVcbiAgcmV0dXJuIEJ1ZmZlci5jb21wYXJlKHRoaXMsIGIpID09PSAwXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uIGluc3BlY3QgKCkge1xuICB2YXIgc3RyID0gJydcbiAgdmFyIG1heCA9IGV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVNcbiAgaWYgKHRoaXMubGVuZ3RoID4gMCkge1xuICAgIHN0ciA9IHRoaXMudG9TdHJpbmcoJ2hleCcsIDAsIG1heCkubWF0Y2goLy57Mn0vZykuam9pbignICcpXG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbWF4KSBzdHIgKz0gJyAuLi4gJ1xuICB9XG4gIHJldHVybiAnPEJ1ZmZlciAnICsgc3RyICsgJz4nXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKHRhcmdldCwgc3RhcnQsIGVuZCwgdGhpc1N0YXJ0LCB0aGlzRW5kKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKHRhcmdldCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgfVxuXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgc3RhcnQgPSAwXG4gIH1cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5kID0gdGFyZ2V0ID8gdGFyZ2V0Lmxlbmd0aCA6IDBcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzU3RhcnQgPSAwXG4gIH1cbiAgaWYgKHRoaXNFbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXNFbmQgPSB0aGlzLmxlbmd0aFxuICB9XG5cbiAgaWYgKHN0YXJ0IDwgMCB8fCBlbmQgPiB0YXJnZXQubGVuZ3RoIHx8IHRoaXNTdGFydCA8IDAgfHwgdGhpc0VuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ291dCBvZiByYW5nZSBpbmRleCcpXG4gIH1cblxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQgJiYgc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDBcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQpIHtcbiAgICByZXR1cm4gLTFcbiAgfVxuICBpZiAoc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDFcbiAgfVxuXG4gIHN0YXJ0ID4+Pj0gMFxuICBlbmQgPj4+PSAwXG4gIHRoaXNTdGFydCA+Pj49IDBcbiAgdGhpc0VuZCA+Pj49IDBcblxuICBpZiAodGhpcyA9PT0gdGFyZ2V0KSByZXR1cm4gMFxuXG4gIHZhciB4ID0gdGhpc0VuZCAtIHRoaXNTdGFydFxuICB2YXIgeSA9IGVuZCAtIHN0YXJ0XG4gIHZhciBsZW4gPSBNYXRoLm1pbih4LCB5KVxuXG4gIHZhciB0aGlzQ29weSA9IHRoaXMuc2xpY2UodGhpc1N0YXJ0LCB0aGlzRW5kKVxuICB2YXIgdGFyZ2V0Q29weSA9IHRhcmdldC5zbGljZShzdGFydCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAodGhpc0NvcHlbaV0gIT09IHRhcmdldENvcHlbaV0pIHtcbiAgICAgIHggPSB0aGlzQ29weVtpXVxuICAgICAgeSA9IHRhcmdldENvcHlbaV1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufVxuXG4vLyBGaW5kcyBlaXRoZXIgdGhlIGZpcnN0IGluZGV4IG9mIGB2YWxgIGluIGBidWZmZXJgIGF0IG9mZnNldCA+PSBgYnl0ZU9mZnNldGAsXG4vLyBPUiB0aGUgbGFzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPD0gYGJ5dGVPZmZzZXRgLlxuLy9cbi8vIEFyZ3VtZW50czpcbi8vIC0gYnVmZmVyIC0gYSBCdWZmZXIgdG8gc2VhcmNoXG4vLyAtIHZhbCAtIGEgc3RyaW5nLCBCdWZmZXIsIG9yIG51bWJlclxuLy8gLSBieXRlT2Zmc2V0IC0gYW4gaW5kZXggaW50byBgYnVmZmVyYDsgd2lsbCBiZSBjbGFtcGVkIHRvIGFuIGludDMyXG4vLyAtIGVuY29kaW5nIC0gYW4gb3B0aW9uYWwgZW5jb2RpbmcsIHJlbGV2YW50IGlzIHZhbCBpcyBhIHN0cmluZ1xuLy8gLSBkaXIgLSB0cnVlIGZvciBpbmRleE9mLCBmYWxzZSBmb3IgbGFzdEluZGV4T2ZcbmZ1bmN0aW9uIGJpZGlyZWN0aW9uYWxJbmRleE9mIChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xuICAvLyBFbXB0eSBidWZmZXIgbWVhbnMgbm8gbWF0Y2hcbiAgaWYgKGJ1ZmZlci5sZW5ndGggPT09IDApIHJldHVybiAtMVxuXG4gIC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0XG4gIGlmICh0eXBlb2YgYnl0ZU9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IGJ5dGVPZmZzZXRcbiAgICBieXRlT2Zmc2V0ID0gMFxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPiAweDdmZmZmZmZmKSB7XG4gICAgYnl0ZU9mZnNldCA9IDB4N2ZmZmZmZmZcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgLTB4ODAwMDAwMDApIHtcbiAgICBieXRlT2Zmc2V0ID0gLTB4ODAwMDAwMDBcbiAgfVxuICBieXRlT2Zmc2V0ID0gK2J5dGVPZmZzZXQgIC8vIENvZXJjZSB0byBOdW1iZXIuXG4gIGlmIChpc05hTihieXRlT2Zmc2V0KSkge1xuICAgIC8vIGJ5dGVPZmZzZXQ6IGl0IGl0J3MgdW5kZWZpbmVkLCBudWxsLCBOYU4sIFwiZm9vXCIsIGV0Yywgc2VhcmNoIHdob2xlIGJ1ZmZlclxuICAgIGJ5dGVPZmZzZXQgPSBkaXIgPyAwIDogKGJ1ZmZlci5sZW5ndGggLSAxKVxuICB9XG5cbiAgLy8gTm9ybWFsaXplIGJ5dGVPZmZzZXQ6IG5lZ2F0aXZlIG9mZnNldHMgc3RhcnQgZnJvbSB0aGUgZW5kIG9mIHRoZSBidWZmZXJcbiAgaWYgKGJ5dGVPZmZzZXQgPCAwKSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCArIGJ5dGVPZmZzZXRcbiAgaWYgKGJ5dGVPZmZzZXQgPj0gYnVmZmVyLmxlbmd0aCkge1xuICAgIGlmIChkaXIpIHJldHVybiAtMVxuICAgIGVsc2UgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggLSAxXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IDApIHtcbiAgICBpZiAoZGlyKSBieXRlT2Zmc2V0ID0gMFxuICAgIGVsc2UgcmV0dXJuIC0xXG4gIH1cblxuICAvLyBOb3JtYWxpemUgdmFsXG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIHZhbCA9IEJ1ZmZlci5mcm9tKHZhbCwgZW5jb2RpbmcpXG4gIH1cblxuICAvLyBGaW5hbGx5LCBzZWFyY2ggZWl0aGVyIGluZGV4T2YgKGlmIGRpciBpcyB0cnVlKSBvciBsYXN0SW5kZXhPZlxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHZhbCkpIHtcbiAgICAvLyBTcGVjaWFsIGNhc2U6IGxvb2tpbmcgZm9yIGVtcHR5IHN0cmluZy9idWZmZXIgYWx3YXlzIGZhaWxzXG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiAtMVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgdmFsID0gdmFsICYgMHhGRiAvLyBTZWFyY2ggZm9yIGEgYnl0ZSB2YWx1ZSBbMC0yNTVdXG4gICAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUICYmXG4gICAgICAgIHR5cGVvZiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpZiAoZGlyKSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUubGFzdEluZGV4T2YuY2FsbChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldClcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZihidWZmZXIsIFsgdmFsIF0sIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpXG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCd2YWwgbXVzdCBiZSBzdHJpbmcsIG51bWJlciBvciBCdWZmZXInKVxufVxuXG5mdW5jdGlvbiBhcnJheUluZGV4T2YgKGFyciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKSB7XG4gIHZhciBpbmRleFNpemUgPSAxXG4gIHZhciBhcnJMZW5ndGggPSBhcnIubGVuZ3RoXG4gIHZhciB2YWxMZW5ndGggPSB2YWwubGVuZ3RoXG5cbiAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQpIHtcbiAgICBlbmNvZGluZyA9IFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgIGlmIChlbmNvZGluZyA9PT0gJ3VjczInIHx8IGVuY29kaW5nID09PSAndWNzLTInIHx8XG4gICAgICAgIGVuY29kaW5nID09PSAndXRmMTZsZScgfHwgZW5jb2RpbmcgPT09ICd1dGYtMTZsZScpIHtcbiAgICAgIGlmIChhcnIubGVuZ3RoIDwgMiB8fCB2YWwubGVuZ3RoIDwgMikge1xuICAgICAgICByZXR1cm4gLTFcbiAgICAgIH1cbiAgICAgIGluZGV4U2l6ZSA9IDJcbiAgICAgIGFyckxlbmd0aCAvPSAyXG4gICAgICB2YWxMZW5ndGggLz0gMlxuICAgICAgYnl0ZU9mZnNldCAvPSAyXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhZCAoYnVmLCBpKSB7XG4gICAgaWYgKGluZGV4U2l6ZSA9PT0gMSkge1xuICAgICAgcmV0dXJuIGJ1ZltpXVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYnVmLnJlYWRVSW50MTZCRShpICogaW5kZXhTaXplKVxuICAgIH1cbiAgfVxuXG4gIHZhciBpXG4gIGlmIChkaXIpIHtcbiAgICB2YXIgZm91bmRJbmRleCA9IC0xXG4gICAgZm9yIChpID0gYnl0ZU9mZnNldDsgaSA8IGFyckxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAocmVhZChhcnIsIGkpID09PSByZWFkKHZhbCwgZm91bmRJbmRleCA9PT0gLTEgPyAwIDogaSAtIGZvdW5kSW5kZXgpKSB7XG4gICAgICAgIGlmIChmb3VuZEluZGV4ID09PSAtMSkgZm91bmRJbmRleCA9IGlcbiAgICAgICAgaWYgKGkgLSBmb3VuZEluZGV4ICsgMSA9PT0gdmFsTGVuZ3RoKSByZXR1cm4gZm91bmRJbmRleCAqIGluZGV4U2l6ZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggIT09IC0xKSBpIC09IGkgLSBmb3VuZEluZGV4XG4gICAgICAgIGZvdW5kSW5kZXggPSAtMVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoYnl0ZU9mZnNldCArIHZhbExlbmd0aCA+IGFyckxlbmd0aCkgYnl0ZU9mZnNldCA9IGFyckxlbmd0aCAtIHZhbExlbmd0aFxuICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgZm91bmQgPSB0cnVlXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHZhbExlbmd0aDsgaisrKSB7XG4gICAgICAgIGlmIChyZWFkKGFyciwgaSArIGopICE9PSByZWFkKHZhbCwgaikpIHtcbiAgICAgICAgICBmb3VuZCA9IGZhbHNlXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGZvdW5kKSByZXR1cm4gaVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiAtMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluY2x1ZGVzID0gZnVuY3Rpb24gaW5jbHVkZXMgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIHRoaXMuaW5kZXhPZih2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSAhPT0gLTFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbmRleE9mID0gZnVuY3Rpb24gaW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgdHJ1ZSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5sYXN0SW5kZXhPZiA9IGZ1bmN0aW9uIGxhc3RJbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBmYWxzZSlcbn1cblxuZnVuY3Rpb24gaGV4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICBvZmZzZXQgPSBOdW1iZXIob2Zmc2V0KSB8fCAwXG4gIHZhciByZW1haW5pbmcgPSBidWYubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gIH0gZWxzZSB7XG4gICAgbGVuZ3RoID0gTnVtYmVyKGxlbmd0aClcbiAgICBpZiAobGVuZ3RoID4gcmVtYWluaW5nKSB7XG4gICAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgICB9XG4gIH1cblxuICAvLyBtdXN0IGJlIGFuIGV2ZW4gbnVtYmVyIG9mIGRpZ2l0c1xuICB2YXIgc3RyTGVuID0gc3RyaW5nLmxlbmd0aFxuICBpZiAoc3RyTGVuICUgMiAhPT0gMCkgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBoZXggc3RyaW5nJylcblxuICBpZiAobGVuZ3RoID4gc3RyTGVuIC8gMikge1xuICAgIGxlbmd0aCA9IHN0ckxlbiAvIDJcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgdmFyIHBhcnNlZCA9IHBhcnNlSW50KHN0cmluZy5zdWJzdHIoaSAqIDIsIDIpLCAxNilcbiAgICBpZiAoaXNOYU4ocGFyc2VkKSkgcmV0dXJuIGlcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSBwYXJzZWRcbiAgfVxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiB1dGY4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGY4VG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBhc2NpaVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYXNjaWlUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGxhdGluMVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGFzY2lpV3JpdGUoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBiYXNlNjRXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGJhc2U2NFRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gdWNzMldyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmMTZsZVRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIHdyaXRlIChzdHJpbmcsIG9mZnNldCwgbGVuZ3RoLCBlbmNvZGluZykge1xuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nKVxuICBpZiAob2Zmc2V0ID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgb2Zmc2V0ID0gMFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBlbmNvZGluZylcbiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygb2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gb2Zmc2V0XG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgICBvZmZzZXQgPSAwXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIG9mZnNldFssIGxlbmd0aF1bLCBlbmNvZGluZ10pXG4gIH0gZWxzZSBpZiAoaXNGaW5pdGUob2Zmc2V0KSkge1xuICAgIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgICBpZiAoaXNGaW5pdGUobGVuZ3RoKSkge1xuICAgICAgbGVuZ3RoID0gbGVuZ3RoIHwgMFxuICAgICAgaWYgKGVuY29kaW5nID09PSB1bmRlZmluZWQpIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgfSBlbHNlIHtcbiAgICAgIGVuY29kaW5nID0gbGVuZ3RoXG4gICAgICBsZW5ndGggPSB1bmRlZmluZWRcbiAgICB9XG4gIC8vIGxlZ2FjeSB3cml0ZShzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXQsIGxlbmd0aCkgLSByZW1vdmUgaW4gdjAuMTNcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnQnVmZmVyLndyaXRlKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldFssIGxlbmd0aF0pIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQnXG4gICAgKVxuICB9XG5cbiAgdmFyIHJlbWFpbmluZyA9IHRoaXMubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCB8fCBsZW5ndGggPiByZW1haW5pbmcpIGxlbmd0aCA9IHJlbWFpbmluZ1xuXG4gIGlmICgoc3RyaW5nLmxlbmd0aCA+IDAgJiYgKGxlbmd0aCA8IDAgfHwgb2Zmc2V0IDwgMCkpIHx8IG9mZnNldCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gd3JpdGUgb3V0c2lkZSBidWZmZXIgYm91bmRzJylcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGF0aW4xV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgLy8gV2FybmluZzogbWF4TGVuZ3RoIG5vdCB0YWtlbiBpbnRvIGFjY291bnQgaW4gYmFzZTY0V3JpdGVcbiAgICAgICAgcmV0dXJuIGJhc2U2NFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1Y3MyV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OICgpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAnQnVmZmVyJyxcbiAgICBkYXRhOiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0aGlzLl9hcnIgfHwgdGhpcywgMClcbiAgfVxufVxuXG5mdW5jdGlvbiBiYXNlNjRTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGlmIChzdGFydCA9PT0gMCAmJiBlbmQgPT09IGJ1Zi5sZW5ndGgpIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYuc2xpY2Uoc3RhcnQsIGVuZCkpXG4gIH1cbn1cblxuZnVuY3Rpb24gdXRmOFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuICB2YXIgcmVzID0gW11cblxuICB2YXIgaSA9IHN0YXJ0XG4gIHdoaWxlIChpIDwgZW5kKSB7XG4gICAgdmFyIGZpcnN0Qnl0ZSA9IGJ1ZltpXVxuICAgIHZhciBjb2RlUG9pbnQgPSBudWxsXG4gICAgdmFyIGJ5dGVzUGVyU2VxdWVuY2UgPSAoZmlyc3RCeXRlID4gMHhFRikgPyA0XG4gICAgICA6IChmaXJzdEJ5dGUgPiAweERGKSA/IDNcbiAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4QkYpID8gMlxuICAgICAgOiAxXG5cbiAgICBpZiAoaSArIGJ5dGVzUGVyU2VxdWVuY2UgPD0gZW5kKSB7XG4gICAgICB2YXIgc2Vjb25kQnl0ZSwgdGhpcmRCeXRlLCBmb3VydGhCeXRlLCB0ZW1wQ29kZVBvaW50XG5cbiAgICAgIHN3aXRjaCAoYnl0ZXNQZXJTZXF1ZW5jZSkge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgaWYgKGZpcnN0Qnl0ZSA8IDB4ODApIHtcbiAgICAgICAgICAgIGNvZGVQb2ludCA9IGZpcnN0Qnl0ZVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweDFGKSA8PCAweDYgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0YpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHhDIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAodGhpcmRCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3RkYgJiYgKHRlbXBDb2RlUG9pbnQgPCAweEQ4MDAgfHwgdGVtcENvZGVQb2ludCA+IDB4REZGRikpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXG4gICAgICAgICAgZm91cnRoQnl0ZSA9IGJ1ZltpICsgM11cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKGZvdXJ0aEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4MTIgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4QyB8ICh0aGlyZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAoZm91cnRoQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4RkZGRiAmJiB0ZW1wQ29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY29kZVBvaW50ID09PSBudWxsKSB7XG4gICAgICAvLyB3ZSBkaWQgbm90IGdlbmVyYXRlIGEgdmFsaWQgY29kZVBvaW50IHNvIGluc2VydCBhXG4gICAgICAvLyByZXBsYWNlbWVudCBjaGFyIChVK0ZGRkQpIGFuZCBhZHZhbmNlIG9ubHkgMSBieXRlXG4gICAgICBjb2RlUG9pbnQgPSAweEZGRkRcbiAgICAgIGJ5dGVzUGVyU2VxdWVuY2UgPSAxXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPiAweEZGRkYpIHtcbiAgICAgIC8vIGVuY29kZSB0byB1dGYxNiAoc3Vycm9nYXRlIHBhaXIgZGFuY2UpXG4gICAgICBjb2RlUG9pbnQgLT0gMHgxMDAwMFxuICAgICAgcmVzLnB1c2goY29kZVBvaW50ID4+PiAxMCAmIDB4M0ZGIHwgMHhEODAwKVxuICAgICAgY29kZVBvaW50ID0gMHhEQzAwIHwgY29kZVBvaW50ICYgMHgzRkZcbiAgICB9XG5cbiAgICByZXMucHVzaChjb2RlUG9pbnQpXG4gICAgaSArPSBieXRlc1BlclNlcXVlbmNlXG4gIH1cblxuICByZXR1cm4gZGVjb2RlQ29kZVBvaW50c0FycmF5KHJlcylcbn1cblxuLy8gQmFzZWQgb24gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjI3NDcyNzIvNjgwNzQyLCB0aGUgYnJvd3NlciB3aXRoXG4vLyB0aGUgbG93ZXN0IGxpbWl0IGlzIENocm9tZSwgd2l0aCAweDEwMDAwIGFyZ3MuXG4vLyBXZSBnbyAxIG1hZ25pdHVkZSBsZXNzLCBmb3Igc2FmZXR5XG52YXIgTUFYX0FSR1VNRU5UU19MRU5HVEggPSAweDEwMDBcblxuZnVuY3Rpb24gZGVjb2RlQ29kZVBvaW50c0FycmF5IChjb2RlUG9pbnRzKSB7XG4gIHZhciBsZW4gPSBjb2RlUG9pbnRzLmxlbmd0aFxuICBpZiAobGVuIDw9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKSB7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBjb2RlUG9pbnRzKSAvLyBhdm9pZCBleHRyYSBzbGljZSgpXG4gIH1cblxuICAvLyBEZWNvZGUgaW4gY2h1bmtzIHRvIGF2b2lkIFwiY2FsbCBzdGFjayBzaXplIGV4Y2VlZGVkXCIuXG4gIHZhciByZXMgPSAnJ1xuICB2YXIgaSA9IDBcbiAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShcbiAgICAgIFN0cmluZyxcbiAgICAgIGNvZGVQb2ludHMuc2xpY2UoaSwgaSArPSBNQVhfQVJHVU1FTlRTX0xFTkdUSClcbiAgICApXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSAmIDB4N0YpXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBsYXRpbjFTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0pXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBoZXhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG5cbiAgaWYgKCFzdGFydCB8fCBzdGFydCA8IDApIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCB8fCBlbmQgPCAwIHx8IGVuZCA+IGxlbikgZW5kID0gbGVuXG5cbiAgdmFyIG91dCA9ICcnXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgb3V0ICs9IHRvSGV4KGJ1ZltpXSlcbiAgfVxuICByZXR1cm4gb3V0XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBieXRlcyA9IGJ1Zi5zbGljZShzdGFydCwgZW5kKVxuICB2YXIgcmVzID0gJydcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGVzW2ldICsgYnl0ZXNbaSArIDFdICogMjU2KVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uIHNsaWNlIChzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBzdGFydCA9IH5+c3RhcnRcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyBsZW4gOiB+fmVuZFxuXG4gIGlmIChzdGFydCA8IDApIHtcbiAgICBzdGFydCArPSBsZW5cbiAgICBpZiAoc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgfSBlbHNlIGlmIChzdGFydCA+IGxlbikge1xuICAgIHN0YXJ0ID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgMCkge1xuICAgIGVuZCArPSBsZW5cbiAgICBpZiAoZW5kIDwgMCkgZW5kID0gMFxuICB9IGVsc2UgaWYgKGVuZCA+IGxlbikge1xuICAgIGVuZCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIHZhciBuZXdCdWZcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgbmV3QnVmID0gdGhpcy5zdWJhcnJheShzdGFydCwgZW5kKVxuICAgIG5ld0J1Zi5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIH0gZWxzZSB7XG4gICAgdmFyIHNsaWNlTGVuID0gZW5kIC0gc3RhcnRcbiAgICBuZXdCdWYgPSBuZXcgQnVmZmVyKHNsaWNlTGVuLCB1bmRlZmluZWQpXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzbGljZUxlbjsgKytpKSB7XG4gICAgICBuZXdCdWZbaV0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3QnVmXG59XG5cbi8qXG4gKiBOZWVkIHRvIG1ha2Ugc3VyZSB0aGF0IGJ1ZmZlciBpc24ndCB0cnlpbmcgdG8gd3JpdGUgb3V0IG9mIGJvdW5kcy5cbiAqL1xuZnVuY3Rpb24gY2hlY2tPZmZzZXQgKG9mZnNldCwgZXh0LCBsZW5ndGgpIHtcbiAgaWYgKChvZmZzZXQgJSAxKSAhPT0gMCB8fCBvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb2Zmc2V0IGlzIG5vdCB1aW50JylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RyeWluZyB0byBhY2Nlc3MgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50TEUgPSBmdW5jdGlvbiByZWFkVUludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XVxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bFxuICB9XG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50QkUgPSBmdW5jdGlvbiByZWFkVUludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuICB9XG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXVxuICB2YXIgbXVsID0gMVxuICB3aGlsZSAoYnl0ZUxlbmd0aCA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQ4ID0gZnVuY3Rpb24gcmVhZFVJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2TEUgPSBmdW5jdGlvbiByZWFkVUludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkJFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDgpIHwgdGhpc1tvZmZzZXQgKyAxXVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAoKHRoaXNbb2Zmc2V0XSkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpKSArXG4gICAgICAodGhpc1tvZmZzZXQgKyAzXSAqIDB4MTAwMDAwMClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyQkUgPSBmdW5jdGlvbiByZWFkVUludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSAqIDB4MTAwMDAwMCkgK1xuICAgICgodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICB0aGlzW29mZnNldCArIDNdKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRMRSA9IGZ1bmN0aW9uIHJlYWRJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF1cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuICBtdWwgKj0gMHg4MFxuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpXG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRCRSA9IGZ1bmN0aW9uIHJlYWRJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aFxuICB2YXIgbXVsID0gMVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWldXG4gIHdoaWxlIChpID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0taV0gKiBtdWxcbiAgfVxuICBtdWwgKj0gMHg4MFxuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpXG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQ4ID0gZnVuY3Rpb24gcmVhZEludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgaWYgKCEodGhpc1tvZmZzZXRdICYgMHg4MCkpIHJldHVybiAodGhpc1tvZmZzZXRdKVxuICByZXR1cm4gKCgweGZmIC0gdGhpc1tvZmZzZXRdICsgMSkgKiAtMSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2QkUgPSBmdW5jdGlvbiByZWFkSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAxXSB8ICh0aGlzW29mZnNldF0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkxFID0gZnVuY3Rpb24gcmVhZEludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDNdIDw8IDI0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkJFID0gZnVuY3Rpb24gcmVhZEludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCAyNCkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDNdKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdExFID0gZnVuY3Rpb24gcmVhZEZsb2F0TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdEJFID0gZnVuY3Rpb24gcmVhZEZsb2F0QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlTEUgPSBmdW5jdGlvbiByZWFkRG91YmxlTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDUyLCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVCRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDUyLCA4KVxufVxuXG5mdW5jdGlvbiBjaGVja0ludCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiYnVmZmVyXCIgYXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlciBpbnN0YW5jZScpXG4gIGlmICh2YWx1ZSA+IG1heCB8fCB2YWx1ZSA8IG1pbikgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1widmFsdWVcIiBhcmd1bWVudCBpcyBvdXQgb2YgYm91bmRzJylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludExFID0gZnVuY3Rpb24gd3JpdGVVSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApXG4gIH1cblxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludEJFID0gZnVuY3Rpb24gd3JpdGVVSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApXG4gIH1cblxuICB2YXIgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIHZhciBtdWwgPSAxXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDggPSBmdW5jdGlvbiB3cml0ZVVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4ZmYsIDApXG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHZhbHVlID0gTWF0aC5mbG9vcih2YWx1ZSlcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuZnVuY3Rpb24gb2JqZWN0V3JpdGVVSW50MTYgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmICsgdmFsdWUgKyAxXG4gIGZvciAodmFyIGkgPSAwLCBqID0gTWF0aC5taW4oYnVmLmxlbmd0aCAtIG9mZnNldCwgMik7IGkgPCBqOyArK2kpIHtcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSAodmFsdWUgJiAoMHhmZiA8PCAoOCAqIChsaXR0bGVFbmRpYW4gPyBpIDogMSAtIGkpKSkpID4+PlxuICAgICAgKGxpdHRsZUVuZGlhbiA/IGkgOiAxIC0gaSkgKiA4XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuZnVuY3Rpb24gb2JqZWN0V3JpdGVVSW50MzIgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMVxuICBmb3IgKHZhciBpID0gMCwgaiA9IE1hdGgubWluKGJ1Zi5sZW5ndGggLSBvZmZzZXQsIDQpOyBpIDwgajsgKytpKSB7XG4gICAgYnVmW29mZnNldCArIGldID0gKHZhbHVlID4+PiAobGl0dGxlRW5kaWFuID8gaSA6IDMgLSBpKSAqIDgpICYgMHhmZlxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludExFID0gZnVuY3Rpb24gd3JpdGVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGggLSAxKVxuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpXG4gIH1cblxuICB2YXIgaSA9IDBcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHN1YiA9IDBcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpIC0gMV0gIT09IDApIHtcbiAgICAgIHN1YiA9IDFcbiAgICB9XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludEJFID0gZnVuY3Rpb24gd3JpdGVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGggLSAxKVxuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpXG4gIH1cblxuICB2YXIgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIHZhciBtdWwgPSAxXG4gIHZhciBzdWIgPSAwXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpICsgMV0gIT09IDApIHtcbiAgICAgIHN1YiA9IDFcbiAgICB9XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDggPSBmdW5jdGlvbiB3cml0ZUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHg3ZiwgLTB4ODApXG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHZhbHVlID0gTWF0aC5mbG9vcih2YWx1ZSlcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmICsgdmFsdWUgKyAxXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAxXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZmZmZmYgKyB2YWx1ZSArIDFcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbmZ1bmN0aW9uIGNoZWNrSUVFRTc1NCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbiAgaWYgKG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5mdW5jdGlvbiB3cml0ZUZsb2F0IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDQsIDMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgsIC0zLjQwMjgyMzQ2NjM4NTI4ODZlKzM4KVxuICB9XG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDIzLCA0KVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRMRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdEJFID0gZnVuY3Rpb24gd3JpdGVGbG9hdEJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRG91YmxlIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDgsIDEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4LCAtMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgNTIsIDgpXG4gIHJldHVybiBvZmZzZXQgKyA4XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVMRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUJFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuLy8gY29weSh0YXJnZXRCdWZmZXIsIHRhcmdldFN0YXJ0PTAsIHNvdXJjZVN0YXJ0PTAsIHNvdXJjZUVuZD1idWZmZXIubGVuZ3RoKVxuQnVmZmVyLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gY29weSAodGFyZ2V0LCB0YXJnZXRTdGFydCwgc3RhcnQsIGVuZCkge1xuICBpZiAoIXN0YXJ0KSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgJiYgZW5kICE9PSAwKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0U3RhcnQgPj0gdGFyZ2V0Lmxlbmd0aCkgdGFyZ2V0U3RhcnQgPSB0YXJnZXQubGVuZ3RoXG4gIGlmICghdGFyZ2V0U3RhcnQpIHRhcmdldFN0YXJ0ID0gMFxuICBpZiAoZW5kID4gMCAmJiBlbmQgPCBzdGFydCkgZW5kID0gc3RhcnRcblxuICAvLyBDb3B5IDAgYnl0ZXM7IHdlJ3JlIGRvbmVcbiAgaWYgKGVuZCA9PT0gc3RhcnQpIHJldHVybiAwXG4gIGlmICh0YXJnZXQubGVuZ3RoID09PSAwIHx8IHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIEZhdGFsIGVycm9yIGNvbmRpdGlvbnNcbiAgaWYgKHRhcmdldFN0YXJ0IDwgMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCd0YXJnZXRTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgfVxuICBpZiAoc3RhcnQgPCAwIHx8IHN0YXJ0ID49IHRoaXMubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc291cmNlU3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChlbmQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc291cmNlRW5kIG91dCBvZiBib3VuZHMnKVxuXG4gIC8vIEFyZSB3ZSBvb2I/XG4gIGlmIChlbmQgPiB0aGlzLmxlbmd0aCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCA8IGVuZCAtIHN0YXJ0KSB7XG4gICAgZW5kID0gdGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0ICsgc3RhcnRcbiAgfVxuXG4gIHZhciBsZW4gPSBlbmQgLSBzdGFydFxuICB2YXIgaVxuXG4gIGlmICh0aGlzID09PSB0YXJnZXQgJiYgc3RhcnQgPCB0YXJnZXRTdGFydCAmJiB0YXJnZXRTdGFydCA8IGVuZCkge1xuICAgIC8vIGRlc2NlbmRpbmcgY29weSBmcm9tIGVuZFxuICAgIGZvciAoaSA9IGxlbiAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICB0YXJnZXRbaSArIHRhcmdldFN0YXJ0XSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgfSBlbHNlIGlmIChsZW4gPCAxMDAwIHx8ICFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIGFzY2VuZGluZyBjb3B5IGZyb20gc3RhcnRcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIHRhcmdldFtpICsgdGFyZ2V0U3RhcnRdID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIFVpbnQ4QXJyYXkucHJvdG90eXBlLnNldC5jYWxsKFxuICAgICAgdGFyZ2V0LFxuICAgICAgdGhpcy5zdWJhcnJheShzdGFydCwgc3RhcnQgKyBsZW4pLFxuICAgICAgdGFyZ2V0U3RhcnRcbiAgICApXG4gIH1cblxuICByZXR1cm4gbGVuXG59XG5cbi8vIFVzYWdlOlxuLy8gICAgYnVmZmVyLmZpbGwobnVtYmVyWywgb2Zmc2V0WywgZW5kXV0pXG4vLyAgICBidWZmZXIuZmlsbChidWZmZXJbLCBvZmZzZXRbLCBlbmRdXSlcbi8vICAgIGJ1ZmZlci5maWxsKHN0cmluZ1ssIG9mZnNldFssIGVuZF1dWywgZW5jb2RpbmddKVxuQnVmZmVyLnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24gZmlsbCAodmFsLCBzdGFydCwgZW5kLCBlbmNvZGluZykge1xuICAvLyBIYW5kbGUgc3RyaW5nIGNhc2VzOlxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAodHlwZW9mIHN0YXJ0ID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBzdGFydFxuICAgICAgc3RhcnQgPSAwXG4gICAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGVuZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gZW5kXG4gICAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICAgIH1cbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMSkge1xuICAgICAgdmFyIGNvZGUgPSB2YWwuY2hhckNvZGVBdCgwKVxuICAgICAgaWYgKGNvZGUgPCAyNTYpIHtcbiAgICAgICAgdmFsID0gY29kZVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdlbmNvZGluZyBtdXN0IGJlIGEgc3RyaW5nJylcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycgJiYgIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHZhbCA9IHZhbCAmIDI1NVxuICB9XG5cbiAgLy8gSW52YWxpZCByYW5nZXMgYXJlIG5vdCBzZXQgdG8gYSBkZWZhdWx0LCBzbyBjYW4gcmFuZ2UgY2hlY2sgZWFybHkuXG4gIGlmIChzdGFydCA8IDAgfHwgdGhpcy5sZW5ndGggPCBzdGFydCB8fCB0aGlzLmxlbmd0aCA8IGVuZCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdPdXQgb2YgcmFuZ2UgaW5kZXgnKVxuICB9XG5cbiAgaWYgKGVuZCA8PSBzdGFydCkge1xuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBzdGFydCA9IHN0YXJ0ID4+PiAwXG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gdGhpcy5sZW5ndGggOiBlbmQgPj4+IDBcblxuICBpZiAoIXZhbCkgdmFsID0gMFxuXG4gIHZhciBpXG4gIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICAgIHRoaXNbaV0gPSB2YWxcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGJ5dGVzID0gQnVmZmVyLmlzQnVmZmVyKHZhbClcbiAgICAgID8gdmFsXG4gICAgICA6IHV0ZjhUb0J5dGVzKG5ldyBCdWZmZXIodmFsLCBlbmNvZGluZykudG9TdHJpbmcoKSlcbiAgICB2YXIgbGVuID0gYnl0ZXMubGVuZ3RoXG4gICAgZm9yIChpID0gMDsgaSA8IGVuZCAtIHN0YXJ0OyArK2kpIHtcbiAgICAgIHRoaXNbaSArIHN0YXJ0XSA9IGJ5dGVzW2kgJSBsZW5dXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuLy8gSEVMUEVSIEZVTkNUSU9OU1xuLy8gPT09PT09PT09PT09PT09PVxuXG52YXIgSU5WQUxJRF9CQVNFNjRfUkUgPSAvW14rXFwvMC05QS1aYS16LV9dL2dcblxuZnVuY3Rpb24gYmFzZTY0Y2xlYW4gKHN0cikge1xuICAvLyBOb2RlIHN0cmlwcyBvdXQgaW52YWxpZCBjaGFyYWN0ZXJzIGxpa2UgXFxuIGFuZCBcXHQgZnJvbSB0aGUgc3RyaW5nLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgc3RyID0gc3RyaW5ndHJpbShzdHIpLnJlcGxhY2UoSU5WQUxJRF9CQVNFNjRfUkUsICcnKVxuICAvLyBOb2RlIGNvbnZlcnRzIHN0cmluZ3Mgd2l0aCBsZW5ndGggPCAyIHRvICcnXG4gIGlmIChzdHIubGVuZ3RoIDwgMikgcmV0dXJuICcnXG4gIC8vIE5vZGUgYWxsb3dzIGZvciBub24tcGFkZGVkIGJhc2U2NCBzdHJpbmdzIChtaXNzaW5nIHRyYWlsaW5nID09PSksIGJhc2U2NC1qcyBkb2VzIG5vdFxuICB3aGlsZSAoc3RyLmxlbmd0aCAlIDQgIT09IDApIHtcbiAgICBzdHIgPSBzdHIgKyAnPSdcbiAgfVxuICByZXR1cm4gc3RyXG59XG5cbmZ1bmN0aW9uIHN0cmluZ3RyaW0gKHN0cikge1xuICBpZiAoc3RyLnRyaW0pIHJldHVybiBzdHIudHJpbSgpXG4gIHJldHVybiBzdHIucmVwbGFjZSgvXlxccyt8XFxzKyQvZywgJycpXG59XG5cbmZ1bmN0aW9uIHRvSGV4IChuKSB7XG4gIGlmIChuIDwgMTYpIHJldHVybiAnMCcgKyBuLnRvU3RyaW5nKDE2KVxuICByZXR1cm4gbi50b1N0cmluZygxNilcbn1cblxuZnVuY3Rpb24gdXRmOFRvQnl0ZXMgKHN0cmluZywgdW5pdHMpIHtcbiAgdW5pdHMgPSB1bml0cyB8fCBJbmZpbml0eVxuICB2YXIgY29kZVBvaW50XG4gIHZhciBsZW5ndGggPSBzdHJpbmcubGVuZ3RoXG4gIHZhciBsZWFkU3Vycm9nYXRlID0gbnVsbFxuICB2YXIgYnl0ZXMgPSBbXVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBjb2RlUG9pbnQgPSBzdHJpbmcuY2hhckNvZGVBdChpKVxuXG4gICAgLy8gaXMgc3Vycm9nYXRlIGNvbXBvbmVudFxuICAgIGlmIChjb2RlUG9pbnQgPiAweEQ3RkYgJiYgY29kZVBvaW50IDwgMHhFMDAwKSB7XG4gICAgICAvLyBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCFsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAgIC8vIG5vIGxlYWQgeWV0XG4gICAgICAgIGlmIChjb2RlUG9pbnQgPiAweERCRkYpIHtcbiAgICAgICAgICAvLyB1bmV4cGVjdGVkIHRyYWlsXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfSBlbHNlIGlmIChpICsgMSA9PT0gbGVuZ3RoKSB7XG4gICAgICAgICAgLy8gdW5wYWlyZWQgbGVhZFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICAvLyB2YWxpZCBsZWFkXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcblxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyAyIGxlYWRzIGluIGEgcm93XG4gICAgICBpZiAoY29kZVBvaW50IDwgMHhEQzAwKSB7XG4gICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIHZhbGlkIHN1cnJvZ2F0ZSBwYWlyXG4gICAgICBjb2RlUG9pbnQgPSAobGVhZFN1cnJvZ2F0ZSAtIDB4RDgwMCA8PCAxMCB8IGNvZGVQb2ludCAtIDB4REMwMCkgKyAweDEwMDAwXG4gICAgfSBlbHNlIGlmIChsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAvLyB2YWxpZCBibXAgY2hhciwgYnV0IGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICB9XG5cbiAgICBsZWFkU3Vycm9nYXRlID0gbnVsbFxuXG4gICAgLy8gZW5jb2RlIHV0ZjhcbiAgICBpZiAoY29kZVBvaW50IDwgMHg4MCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAxKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKGNvZGVQb2ludClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4ODAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgfCAweEMwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAzKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDIHwgMHhFMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gNCkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4MTIgfCAweEYwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNvZGUgcG9pbnQnKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBieXRlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVRvQnl0ZXMgKHN0cikge1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICAvLyBOb2RlJ3MgY29kZSBzZWVtcyB0byBiZSBkb2luZyB0aGlzIGFuZCBub3QgJiAweDdGLi5cbiAgICBieXRlQXJyYXkucHVzaChzdHIuY2hhckNvZGVBdChpKSAmIDB4RkYpXG4gIH1cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiB1dGYxNmxlVG9CeXRlcyAoc3RyLCB1bml0cykge1xuICB2YXIgYywgaGksIGxvXG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuXG4gICAgYyA9IHN0ci5jaGFyQ29kZUF0KGkpXG4gICAgaGkgPSBjID4+IDhcbiAgICBsbyA9IGMgJSAyNTZcbiAgICBieXRlQXJyYXkucHVzaChsbylcbiAgICBieXRlQXJyYXkucHVzaChoaSlcbiAgfVxuXG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gYmFzZTY0VG9CeXRlcyAoc3RyKSB7XG4gIHJldHVybiBiYXNlNjQudG9CeXRlQXJyYXkoYmFzZTY0Y2xlYW4oc3RyKSlcbn1cblxuZnVuY3Rpb24gYmxpdEJ1ZmZlciAoc3JjLCBkc3QsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoKGkgKyBvZmZzZXQgPj0gZHN0Lmxlbmd0aCkgfHwgKGkgPj0gc3JjLmxlbmd0aCkpIGJyZWFrXG4gICAgZHN0W2kgKyBvZmZzZXRdID0gc3JjW2ldXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuZnVuY3Rpb24gaXNuYW4gKHZhbCkge1xuICByZXR1cm4gdmFsICE9PSB2YWwgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zZWxmLWNvbXBhcmVcbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///6\n")},function(module,exports){eval('var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function("return this")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === "object") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it\'s\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Xcml0aW5nQW5pbWF0aW9uLyh3ZWJwYWNrKS9idWlsZGluL2dsb2JhbC5qcz9jZDAwIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNENBQTRDOztBQUU1QyIsImZpbGUiOiI3LmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIGc7XG5cbi8vIFRoaXMgd29ya3MgaW4gbm9uLXN0cmljdCBtb2RlXG5nID0gKGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gdGhpcztcbn0pKCk7XG5cbnRyeSB7XG5cdC8vIFRoaXMgd29ya3MgaWYgZXZhbCBpcyBhbGxvd2VkIChzZWUgQ1NQKVxuXHRnID0gZyB8fCBuZXcgRnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpO1xufSBjYXRjaCAoZSkge1xuXHQvLyBUaGlzIHdvcmtzIGlmIHRoZSB3aW5kb3cgcmVmZXJlbmNlIGlzIGF2YWlsYWJsZVxuXHRpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIikgZyA9IHdpbmRvdztcbn1cblxuLy8gZyBjYW4gc3RpbGwgYmUgdW5kZWZpbmVkLCBidXQgbm90aGluZyB0byBkbyBhYm91dCBpdC4uLlxuLy8gV2UgcmV0dXJuIHVuZGVmaW5lZCwgaW5zdGVhZCBvZiBub3RoaW5nIGhlcmUsIHNvIGl0J3Ncbi8vIGVhc2llciB0byBoYW5kbGUgdGhpcyBjYXNlLiBpZighZ2xvYmFsKSB7IC4uLn1cblxubW9kdWxlLmV4cG9ydHMgPSBnO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///7\n')},function(module,exports,__webpack_require__){"use strict";eval("\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  for (var i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(\n      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)\n    ))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Xcml0aW5nQW5pbWF0aW9uLy4vbm9kZV9tb2R1bGVzL2Jhc2U2NC1qcy9pbmRleC5qcz8xZmI1Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFZOztBQUVaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQ0FBa0MsU0FBUztBQUMzQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixTQUFTO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMENBQTBDLFVBQVU7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJmaWxlIjoiOC5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5leHBvcnRzLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoXG5leHBvcnRzLnRvQnl0ZUFycmF5ID0gdG9CeXRlQXJyYXlcbmV4cG9ydHMuZnJvbUJ5dGVBcnJheSA9IGZyb21CeXRlQXJyYXlcblxudmFyIGxvb2t1cCA9IFtdXG52YXIgcmV2TG9va3VwID0gW11cbnZhciBBcnIgPSB0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcgPyBVaW50OEFycmF5IDogQXJyYXlcblxudmFyIGNvZGUgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLydcbmZvciAodmFyIGkgPSAwLCBsZW4gPSBjb2RlLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gIGxvb2t1cFtpXSA9IGNvZGVbaV1cbiAgcmV2TG9va3VwW2NvZGUuY2hhckNvZGVBdChpKV0gPSBpXG59XG5cbi8vIFN1cHBvcnQgZGVjb2RpbmcgVVJMLXNhZmUgYmFzZTY0IHN0cmluZ3MsIGFzIE5vZGUuanMgZG9lcy5cbi8vIFNlZTogaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQmFzZTY0I1VSTF9hcHBsaWNhdGlvbnNcbnJldkxvb2t1cFsnLScuY2hhckNvZGVBdCgwKV0gPSA2MlxucmV2TG9va3VwWydfJy5jaGFyQ29kZUF0KDApXSA9IDYzXG5cbmZ1bmN0aW9uIGdldExlbnMgKGI2NCkge1xuICB2YXIgbGVuID0gYjY0Lmxlbmd0aFxuXG4gIGlmIChsZW4gJSA0ID4gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzdHJpbmcuIExlbmd0aCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNCcpXG4gIH1cblxuICAvLyBUcmltIG9mZiBleHRyYSBieXRlcyBhZnRlciBwbGFjZWhvbGRlciBieXRlcyBhcmUgZm91bmRcbiAgLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vYmVhdGdhbW1pdC9iYXNlNjQtanMvaXNzdWVzLzQyXG4gIHZhciB2YWxpZExlbiA9IGI2NC5pbmRleE9mKCc9JylcbiAgaWYgKHZhbGlkTGVuID09PSAtMSkgdmFsaWRMZW4gPSBsZW5cblxuICB2YXIgcGxhY2VIb2xkZXJzTGVuID0gdmFsaWRMZW4gPT09IGxlblxuICAgID8gMFxuICAgIDogNCAtICh2YWxpZExlbiAlIDQpXG5cbiAgcmV0dXJuIFt2YWxpZExlbiwgcGxhY2VIb2xkZXJzTGVuXVxufVxuXG4vLyBiYXNlNjQgaXMgNC8zICsgdXAgdG8gdHdvIGNoYXJhY3RlcnMgb2YgdGhlIG9yaWdpbmFsIGRhdGFcbmZ1bmN0aW9uIGJ5dGVMZW5ndGggKGI2NCkge1xuICB2YXIgbGVucyA9IGdldExlbnMoYjY0KVxuICB2YXIgdmFsaWRMZW4gPSBsZW5zWzBdXG4gIHZhciBwbGFjZUhvbGRlcnNMZW4gPSBsZW5zWzFdXG4gIHJldHVybiAoKHZhbGlkTGVuICsgcGxhY2VIb2xkZXJzTGVuKSAqIDMgLyA0KSAtIHBsYWNlSG9sZGVyc0xlblxufVxuXG5mdW5jdGlvbiBfYnl0ZUxlbmd0aCAoYjY0LCB2YWxpZExlbiwgcGxhY2VIb2xkZXJzTGVuKSB7XG4gIHJldHVybiAoKHZhbGlkTGVuICsgcGxhY2VIb2xkZXJzTGVuKSAqIDMgLyA0KSAtIHBsYWNlSG9sZGVyc0xlblxufVxuXG5mdW5jdGlvbiB0b0J5dGVBcnJheSAoYjY0KSB7XG4gIHZhciB0bXBcbiAgdmFyIGxlbnMgPSBnZXRMZW5zKGI2NClcbiAgdmFyIHZhbGlkTGVuID0gbGVuc1swXVxuICB2YXIgcGxhY2VIb2xkZXJzTGVuID0gbGVuc1sxXVxuXG4gIHZhciBhcnIgPSBuZXcgQXJyKF9ieXRlTGVuZ3RoKGI2NCwgdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbikpXG5cbiAgdmFyIGN1ckJ5dGUgPSAwXG5cbiAgLy8gaWYgdGhlcmUgYXJlIHBsYWNlaG9sZGVycywgb25seSBnZXQgdXAgdG8gdGhlIGxhc3QgY29tcGxldGUgNCBjaGFyc1xuICB2YXIgbGVuID0gcGxhY2VIb2xkZXJzTGVuID4gMFxuICAgID8gdmFsaWRMZW4gLSA0XG4gICAgOiB2YWxpZExlblxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICB0bXAgPVxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTgpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA8PCAxMikgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildIDw8IDYpIHxcbiAgICAgIHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMyldXG4gICAgYXJyW2N1ckJ5dGUrK10gPSAodG1wID4+IDE2KSAmIDB4RkZcbiAgICBhcnJbY3VyQnl0ZSsrXSA9ICh0bXAgPj4gOCkgJiAweEZGXG4gICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICBpZiAocGxhY2VIb2xkZXJzTGVuID09PSAyKSB7XG4gICAgdG1wID1cbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDIpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA+PiA0KVxuICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgaWYgKHBsYWNlSG9sZGVyc0xlbiA9PT0gMSkge1xuICAgIHRtcCA9XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxMCkgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDQpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDIpXSA+PiAyKVxuICAgIGFycltjdXJCeXRlKytdID0gKHRtcCA+PiA4KSAmIDB4RkZcbiAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBhcnJcbn1cblxuZnVuY3Rpb24gdHJpcGxldFRvQmFzZTY0IChudW0pIHtcbiAgcmV0dXJuIGxvb2t1cFtudW0gPj4gMTggJiAweDNGXSArXG4gICAgbG9va3VwW251bSA+PiAxMiAmIDB4M0ZdICtcbiAgICBsb29rdXBbbnVtID4+IDYgJiAweDNGXSArXG4gICAgbG9va3VwW251bSAmIDB4M0ZdXG59XG5cbmZ1bmN0aW9uIGVuY29kZUNodW5rICh1aW50OCwgc3RhcnQsIGVuZCkge1xuICB2YXIgdG1wXG4gIHZhciBvdXRwdXQgPSBbXVxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkgKz0gMykge1xuICAgIHRtcCA9XG4gICAgICAoKHVpbnQ4W2ldIDw8IDE2KSAmIDB4RkYwMDAwKSArXG4gICAgICAoKHVpbnQ4W2kgKyAxXSA8PCA4KSAmIDB4RkYwMCkgK1xuICAgICAgKHVpbnQ4W2kgKyAyXSAmIDB4RkYpXG4gICAgb3V0cHV0LnB1c2godHJpcGxldFRvQmFzZTY0KHRtcCkpXG4gIH1cbiAgcmV0dXJuIG91dHB1dC5qb2luKCcnKVxufVxuXG5mdW5jdGlvbiBmcm9tQnl0ZUFycmF5ICh1aW50OCkge1xuICB2YXIgdG1wXG4gIHZhciBsZW4gPSB1aW50OC5sZW5ndGhcbiAgdmFyIGV4dHJhQnl0ZXMgPSBsZW4gJSAzIC8vIGlmIHdlIGhhdmUgMSBieXRlIGxlZnQsIHBhZCAyIGJ5dGVzXG4gIHZhciBwYXJ0cyA9IFtdXG4gIHZhciBtYXhDaHVua0xlbmd0aCA9IDE2MzgzIC8vIG11c3QgYmUgbXVsdGlwbGUgb2YgM1xuXG4gIC8vIGdvIHRocm91Z2ggdGhlIGFycmF5IGV2ZXJ5IHRocmVlIGJ5dGVzLCB3ZSdsbCBkZWFsIHdpdGggdHJhaWxpbmcgc3R1ZmYgbGF0ZXJcbiAgZm9yICh2YXIgaSA9IDAsIGxlbjIgPSBsZW4gLSBleHRyYUJ5dGVzOyBpIDwgbGVuMjsgaSArPSBtYXhDaHVua0xlbmd0aCkge1xuICAgIHBhcnRzLnB1c2goZW5jb2RlQ2h1bmsoXG4gICAgICB1aW50OCwgaSwgKGkgKyBtYXhDaHVua0xlbmd0aCkgPiBsZW4yID8gbGVuMiA6IChpICsgbWF4Q2h1bmtMZW5ndGgpXG4gICAgKSlcbiAgfVxuXG4gIC8vIHBhZCB0aGUgZW5kIHdpdGggemVyb3MsIGJ1dCBtYWtlIHN1cmUgdG8gbm90IGZvcmdldCB0aGUgZXh0cmEgYnl0ZXNcbiAgaWYgKGV4dHJhQnl0ZXMgPT09IDEpIHtcbiAgICB0bXAgPSB1aW50OFtsZW4gLSAxXVxuICAgIHBhcnRzLnB1c2goXG4gICAgICBsb29rdXBbdG1wID4+IDJdICtcbiAgICAgIGxvb2t1cFsodG1wIDw8IDQpICYgMHgzRl0gK1xuICAgICAgJz09J1xuICAgIClcbiAgfSBlbHNlIGlmIChleHRyYUJ5dGVzID09PSAyKSB7XG4gICAgdG1wID0gKHVpbnQ4W2xlbiAtIDJdIDw8IDgpICsgdWludDhbbGVuIC0gMV1cbiAgICBwYXJ0cy5wdXNoKFxuICAgICAgbG9va3VwW3RtcCA+PiAxMF0gK1xuICAgICAgbG9va3VwWyh0bXAgPj4gNCkgJiAweDNGXSArXG4gICAgICBsb29rdXBbKHRtcCA8PCAyKSAmIDB4M0ZdICtcbiAgICAgICc9J1xuICAgIClcbiAgfVxuXG4gIHJldHVybiBwYXJ0cy5qb2luKCcnKVxufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///8\n")},function(module,exports){eval("exports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = ((value * c) - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Xcml0aW5nQW5pbWF0aW9uLy4vbm9kZV9tb2R1bGVzL2llZWU3NTQvaW5kZXguanM/OTE1MiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUSxXQUFXOztBQUVuQjtBQUNBO0FBQ0E7QUFDQSxRQUFRLFdBQVc7O0FBRW5CO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxRQUFRLFdBQVc7O0FBRW5CO0FBQ0E7QUFDQSxRQUFRLFVBQVU7O0FBRWxCO0FBQ0EiLCJmaWxlIjoiOS5qcyIsInNvdXJjZXNDb250ZW50IjpbImV4cG9ydHMucmVhZCA9IGZ1bmN0aW9uIChidWZmZXIsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtXG4gIHZhciBlTGVuID0gKG5CeXRlcyAqIDgpIC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBuQml0cyA9IC03XG4gIHZhciBpID0gaXNMRSA/IChuQnl0ZXMgLSAxKSA6IDBcbiAgdmFyIGQgPSBpc0xFID8gLTEgOiAxXG4gIHZhciBzID0gYnVmZmVyW29mZnNldCArIGldXG5cbiAgaSArPSBkXG5cbiAgZSA9IHMgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgcyA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gZUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBlID0gKGUgKiAyNTYpICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgbSA9IGUgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgZSA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gbUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBtID0gKG0gKiAyNTYpICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgaWYgKGUgPT09IDApIHtcbiAgICBlID0gMSAtIGVCaWFzXG4gIH0gZWxzZSBpZiAoZSA9PT0gZU1heCkge1xuICAgIHJldHVybiBtID8gTmFOIDogKChzID8gLTEgOiAxKSAqIEluZmluaXR5KVxuICB9IGVsc2Uge1xuICAgIG0gPSBtICsgTWF0aC5wb3coMiwgbUxlbilcbiAgICBlID0gZSAtIGVCaWFzXG4gIH1cbiAgcmV0dXJuIChzID8gLTEgOiAxKSAqIG0gKiBNYXRoLnBvdygyLCBlIC0gbUxlbilcbn1cblxuZXhwb3J0cy53cml0ZSA9IGZ1bmN0aW9uIChidWZmZXIsIHZhbHVlLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbSwgY1xuICB2YXIgZUxlbiA9IChuQnl0ZXMgKiA4KSAtIG1MZW4gLSAxXG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxXG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMVxuICB2YXIgcnQgPSAobUxlbiA9PT0gMjMgPyBNYXRoLnBvdygyLCAtMjQpIC0gTWF0aC5wb3coMiwgLTc3KSA6IDApXG4gIHZhciBpID0gaXNMRSA/IDAgOiAobkJ5dGVzIC0gMSlcbiAgdmFyIGQgPSBpc0xFID8gMSA6IC0xXG4gIHZhciBzID0gdmFsdWUgPCAwIHx8ICh2YWx1ZSA9PT0gMCAmJiAxIC8gdmFsdWUgPCAwKSA/IDEgOiAwXG5cbiAgdmFsdWUgPSBNYXRoLmFicyh2YWx1ZSlcblxuICBpZiAoaXNOYU4odmFsdWUpIHx8IHZhbHVlID09PSBJbmZpbml0eSkge1xuICAgIG0gPSBpc05hTih2YWx1ZSkgPyAxIDogMFxuICAgIGUgPSBlTWF4XG4gIH0gZWxzZSB7XG4gICAgZSA9IE1hdGguZmxvb3IoTWF0aC5sb2codmFsdWUpIC8gTWF0aC5MTjIpXG4gICAgaWYgKHZhbHVlICogKGMgPSBNYXRoLnBvdygyLCAtZSkpIDwgMSkge1xuICAgICAgZS0tXG4gICAgICBjICo9IDJcbiAgICB9XG4gICAgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICB2YWx1ZSArPSBydCAvIGNcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUgKz0gcnQgKiBNYXRoLnBvdygyLCAxIC0gZUJpYXMpXG4gICAgfVxuICAgIGlmICh2YWx1ZSAqIGMgPj0gMikge1xuICAgICAgZSsrXG4gICAgICBjIC89IDJcbiAgICB9XG5cbiAgICBpZiAoZSArIGVCaWFzID49IGVNYXgpIHtcbiAgICAgIG0gPSAwXG4gICAgICBlID0gZU1heFxuICAgIH0gZWxzZSBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIG0gPSAoKHZhbHVlICogYykgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gZSArIGVCaWFzXG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSB2YWx1ZSAqIE1hdGgucG93KDIsIGVCaWFzIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IDBcbiAgICB9XG4gIH1cblxuICBmb3IgKDsgbUxlbiA+PSA4OyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBtICYgMHhmZiwgaSArPSBkLCBtIC89IDI1NiwgbUxlbiAtPSA4KSB7fVxuXG4gIGUgPSAoZSA8PCBtTGVuKSB8IG1cbiAgZUxlbiArPSBtTGVuXG4gIGZvciAoOyBlTGVuID4gMDsgYnVmZmVyW29mZnNldCArIGldID0gZSAmIDB4ZmYsIGkgKz0gZCwgZSAvPSAyNTYsIGVMZW4gLT0gOCkge31cblxuICBidWZmZXJbb2Zmc2V0ICsgaSAtIGRdIHw9IHMgKiAxMjhcbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///9\n")},function(module,exports){eval("var toString = {}.toString;\n\nmodule.exports = Array.isArray || function (arr) {\n  return toString.call(arr) == '[object Array]';\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Xcml0aW5nQW5pbWF0aW9uLy4vbm9kZV9tb2R1bGVzL2lzYXJyYXkvaW5kZXguanM/ZTNkYiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQSIsImZpbGUiOiIxMC5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKGFycikge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbChhcnIpID09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///10\n")},function(module,exports,__webpack_require__){eval("/* WEBPACK VAR INJECTION */(function(process) {// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// resolves . and .. elements in a path array with directory names there\n// must be no slashes, empty elements, or device names (c:\\) in the array\n// (so also no leading and trailing slashes - it does not distinguish\n// relative and absolute paths)\nfunction normalizeArray(parts, allowAboveRoot) {\n  // if the path tries to go above the root, `up` ends up > 0\n  var up = 0;\n  for (var i = parts.length - 1; i >= 0; i--) {\n    var last = parts[i];\n    if (last === '.') {\n      parts.splice(i, 1);\n    } else if (last === '..') {\n      parts.splice(i, 1);\n      up++;\n    } else if (up) {\n      parts.splice(i, 1);\n      up--;\n    }\n  }\n\n  // if the path is allowed to go above the root, restore leading ..s\n  if (allowAboveRoot) {\n    for (; up--; up) {\n      parts.unshift('..');\n    }\n  }\n\n  return parts;\n}\n\n// Split a filename into [root, dir, basename, ext], unix version\n// 'root' is just a slash, or nothing.\nvar splitPathRe =\n    /^(\\/?|)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?|)(\\.[^.\\/]*|))(?:[\\/]*)$/;\nvar splitPath = function(filename) {\n  return splitPathRe.exec(filename).slice(1);\n};\n\n// path.resolve([from ...], to)\n// posix version\nexports.resolve = function() {\n  var resolvedPath = '',\n      resolvedAbsolute = false;\n\n  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n    var path = (i >= 0) ? arguments[i] : process.cwd();\n\n    // Skip empty and invalid entries\n    if (typeof path !== 'string') {\n      throw new TypeError('Arguments to path.resolve must be strings');\n    } else if (!path) {\n      continue;\n    }\n\n    resolvedPath = path + '/' + resolvedPath;\n    resolvedAbsolute = path.charAt(0) === '/';\n  }\n\n  // At this point the path should be resolved to a full absolute path, but\n  // handle relative paths to be safe (might happen when process.cwd() fails)\n\n  // Normalize the path\n  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {\n    return !!p;\n  }), !resolvedAbsolute).join('/');\n\n  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';\n};\n\n// path.normalize(path)\n// posix version\nexports.normalize = function(path) {\n  var isAbsolute = exports.isAbsolute(path),\n      trailingSlash = substr(path, -1) === '/';\n\n  // Normalize the path\n  path = normalizeArray(filter(path.split('/'), function(p) {\n    return !!p;\n  }), !isAbsolute).join('/');\n\n  if (!path && !isAbsolute) {\n    path = '.';\n  }\n  if (path && trailingSlash) {\n    path += '/';\n  }\n\n  return (isAbsolute ? '/' : '') + path;\n};\n\n// posix version\nexports.isAbsolute = function(path) {\n  return path.charAt(0) === '/';\n};\n\n// posix version\nexports.join = function() {\n  var paths = Array.prototype.slice.call(arguments, 0);\n  return exports.normalize(filter(paths, function(p, index) {\n    if (typeof p !== 'string') {\n      throw new TypeError('Arguments to path.join must be strings');\n    }\n    return p;\n  }).join('/'));\n};\n\n\n// path.relative(from, to)\n// posix version\nexports.relative = function(from, to) {\n  from = exports.resolve(from).substr(1);\n  to = exports.resolve(to).substr(1);\n\n  function trim(arr) {\n    var start = 0;\n    for (; start < arr.length; start++) {\n      if (arr[start] !== '') break;\n    }\n\n    var end = arr.length - 1;\n    for (; end >= 0; end--) {\n      if (arr[end] !== '') break;\n    }\n\n    if (start > end) return [];\n    return arr.slice(start, end - start + 1);\n  }\n\n  var fromParts = trim(from.split('/'));\n  var toParts = trim(to.split('/'));\n\n  var length = Math.min(fromParts.length, toParts.length);\n  var samePartsLength = length;\n  for (var i = 0; i < length; i++) {\n    if (fromParts[i] !== toParts[i]) {\n      samePartsLength = i;\n      break;\n    }\n  }\n\n  var outputParts = [];\n  for (var i = samePartsLength; i < fromParts.length; i++) {\n    outputParts.push('..');\n  }\n\n  outputParts = outputParts.concat(toParts.slice(samePartsLength));\n\n  return outputParts.join('/');\n};\n\nexports.sep = '/';\nexports.delimiter = ':';\n\nexports.dirname = function(path) {\n  var result = splitPath(path),\n      root = result[0],\n      dir = result[1];\n\n  if (!root && !dir) {\n    // No dirname whatsoever\n    return '.';\n  }\n\n  if (dir) {\n    // It has a dirname, strip trailing slash\n    dir = dir.substr(0, dir.length - 1);\n  }\n\n  return root + dir;\n};\n\n\nexports.basename = function(path, ext) {\n  var f = splitPath(path)[2];\n  // TODO: make this comparison case-insensitive on windows?\n  if (ext && f.substr(-1 * ext.length) === ext) {\n    f = f.substr(0, f.length - ext.length);\n  }\n  return f;\n};\n\n\nexports.extname = function(path) {\n  return splitPath(path)[3];\n};\n\nfunction filter (xs, f) {\n    if (xs.filter) return xs.filter(f);\n    var res = [];\n    for (var i = 0; i < xs.length; i++) {\n        if (f(xs[i], i, xs)) res.push(xs[i]);\n    }\n    return res;\n}\n\n// String.prototype.substr - negative index don't work in IE8\nvar substr = 'ab'.substr(-1) === 'b'\n    ? function (str, start, len) { return str.substr(start, len) }\n    : function (str, start, len) {\n        if (start < 0) start = str.length + start;\n        return str.substr(start, len);\n    }\n;\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(12)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Xcml0aW5nQW5pbWF0aW9uLy4vbm9kZV9tb2R1bGVzL3BhdGgtYnJvd3NlcmlmeS9pbmRleC5qcz9kZjdjIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsUUFBUTtBQUN4QztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVSxNQUFNO0FBQ2hCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixJQUFJO0FBQ2pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9DQUFvQyw4QkFBOEI7QUFDbEU7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVLG9CQUFvQjtBQUM5QjtBQUNBOztBQUVBO0FBQ0EsVUFBVSxVQUFVO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQixZQUFZO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwrQkFBK0Isc0JBQXNCO0FBQ3JEO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsZUFBZTtBQUNsQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiMTEuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gcmVzb2x2ZXMgLiBhbmQgLi4gZWxlbWVudHMgaW4gYSBwYXRoIGFycmF5IHdpdGggZGlyZWN0b3J5IG5hbWVzIHRoZXJlXG4vLyBtdXN0IGJlIG5vIHNsYXNoZXMsIGVtcHR5IGVsZW1lbnRzLCBvciBkZXZpY2UgbmFtZXMgKGM6XFwpIGluIHRoZSBhcnJheVxuLy8gKHNvIGFsc28gbm8gbGVhZGluZyBhbmQgdHJhaWxpbmcgc2xhc2hlcyAtIGl0IGRvZXMgbm90IGRpc3Rpbmd1aXNoXG4vLyByZWxhdGl2ZSBhbmQgYWJzb2x1dGUgcGF0aHMpXG5mdW5jdGlvbiBub3JtYWxpemVBcnJheShwYXJ0cywgYWxsb3dBYm92ZVJvb3QpIHtcbiAgLy8gaWYgdGhlIHBhdGggdHJpZXMgdG8gZ28gYWJvdmUgdGhlIHJvb3QsIGB1cGAgZW5kcyB1cCA+IDBcbiAgdmFyIHVwID0gMDtcbiAgZm9yICh2YXIgaSA9IHBhcnRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgdmFyIGxhc3QgPSBwYXJ0c1tpXTtcbiAgICBpZiAobGFzdCA9PT0gJy4nKSB7XG4gICAgICBwYXJ0cy5zcGxpY2UoaSwgMSk7XG4gICAgfSBlbHNlIGlmIChsYXN0ID09PSAnLi4nKSB7XG4gICAgICBwYXJ0cy5zcGxpY2UoaSwgMSk7XG4gICAgICB1cCsrO1xuICAgIH0gZWxzZSBpZiAodXApIHtcbiAgICAgIHBhcnRzLnNwbGljZShpLCAxKTtcbiAgICAgIHVwLS07XG4gICAgfVxuICB9XG5cbiAgLy8gaWYgdGhlIHBhdGggaXMgYWxsb3dlZCB0byBnbyBhYm92ZSB0aGUgcm9vdCwgcmVzdG9yZSBsZWFkaW5nIC4uc1xuICBpZiAoYWxsb3dBYm92ZVJvb3QpIHtcbiAgICBmb3IgKDsgdXAtLTsgdXApIHtcbiAgICAgIHBhcnRzLnVuc2hpZnQoJy4uJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHBhcnRzO1xufVxuXG4vLyBTcGxpdCBhIGZpbGVuYW1lIGludG8gW3Jvb3QsIGRpciwgYmFzZW5hbWUsIGV4dF0sIHVuaXggdmVyc2lvblxuLy8gJ3Jvb3QnIGlzIGp1c3QgYSBzbGFzaCwgb3Igbm90aGluZy5cbnZhciBzcGxpdFBhdGhSZSA9XG4gICAgL14oXFwvP3wpKFtcXHNcXFNdKj8pKCg/OlxcLnsxLDJ9fFteXFwvXSs/fCkoXFwuW14uXFwvXSp8KSkoPzpbXFwvXSopJC87XG52YXIgc3BsaXRQYXRoID0gZnVuY3Rpb24oZmlsZW5hbWUpIHtcbiAgcmV0dXJuIHNwbGl0UGF0aFJlLmV4ZWMoZmlsZW5hbWUpLnNsaWNlKDEpO1xufTtcblxuLy8gcGF0aC5yZXNvbHZlKFtmcm9tIC4uLl0sIHRvKVxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5yZXNvbHZlID0gZnVuY3Rpb24oKSB7XG4gIHZhciByZXNvbHZlZFBhdGggPSAnJyxcbiAgICAgIHJlc29sdmVkQWJzb2x1dGUgPSBmYWxzZTtcblxuICBmb3IgKHZhciBpID0gYXJndW1lbnRzLmxlbmd0aCAtIDE7IGkgPj0gLTEgJiYgIXJlc29sdmVkQWJzb2x1dGU7IGktLSkge1xuICAgIHZhciBwYXRoID0gKGkgPj0gMCkgPyBhcmd1bWVudHNbaV0gOiBwcm9jZXNzLmN3ZCgpO1xuXG4gICAgLy8gU2tpcCBlbXB0eSBhbmQgaW52YWxpZCBlbnRyaWVzXG4gICAgaWYgKHR5cGVvZiBwYXRoICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnRzIHRvIHBhdGgucmVzb2x2ZSBtdXN0IGJlIHN0cmluZ3MnKTtcbiAgICB9IGVsc2UgaWYgKCFwYXRoKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICByZXNvbHZlZFBhdGggPSBwYXRoICsgJy8nICsgcmVzb2x2ZWRQYXRoO1xuICAgIHJlc29sdmVkQWJzb2x1dGUgPSBwYXRoLmNoYXJBdCgwKSA9PT0gJy8nO1xuICB9XG5cbiAgLy8gQXQgdGhpcyBwb2ludCB0aGUgcGF0aCBzaG91bGQgYmUgcmVzb2x2ZWQgdG8gYSBmdWxsIGFic29sdXRlIHBhdGgsIGJ1dFxuICAvLyBoYW5kbGUgcmVsYXRpdmUgcGF0aHMgdG8gYmUgc2FmZSAobWlnaHQgaGFwcGVuIHdoZW4gcHJvY2Vzcy5jd2QoKSBmYWlscylcblxuICAvLyBOb3JtYWxpemUgdGhlIHBhdGhcbiAgcmVzb2x2ZWRQYXRoID0gbm9ybWFsaXplQXJyYXkoZmlsdGVyKHJlc29sdmVkUGF0aC5zcGxpdCgnLycpLCBmdW5jdGlvbihwKSB7XG4gICAgcmV0dXJuICEhcDtcbiAgfSksICFyZXNvbHZlZEFic29sdXRlKS5qb2luKCcvJyk7XG5cbiAgcmV0dXJuICgocmVzb2x2ZWRBYnNvbHV0ZSA/ICcvJyA6ICcnKSArIHJlc29sdmVkUGF0aCkgfHwgJy4nO1xufTtcblxuLy8gcGF0aC5ub3JtYWxpemUocGF0aClcbi8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydHMubm9ybWFsaXplID0gZnVuY3Rpb24ocGF0aCkge1xuICB2YXIgaXNBYnNvbHV0ZSA9IGV4cG9ydHMuaXNBYnNvbHV0ZShwYXRoKSxcbiAgICAgIHRyYWlsaW5nU2xhc2ggPSBzdWJzdHIocGF0aCwgLTEpID09PSAnLyc7XG5cbiAgLy8gTm9ybWFsaXplIHRoZSBwYXRoXG4gIHBhdGggPSBub3JtYWxpemVBcnJheShmaWx0ZXIocGF0aC5zcGxpdCgnLycpLCBmdW5jdGlvbihwKSB7XG4gICAgcmV0dXJuICEhcDtcbiAgfSksICFpc0Fic29sdXRlKS5qb2luKCcvJyk7XG5cbiAgaWYgKCFwYXRoICYmICFpc0Fic29sdXRlKSB7XG4gICAgcGF0aCA9ICcuJztcbiAgfVxuICBpZiAocGF0aCAmJiB0cmFpbGluZ1NsYXNoKSB7XG4gICAgcGF0aCArPSAnLyc7XG4gIH1cblxuICByZXR1cm4gKGlzQWJzb2x1dGUgPyAnLycgOiAnJykgKyBwYXRoO1xufTtcblxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5pc0Fic29sdXRlID0gZnVuY3Rpb24ocGF0aCkge1xuICByZXR1cm4gcGF0aC5jaGFyQXQoMCkgPT09ICcvJztcbn07XG5cbi8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydHMuam9pbiA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcGF0aHMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuICByZXR1cm4gZXhwb3J0cy5ub3JtYWxpemUoZmlsdGVyKHBhdGhzLCBmdW5jdGlvbihwLCBpbmRleCkge1xuICAgIGlmICh0eXBlb2YgcCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50cyB0byBwYXRoLmpvaW4gbXVzdCBiZSBzdHJpbmdzJyk7XG4gICAgfVxuICAgIHJldHVybiBwO1xuICB9KS5qb2luKCcvJykpO1xufTtcblxuXG4vLyBwYXRoLnJlbGF0aXZlKGZyb20sIHRvKVxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5yZWxhdGl2ZSA9IGZ1bmN0aW9uKGZyb20sIHRvKSB7XG4gIGZyb20gPSBleHBvcnRzLnJlc29sdmUoZnJvbSkuc3Vic3RyKDEpO1xuICB0byA9IGV4cG9ydHMucmVzb2x2ZSh0bykuc3Vic3RyKDEpO1xuXG4gIGZ1bmN0aW9uIHRyaW0oYXJyKSB7XG4gICAgdmFyIHN0YXJ0ID0gMDtcbiAgICBmb3IgKDsgc3RhcnQgPCBhcnIubGVuZ3RoOyBzdGFydCsrKSB7XG4gICAgICBpZiAoYXJyW3N0YXJ0XSAhPT0gJycpIGJyZWFrO1xuICAgIH1cblxuICAgIHZhciBlbmQgPSBhcnIubGVuZ3RoIC0gMTtcbiAgICBmb3IgKDsgZW5kID49IDA7IGVuZC0tKSB7XG4gICAgICBpZiAoYXJyW2VuZF0gIT09ICcnKSBicmVhaztcbiAgICB9XG5cbiAgICBpZiAoc3RhcnQgPiBlbmQpIHJldHVybiBbXTtcbiAgICByZXR1cm4gYXJyLnNsaWNlKHN0YXJ0LCBlbmQgLSBzdGFydCArIDEpO1xuICB9XG5cbiAgdmFyIGZyb21QYXJ0cyA9IHRyaW0oZnJvbS5zcGxpdCgnLycpKTtcbiAgdmFyIHRvUGFydHMgPSB0cmltKHRvLnNwbGl0KCcvJykpO1xuXG4gIHZhciBsZW5ndGggPSBNYXRoLm1pbihmcm9tUGFydHMubGVuZ3RoLCB0b1BhcnRzLmxlbmd0aCk7XG4gIHZhciBzYW1lUGFydHNMZW5ndGggPSBsZW5ndGg7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoZnJvbVBhcnRzW2ldICE9PSB0b1BhcnRzW2ldKSB7XG4gICAgICBzYW1lUGFydHNMZW5ndGggPSBpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgdmFyIG91dHB1dFBhcnRzID0gW107XG4gIGZvciAodmFyIGkgPSBzYW1lUGFydHNMZW5ndGg7IGkgPCBmcm9tUGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICBvdXRwdXRQYXJ0cy5wdXNoKCcuLicpO1xuICB9XG5cbiAgb3V0cHV0UGFydHMgPSBvdXRwdXRQYXJ0cy5jb25jYXQodG9QYXJ0cy5zbGljZShzYW1lUGFydHNMZW5ndGgpKTtcblxuICByZXR1cm4gb3V0cHV0UGFydHMuam9pbignLycpO1xufTtcblxuZXhwb3J0cy5zZXAgPSAnLyc7XG5leHBvcnRzLmRlbGltaXRlciA9ICc6JztcblxuZXhwb3J0cy5kaXJuYW1lID0gZnVuY3Rpb24ocGF0aCkge1xuICB2YXIgcmVzdWx0ID0gc3BsaXRQYXRoKHBhdGgpLFxuICAgICAgcm9vdCA9IHJlc3VsdFswXSxcbiAgICAgIGRpciA9IHJlc3VsdFsxXTtcblxuICBpZiAoIXJvb3QgJiYgIWRpcikge1xuICAgIC8vIE5vIGRpcm5hbWUgd2hhdHNvZXZlclxuICAgIHJldHVybiAnLic7XG4gIH1cblxuICBpZiAoZGlyKSB7XG4gICAgLy8gSXQgaGFzIGEgZGlybmFtZSwgc3RyaXAgdHJhaWxpbmcgc2xhc2hcbiAgICBkaXIgPSBkaXIuc3Vic3RyKDAsIGRpci5sZW5ndGggLSAxKTtcbiAgfVxuXG4gIHJldHVybiByb290ICsgZGlyO1xufTtcblxuXG5leHBvcnRzLmJhc2VuYW1lID0gZnVuY3Rpb24ocGF0aCwgZXh0KSB7XG4gIHZhciBmID0gc3BsaXRQYXRoKHBhdGgpWzJdO1xuICAvLyBUT0RPOiBtYWtlIHRoaXMgY29tcGFyaXNvbiBjYXNlLWluc2Vuc2l0aXZlIG9uIHdpbmRvd3M/XG4gIGlmIChleHQgJiYgZi5zdWJzdHIoLTEgKiBleHQubGVuZ3RoKSA9PT0gZXh0KSB7XG4gICAgZiA9IGYuc3Vic3RyKDAsIGYubGVuZ3RoIC0gZXh0Lmxlbmd0aCk7XG4gIH1cbiAgcmV0dXJuIGY7XG59O1xuXG5cbmV4cG9ydHMuZXh0bmFtZSA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgcmV0dXJuIHNwbGl0UGF0aChwYXRoKVszXTtcbn07XG5cbmZ1bmN0aW9uIGZpbHRlciAoeHMsIGYpIHtcbiAgICBpZiAoeHMuZmlsdGVyKSByZXR1cm4geHMuZmlsdGVyKGYpO1xuICAgIHZhciByZXMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHhzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChmKHhzW2ldLCBpLCB4cykpIHJlcy5wdXNoKHhzW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cblxuLy8gU3RyaW5nLnByb3RvdHlwZS5zdWJzdHIgLSBuZWdhdGl2ZSBpbmRleCBkb24ndCB3b3JrIGluIElFOFxudmFyIHN1YnN0ciA9ICdhYicuc3Vic3RyKC0xKSA9PT0gJ2InXG4gICAgPyBmdW5jdGlvbiAoc3RyLCBzdGFydCwgbGVuKSB7IHJldHVybiBzdHIuc3Vic3RyKHN0YXJ0LCBsZW4pIH1cbiAgICA6IGZ1bmN0aW9uIChzdHIsIHN0YXJ0LCBsZW4pIHtcbiAgICAgICAgaWYgKHN0YXJ0IDwgMCkgc3RhcnQgPSBzdHIubGVuZ3RoICsgc3RhcnQ7XG4gICAgICAgIHJldHVybiBzdHIuc3Vic3RyKHN0YXJ0LCBsZW4pO1xuICAgIH1cbjtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///11\n")},function(module,exports){eval("// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Xcml0aW5nQW5pbWF0aW9uLy4vbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcz9mMjhjIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsc0JBQXNCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQ0FBcUM7O0FBRXJDO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFVBQVUiLCJmaWxlIjoiMTIuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXG5cbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dDtcblxuZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG4oZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgIH1cbn0gKCkpXG5mdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xuICAgIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICAvLyBpZiBzZXRUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxufVxuZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xuICAgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGRlZmF1bHRDbGVhclRpbWVvdXQgfHwgIWNhY2hlZENsZWFyVGltZW91dCkgJiYgY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpO1xuICAgICAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxuICAgICAgICAgICAgLy8gU29tZSB2ZXJzaW9ucyBvZiBJLkUuIGhhdmUgZGlmZmVyZW50IHJ1bGVzIGZvciBjbGVhclRpbWVvdXQgdnMgc2V0VGltZW91dFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG59XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRPbmNlTGlzdGVuZXIgPSBub29wO1xuXG5wcm9jZXNzLmxpc3RlbmVycyA9IGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBbXSB9XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///12\n")}])});